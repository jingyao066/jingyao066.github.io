---
title: mysql进阶-索引
tags: mysql
date: 2019-01-07 22:05:33
---

# 索引概述
在关系数据库中，索引是一种单独的、物理的对数据库表中一列或多列的值进行排序的一种存储结构，它是某个表中一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单。
简单来说，索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。

索引提供指向存储在表的指定列中的数据值的指针，然后根据您指定的排序顺序对这些指针排序。数据库使用索引以找到特定值，然后顺指针找到包含该值的行。
这样可以使对应于表的SQL语句执行得更快，可快速访问数据库表中的特定信息。

当表中有大量记录时，若要对表进行查询，第一种搜索信息方式是全表搜索，是将所有记录一一取出，和查询条件进行一一对比，然后返回满足条件的记录，
这样做会消耗大量数据库系统时间，并造成大量磁盘I/O操作；第二种就是在表中建立索引，然后在索引中找到符合查询条件的索引值，最后通过保存在索引中的ROWID（相当于页码）快速找到表中对应的记录。

概念：
索引是为了加速对表中数据行的检索而创建的一种分散的存储结构。索引是针对表而建立的，它是由数据页面以外的索引页面组成的，每个索引页面中的行都会含有逻辑指针，以便加速检索物理数据。

# 作用
优点：
1.加快数据的检索速度，大大减少了服务器需要扫描的数据量
2.加快表连接的速度
3.在使用join、where、group by、having、order by等子句进行数据检索时，利用索引可以减少排序和分组的时间
注：某些where条件会导致索引失效
4.帮助服务器避免排序和临时表
5.将随机I/O变为顺序I/O

缺点：
1.索引需要占用物理空间
2.对表中数据进行增删改时，索引也需要维护，加大维护成本

# 使用原则
并不是每个字段度设置索引就好，也不是索引越多越好，合理使用索引
1.对经常查询的字段创建索引，避免对经常更新的字段创建索引
2.数据量小的表尽量不要使用索引，因为由于数据较少，可能查询全部数据花费的时间比遍历索引的时间还要短，索引就可能不会产生优化效果。
3.相同值较多的字段，不要建立索引，如：性别，只有男女两个不同的值。

# 索引分类
索引是在存储引擎中实现的，也就是说不同的存储引擎，会使用不同的索引。
MyISAM和InnoDB存储引擎：只支持BTREE索引，也就是说默认使用BTREE，不能够更换；MEMORY/HEAP存储引擎：支持HASH和BTREE索引。

## B-Tree
B树，不要读作"B减树"。 数据结构中有三种树形结构：B树(B-tree)，B+树(B+tree)，B*树(B*tree)
当人们谈论索引时，如果没有特别指明类型，那多半说的是B-Tree索引，它使用B-Tree数据结构来存储数据。

特点：
1.所有的值都是按顺序存储，并且每一个叶子页到根的距离相同。
2.加快数据的访问速度
3.索引列是顺序组织存储，适合查找范围数据。
4.适用于全键值、键值范围、键前缀(只适用于最左前缀查找)

限制：
1.若不是按照索引的最左列开始查找，则无法使用索引。
2.不能跳过索引中的列。如：有a,b,c三个索引列，若不指定b索引，则无法命中c索引，只能使用a索引。
3.若查询中包含范围查询，则其右边的所有列都无法命中索引(如：like '%J%')

可见索引列的顺序十分重要，在优化性能时，可能需要使用相同的列，但顺序不同的索引来满足不同类型的查询需求。

## (hash index)哈希索引
哈希索引基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值计算出来的哈希码也不一样。
哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

mysql中，只有Memory引擎显式支持哈希索引，也是Memory引擎的默认搜索引擎，也支持B-Tree索引。
值得一提的是，Memory引擎支持非唯一索引，即若多个列的哈希值相同，索引会以链表的方式存放多个记录指针到同一哈希条目中。

因为索引本身只需存储对应的哈希值，所以索引的结构十分紧凑，这也让哈希索引查找的速度非常快，然而，哈希索引也有它的限制。
1.哈希索引只包含哈希值和行指针，而不存储字段值，所以不能使用索引中的值来避免读取行。不过，访问内存中的行的速度很快，所以大部分情况下这一点对性能的影响并不明显。
2.哈希索引数据并不是按照索引值顺序存储的，所以无法用于排序
3.哈希索引不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如：在数据列(A,B)上建立哈希索引，如果查询只有数据数据列A，则无法使用该索引。
4.哈希索引只支持等值比较查询，包括=、in()、<=>(<>和<=>是不同的操作)。也不支持范围查询，例如：where price > 100。
5.访问哈希索引的数据非常快，除非有很多哈希冲突(不同的索引列值却有相同的哈希值)。当出现哈希冲突的时候，存储引擎必须遍历链表中所有的行指针，逐行进行比较，直到找到所有符合条件的行。
6.如果哈希冲突很多的话，一些索引维护操作的代价也会很高。例如：在某个选择性很低(哈希冲突很多)的列上建立哈希索引，那么当从表中删除一行时，存储引擎需要遍历对应哈希值的链表中的每一行，找到并删除对应行的引用，冲突越多，代价越大。

因为这些限制，哈希索引只适用于某些特定的场合。而一旦适合哈希索引，则它带来的性能提升将非常显著。

InnoDB引擎有个特殊的功能叫做"自适应哈希索引(adaptive hash index)"。当InnoDB注意到某些索引值呗使用的非常频繁时，它会在内存中基于B-Tree索引之上再创建一个哈希索引，这就让B-Tree索引也具有哈希索引的一些特点，
如快速哈希查找。这是一个完全自动的，内部的行为，用户无法控制或配置，不过如果有需要，可以关闭该功能。

创建自定义哈希索引(略)，参考《高性能MySQL》148页。

## 空间数据索引(R-Tree)
MyISAM表支持空间索引，可以用作地理数据存储。和B-Tree索引不同，这类索引无须前缀查询。空间索引会从所有维度来索引数据。查询时，可以有效的使用任意维度来组合查询。

## 全文索引
全文索引是一种特殊类型的索引。它查找的是文本中的关键词，而不是直接比对索引中的值。全文索引和其他积累索引的匹配方式完全不一样，它有许多需要注意的细节，如停用词、词干和复数、布尔搜索等。
全文索引更类似搜索引擎做的事情，而不是简单的where条件匹配。

在相同的列上同时创建全文索引和基于B-Tree的索引不会有冲突，全文索引适用于match against操作，而不是普通的where条件操作。

# 高性能索引策略
正确的创建和使用索引是实现高性能查询的基础。接下来学习如何高效的使用索引。

## 独立的列
独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。如果查询中的列不是独立的，则MySQL就不会使用索引。
如：下面的查询无法使用id列的索引
`select id from table_name where id + 1 = 5`

可以看出where后的表达式其实等价于 id = 4 ,但是mysql无法自动解析这个方程式，这完全是用户行为。
我们应该养成简化where条件的习惯，始终将索引单独放在比较符号的一侧。

下面是另一个常见错误：所有格式化时间的函数，TO_DAYS()、DATE_FORMAT()等都会导致索引失效。
`select ...where TO_DAYS(CURRENT_DATE) - TO_DAYS(date_col) <= 10`

## 前缀索引和索引选择性
有时候需要索引很长的字符列，这会让索引变得大且慢。一个策略是模拟哈希索引，另一种就是前缀索引。
通常可以索引开始的部分字符(注：此处"索引"是动词，指"索引"这个动作，不是名词)，这样可以大大节约索引空间，从而提高索引效率。但这样也会降低索引的选择性。

索引选择性：不重复的索引值(也称为基数)和数据表的记录总数(#T)的比值，范围从1/#T到1之间。索引的选择性越高则查询效率越高，因为选择性高的索引可以让MySQL在查找时过滤掉更多的行，
唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。

一般情况下某个列前缀的选择性足以满足查询性能，对于BLOB、TEXT或VARCHAR类型的列，必须使用前缀索引，因为mysql不允许索引这些列的完整长度。
诀窍在于选择足够长的前缀以保证较高的选择性，同时又不能太长。前缀应该足够长，以使得前缀索引的选择性接近于索引的整个列，换句话说，前缀的"基数"应该接近完整列的"基数"。

为了决定前缀的合适长度，需要找到最常见的值的列表，然后和最常见的前缀列表进行比较。

下面的实验省略了sql的查询结果。请参考《高性能MySQL》154页。
1.假定我们有一张城市表city，找到最常见的城市列表：
`select count(*) as cnt,city from city group by city order by cnt desc limit 10`
查看结果发现，每个值都出现了45-65次

2.现在查找最频繁出现的城市前缀，先从3个前缀字母开始。
`select count(*) as cnt,left(city,3) as pref from city order by cnt desc limit 10`
结果是每个值都出现了450-150次，每个前缀都比原来城市出现的次数更多，因此唯一前缀比唯一城市要少得多。

3.然后增加前缀长度，知道这个前缀的选择性接近完整列的选择性。
`select count(*) as cnt,left(city,7) as pref from city order by cnt desc limit 10`
实验发现前缀长度为7比较合适。


计算合适前缀长度的另一个方法就是计算完整列的选择性，并使前缀的选择性接近于完整列的选择性。
`select count(distinct city)/count(*) from city`
结果为：0.0312

通产来说，该例子中如果前缀选择性接近0.031，基本上就可用了。可以在一个查询中针对不同长度进行计算，这对于大表非常有用。
```
select count(distinct left(city,3))/count(*) as sel3,
count(distinct left(city,4))/count(*) as sel4,
count(distinct left(city,5))/count(*) as sel5,
count(distinct left(city,6))/count(*) as sel6,
count(distinct left(city,7))/count(*) as sel7,
from city;
```
结果为：
`0.0239 | 0.0293 | 0.0305 | 0.0309 | 0.0310`
发现前缀长度为7时，最为合适。

创建前缀索引：
`alter table city add key(city(7));`

前缀索引是一种能是索引更小、更快的办法，另一方面也有缺点：mysql无法使用前缀索引做order by 和 group by，也无法使用前缀索引做覆盖扫描。

## 多列索引
关于多列索引常见的错误：
1. 为每个列创建独立的索引；
2. 按照错误的顺序创建多列索引。

为每个列创建独立的索引：
```
create table t{
    c1 int,
    c2 int,
    c3 int,
    key(c1),
    key(c2),
    key(c3)
}
```
这种索引策略，一般是听到"把where条件里的列都加上索引"这种模糊的建议导致的。实际上这个建议是非常错误的。
在多个列上建立独立的单列索引大部分情况并不能提高mysql的查询性能。mysql5.0开始引入一种叫"索引合并(index nerge)"的策略，一定程度可以使用表上的多个单列索引来定位指定的行。

## 选择合适的索引列顺序
正确的索引顺序依赖于使用该索引的查询，并且需要考虑满足排序和分组的需要。
在一个多列B-Tree索引中，索引列的顺序意味着索引优先按照最做列进行排序，所以索引可以按照升序或降序进行扫描，以满足精确符合列顺序的order by 、group by 和distinct等字句的查询需求，所以多列索引的列顺序至关重要。

当不需要考虑排序和分组时，将**选择性最高的列放在前面**通常是很好的，这时索引的作用只是优化where条件的查找。对于在where子句中只使用了索引部分前缀列的查询来说选择性也更高。然而，性能不只是依赖于所有索引列的选择性(整体基数)，也和查询条件的具体值有关，也就是和值的分布有关。可能需要根据那些运行频率最高的查询来调整索引列的顺序。

对于下面一条查询：
`select * from payment where staff_id = 2 and customer_id = 573`

因为经验法则考虑的是全局基数和选择性，而不是某个具体的查询，所以按照经验法：
```
select 
    count(distinct staff_id)/count(*) as staff_id_selectivity,
    count(distinct customer_id)/count(*) as customer_id_selectivity,
    count(*)
from payment
```
运行结果：
```
staff_id_selectivity：0.0001
customer_id_selectivity：0.0373
count(*)：16049
```
customer_id的选择性更高，所以将其作为索引列的第一列。

## 聚簇索引

