<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>7_计算机网络面试题 | Wjy&#39;s Blog</title>
<meta name="keywords" content="interview">
<meta name="description" content="计算机网络基础 网络分层模型 OSI 七层模型是什么？每一层的作用是什么？ OSI 七层模型 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功">
<meta name="author" content="Wjy">
<link rel="canonical" href="https://funny-toffee-4aa7c3.netlify.app/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://funny-toffee-4aa7c3.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://funny-toffee-4aa7c3.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://funny-toffee-4aa7c3.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://funny-toffee-4aa7c3.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://funny-toffee-4aa7c3.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://funny-toffee-4aa7c3.netlify.app/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="https://funny-toffee-4aa7c3.netlify.app/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/">
  <meta property="og:site_name" content="Wjy&#39;s Blog">
  <meta property="og:title" content="7_计算机网络面试题">
  <meta property="og:description" content="计算机网络基础 网络分层模型 OSI 七层模型是什么？每一层的作用是什么？ OSI 七层模型 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-14T05:00:00+00:00">
    <meta property="article:modified_time" content="2023-07-14T05:00:00+00:00">
    <meta property="article:tag" content="Interview">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="7_计算机网络面试题">
<meta name="twitter:description" content="计算机网络基础 网络分层模型 OSI 七层模型是什么？每一层的作用是什么？ OSI 七层模型 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://funny-toffee-4aa7c3.netlify.app/en/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "7_计算机网络面试题",
      "item": "https://funny-toffee-4aa7c3.netlify.app/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "7_计算机网络面试题",
  "name": "7_计算机网络面试题",
  "description": "计算机网络基础 网络分层模型 OSI 七层模型是什么？每一层的作用是什么？ OSI 七层模型 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功",
  "keywords": [
    "interview"
  ],
  "articleBody": "计算机网络基础 网络分层模型 OSI 七层模型是什么？每一层的作用是什么？ OSI 七层模型 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：\n每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。\nOSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。\n上面这种图可能比较抽象，再来一个比较生动的图片。\n既然 OSI 七层模型这么厉害，为什么干不过 TCP/IP 四 层模型呢？\n的确，OSI 七层模型当时一直被一些大公司甚至一些国家政府支持。这样的背景下，为什么会失败呢？我觉得主要有下面几方面原因：\nOSI 的专家缺乏实际经验，他们在完成 OSI 标准时缺乏商业驱动力 OSI 的协议实现起来过分复杂，而且运行效率很低 OSI 制定标准的周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场（20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制定出来，但基于 TCP/IP 的互联网已经抢先在全球相当大的范围成功运行了） OSI 的层次划分不太合理，有些功能在多个层次中重复出现。 OSI 七层模型虽然失败了，但是却提供了很多不错的理论基础。为了更好地去了解网络分层，OSI 七层模型还是非常有必要学习的。\n最后再分享一个关于 OSI 七层模型非常不错的总结图片！\nTCP/IP 四层模型是什么？每一层的作用是什么？ TCP/IP 四层模型 是目前被广泛采用的一种模型，我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：\n应用层 传输层 网络层 网络接口层 需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：\n应用层（Application layer） 应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。 我们把应用层交互的数据单元称为报文。\n应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。\n传输层（Transport layer） 传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。\n传输层常见协议：\nTCP（Transmisson Control Protocol，传输控制协议 ）：提供 面向连接 的，可靠 的数据传输服务。\nUDP（User Datagram Protocol，用户数据协议）：提供 无连接 的，尽最大努力 的数据传输服务（不保证数据传输的可靠性），简单高效。\n网络层（Network layer） 网络层负责为分组交换网上的不同主机提供通信服务。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。\n⚠️ 注意：不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混。\n网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。\n这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。\n互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做 网际层 或 IP 层。\n网络接口层（Network interface layer） 我们可以把网络接口层看作是数据链路层和物理层的合体。\n数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。 物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异 总结 简单总结一下每一层包含的协议和核心技术:\n应用层协议 :\nHTTP（Hypertext Transfer Protocol，超文本传输协议） SMTP（Simple Mail Transfer Protocol，简单邮件发送协议） POP3/IMAP（邮件接收协议） FTP（File Transfer Protocol，文件传输协议） Telnet（远程登陆协议） SSH（Secure Shell Protocol，安全的网络传输协议） RTP（Real-time Transport Protocol，实时传输协议） DNS（Domain Name System，域名管理系统） …… 传输层协议 :\nTCP 协议 报文段结构 可靠数据传输 流量控制 拥塞控制 UDP 协议 报文段结构 RDT（可靠数据传输协议） 网络层协议 :\nIP（Internet Protocol，网际协议） ARP（Address Resolution Protocol，地址解析协议） ICMP 协议（控制报文协议，用于发送控制消息） NAT（Network Address Translation，网络地址转换协议） OSPF（Open Shortest Path First，开放式最短路径优先） RIP(Routing Information Protocol，路由信息协议） BGP（Border Gateway Protocol，边界网关协议） …… 网络接口层 :\n差错检测技术 多路访问协议（信道复用技术） CSMA/CD 协议 MAC 协议 以太网技术 …… 为什么网络要分层？ 说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:\nRepository（数据库操作） Service（业务操作） Controller（前后端数据交互） 复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。\n好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：\n各层之间相互独立：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）。这个和我们对开发时系统进行分层是一个道理。 提高了整体灵活性：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。 大问题化小：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。 我想到了计算机世界非常非常有名的一句话，这里分享一下：\n计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。\n常见网络协议 应用层有哪些常见的协议？ HTTP HTTP（Hypertext Transfer Protocol，超文本传输协议）：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。\nHTTP 使用客户端-服务器模型，客户端向服务器发送 HTTP Request（请求），服务器响应请求并返回 HTTP Response（响应），整个过程如下图所示。\nHTTP 协议基于 TCP 协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。\n另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。\nSMTP SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。\nSMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：\n电子邮件的发送过程 如何判断邮箱是真正存在的？ 电子邮件的发送过程？\n比如我的邮箱是“dabai@cszhinan.com”，我要向“xiaoma@qq.com”发送邮件，整个过程可以简单分为下面几步：\n通过 SMTP 协议，我将我写好的邮件交给 163 邮箱服务器（邮局）。 163 邮箱服务器发现我发送的邮箱是 qq 邮箱，然后它使用 SMTP 协议将我的邮件转发到 qq 邮箱服务器。 qq 邮箱服务器接收邮件之后就通知邮箱为“xiaoma@qq.com”的用户来收邮件，然后用户就通过 POP3/IMAP 协议将邮件取出。 如何判断邮箱是真正存在的？\n很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：\n查找邮箱域名对应的 SMTP 服务器地址 尝试与服务器建立连接 连接成功后尝试向需要验证的邮箱发送邮件 根据返回结果判定邮箱地址的真实性 推荐几个在线邮箱是否有效检测工具：\nhttps://verify-email.org/ http://tool.chacuo.net/mailverify https://www.emailcamel.com/ POP3/IMAP POP3/IMAP（邮件接收协议）：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。\nFTP FTP（File Transfer Protocol，文件传输协议） : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。\nFTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：\nFTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：\n控制连接：用于传送控制信息（命令和响应） 数据连接：用于数据传送； 这种将命令和数据分开传送的思想大大提高了 FTP 的效率。\n注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。因此，FTP 传输的文件可能会被窃听或篡改。建议在传输敏感数据时使用更安全的协议，如 SFTP（一种基于 SSH 协议的安全文件传输协议，用于在网络上安全地传输文件）。\nTelnet Telnet（远程登陆协议）：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。\nSSH SSH（Secure Shell Protocol，安全的网络传输协议）：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务\nSSH 的经典用途是登录到远程电脑中执行命令。除此之外，SSH 也支持隧道协议、端口映射和 X11 连接。借助 SFTP 或 SCP 协议，SSH 还可以传输文件。\nSSH 使用客户端-服务器模型，默认端口是 22。SSH 是一个守护进程，负责实时监听客户端请求，并进行处理。大多数现代操作系统都提供了 SSH。\nRTP RTP（Real-time Transport Protocol，实时传输协议）：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。\nRTP 协议分为两种子协议：\nRTP（Real-time Transport Protocol，实时传输协议）：传输具有实时特性的数据。 RTCP（RTP Control Protocol，RTP 控制协议）：提供实时传输过程中的统计信息（如网络延迟、丢包率等），WebRTC 正是根据这些信息处理丢包 DNS DNS（Domain Name System，域名管理系统）: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。\n传输层有哪些常见的协议？ TCP（Transmission Control Protocol，传输控制协议 ）：提供 面向连接 的，可靠 的数据传输服务。\nUDP（User Datagram Protocol，用户数据协议）：提供 无连接 的，尽最大努力 的数据传输服务（不保证数据传输的可靠性），简单高效。\n网络层有哪些常见的协议？ IP（Internet Protocol，网际协议）：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。\nARP（Address Resolution Protocol，地址解析协议）：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。\nICMP（Internet Control Message Protocol，互联网控制报文协议）：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。\nNAT（Network Address Translation，网络地址转换协议）：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。\nOSPF（Open Shortest Path First，开放式最短路径优先） ）：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。\nRIP(Routing Information Protocol，路由信息协议）：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。\nBGP（Border Gateway Protocol，边界网关协议）：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。\nHTTP 从输入 URL 到页面展示到底发生了什么？（非常重要） 图解（图片来源：《图解 HTTP》）：\n上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议\n总体来说分为以下几个过程:\nDNS 解析 TCP 连接 发送 HTTP 请求 服务器处理请求并返回 HTTP 报文 浏览器解析渲染页面 连接结束 具体可以参考下面这两篇文章：\n从输入 URL 到页面加载发生了什么？ 浏览器从输入网址到页面展示的过程 HTTP状态码有哪些 HTTP 状态码用于描述 HTTP 请求的结果，比如 2xx 就代表请求被成功处理。\n1xx Informational（信息性状态码） 相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。\n2xx Success（成功状态码） 200 OK：请求被成功处理。比如我们发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。 201 Created：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。 202 Accepted：服务端已经接收到了请求，但是还未处理。 204 No Content：服务端已经成功处理了请求，但是没有返回任何内容。 这里格外提一下 204 状态码，平时学习/工作中见到的次数并不多。\n3xx Redirection（重定向状态码） 301 Moved Permanently：资源被永久重定向了。比如你的网站的网址更换了。 302 Found：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。 4xx Client Error（客户端错误状态码） 400 Bad Request：发送的 HTTP 请求存在问题。比如请求参数不合法、请求方法错误。 401 Unauthorized：未认证却请求需要认证之后才能访问的资源。 403 Forbidden：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。 404 Not Found：你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。 409 Conflict：表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。 5xx Server Error（服务端错误状态码） 500 Internal Server Error：服务端出问题了（通常是服务端出 Bug 了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。 502 Bad Gateway：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。 HTTP Header 中常见的字段有哪些？ 请求头字段名 说明 示例 Accept 能够接受的回应内容类型（Content-Types）。 Accept: text/plain Accept-Charset 能够接受的字符集 Accept-Charset: utf-8 Accept-Datetime 能够接受的按照时间来表示的版本 Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT Accept-Encoding 能够接受的编码方式列表。参考 HTTP 压缩。 Accept-Encoding: gzip, deflate Accept-Language 能够接受的回应内容的自然语言列表。 Accept-Language: en-US Authorization 用于超文本传输协议的认证的认证信息 Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Cache-Control 用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令 Cache-Control: no-cache Connection 该浏览器想要优先使用的连接类型 Connection: keep-alive Connection: Upgrade Content-Length 以 八位字节数组 （8 位的字节）表示的请求体的长度 Content-Length: 348 Content-MD5 请求体的内容的二进制 MD5 散列值，以 Base64 编码的结果 Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ== Content-Type 请求体的 多媒体类型 （用于 POST 和 PUT 请求中） Content-Type: application/x-www-form-urlencoded Cookie 之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议 Cookie Cookie: $Version=1; Skin=new; Date 发送该消息的日期和时间(按照 RFC 7231 中定义的\"超文本传输协议日期\"格式来发送) Date: Tue, 15 Nov 1994 08:12:31 GMT Expect 表明客户端要求服务器做出特定的行为 Expect: 100-continue From 发起此请求的用户的邮件地址 From: user@example.com Host 服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。 Host: en.wikipedia.org:80 If-Match 仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源。 If-Match: “737060cd8c284d8af7ad3082f209582d” If-Modified-Since 允许在对应的内容未被修改的情况下返回 304 未修改（ 304 Not Modified ） If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT If-None-Match 允许在对应的内容未被修改的情况下返回 304 未修改（ 304 Not Modified ） If-None-Match: “737060cd8c284d8af7ad3082f209582d” If-Range 如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体 If-Range: “737060cd8c284d8af7ad3082f209582d” If-Unmodified-Since 仅当该实体自某个特定时间已来未被修改的情况下，才发送回应。 If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT Max-Forwards 限制该消息可被代理及网关转发的次数。 Max-Forwards: 10 Origin 发起一个针对 跨来源资源共享 的请求。 Origin: http://www.example-social-network.com Pragma 与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生多种效果。 Pragma: no-cache Proxy-Authorization 用来向代理进行认证的认证信息。 Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ== Range 仅请求某个实体的一部分。字节偏移以 0 开始。参见字节服务。 Range: bytes=500-999 Referer 表示浏览器所访问的前一个页面，正是那个页面上的某个链接将浏览器带到了当前所请求的这个页面。 Referer: http://en.wikipedia.org/wiki/Main_Page TE 浏览器预期接受的传输编码方式：可使用回应协议头 Transfer-Encoding 字段中的值； TE: trailers, deflate Upgrade 要求服务器升级到另一个协议。 Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11 User-Agent 浏览器的浏览器身份标识字符串 User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0 Via 向服务器告知，这个请求是由哪些代理发出的。 Via: 1.0 fred, 1.1 example.com (Apache/1.1) Warning 一个一般性的警告，告知，在实体内容体中可能存在错误。 Warning: 199 Miscellaneous warning HTTP 和 HTTPS 有什么区别？（应用层） HTTP协议介绍 HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。\n并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。\nHTTP 协议通信过程 HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：\n服务器在 80 端口等待客户的请求。 浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。 服务器接收来自浏览器的 TCP 连接。 浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。 关闭 TCP 连接。 HTTPS 协议介绍 HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.\nHTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。\nHTTPS 的核心—SSL/TLS 协议 HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。接下来重点介绍一下 SSL/TLS 的工作原理。\nSSL 和 TLS 的区别？ SSL 和 TLS 没有太大的区别。\nSSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，新版本被命名为 TLS 1.0。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混称为 SSL/TLS。\nSSL/TLS 的工作原理 非对称加密 SSL/TLS 的核心要素是非对称加密。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，\n在某个自助邮局，每个通信信道都是一个邮箱，每一个邮箱所有者都在旁边立了一个牌子，上面挂着一把钥匙：这是我的公钥，发送者请将信件放入我的邮箱，并用公钥锁好。\n但是公钥只能加锁，并不能解锁。解锁只能由邮箱的所有者——因为只有他保存着私钥。\n这样，通信信息就不会被其他人截获了，这依赖于私钥的保密性。\n非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。\n单向函数：已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x)；而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。\n单向陷门函数：一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y=f(x;h)；而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。\n上图就是一个单向函数（不是单项陷门函数），假设有一个绝世秘籍，任何知道了这个秘籍的人都可以把苹果汁榨成苹果，那么这个秘籍就是“陷门”了吧。\n在这里，函数 f 的计算方法相当于公钥，陷门 h 相当于私钥。公钥 f 是公开的，任何人对已有输入，都可以用 f 加密，而要想根据加密信息还原出原信息，必须要有私钥才行。\n对称加密 使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。\n对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。\n对称加密的密钥生成代价比公私钥对的生成代价低得多，那么有的人会问了，为什么 SSL/TLS 还需要使用非对称加密呢？因为对称加密的保密性完全依赖于密钥的保密性。在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。\n公钥传输的信赖性 SSL/TLS 介绍到这里，了解信息安全的朋友又会想到一个安全隐患，设想一个下面的场景：\n客户端 C 和服务器 S 想要使用 SSL/TLS 通信，由上述 SSL/TLS 通信原理，C 需要先知道 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。要注意网络信道通信中有几个前提：\n任何人都可以捕获通信包 通信包的保密性由发送者设计 保密算法设计方案默认为公开，而（解密）密钥默认是安全的 因此，假设 S 公钥不做加密，在信道中传输，那么很有可能存在一个攻击者 A，发送给 C 一个诈包，假装是 S 公钥，其实是诱饵服务器 AS 的公钥。当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。\n同样的，S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！\n为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的电子签名（见下节）。\n当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。\n数字签名 好，到这一小节，已经是 SSL/TLS 的尾声了。上一小节提到了数字签名，数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是 靠数字签名技术 。\n数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：\nCA 知道服务器的公钥，对证书采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。\n现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。\n客户端对证书数据（包含服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。\n总结来说，带有证书的公钥传输机制如下：\n设有服务器 S，客户端 C，和第三方信赖机构 CA。 S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。 S 获得 CA 颁发的证书，将该证书传递给 C。 C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。 如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。 对于数字签名，我这里讲的比较简单，如果你没有搞清楚的话，强烈推荐你看看数字签名及数字证书原理这个视频，这是我看过最清晰的讲解。\n总结 端口号：HTTP 默认是 80，HTTPS 默认是 443。 URL 前缀：HTTP 的 URL 前缀是 http://，HTTPS 的 URL 前缀是 https://。 安全性和资源消耗：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。 HTTP/1.0 和 HTTP/1.1 有什么区别？ 以下面几个维度来对比 HTTP 1.0 和 HTTP 1.1：\n响应状态码 缓存处理 连接方式 Host 头处理 带宽优化 响应状态码 HTTP/1.0 仅定义了 16 种状态码。HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，100 (Continue)——在请求大资源前的预热请求，206 (Partial Content)——范围请求的标识码，409 (Conflict)——请求与当前资源的规定冲突，410 (Gone)——资源已被永久转移，而且没有任何已知的转发地址。\n缓存处理 缓存技术通过避免用户与源服务器的频繁交互，节约了大量的网络带宽，降低了用户接收信息的延迟。\nHTTP/1.0 HTTP/1.0 提供的缓存机制非常简单。服务器端使用Expires标签来标志（时间）一个响应体，在Expires标志时间内的请求，都会获得该响应体缓存。服务器端在初次返回给客户端的响应体中，有一个Last-Modified标签，该标签标记了被请求资源在服务器端的最后一次修改。在请求头中，使用If-Modified-Since标签，该标签标志一个时间，意为客户端向服务器进行问询：“该时间之后，我要请求的资源是否有被修改过？”通常情况下，请求头中的If-Modified-Since的值即为上一次获得该资源时，响应体中的Last-Modified的值。\n如果服务器接收到了请求头，并判断If-Modified-Since时间后，资源确实没有修改过，则返回给客户端一个304 not modified响应头，表示”缓冲可用，你从浏览器里拿吧！”。\n如果服务器判断If-Modified-Since时间后，资源被修改过，则返回给客户端一个200 OK的响应体，并附带全新的资源内容，表示”你要的我已经改过的，给你一份新的”。\nHTTP/1.1 HTTP/1.1 的缓存机制在 HTTP/1.0 的基础上，大大增加了灵活性和扩展性。基本工作原理和 HTTP/1.0 保持不变，而是增加了更多细致的特性。其中，请求头中最常见的特性就是Cache-Control，详见 MDN Web 文档 Cache-Control\n连接方式 HTTP/1.0 默认使用短连接 ，也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 TCP 连接，这样就会导致有大量的“握手报文”和“挥手报文”占用了带宽。\n为了解决 HTTP/1.0 存在的资源浪费的问题， HTTP/1.1 优化为默认长连接模式 。 采用长连接模式的请求报文会通知服务端：“我向你请求连接，并且连接成功建立后，请不要关闭”。因此，该 TCP 连接将持续打开，为后续的客户端-服务端的数据交互服务。也就是说在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。\n如果 TCP 连接一直保持的话也是对资源的浪费，因此，一些服务器软件（如 Apache）还会支持超时时间的时间。在超时时间之内没有新的请求达到，TCP 连接才会被关闭。\n有必要说明的是，HTTP/1.0 仍提供了长连接选项，即在请求头中加入Connection: Keep-alive。同样的，在 HTTP/1.1 中，如果不希望使用长连接选项，也可以在请求头中加入Connection: close，这样会通知服务器端：“我不需要长连接，连接成功后即可关闭”。\nHTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。\n实现长连接需要客户端和服务端都支持长连接。\nHost 头处理 域名系统（DNS）允许多个主机名绑定到同一个 IP 地址上，但是 HTTP/1.0 并没有考虑这个问题，假设我们有一个资源 URL 是http://example1.org/home.html，HTTP/1.0的请求报文中，将会请求的是GET /home.html HTTP/1.0.也就是不会加入主机名。这样的报文送到服务器端，服务器是理解不了客户端想请求的真正网址。\n因此，HTTP/1.1 在请求头中加入了Host字段。加入Host字段的报文头部将会是：\n1 2 GET /home.html HTTP/1.1 Host: example1.org 这样，服务器端就可以确定客户端想要请求的真正的网址了。\n带宽优化 范围请求 HTTP/1.1 引入了范围请求（range request）机制，以避免带宽的浪费。当客户端想请求一个文件的一部分，或者需要继续下载一个已经下载了部分但被终止的文件，HTTP/1.1 可以在请求中加入Range头部，以请求（并只能请求字节型数据）数据的一部分。服务器端可以忽略Range头部，也可以返回若干Range响应。\n如果一个响应包含部分数据的话，那么将带有206 (Partial Content)状态码。该状态码的意义在于避免了 HTTP/1.0 代理缓存错误地把该响应认为是一个完整的数据响应，从而把他当作为一个请求的响应缓存。\n在范围响应中，Content-Range头部标志指示出了该数据块的偏移量和数据块的长度。\n状态码 100 HTTP/1.1 中新加入了状态码100。该状态码的使用场景为，存在某些较大的文件请求，服务器可能不愿意响应这种请求，此时状态码100可以作为指示请求是否会被正常响应，过程如下图：\n然而在 HTTP/1.0 中，并没有100 (Continue)状态码，要想触发这一机制，可以发送一个Expect头部，其中包含一个100-continue的值。\n压缩 许多格式的数据在传输时都会做预压缩处理。数据的压缩可以大幅优化带宽的利用。然而，HTTP/1.0 对数据压缩的选项提供的不多，不支持压缩细节的选择，也无法区分端到端（end-to-end）压缩或者是逐跳（hop-by-hop）压缩。\nHTTP/1.1 则对内容编码（content-codings）和传输编码（transfer-codings）做了区分。内容编码总是端到端的，传输编码总是逐跳的。\nHTTP/1.0 包含了Content-Encoding头部，对消息进行端到端编码。HTTP/1.1 加入了Transfer-Encoding头部，可以对消息进行逐跳传输编码。HTTP/1.1 还加入了Accept-Encoding头部，是客户端用来指示他能处理什么样的内容编码。\n总结 连接方式 : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。 状态响应码 : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，100 (Continue)——在请求大资源前的预热请求，206 (Partial Content)——范围请求的标识码，409 (Conflict)——请求与当前资源的规定冲突，410 (Gone)——资源已被永久转移，而且没有任何已知的转发地址。 缓存处理 : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。 带宽优化及网络连接的使用 :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。 Host 头处理 : HTTP/1.1 在请求头中加入了Host字段。 HTTP/1.1 和 HTTP/2.0 有什么区别？ IO 多路复用（Multiplexing）：HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本）。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。\n二进制帧（Binary Frames）：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。\n头部压缩（Header Compression）：HTTP/1.1 支持Body压缩，Header不支持压缩。HTTP/2.0 支持对Header压缩，减少了网络开销。\n服务器推送（Server Push）：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。\nHTTP/2.0 和 HTTP/3.0 有什么区别？ 传输协议：HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 新增了 QUIC（Quick UDP Internet Connections） 协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。\n连接建立：HTTP/2.0 需要经过经典的 TCP 三次握手过程（由于安全的 HTTPS 连接建立还需要 TLS 握手，共需要大约 3 个 RTT）。由于 QUIC 协议的特性（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。\n队头阻塞：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。\n错误恢复：HTTP/3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP/2.0 则需要依赖于 TCP 的错误恢复机制。\n安全性：HTTP/2.0 和 HTTP/3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。HTTP/2.0 使用 TLS 协议进行加密，而 HTTP/3.0 基于 QUIC 协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。\nHTTP 是不保存状态的协议, 如何保存用户状态? HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。\n在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。\nCookie 被禁用怎么办?\n最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。\nURI 和 URL 的区别是什么? URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。 URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。 URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。\nPING PING 命令的作用是什么？ PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。\n这里简单举一个例子，我们来 PING 一下百度。\n1 2 3 4 5 6 7 8 9 10 11 12 # 发送4个PING请求数据包到 www.baidu.com ❯ ping -c 4 www.baidu.com PING www.a.shifen.com (14.119.104.189): 56 data bytes 64 bytes from 14.119.104.189: icmp_seq=0 ttl=54 time=27.867 ms 64 bytes from 14.119.104.189: icmp_seq=1 ttl=54 time=28.732 ms 64 bytes from 14.119.104.189: icmp_seq=2 ttl=54 time=27.571 ms 64 bytes from 14.119.104.189: icmp_seq=3 ttl=54 time=27.581 ms --- www.a.shifen.com ping statistics --- 4 packets transmitted, 4 packets received, 0.0% packet loss round-trip min/avg/max/stddev = 27.571/27.938/28.732/0.474 ms PING 命令的输出结果通常包括以下几部分信息：\nICMP Echo Request（请求报文）信息：序列号、TTL（Time to Live）值。 目标主机的域名或 IP 地址：输出结果的第一行。 往返时间（RTT，Round-Trip Time）：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。 统计结果（Statistics）：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。 如果 PING 对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题。如果往返时间（RTT）过高，则表明网络延迟过高。\nPING 命令的工作原理是什么？ PING 基于网络层的 ICMP（Internet Control Message Protocol，互联网控制报文协议），其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。\nICMP 报文中包含了类型字段，用于标识 ICMP 报文类型。ICMP 报文的类型有很多种，但大致可以分为两类：\n查询报文类型：向目标主机发送请求并期望得到响应。 差错报文类型：向源主机发送错误信息，用于报告网络中的错误情况。 PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型 。\nPING 命令会向目标主机发送 ICMP Echo Request。 如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。 DNS DNS 的作用是什么？ DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是域名和 IP 地址的映射问题。\n在实际使用中，有一种情况下，浏览器是可以不必动用 DNS 就可以获知域名和 IP 地址的映射的。浏览器在本地会维护一个hosts列表，一般来说浏览器要先查看要访问的域名是否在hosts列表中，如果有的话，直接提取对应的 IP 地址记录，就好了。如果本地hosts列表内没有域名-IP 对应记录的话，那么 DNS 就闪亮登场了。\n目前 DNS 的设计采用的是分布式、层次数据库结构，DNS 是应用层协议，基于 UDP 协议之上，端口为 53 。\nDNS 服务器有哪些？ DNS 服务器自底向上可以依次分为以下几个层级(所有 DNS 服务器都属于以下四个类别之一):\n根 DNS 服务器。根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。 顶级域 DNS 服务器（TLD 服务器）。顶级域是指域名的后缀，如com、org、net和edu等。国家也有自己的顶级域，如uk、fr和ca。TLD 服务器提供了权威 DNS 服务器的 IP 地址。 权威 DNS 服务器。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。 本地 DNS 服务器。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构 DNS工作流程 以下图为例，介绍 DNS 的查询解析过程。DNS 的查询解析过程分为两种模式：\n迭代 递归 下图是实践中常采用的方式，从请求主机到本地 DNS 服务器的查询是递归的，其余的查询时迭代的。\n现在，主机cis.poly.edu想知道gaia.cs.umass.edu的 IP 地址。假设主机cis.poly.edu的本地 DNS 服务器为dns.poly.edu，并且gaia.cs.umass.edu的权威 DNS 服务器为dns.cs.umass.edu。\n首先，主机cis.poly.edu向本地 DNS 服务器dns.poly.edu发送一个 DNS 请求，该查询报文包含被转换的域名gaia.cs.umass.edu。 本地 DNS 服务器dns.poly.edu检查本机缓存，发现并无记录，也不知道gaia.cs.umass.edu的 IP 地址该在何处，不得不向根服务器发送请求。 根服务器注意到请求报文中含有edu顶级域，因此告诉本地 DNS，你可以向edu的 TLD DNS 发送请求，因为目标域名的 IP 地址很可能在那里。 本地 DNS 获取到了edu的 TLD DNS 服务器地址，向其发送请求，询问gaia.cs.umass.edu的 IP 地址。 edu的 TLD DNS 服务器仍不清楚请求域名的 IP 地址，但是它注意到该域名有umass.edu前缀，因此返回告知本地 DNS，umass.edu的权威服务器可能记录了目标域名的 IP 地址。 这一次，本地 DNS 将请求发送给权威 DNS 服务器dns.cs.umass.edu。 终于，由于gaia.cs.umass.edu向权威 DNS 服务器备案过，在这里有它的 IP 地址记录，权威 DNS 成功地将 IP 地址返回给本地 DNS。 最后，本地 DNS 获取到了目标域名的 IP 地址，将其返回给请求主机。 除了迭代式查询，还有一种递归式查询如下图，具体过程和上述类似，只是顺序有所不同。\n另外，DNS 的缓存位于本地 DNS 服务器。由于全世界的根服务器甚少，只有 400 多台，分为 13 组，且顶级域的数量也在一个可数的范围内，因此本地 DNS 通常已经缓存了很多 TLD DNS 服务器，所以在实际查找过程中，无需访问根服务器。根服务器通常是被跳过的，不请求的。\nDNS报文格式 DNS 的报文格式如下图所示：\nDNS 报文分为查询和回答报文，两种形式的报文结构相同。\n标识符。16 比特，用于标识该查询。这个标识符会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和接收到的回答。 标志。1 比特的”查询/回答“标识位，0表示查询报文，1表示回答报文；1 比特的”权威的“标志位（当某 DNS 服务器是所请求名字的权威 DNS 服务器时，且是回答报文，使用”权威的“标志）；1 比特的”希望递归“标志位，显式地要求执行递归查询；1 比特的”递归可用“标志位，用于回答报文中，表示 DNS 服务器支持递归查询。 问题数、回答 RR 数、权威 RR 数、附加 RR 数。分别指示了后面 4 类数据区域出现的数量。 问题区域。包含正在被查询的主机名字，以及正被询问的问题类型。 回答区域。包含了对最初请求的名字的资源记录。在回答报文的回答区域中可以包含多条 RR，因此一个主机名能够有多个 IP 地址。 权威区域。包含了其他权威服务器的记录。 附加区域。包含了其他有帮助的记录。 DNS 记录 DNS 服务器在响应查询时，需要查询自己的数据库，数据库中的条目被称为资源记录(Resource Record，RR)。RR 提供了主机名到 IP 地址的映射。RR 是一个包含了Name, Value, Type, TTL四个字段的四元组。\nTTL是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。\nName和Value字段的取值取决于Type：\n如果Type=A，则Name是主机名信息，Value 是该主机名对应的 IP 地址。这样的 RR 记录了一条主机名到 IP 地址的映射。 如果 Type=AAAA （与 A 记录非常相似），唯一的区别是 A 记录使用的是 IPv4，而 AAAA 记录使用的是 IPv6。 如果Type=CNAME (Canonical Name Record,真实名称记录) ，则Value是别名为Name的主机对应的规范主机名。Value值才是规范主机名。CNAME 记录将一个主机名映射到另一个主机名。CNAME 记录用于为现有的 A 记录创建别名。下文有示例。 如果Type=NS，则Name是个域，而Value是个知道如何获得该域中主机 IP 地址的权威 DNS 服务器的主机名。通常这样的 RR 是由 TLD 服务器发布的。 如果Type=MX ，则Value是个别名为Name的邮件服务器的规范主机名。既然有了 MX 记录，那么邮件服务器可以和其他服务器使用相同的别名。为了获得邮件服务器的规范主机名，需要请求 MX 记录；为了获得其他服务器的规范主机名，需要请求 CNAME 记录。 CNAME记录总是指向另一则域名，而非 IP 地址。假设有下述 DNS zone：\n1 2 3 4 NAME TYPE VALUE -------------------------------------------------- bar.example.com. CNAME foo.example.com. foo.example.com. A 192.0.2.23 当用户查询 bar.example.com 的时候，DNS Server 实际返回的是 foo.example.com 的 IP 地址。\nTCP 和 UDP TCP 与 UDP 的区别（重要） 是否面向连接：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。 是否是可靠传输：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。 是否有状态：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（这很渣男！）。 传输效率：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。 传输形式：TCP 是面向字节流的，UDP 是面向报文的。 首部开销：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。 是否提供广播或多播服务：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多； …… TCP UDP 是否面向连接 是 否 是否可靠 是 否 是否有状态 是 否 传输效率 较慢 较快 传输形式 字节流 数据报文段 首部开销 20 ～ 60 bytes 8 bytes 是否提供广播或多播服务 否 是 什么时候选择 TCP，什么时候选 UDP? UDP 一般用于即时通信，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。 TCP 用于对传输准确性要求特别高的场景，比如文件传输、发送和接收邮件、远程登录等等。 HTTP 基于 TCP 还是 UDP？ HTTP 协议是基于 TCP 协议的，所以发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。\n🐛 修正（参见 issue#1915）：\nHTTP/3.0 之前是基于 TCP 协议的，而 HTTP/3.0 将弃用 TCP，改用 基于 UDP 的 QUIC 协议 。\n此变化解决了 HTTP/2 中存在的队头阻塞问题。队头阻塞是指在 HTTP/2.0 中，多个 HTTP 请求和响应共享一个 TCP 连接，如果其中一个请求或响应因为网络拥塞或丢包而被阻塞，那么后续的请求或响应也无法发送，导致整个连接的效率降低。这是由于 HTTP/2.0 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。HTTP/3.0 在一定程度上解决了队头阻塞问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。\n除了解决队头阻塞问题，HTTP/3.0 还可以减少握手过程的延迟。在 HTTP/2.0 中，如果要建立一个安全的 HTTPS 连接，需要经过 TCP 三次握手和 TLS 握手：\nTCP 三次握手：客户端和服务器交换 SYN 和 ACK 包，建立一个 TCP 连接。这个过程需要 1.5 个 RTT（round-trip time），即一个数据包从发送到接收的时间。 TLS 握手：客户端和服务器交换密钥和证书，建立一个 TLS 加密层。这个过程需要至少 1 个 RTT（TLS 1.3）或者 2 个 RTT（TLS 1.2）。 所以，HTTP/2.0 的连接建立就至少需要 2.5 个 RTT（TLS 1.3）或者 3.5 个 RTT（TLS 1.2）。而在 HTTP/3.0 中，使用的 QUIC 协议（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。\n相关证明可以参考下面这两个链接：\nhttps://zh.wikipedia.org/zh/HTTP/3 https://datatracker.ietf.org/doc/rfc9114/ 使用 TCP 的协议有哪些?使用 UDP 的协议有哪些? 运行于 TCP 协议之上的协议：\nHTTP 协议：超文本传输协议（HTTP，HyperText Transfer Protocol)是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。 HTTPS 协议：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议 FTP 协议：文件传输协议 FTP（File Transfer Protocol）是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。 SMTP 协议：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。 POP3/IMAP 协议：两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。 Telnet 协议：用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。 SSH 协议 : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。 …… 运行于 UDP 协议之上的协议：\nDHCP 协议：动态主机配置协议，动态配置 IP 地址 DNS：域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。 …… TCP 三次握手和四次挥手（传输层） 建立连接-TCP 三次握手 建立一个 TCP 连接需要“三次握手”，缺一不可：\n一次握手:客户端发送带有 SYN（SEQ=x） 标志的数据包 -\u003e 服务端，然后客户端进入 SYN_SEND 状态，等待服务器的确认； 二次握手:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –\u003e 客户端,然后服务端进入 SYN_RECV 状态 三次握手:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –\u003e 服务端，然后客户端和服务器端都进入ESTABLISHED 状态，完成 TCP 三次握手。 当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！\n为什么要三次握手? 三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。\n第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常 第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常 第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常 三次握手就能确认双方收发功能都正常，缺一不可。\n更详细的解答可以看这个：TCP 为什么是三次握手，而不是两次或四次？ - 车小胖的回答 - 知乎\n第 2 次握手传回了 ACK，为什么还要传回 SYN？ 服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。\nSYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。\n断开连接-TCP 四次挥手 断开一个 TCP 连接则需要“四次挥手”，缺一不可：\n第一次挥手：客户端发送一个 FIN（SEQ=x） 标志的数据包-\u003e服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 FIN-WAIT-1 状态。 第二次挥手：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包-\u003e客户端 。然后，此时服务端进入 CLOSE-WAIT 状态，客户端进入 FIN-WAIT-2 状态。 第三次挥手：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包-\u003e客户端请求关闭连接，然后，服务端进入 LAST-ACK 状态。 第四次挥手：客户端发送 ACK (ACK=y+1)标志的数据包-\u003e服务端并且进入TIME-WAIT状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 2MSL 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。 只要四次挥手没有结束，客户端和服务端就可以继续传输数据！\n为什么要四次挥手？ TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。\n举个例子：A 和 B 打电话，通话即将结束后。\n第一次挥手：A 说“我没啥要说的了” 第二次挥手：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话 第三次挥手：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了” 第四次挥手：A 回答“知道了”，这样通话才算结束。 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？ 因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。\n如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？ 客户端没有收到 ACK 确认，会重新发送 FIN 请求。\n为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？ 第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。\nMSL(Maximum Segment Lifetime) : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。\nTCP 传输可靠性保障（传输层） TCP 如何保证传输的可靠性？ 基于数据块传输：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。 对失序数据包重新排序以及去重：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。 校验和 : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。 超时重传 : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为已丢失并进行重传。 流量控制 : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。 拥塞控制 : 当网络拥塞时，减少数据的发送。 TCP 如何实现流量控制？ TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。\n为什么需要流量控制? 这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 接收缓冲区(Receiving Buffers) 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。\n这里需要注意的是（常见误区）：\n发送端不等同于客户端 接收端不等同于服务端 TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是服务端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP 传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同\nTCP 发送窗口可以划分成四个部分：\n已经发送并且确认的 TCP 段（已经发送并确认）； 已经发送但是没有确认的 TCP 段（已经发送未确认）； 未发送但是接收方准备接收的 TCP 段（可以发送）； 未发送并且接收方也并未准备接受的 TCP 段（不可发送）。 TCP 发送窗口结构图示：\nSND.WND：发送窗口。 SND.UNA：Send Unacknowledged 指针，指向发送窗口的第一个字节。 SND.NXT：Send Next 指针，指向可用窗口的第一个字节。 可用窗口大小 = SND.UNA + SND.WND - SND.NXT 。\nTCP 接收窗口可以划分成三个部分：\n已经接收并且已经确认的 TCP 段（已经接收并确认）； 等待接收且允许发送方发送 TCP 段（可以接收未确认）； 不可接收且不允许发送方发送 TCP 段（不可接收）。 TCP 接收窗口结构图示：\n接收窗口的大小是根据接收端处理数据的速度动态调整的。 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。\n另外，这里的滑动窗口大小只是为了演示使用，实际窗口大小通常会远远大于这个值。\nTCP 的拥塞控制是怎么实现的？ 在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。\n为了进行拥塞控制，TCP 发送方要维持一个 拥塞窗口(cwnd) 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。\nTCP 的拥塞控制采用了四种算法，即 慢开始、 拥塞避免、快重传 和 快恢复。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。\n慢开始： 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。 拥塞避免： 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1. 快重传与快恢复： 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。 ARQ 协议了解吗? 自动重传请求（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。\nARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。\n停止等待 ARQ 协议 停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；\n在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。\n1) 无差错情况:\n发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。\n2) 出现差错情况（超时重传）:\n停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 自动重传请求 ARQ 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。\n3) 确认丢失和确认迟到\n确认丢失：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。 确认迟到：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。 连续 ARQ 协议 连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。\n优点： 信道利用率高，容易实现，即使确认丢失，也不必重传。\n缺点： 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。\nIP IP 协议的作用是什么？ IP（Internet Protocol，网际协议） 是 TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。\n目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。\n什么是 IP 地址？IP 寻址如何工作？ 每个连入互联网的设备或域（如计算机、服务器、路由器等）都被分配一个 IP 地址（Internet Protocol address），作为唯一标识符。每个 IP 地址都是一个字符序列，如 192.168.1.1（IPv4）、2001:0db8:85a3:0000:0000:8a2e:0370:7334（IPv6） 。\n当网络设备发送 IP 数据包时，数据包中包含了 源 IP 地址 和 目的 IP 地址 。源 IP 地址用于标识数据包的发送方设备或域，而目的 IP 地址则用于标识数据包的接收方设备或域。这类似于一封邮件中同时包含了目的地地址和回邮地址。\n网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。\n这种基于 IP 地址的寻址方式是互联网通信的基础，它允许数据包在不同的网络之间传递，从而实现了全球范围内的网络互联互通。IP 地址的唯一性和全局性保证了网络中的每个设备都可以通过其独特的 IP 地址进行标识和寻址。\n什么是 IP 地址过滤？ IP 地址过滤（IP Address Filtering） 简单来说就是限制或阻止特定 IP 地址或 IP 地址范围的访问。例如，你有一个图片服务突然被某一个 IP 地址攻击，那我们就可以禁止这个 IP 地址访问图片服务。\nIP 地址过滤是一种简单的网络安全措施，实际应用中一般会结合其他网络安全措施，如认证、授权、加密等一起使用。单独使用 IP 地址过滤并不能完全保证网络的安全。\nIPv4 和 IPv6 有什么区别？ IPv4（Internet Protocol version 4） 是目前广泛使用的 IP 地址版本，其格式是四组由点分隔的数字，例如：123.89.46.72。IPv4 使用 32 位地址作为其 Internet 地址，这意味着共有约 42 亿（ 2^32）个可用 IP 地址。\n这么少当然不够用啦！为了解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议 - IPv6（Internet Protocol version 6）。IPv6 地址使用更复杂的格式，该格式使用由单或双冒号分隔的一组数字和字母，例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334 。IPv6 使用 128 位互联网地址，这意味着越有 2^128（3 开头的 39 位数字，恐怖如斯） 个可用 IP 地址。\n除了更大的地址空间之外，IPv6 的优势还包括：\n无状态地址自动配置（Stateless Address Autoconfiguration，简称 SLAAC）：主机可以直接通过根据接口标识和网络前缀生成全局唯一的 IPv6 地址，而无需依赖 DHCP（Dynamic Host Configuration Protocol）服务器，简化了网络配置和管理。 NAT（Network Address Translation，网络地址转换） 成为可选项：IPv6 地址资源充足，可以给全球每个设备一个独立的地址。 对标头结构进行了改进：IPv6 标头结构相较于 IPv4 更加简化和高效，减少了处理开销，提高了网络性能。 可选的扩展头：允许在 IPv6 标头中添加不同的扩展头（Extension Headers），用于实现不同类型的功能和选项。 ICMPv6（Internet Control Message Protocol for IPv6）：IPv6 中的 ICMPv6 相较于 IPv4 中的 ICMP 有了一些改进，如邻居发现、路径 MTU 发现等功能的改进，从而提升了网络的可靠性和性能。 NAT 的作用是什么？ NAT（Network Address Translation，网络地址转换） 主要用于在不同网络之间转换 IP 地址。它允许将私有 IP 地址（如在局域网中使用的 IP 地址）映射为公有 IP 地址（在互联网中使用的 IP 地址）或者反向映射，从而实现局域网内的多个设备通过单一公有 IP 地址访问互联网。\nNAT 不光可以缓解 IPv4 地址资源短缺的问题，还可以隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络中的设备，从而提高了内部网络的安全性。\n应用场景 NAT 协议（Network Address Translation） 的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，Local Area Network，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（Wide Area Network，WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。\n这个场景其实不难理解。随着一个个小型办公室、家庭办公室（Small Office, Home Office, SOHO）的出现，为了管理这些 SOHO，一个个子网被设计出来，从而在整个 Internet 中的主机数量将非常庞大。如果每个主机都有一个“绝对唯一”的 IP 地址，那么 IPv4 地址的表达能力可能很快达到上限（$2^{32}$）。因此，实际上，SOHO 子网中的 IP 地址是“相对的”，这在一定程度上也缓解了 IPv4 地址的分配压力。\nSOHO 子网的“代理人”，也就是和外界的窗口，通常由路由器扮演。路由器的 LAN 一侧管理着一个小子网，而它的 WAN 接口才是真正参与到 Internet 中的接口，也就有一个“绝对唯一的地址”。NAT 协议，正是在 LAN 中的主机在与 LAN 外界通信时，起到了地址转换的关键作用。\n细节 假设当前场景如上图。中间是一个路由器，它的右侧组织了一个 LAN，网络号为10.0.0/24。LAN 侧接口的 IP 地址为10.0.0.4，并且该子网内有至少三台主机，分别是10.0.0.1，10.0.0.2和10.0.0.3。路由器的左侧连接的是 WAN，WAN 侧接口的 IP 地址为138.76.29.7。\n首先，针对以上信息，我们有如下事实需要说明：\n路由器的右侧子网的网络号为10.0.0/24，主机号为10.0.0/8，三台主机地址，以及路由器的 LAN 侧接口地址，均由 DHCP 协议规定。而且，该 DHCP 运行在路由器内部（路由器自维护一个小 DHCP 服务器），从而为子网内提供 DHCP 服务。 路由器的 WAN 侧接口地址同样由 DHCP 协议规定，但该地址是路由器从 ISP（网络服务提供商）处获得，也就是该 DHCP 通常运行在路由器所在区域的 DHCP 服务器上。 现在，路由器内部还运行着 NAT 协议，从而为 LAN-WAN 间通信提供地址转换服务。为此，一个很重要的结构是 NAT 转换表。为了说明 NAT 的运行细节，假设有以下请求发生：\n主机10.0.0.1向 IP 地址为128.119.40.186的 Web 服务器（端口 80）发送了 HTTP 请求（如请求页面）。此时，主机10.0.0.1将随机指派一个端口，如3345，作为本次请求的源端口号，将该请求发送到路由器中（目的地址将是128.119.40.186，但会先到达10.0.0.4）。 10.0.0.4即路由器的 LAN 接口收到10.0.0.1的请求。路由器将为该请求指派一个新的源端口号，如5001，并将请求报文发送给 WAN 接口138.76.29.7。同时，在 NAT 转换表中记录一条转换记录138.76.29.7:5001——10.0.0.1:3345。 请求报文到达 WAN 接口，继续向目的主机128.119.40.186发送。 之后，将会有如下响应发生：\n主机128.119.40.186收到请求，构造响应报文，并将其发送给目的地138.76.29.7:5001。 响应报文到达路由器的 WAN 接口。路由器查询 NAT 转换表，发现138.76.29.7:5001在转换表中有记录，从而将其目的地址和目的端口转换成为10.0.0.1:3345，再发送到10.0.0.4上。 被转换的响应报文到达路由器的 LAN 接口，继而被转发至目的地10.0.0.1。 修正（参见：issue#2009）：上图第四步的 Dest 值应该为 10.0.0.1:3345 而不是~~138.76.29.7:5001~~，这里笔误了。\n划重点 针对以上过程，有以下几个重点需要强调：\n当请求报文到达路由器，并被指定了新端口号时，由于端口号有 16 位，因此，通常来说，一个路由器管理的 LAN 中的最大主机数 $≈65500$（$2^{16}$ 的地址空间），但通常 SOHO 子网内不会有如此多的主机数量。 对于目的服务器来说，从来不知道“到底是哪个主机给我发送的请求”，它只知道是来自138.76.29.7:5001的路由器转发的请求。因此，可以说，**路由器在 WAN 和 LAN 之间起到了屏蔽作用，**所有内部主机发送到外部的报文，都具有同一个 IP 地址（不同的端口号），所有外部发送到内部的报文，也都只有一个目的地（不同端口号），是经过了 NAT 转换后，外部报文才得以正确地送达内部主机。 在报文穿过路由器，发生 NAT 转换时，如果 LAN 主机 IP 已经在 NAT 转换表中注册过了，则不需要路由器新指派端口，而是直接按照转换记录穿过路由器。同理，外部报文发送至内部时也如此。 总结 NAT 协议的特点，有以下几点：\nNAT 协议通过对 WAN 屏蔽 LAN，有效地缓解了 IPv4 地址分配压力。 LAN 主机 IP 地址的变更，无需通告 WAN。 WAN 的 ISP 变更接口地址时，无需通告 LAN 内主机。 LAN 主机对 WAN 不可见，不可直接寻址，可以保证一定程度的安全性。 然而，NAT 协议由于其独特性，存在着一些争议。比如，可能你已经注意到了，**NAT 协议在 LAN 以外，标识一个内部主机时，使用的是端口号，因为 IP 地址都是相同的。**这种将端口号作为主机寻址的行为，可能会引发一些误会。此外，路由器作为网络层的设备，修改了传输层的分组内容（修改了源 IP 地址和端口号），同样是不规范的行为。但是，尽管如此，NAT 协议作为 IPv4 时代的产物，极大地方便了一些本来棘手的问题，一直被沿用至今。\nARP 每当我们学习一个新的网络协议的时候，都要把他结合到 OSI 七层模型中，或者是 TCP/IP 协议栈中来学习，一是要学习该协议在整个网络协议栈中的位置，二是要学习该协议解决了什么问题，地位如何？三是要学习该协议的工作原理，以及一些更深入的细节。\nARP 协议，可以说是在协议栈中属于一个偏底层的、非常重要的、又非常简单的通信协议。\n开始阅读这篇文章之前，你可以先看看下面几个问题：\nARP 协议在协议栈中的位置？ ARP 协议在协议栈中的位置非常重要，在理解了它的工作原理之后，也很难说它到底是网络层协议，还是链路层协议，因为它恰恰串联起了网络层和链路层。国外的大部分教程通常将 ARP 协议放在网络层。 ARP 协议解决了什么问题，地位如何？ ARP 协议，全称 地址解析协议（Address Resolution Protocol），它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。 ARP 工作原理？ 只希望大家记住几个关键词：ARP 表、广播问询、单播响应。 什么是 Mac 地址？ MAC 地址的全称是 媒体访问控制地址（Media Access Control Address）。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。\n可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。\n还有一点要知道的是，不仅仅是网络资源才有 IP 地址，网络设备也有 IP 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 IP 地址通常是内网 IP，内网的设备在与内网以外的设备进行通信时，需要用到 NAT 协议。\nMAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（$2^{48}$），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是前 24 比特由 IEEE 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 MAC 地址不会重复。\nMAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。\n最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。\nARP 协议工作原理 ARP 协议工作时有一个大前提，那就是 ARP 表。\n在一个局域网内，每个网络设备都自己维护了一个 ARP 表，ARP 表记录了某些其他网络设备的 IP 地址-MAC 地址映射关系，该映射关系以 三元组的形式存储。其中，TTL 为该映射关系的生存周期，典型值为 20 分钟，超过该时间，该条目将被丢弃。\nARP 的工作原理将分两种场景讨论：\n同一局域网内的 MAC 寻址； 从一个局域网到另一个局域网中的网络设备的寻址。 同一局域网内的 MAC 寻址 假设当前有如下场景：IP 地址为137.196.7.23的主机 A，想要给同一局域网内的 IP 地址为137.196.7.14主机 B，发送 IP 数据报文。\n再次强调，当主机发送 IP 数据报文时（网络层），仅知道目的地的 IP 地址，并不清楚目的地的 MAC 地址，而 ARP 协议就是解决这一问题的。\n为了达成这一目标，主机 A 将不得不通过 ARP 协议来获取主机 B 的 MAC 地址，并将 IP 报文封装成链路层帧，发送到下一跳上。在该局域网内，关于此将按照时间顺序，依次发生如下事件：\n主机 A 检索自己的 ARP 表，发现 ARP 表中并无主机 B 的 IP 地址对应的映射条目，也就无从知道主机 B 的 MAC 地址。\n主机 A 将构造一个 ARP 查询分组，并将其广播到所在的局域网中。\nARP 分组是一种特殊报文，ARP 分组有两类，一种是查询分组，另一种是响应分组，它们具有相同的格式，均包含了发送和接收的 IP 地址、发送和接收的 MAC 地址。当然了，查询分组中，发送的 IP 地址，即为主机 A 的 IP 地址，接收的 IP 地址即为主机 B 的 IP 地址，发送的 MAC 地址也是主机 A 的 MAC 地址，但接收的 MAC 地址绝不会是主机 B 的 MAC 地址（因为这正是我们要问询的！），而是一个特殊值——FF-FF-FF-FF-FF-FF，之前说过，该 MAC 地址是广播地址，也就是说，查询分组将广播给该局域网内的所有设备。\n主机 A 构造的查询分组将在该局域网内广播，理论上，每一个设备都会收到该分组，并检查查询分组的接收 IP 地址是否为自己的 IP 地址，如果是，说明查询分组已经到达了主机 B，否则，该查询分组对当前设备无效，丢弃之。\n主机 B 收到了查询分组之后，验证是对自己的问询，接着构造一个 ARP 响应分组，该分组的目的地只有一个——主机 A，发送给主机 A。同时，主机 B 提取查询分组中的 IP 地址和 MAC 地址信息，在自己的 ARP 表中构造一条主机 A 的 IP-MAC 映射记录。\nARP 响应分组具有和 ARP 查询分组相同的构造，不同的是，发送和接受的 IP 地址恰恰相反，发送的 MAC 地址为发送者本身，目标 MAC 地址为查询分组的发送者，也就是说，ARP 响应分组只有一个目的地，而非广播。\n主机 A 终将收到主机 B 的响应分组，提取出该分组中的 IP 地址和 MAC 地址后，构造映射信息，加入到自己的 ARP 表中。\n在整个过程中，有几点需要补充说明的是：\n主机 A 想要给主机 B 发送 IP 数据报，如果主机 B 的 IP-MAC 映射信息已经存在于主机 A 的 ARP 表中，那么主机 A 无需广播，只需提取 MAC 地址并构造链路层帧发送即可。 ARP 表中的映射信息是有生存周期的，典型值为 20 分钟。 目标主机接收到了问询主机构造的问询报文后，将先把问询主机的 IP-MAC 映射存进自己的 ARP 表中，这样才能获取到响应的目标 MAC 地址，顺利的发送响应分组。 总结来说，ARP 协议是一个广播问询，单播响应协议。\n不同局域网内的 MAC 寻址 更复杂的情况是，发送主机 A 和接收主机 B 不在同一个子网中，假设一个一般场景，两台主机所在的子网由一台路由器联通。这里需要注意的是，一般情况下，我们说网络设备都有一个 IP 地址和一个 MAC 地址，这里说的网络设备，更严谨的说法应该是一个接口。路由器作为互联设备，具有多个接口，每个接口同样也应该具备不重复的 IP 地址和 MAC 地址。因此，在讨论 ARP 表时，路由器的多个接口都各自维护一个 ARP 表，而非一个路由器只维护一个 ARP 表。\n接下来，回顾同一子网内的 MAC 寻址，如果主机 A 发送一个广播问询分组，那么 A 所在的子网内所有设备（接口）都将会捕获该分组，因为该分组的目的 IP 与发送主机A的IP在同一个子网中。但是当目的IP与A不在同一子网时，A所在子网内将不会有设备成功接收该分组。那么，主机 A 应该发送怎样的查询分组呢？整个过程按照时间顺序发生的事件如下：\n主机 A 查询 ARP 表，期望寻找到目标路由器的本子网接口的 MAC 地址。\n目标路由器指的是，根据目的主机 B 的 IP 地址，分析出 B 所在的子网，能够把报文转发到 B 所在子网的那个路由器。\n主机 A 未能找到目标路由器的本子网接口的 MAC 地址，将采用 ARP 协议，问询到该 MAC 地址，由于目标接口与主机 A 在同一个子网内，该过程与同一局域网内的 MAC 寻址相同。\n主机 A 获取到目标接口的 MAC 地址，先构造 IP 数据报，其中源 IP 是 A 的 IP 地址，目的 IP 地址是 B 的 IP 地址，再构造链路层帧，其中源 MAC 地址是 A 的 MAC 地址，目的 MAC 地址是本子网内与路由器连接的接口的 MAC 地址。主机 A 将把这个链路层帧，以单播的方式，发送给目标接口。\n目标接口接收到了主机 A 发过来的链路层帧，解析，根据目的 IP 地址，查询转发表，将该 IP 数据报转发到与主机 B 所在子网相连的接口上。\n到此，该帧已经从主机 A 所在的子网，转移到了主机 B 所在的子网了。\n路由器接口查询 ARP 表，期望寻找到主机 B 的 MAC 地址。\n路由器接口如未能找到主机 B 的 MAC 地址，将采用 ARP 协议，广播问询，单播响应，获取到主机 B 的 MAC 地址。\n路由器接口将对 IP 数据报重新封装成链路层帧，目标 MAC 地址为主机 B 的 MAC 地址，单播发送，直到目的地。\n网络攻击常见手段 这篇文章的内容主要是介绍 TCP/IP 常见攻击手段，尤其是 DDoS 攻击，也会补充一些其他的常见网络攻击手段。\nIP 欺骗 IP 是什么? 在网络中，所有的设备都会分配一个地址。这个地址就仿佛小蓝的家地址「多少号多少室」，这个号就是分配给整个子网的，「室」对应的号码即分配给子网中计算机的，这就是网络中的地址。「号」对应的号码为网络号，「室」对应的号码为主机号，这个地址的整体就是 IP 地址。\n通过 IP 地址我们能知道什么？ 通过 IP 地址，我们就可以知道判断访问对象服务器的位置，从而将消息发送到服务器。一般发送者发出的消息首先经过子网的集线器，转发到最近的路由器，然后根据路由位置访问下一个路由器的位置，直到终点\nIP 头部格式 :\nIP 欺骗技术是什么？ IP 欺骗技术就是伪造某台主机的 IP 地址的技术。通过 IP 地址的伪装使得某台主机能够伪装另外的一台主机，而这台主机往往具有某种特权或者被另外的主机所信任。\n假设现在有一个合法用户 (1.1.1.1) 已经同服务器建立正常的连接，攻击者构造攻击的 TCP 数据，伪装自己的 IP 为 1.1.1.1，并向服务器发送一个带有 RSI 位的 TCP 数据段。服务器接收到这样的数据后，认为从 1.1.1.1 发送的连接有错误，就会清空缓冲区中建立好的连接。\n这时，如果合法用户 1.1.1.1 再发送合法数据，服务器就已经没有这样的连接了，该用户就必须从新开始建立连接。攻击时，伪造大量的 IP 地址，向目标发送 RST 数据，使服务器不对合法用户服务。虽然 IP 地址欺骗攻击有着相当难度，但我们应该清醒地意识到，这种攻击非常广泛，入侵往往从这种攻击开始。\n如何缓解 IP 欺骗？ 虽然无法预防 IP 欺骗，但可以采取措施来阻止伪造数据包渗透网络。入口过滤 是防范欺骗的一种极为常见的防御措施，如 BCP38（通用最佳实践文档）所示。入口过滤是一种数据包过滤形式，通常在网络边缘设备上实施，用于检查传入的 IP 数据包并确定其源标头。如果这些数据包的源标头与其来源不匹配或者看上去很可疑，则拒绝这些数据包。一些网络还实施出口过滤，检查退出网络的 IP 数据包，确保这些数据包具有合法源标头，以防止网络内部用户使用 IP 欺骗技术发起出站恶意攻击。\nSYN Flood(洪水) SYN Flood 是互联网上最原始、最经典的 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击之一，旨在耗尽可用服务器资源，致使服务器无法传输合法流量\nSYN Flood 利用了 TCP 协议的三次握手机制，攻击者通常利用工具或者控制僵尸主机向服务器发送海量的变源 IP 地址或变源端口的 TCP SYN 报文，服务器响应了这些报文后就会生成大量的半连接，当系统资源被耗尽后，服务器将无法提供正常的服务。 增加服务器性能，提供更多的连接能力对于 SYN Flood 的海量报文来说杯水车薪，防御 SYN Flood 的关键在于判断哪些连接请求来自于真实源，屏蔽非真实源的请求以保障正常的业务请求能得到服务。\nTCP SYN Flood 攻击原理是什么？ TCP SYN Flood 攻击利用的是 TCP 的三次握手（SYN -\u003e SYN/ACK -\u003e ACK），假设连接发起方是 A，连接接受方是 B，即 B 在某个端口（Port）上监听 A 发出的连接请求，过程如下图所示，左边是 A，右边是 B。\nA 首先发送 SYN（Synchronization）消息给 B，要求 B 做好接收数据的准备；B 收到后反馈 SYN-ACK（Synchronization-Acknowledgement） 消息给 A，这个消息的目的有两个：\n向 A 确认已做好接收数据的准备， 同时要求 A 也做好接收数据的准备，此时 B 已向 A 确认好接收状态，并等待 A 的确认，连接处于半开状态（Half-Open），顾名思义只开了一半；A 收到后再次发送 ACK (Acknowledgement) 消息给 B，向 B 确认也做好了接收数据的准备，至此三次握手完成，「连接」就建立了， 大家注意到没有，最关键的一点在于双方是否都按对方的要求进入了可以接收消息的状态。而这个状态的确认主要是双方将要使用的消息序号(**SequenceNum)，**TCP** 为保证消息按发送顺序抵达接收方的上层应用，需要用**消息序号来标记消息的发送先后顺序的。\nTCP是「双工」(Duplex)连接，同时支持双向通信，也就是双方同时可向对方发送消息，其中 SYN 和 SYN-ACK 消息开启了 A→B 的单向通信通道（B 获知了 A 的消息序号）；SYN-ACK 和 ACK 消息开启了 B→A 单向通信通道（A 获知了 B 的消息序号）。\n上面讨论的是双方在诚实守信，正常情况下的通信。\n但实际情况是，网络可能不稳定会丢包，使握手消息不能抵达对方，也可能是对方故意不按规矩来，故意延迟或不发送握手确认消息。\n假设 B 通过某 TCP 端口提供服务，B 在收到 A 的 SYN 消息时，积极的反馈了 SYN-ACK 消息，使连接进入半开状态，因为 B 不确定自己发给 A 的 SYN-ACK 消息或 A 反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接都设一个Timer，如果超过时间还没有收到 A 的 ACK 消息，则重新发送一次 SYN-ACK 消息给 A，直到重试超过一定次数时才会放弃。\nB 为帮助 A 能顺利连接，需要分配内核资源维护半开连接，那么当 B 面临海量的连接 A 时，如上图所示，SYN Flood 攻击就形成了。攻击方 A 可以控制肉鸡向 B 发送大量 SYN 消息但不响应 ACK 消息，或者干脆伪造 SYN 消息中的 Source IP，使 B 反馈的 SYN-ACK 消息石沉大海，导致 B 被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。\nSYN Flood 的常见形式有哪些？ 恶意用户可通过三种不同方式发起 SYN Flood 攻击：\n直接攻击： 不伪造 IP 地址的 SYN 洪水攻击称为直接攻击。在此类攻击中，攻击者完全不屏蔽其 IP 地址。由于攻击者使用具有真实 IP 地址的单一源设备发起攻击，因此很容易发现并清理攻击者。为使目标机器呈现半开状态，黑客将阻止个人机器对服务器的 SYN-ACK 数据包做出响应。为此，通常采用以下两种方式实现：部署防火墙规则，阻止除 SYN 数据包以外的各类传出数据包；或者，对传入的所有 SYN-ACK 数据包进行过滤，防止其到达恶意用户机器。实际上，这种方法很少使用（即便使用过也不多见），因为此类攻击相当容易缓解 – 只需阻止每个恶意系统的 IP 地址。哪怕攻击者使用僵尸网络（如 Mirai 僵尸网络），通常也不会刻意屏蔽受感染设备的 IP。 欺骗攻击： 恶意用户还可以伪造其发送的各个 SYN 数据包的 IP 地址，以便阻止缓解措施并加大身份暴露难度。虽然数据包可能经过伪装，但还是可以通过这些数据包追根溯源。此类检测工作很难开展，但并非不可实现；特别是，如果 Internet 服务提供商 (ISP) 愿意提供帮助，则更容易实现。 分布式攻击（DDoS）： 如果使用僵尸网络发起攻击，则追溯攻击源头的可能性很低。随着混淆级别的攀升，攻击者可能还会命令每台分布式设备伪造其发送数据包的 IP 地址。哪怕攻击者使用僵尸网络（如 Mirai 僵尸网络），通常也不会刻意屏蔽受感染设备的 IP。 如何缓解 SYN Flood？ 扩展积压工作队列\n目标设备安装的每个操作系统都允许具有一定数量的半开连接。若要响应大量 SYN 数据包，一种方法是增加操作系统允许的最大半开连接数目。为成功扩展最大积压工作，系统必须额外预留内存资源以处理各类新请求。如果系统没有足够的内存，无法应对增加的积压工作队列规模，将对系统性能产生负面影响，但仍然好过拒绝服务。\n回收最先创建的 TCP 半开连接\n另一种缓解策略是在填充积压工作后覆盖最先创建的半开连接。这项策略要求完全建立合法连接的时间低于恶意 SYN 数据包填充积压工作的时间。当攻击量增加或积压工作规模小于实际需求时，这项特定的防御措施将不奏效。\nSYN Cookie\n此策略要求服务器创建 Cookie。为避免在填充积压工作时断开连接，服务器使用 SYN-ACK 数据包响应每一项连接请求，而后从积压工作中删除 SYN 请求，同时从内存中删除请求，保证端口保持打开状态并做好重新建立连接的准备。如果连接是合法请求并且已将最后一个 ACK 数据包从客户端机器发回服务器，服务器将重建（存在一些限制）SYN 积压工作队列条目。虽然这项缓解措施势必会丢失一些 TCP 连接信息，但好过因此导致对合法用户发起拒绝服务攻击。\nUDP Flood(洪水) UDP Flood 也是一种拒绝服务攻击，将大量的用户数据报协议（UDP）数据包发送到目标服务器，目的是压倒该设备的处理和响应能力。防火墙保护目标服务器也可能因 UDP 泛滥而耗尽，从而导致对合法流量的拒绝服务。\nUDP Flood 攻击原理是什么？ UDP Flood 主要通过利用服务器响应发送到其中一个端口的 UDP 数据包所采取的步骤。在正常情况下，当服务器在特定端口接收到 UDP 数据包时，会经过两个步骤：\n服务器首先检查是否正在运行正在侦听指定端口的请求的程序。 如果没有程序在该端口接收数据包，则服务器使用 ICMP（ping）数据包进行响应，以通知发送方目的地不可达。 举个例子。假设今天要联系酒店的小蓝，酒店客服接到电话后先查看房间的列表来确保小蓝在客房内，随后转接给小蓝。\n首先，接待员接收到呼叫者要求连接到特定房间的电话。接待员然后需要查看所有房间的清单，以确保客人在房间中可用，并愿意接听电话。碰巧的是，此时如果突然间所有的电话线同时亮起来，那么他们就会很快就变得不堪重负了。\n当服务器接收到每个新的 UDP 数据包时，它将通过步骤来处理请求，并利用该过程中的服务器资源。发送 UDP 报文时，每个报文将包含源设备的 IP 地址。在这种类型的 DDoS 攻击期间，攻击者通常不会使用自己的真实 IP 地址，而是会欺骗 UDP 数据包的源 IP 地址，从而阻止攻击者的真实位置被暴露并潜在地饱和来自目标的响应数据包服务器。\n由于目标服务器利用资源检查并响应每个接收到的 UDP 数据包的结果，当接收到大量 UDP 数据包时，目标的资源可能会迅速耗尽，导致对正常流量的拒绝服务\n如何缓解 UDP Flooding？ 大多数操作系统部分限制了 ICMP 报文的响应速率，以中断需要 ICMP 响应的 DDoS 攻击。这种缓解的一个缺点是在攻击过程中，合法的数据包也可能被过滤。如果 UDP Flood 的容量足够高以使目标服务器的防火墙的状态表饱和，则在服务器级别发生的任何缓解都将不足以应对目标设备上游的瓶颈。\nHTTP Flood(洪水) HTTP Flood 是一种大规模的 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击，旨在利用 HTTP 请求使目标服务器不堪重负。目标因请求而达到饱和，且无法响应正常流量后，将出现拒绝服务，拒绝来自实际用户的其他请求。\nHTTP Flood 的攻击原理是什么？ HTTP 洪水攻击是“第 7 层”DDoS 攻击的一种。第 7 层是 OSI 模型的应用程序层，指的是 HTTP 等互联网协议。HTTP 是基于浏览器的互联网请求的基础，通常用于加载网页或通过互联网发送表单内容。缓解应用程序层攻击特别复杂，因为恶意流量和正常流量很难区分。\n为了获得最大效率，恶意行为者通常会利用或创建僵尸网络，以最大程度地扩大攻击的影响。通过利用感染了恶意软件的多台设备，攻击者可以发起大量攻击流量来进行攻击。\nHTTP 洪水攻击有两种：\nHTTP GET 攻击：在这种攻击形式下，多台计算机或其他设备相互协调，向目标服务器发送对图像、文件或其他资产的多个请求。当目标被传入的请求和响应所淹没时，来自正常流量源的其他请求将被拒绝服务。 HTTP POST 攻击：一般而言，在网站上提交表单时，服务器必须处理传入的请求并将数据推送到持久层（通常是数据库）。与发送 POST 请求所需的处理能力和带宽相比，处理表单数据和运行必要数据库命令的过程相对密集。这种攻击利用相对资源消耗的差异，直接向目标服务器发送许多 POST 请求，直到目标服务器的容量饱和并拒绝服务为止。 如何防护 HTTP Flood？ 如前所述，缓解第 7 层攻击非常复杂，而且通常要从多方面进行。一种方法是对发出请求的设备实施质询，以测试它是否是机器人，这与在线创建帐户时常用的 CAPTCHA 测试非常相似。通过提出 JavaScript 计算挑战之类的要求，可以缓解许多攻击。\n其他阻止 HTTP 洪水攻击的途径包括使用 Web 应用程序防火墙 (WAF)、管理 IP 信誉数据库以跟踪和有选择地阻止恶意流量，以及由工程师进行动态分析。Cloudflare 具有超过 2000 万个互联网设备的规模优势，能够分析来自各种来源的流量并通过快速更新的 WAF 规则和其他防护策略来缓解潜在的攻击，从而消除应用程序层 DDoS 流量。\nDNS Flood(洪水) 域名系统（DNS）服务器是互联网的“电话簿“；互联网设备通过这些服务器来查找特定 Web 服务器以便访问互联网内容。DNS Flood 攻击是一种分布式拒绝服务（DDoS）攻击，攻击者用大量流量淹没某个域的 DNS 服务器，以尝试中断该域的 DNS 解析。如果用户无法找到电话簿，就无法查找到用于调用特定资源的地址。通过中断 DNS 解析，DNS Flood 攻击将破坏网站、API 或 Web 应用程序响应合法流量的能力。很难将 DNS Flood 攻击与正常的大流量区分开来，因为这些大规模流量往往来自多个唯一地址，查询该域的真实记录，模仿合法流量。\nDNS Flood 的攻击原理是什么？ 域名系统的功能是将易于记忆的名称（例如 example.com）转换成难以记住的网站服务器地址（例如 192.168.0.1），因此成功攻击 DNS 基础设施将导致大多数人无法使用互联网。DNS Flood 攻击是一种相对较新的基于 DNS 的攻击，这种攻击是在高带宽物联网（IoT）僵尸网络（如 Mirai）兴起后激增的。DNS Flood 攻击使用 IP 摄像头、DVR 盒和其他 IoT 设备的高带宽连接直接淹没主要提供商的 DNS 服务器。来自 IoT 设备的大量请求淹没 DNS 提供商的服务，阻止合法用户访问提供商的 DNS 服务器。\nDNS Flood 攻击不同于 DNS 放大攻击。与 DNS Flood 攻击不同，DNS 放大攻击反射并放大不安全 DNS 服务器的流量，以便隐藏攻击的源头并提高攻击的有效性。DNS 放大攻击使用连接带宽较小的设备向不安全的 DNS 服务器发送无数请求。这些设备对非常大的 DNS 记录发出小型请求，但在发出请求时，攻击者伪造返回地址为目标受害者。这种放大效果让攻击者能借助有限的攻击资源来破坏较大的目标。\n如何防护 DNS Flood? DNS Flood 对传统上基于放大的攻击方法做出了改变。借助轻易获得的高带宽僵尸网络，攻击者现能针对大型组织发动攻击。除非被破坏的 IoT 设备得以更新或替换，否则抵御这些攻击的唯一方法是使用一个超大型、高度分布式的 DNS 系统，以便实时监测、吸收和阻止攻击流量。\nTCP 重置攻击 在 TCP 重置攻击中，攻击者通过向通信的一方或双方发送伪造的消息，告诉它们立即断开连接，从而使通信双方连接中断。正常情况下，如果客户端收发现到达的报文段对于相关连接而言是不正确的，TCP 就会发送一个重置报文段，从而导致 TCP 连接的快速拆卸。\nTCP 重置攻击利用这一机制，通过向通信方发送伪造的重置报文段，欺骗通信双方提前关闭 TCP 连接。如果伪造的重置报文段完全逼真，接收者就会认为它有效，并关闭 TCP 连接，防止连接被用来进一步交换信息。服务端可以创建一个新的 TCP 连接来恢复通信，但仍然可能会被攻击者重置连接。万幸的是，攻击者需要一定的时间来组装和发送伪造的报文，所以一般情况下这种攻击只对长连接有杀伤力，对于短连接而言，你还没攻击呢，人家已经完成了信息交换。\n从某种意义上来说，伪造 TCP 报文段是很容易的，因为 TCP/IP 都没有任何内置的方法来验证服务端的身份。有些特殊的 IP 扩展协议（例如 IPSec）确实可以验证身份，但并没有被广泛使用。客户端只能接收报文段，并在可能的情况下使用更高级别的协议（如 TLS）来验证服务端的身份。但这个方法对 TCP 重置包并不适用，因为 TCP 重置包是 TCP 协议本身的一部分，无法使用更高级别的协议进行验证。\n模拟攻击 以下实验是在 OSX 系统中完成的，其他系统请自行测试。\n现在来总结一下伪造一个 TCP 重置报文要做哪些事情：\n嗅探通信双方的交换信息。 截获一个 ACK 标志位置位 1 的报文段，并读取其 ACK 号。 伪造一个 TCP 重置报文段（RST 标志位置为 1），其序列号等于上面截获的报文的 ACK 号。这只是理想情况下的方案，假设信息交换的速度不是很快。大多数情况下为了增加成功率，可以连续发送序列号不同的重置报文。 将伪造的重置报文发送给通信的一方或双方，时其中断连接。 为了实验简单，我们可以使用本地计算机通过 localhost 与自己通信，然后对自己进行 TCP 重置攻击。需要以下几个步骤：\n在两个终端之间建立一个 TCP 连接。 编写一个能嗅探通信双方数据的攻击程序。 修改攻击程序，伪造并发送重置报文。 下面正式开始实验。\n建立 TCP 连接\n可以使用 netcat 工具来建立 TCP 连接，这个工具很多操作系统都预装了。打开第一个终端窗口，运行以下命令：\n1 $ nc -nvl 8000 这个命令会启动一个 TCP 服务，监听端口为 8000。接着再打开第二个终端窗口，运行以下命令：\n1 $ nc 127.0.0.1 8000 该命令会尝试与上面的服务建立连接，在其中一个窗口输入一些字符，就会通过 TCP 连接发送给另一个窗口并打印出来。\n嗅探流量\n编写一个攻击程序，使用 Python 网络库 scapy 来读取两个终端窗口之间交换的数据，并将其打印到终端上。代码比较长，下面为一部份，完整代码后台回复 TCP 攻击，代码的核心是调用 scapy 的嗅探方法：\n这段代码告诉 scapy 在 lo0 网络接口上嗅探数据包，并记录所有 TCP 连接的详细信息。\niface : 告诉 scapy 在 lo0（localhost）网络接口上进行监听。 lfilter : 这是个过滤器，告诉 scapy 忽略所有不属于指定的 TCP 连接（通信双方皆为 localhost，且端口号为 8000）的数据包。 prn : scapy 通过这个函数来操作所有符合 lfilter 规则的数据包。上面的例子只是将数据包打印到终端，下文将会修改函数来伪造重置报文。 count : scapy 函数返回之前需要嗅探的数据包数量。 发送伪造的重置报文\n下面开始修改程序，发送伪造的 TCP 重置报文来进行 TCP 重置攻击。根据上面的解读，只需要修改 prn 函数就行了，让其检查数据包，提取必要参数，并利用这些参数来伪造 TCP 重置报文并发送。\n例如，假设该程序截获了一个从（src_ip, src_port）发往 （dst_ip, dst_port）的报文段，该报文段的 ACK 标志位已置为 1，ACK 号为 100,000。攻击程序接下来要做的是：\n由于伪造的数据包是对截获的数据包的响应，所以伪造数据包的源 IP/Port 应该是截获数据包的目的 IP/Port，反之亦然。 将伪造数据包的 RST 标志位置为 1，以表示这是一个重置报文。 将伪造数据包的序列号设置为截获数据包的 ACK 号，因为这是发送方期望收到的下一个序列号。 调用 scapy 的 send 方法，将伪造的数据包发送给截获数据包的发送方。 对于我的程序而言，只需将这一行取消注释，并注释这一行的上面一行，就可以全面攻击了。按照步骤 1 的方法设置 TCP 连接，打开第三个窗口运行攻击程序，然后在 TCP 连接的其中一个终端输入一些字符串，你会发现 TCP 连接被中断了！\n进一步实验\n可以继续使用攻击程序进行实验，将伪造数据包的序列号加减 1 看看会发生什么，是不是确实需要和截获数据包的 ACK 号完全相同。 打开 Wireshark，监听 lo0 网络接口，并使用过滤器 ip.src == 127.0.0.1 \u0026\u0026 ip.dst == 127.0.0.1 \u0026\u0026 tcp.port == 8000 来过滤无关数据。你可以看到 TCP 连接的所有细节。 在连接上更快速地发送数据流，使攻击更难执行。 中间人攻击 攻击中间人攻击英文名叫 Man-in-the-MiddleAttack，简称「MITM 攻击」。指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方 直接对话，但事实上整个会话都被攻击者完全控制。我们画一张图：\n中间人攻击的原理是什么？ 举个例子，我和公司签了一个一份劳动合同，一人一份合同。不晓得哪个可能改了合同内容，不知道真假了，怎么搞？只好找专业的机构来鉴定，自然就要花钱。\n在安全领域有句话：我们没有办法杜绝网络犯罪，只好想办法提高网络犯罪的成本。既然没法杜绝这种情况，那我们就想办法提高作案的成本，今天我们就简单了解下基本的网络安全知识，也是面试中的高频面试题了。\n为了避免双方说活不算数的情况，双方引入第三家机构，将合同原文给可信任的第三方机构，只要这个机构不监守自盗，合同就相对安全。\n如果第三方机构内部不严格或容易出现纰漏？\n虽然我们将合同原文给第三方机构了，为了防止内部人员的更改，需要采取什么措施呢\n一种可行的办法是引入 摘要算法 。即合同和摘要一起，为了简单的理解摘要。大家可以想象这个摘要为一个函数，这个函数对原文进行了加密，会产生一个唯一的散列值，一旦原文发生一点点变化，那么这个散列值将会变化。\n有哪些常用的摘要算法呢？ 目前比较常用的加密算法有消息摘要算法和安全散列算法(SHA)。MD5 是将任意长度的文章转化为一个 128 位的散列值，可是在 2004 年，MD5 被证实了容易发生碰撞，即两篇原文产生相同的摘要。这样的话相当于直接给黑客一个后门，轻松伪造摘要。\n所以在大部分的情况下都会选择 SHA 算法 。\n出现内鬼了怎么办？\n看似很安全的场面了，理论上来说杜绝了篡改合同的做法。主要某个员工同时具有修改合同和摘要的权利，那搞事儿就是时间的问题了，毕竟没哪个系统可以完全的杜绝员工接触敏感信息，除非敏感信息都不存在。所以能不能考虑将合同和摘要分开存储呢\n那如何确保员工不会修改合同呢？\n这确实蛮难的，不过办法总比困难多。我们将合同放在双方手中，摘要放在第三方机构，篡改难度进一步加大\n那么员工万一和某个用户串通好了呢？\n看来放在第三方的机构还是不好使，同样存在不小风险。所以还需要寻找新的方案，这就出现了 数字签名和证书。\n数字证书和签名有什么用？ 同样的，举个例子。Sum 和 Mike 两个人签合同。Sum 首先用 SHA 算法计算合同的摘要，然后用自己私钥将摘要加密，得到数字签名。Sum 将合同原文、签名，以及公钥三者都交给 Mike\n如果 Sum 想要证明合同是 Mike 的，那么就要使用 Mike 的公钥，将这个签名解密得到摘要 x，然后 Mike 计算原文的 sha 摘要 Y，随后对比 x 和 y，如果两者相等，就认为数据没有被篡改\n在这样的过程中，Mike 是不能更改 Sum 的合同，因为要修改合同不仅仅要修改原文还要修改摘要，修改摘要需要提供 Mike 的私钥，私钥即 Sum 独有的密码，公钥即 Sum 公布给他人使用的密码\n总之，公钥加密的数据只能私钥可以解密。私钥加密的数据只有公钥可以解密，这就是 非对称加密 。\n隐私保护？不是吓唬大家，信息是透明的兄 die，不过尽量去维护个人的隐私吧，今天学习对称加密和非对称加密。\n大家先读读这个字\"钥\",是读\"yao\"，我以前也是，其实读\"yue\"\n什么是对称加密？ 对称加密，顾名思义，加密方与解密方使用同一钥匙(秘钥)。具体一些就是，发送方通过使用相应的加密算法和秘钥，对将要发送的信息进行加密；对于接收方而言，使用解密算法和相同的秘钥解锁信息，从而有能力阅读信息。\n常见的对称加密算法有哪些？ DES\nDES 使用的密钥表面上是 64 位的，然而只有其中的 56 位被实际用于算法，其余 8 位可以被用于奇偶校验，并在算法中被丢弃。因此，DES 的有效密钥长度为 56 位，通常称 DES 的密钥长度为 56 位。假设秘钥为 56 位，采用暴力破 Jie 的方式，其秘钥个数为 2 的 56 次方，那么每纳秒执行一次解密所需要的时间差不多 1 年的样子。当然，没人这么干。DES 现在已经不是一种安全的加密方法，主要因为它使用的 56 位密钥过短。\nIDEA\n国际数据加密算法(International Data Encryption Algorithm)。秘钥长度 128 位，优点没有专利的限制。\nAES\n当 DES 被破解以后，没过多久推出了 AES 算法，提供了三种长度供选择，128 位、192 位和 256，为了保证性能不受太大的影响，选择 128 即可。\nSM1 和 SM4\n之前几种都是国外的，我们国内自行研究了国密 **SM1 **和 SM4。其中 S 都属于国家标准，算法公开。优点就是国家的大力支持和认可\n总结：\n常见的非对称加密算法有哪些？ 在对称加密中，发送方与接收方使用相同的秘钥。那么在非对称加密中则是发送方与接收方使用的不同的秘钥。其主要解决的问题是防止在秘钥协商的过程中发生泄漏。比如在对称加密中，小蓝将需要发送的消息加密，然后告诉你密码是 123balala,ok,对于其他人而言，很容易就能劫持到密码是 123balala。那么在非对称的情况下，小蓝告诉所有人密码是 123balala,对于中间人而言，拿到也没用，因为没有私钥。所以，非对称密钥其实主要解决了密钥分发的难题。如下图\n其实我们经常都在使用非对称加密，比如使用多台服务器搭建大数据平台 hadoop，为了方便多台机器设置免密登录，是不是就会涉及到秘钥分发。再比如搭建 docker 集群也会使用相关非对称加密算法。\n常见的非对称加密算法：\nRSA（RSA 加密算法，RSA Algorithm）：优势是性能比较快，如果想要较高的加密难度，需要很长的秘钥。 ECC：基于椭圆曲线提出。是目前加密强度最高的非对称加密算法 SM2：同样基于椭圆曲线问题设计。最大优势就是国家认可和大力支持。 常见的散列算法有哪些？ 这个大家应该更加熟悉了，比如我们平常使用的 MD5 校验，在很多时候，我并不是拿来进行加密，而是用来获得唯一性 ID。在做系统的过程中，存储用户的各种密码信息，通常都会通过散列算法，最终存储其散列值。\nMD5\nMD5 可以用来生成一个 128 位的消息摘要，它是目前应用比较普遍的散列算法，具体的应用场景你可以自行  参阅。虽然，因为算法的缺陷，它的唯一性已经被破解了，但是大部分场景下，这并不会构成安全问题。但是，如果不是长度受限（32 个字符），我还是不推荐你继续使用 MD5 的。\nSHA\n安全散列算法。SHA 分为 SHA1 和 SH2 两个版本。该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。\nSM3\n国密算法SM3。加密强度和 SHA-256 想不多。主要是收到国家的支持。\n大部分情况下使用对称加密，具有比较不错的安全性。如果需要分布式进行秘钥分发，考虑非对称。如果不需要可逆计算则散列算法。\n第三方机构和证书机制有什么用？ 问题还有，此时如果 Sum 否认给过 Mike 的公钥和合同，不久 gg 了\n所以需要 Sum 过的话做过的事儿需要足够的信誉，这就引入了 第三方机构和证书机制 。\n证书之所以会有信用，是因为证书的签发方拥有信用。所以如果 Sum 想让 Mike 承认自己的公钥，Sum 不会直接将公钥给 Mike ，而是提供由第三方机构，含有公钥的证书。如果 Mike 也信任这个机构，法律都认可，那 ik，信任关系成立\n如上图所示，Sum 将自己的申请提交给机构，产生证书的原文。机构用自己的私钥签名 Sum 的申请原文（先根据原文内容计算摘要，再用私钥加密），得到带有签名信息的证书。Mike 拿到带签名信息的证书，通过第三方机构的公钥进行解密，获得 Sum 证书的摘要、证书的原文。有了 Sum 证书的摘要和原文，Mike 就可以进行验签。验签通过，Mike 就可以确认 Sum 的证书的确是第三方机构签发的。\n用上面这样一个机制，合同的双方都无法否认合同。这个解决方案的核心在于需要第三方信用服务机构提供信用背书。这里产生了一个最基础的信任链，如果第三方机构的信任崩溃，比如被黑客攻破，那整条信任链条也就断裂了\n为了让这个信任条更加稳固，就需要环环相扣，打造更长的信任链，避免单点信任风险\n上图中，由信誉最好的根证书机构提供根证书，然后根证书机构去签发二级机构的证书；二级机构去签发三级机构的证书；最后有由三级机构去签发 Sum 证书。\n如果要验证 Sum 证书的合法性，就需要用三级机构证书中的公钥去解密 Sum 证书的数字签名。\n如果要验证三级机构证书的合法性，就需要用二级机构的证书去解密三级机构证书的数字签名。\n如果要验证二级结构证书的合法性，就需要用根证书去解密。\n以上，就构成了一个相对长一些的信任链。如果其中一方想要作弊是非常困难的，除非链条中的所有机构同时联合起来，进行欺诈。\n中间人攻击如何避免? 既然知道了中间人攻击的原理也知道了他的危险，现在我们看看如何避免。相信我们都遇到过下面这种状况：\n出现这个界面的很多情况下，都是遇到了中间人攻击的现象，需要对安全证书进行及时地监测。而且大名鼎鼎的 github 网站，也曾遭遇过中间人攻击：\n想要避免中间人攻击的方法目前主要有两个：\n客户端不要轻易相信证书：因为这些证书极有可能是中间人。 App 可以提前预埋证书在本地：意思是我们本地提前有一些证书，这样其他证书就不能再起作用了。 DDoS 通过上面的描述，大部分攻击都是 DDOS 攻击，所以简单总结下这个攻击相关内容。\n其实，像全球互联网各大公司，均遭受过大量的 DDoS。\n2018 年，GitHub 在一瞬间遭到高达 1.35Tbps 的带宽攻击。这次 DDoS 攻击几乎可以堪称是互联网有史以来规模最大、威力最大的 DDoS 攻击了。在 GitHub 遭到攻击后，仅仅一周后，DDoS 攻击又开始对 Google、亚马逊甚至 Pornhub 等网站进行了 DDoS 攻击。后续的 DDoS 攻击带宽最高也达到了 1Tbps。\nDDoS究竟是什么 DDos 全名 Distributed Denial of Service，翻译成中文就是分布式拒绝服务。指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。单一的 DoS 攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用欺骗和伪装的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。\n举个例子\n我开了一家有五十个座位的重庆火锅店，由于用料上等，童叟无欺。平时门庭若市，生意特别红火，而对面二狗家的火锅店却无人问津。二狗为了对付我，想了一个办法，叫了五十个人来我的火锅店坐着却不点菜，让别的客人无法吃饭。\n上面这个例子讲的就是典型的 DDoS 攻击，一般来说是指攻击者利用“肉鸡”对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。在线游戏、互联网金融等领域是 DDoS 攻击的高发行业。\n攻击方式很多，比如 ICMP Flood、UDP Flood、NTP Flood、SYN Flood、CC 攻击、DNS Query Flood等等。\n如何应对 DDoS 攻击？ 高防服务器\n还是拿开的重庆火锅店举例，高防服务器就是我给重庆火锅店增加了两名保安，这两名保安可以让保护店铺不受流氓骚扰，并且还会定期在店铺周围巡逻防止流氓骚扰。\n高防服务器主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等，这东西是不错，就是贵~\n黑名单\n面对火锅店里面的流氓，我一怒之下将他们拍照入档，并禁止他们踏入店铺，但是有的时候遇到长得像的人也会禁止他进入店铺。这个就是设置黑名单，此方法秉承的就是“错杀一千，也不放一百”的原则，会封锁正常流量，影响到正常业务。\nDDoS 清洗\nDDos 清洗，就是我发现客人进店几分钟以后，但是一直不点餐，我就把他踢出店里。\nDDoS 清洗会对用户请求数据进行实时监控，及时发现 DOS 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。\nCDN 加速\nCDN 加速，我们可以这么理解：为了减少流氓骚扰，我干脆将火锅店开到了线上，承接外卖服务，这样流氓找不到店在哪里，也耍不来流氓了。\n在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 DDoS 攻击，也可以将流量分散到各个节点中，防止源站崩溃。\n",
  "wordCount" : "45819",
  "inLanguage": "en",
  "datePublished": "2023-07-14T05:00:00Z",
  "dateModified": "2023-07-14T05:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Wjy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://funny-toffee-4aa7c3.netlify.app/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Wjy's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://funny-toffee-4aa7c3.netlify.app/favicon.ico"
    }
  }
}
</script>

  <script id="MathJax-script" async src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-chtml.min.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath:  [['\\(', '\\)'], ['$', '$']],  
    }
  };
</script>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://funny-toffee-4aa7c3.netlify.app/en/" accesskey="h" title="Wjy&#39;s Blog (Alt + H)">Wjy&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/en/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/en/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/en/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/en/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/en/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://funny-toffee-4aa7c3.netlify.app/en/">Home</a>&nbsp;»&nbsp;<a href="https://funny-toffee-4aa7c3.netlify.app/en/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      7_计算机网络面试题
    </h1>
    <div class="post-meta"><span title='2023-07-14 05:00:00 +0000 UTC'>2023-07-14</span>&nbsp;·&nbsp;Wjy

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%bd%91%e7%bb%9c%e5%9f%ba%e7%a1%80" aria-label="计算机网络基础">计算机网络基础</a><ul>
                        
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c%e5%88%86%e5%b1%82%e6%a8%a1%e5%9e%8b" aria-label="网络分层模型">网络分层模型</a><ul>
                        
                <li>
                    <a href="#osi-%e4%b8%83%e5%b1%82%e6%a8%a1%e5%9e%8b%e6%98%af%e4%bb%80%e4%b9%88%e6%af%8f%e4%b8%80%e5%b1%82%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88" aria-label="OSI 七层模型是什么？每一层的作用是什么？">OSI 七层模型是什么？每一层的作用是什么？</a></li>
                <li>
                    <a href="#tcpip-%e5%9b%9b%e5%b1%82%e6%a8%a1%e5%9e%8b%e6%98%af%e4%bb%80%e4%b9%88%e6%af%8f%e4%b8%80%e5%b1%82%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88" aria-label="TCP/IP 四层模型是什么？每一层的作用是什么？">TCP/IP 四层模型是什么？每一层的作用是什么？</a><ul>
                        
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%b1%82application-layer" aria-label="应用层（Application layer）">应用层（Application layer）</a></li>
                <li>
                    <a href="#%e4%bc%a0%e8%be%93%e5%b1%82transport-layer" aria-label="传输层（Transport layer）">传输层（Transport layer）</a></li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c%e5%b1%82network-layer" aria-label="网络层（Network layer）">网络层（Network layer）</a></li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c%e6%8e%a5%e5%8f%a3%e5%b1%82network-interface-layer" aria-label="网络接口层（Network interface layer）">网络接口层（Network interface layer）</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%bd%91%e7%bb%9c%e8%a6%81%e5%88%86%e5%b1%82" aria-label="为什么网络要分层？">为什么网络要分层？</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e7%bd%91%e7%bb%9c%e5%8d%8f%e8%ae%ae" aria-label="常见网络协议">常见网络协议</a><ul>
                        
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%b1%82%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84%e5%8d%8f%e8%ae%ae" aria-label="应用层有哪些常见的协议？">应用层有哪些常见的协议？</a><ul>
                        
                <li>
                    <a href="#http" aria-label="HTTP">HTTP</a></li>
                <li>
                    <a href="#smtp" aria-label="SMTP">SMTP</a></li>
                <li>
                    <a href="#pop3imap" aria-label="POP3/IMAP">POP3/IMAP</a></li>
                <li>
                    <a href="#ftp" aria-label="FTP">FTP</a></li>
                <li>
                    <a href="#telnet" aria-label="Telnet">Telnet</a></li>
                <li>
                    <a href="#ssh" aria-label="SSH">SSH</a></li>
                <li>
                    <a href="#rtp" aria-label="RTP">RTP</a></li>
                <li>
                    <a href="#dns" aria-label="DNS">DNS</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%bc%a0%e8%be%93%e5%b1%82%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84%e5%8d%8f%e8%ae%ae" aria-label="传输层有哪些常见的协议？">传输层有哪些常见的协议？</a></li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c%e5%b1%82%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e8%a7%81%e7%9a%84%e5%8d%8f%e8%ae%ae" aria-label="网络层有哪些常见的协议？">网络层有哪些常见的协议？</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#http-1" aria-label="HTTP">HTTP</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8e%e8%be%93%e5%85%a5-url-%e5%88%b0%e9%a1%b5%e9%9d%a2%e5%b1%95%e7%a4%ba%e5%88%b0%e5%ba%95%e5%8f%91%e7%94%9f%e4%ba%86%e4%bb%80%e4%b9%88%e9%9d%9e%e5%b8%b8%e9%87%8d%e8%a6%81" aria-label="从输入 URL 到页面展示到底发生了什么？（非常重要）">从输入 URL 到页面展示到底发生了什么？（非常重要）</a></li>
                <li>
                    <a href="#http%e7%8a%b6%e6%80%81%e7%a0%81%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="HTTP状态码有哪些">HTTP状态码有哪些</a><ul>
                        
                <li>
                    <a href="#1xx-informational%e4%bf%a1%e6%81%af%e6%80%a7%e7%8a%b6%e6%80%81%e7%a0%81" aria-label="1xx Informational（信息性状态码）">1xx Informational（信息性状态码）</a></li>
                <li>
                    <a href="#2xx-success%e6%88%90%e5%8a%9f%e7%8a%b6%e6%80%81%e7%a0%81" aria-label="2xx Success（成功状态码）">2xx Success（成功状态码）</a></li>
                <li>
                    <a href="#3xx-redirection%e9%87%8d%e5%ae%9a%e5%90%91%e7%8a%b6%e6%80%81%e7%a0%81" aria-label="3xx Redirection（重定向状态码）">3xx Redirection（重定向状态码）</a></li>
                <li>
                    <a href="#4xx-client-error%e5%ae%a2%e6%88%b7%e7%ab%af%e9%94%99%e8%af%af%e7%8a%b6%e6%80%81%e7%a0%81" aria-label="4xx Client Error（客户端错误状态码）">4xx Client Error（客户端错误状态码）</a></li>
                <li>
                    <a href="#5xx-server-error%e6%9c%8d%e5%8a%a1%e7%ab%af%e9%94%99%e8%af%af%e7%8a%b6%e6%80%81%e7%a0%81" aria-label="5xx Server Error（服务端错误状态码）">5xx Server Error（服务端错误状态码）</a></li></ul>
                </li>
                <li>
                    <a href="#http-header-%e4%b8%ad%e5%b8%b8%e8%a7%81%e7%9a%84%e5%ad%97%e6%ae%b5%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="HTTP Header 中常见的字段有哪些？">HTTP Header 中常见的字段有哪些？</a></li>
                <li>
                    <a href="#http-%e5%92%8c-https-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab%e5%ba%94%e7%94%a8%e5%b1%82" aria-label="HTTP 和 HTTPS 有什么区别？（应用层）">HTTP 和 HTTPS 有什么区别？（应用层）</a><ul>
                        
                <li>
                    <a href="#http%e5%8d%8f%e8%ae%ae%e4%bb%8b%e7%bb%8d" aria-label="HTTP协议介绍">HTTP协议介绍</a></li>
                <li>
                    <a href="#http-%e5%8d%8f%e8%ae%ae%e9%80%9a%e4%bf%a1%e8%bf%87%e7%a8%8b" aria-label="HTTP 协议通信过程">HTTP 协议通信过程</a></li>
                <li>
                    <a href="#https-%e5%8d%8f%e8%ae%ae%e4%bb%8b%e7%bb%8d" aria-label="HTTPS 协议介绍">HTTPS 协议介绍</a></li>
                <li>
                    <a href="#https-%e7%9a%84%e6%a0%b8%e5%bf%83ssltls-%e5%8d%8f%e8%ae%ae" aria-label="HTTPS 的核心—SSL/TLS 协议">HTTPS 的核心—SSL/TLS 协议</a></li>
                <li>
                    <a href="#ssl-%e5%92%8c-tls-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="SSL 和 TLS 的区别？">SSL 和 TLS 的区别？</a></li>
                <li>
                    <a href="#ssltls-%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" aria-label="SSL/TLS 的工作原理">SSL/TLS 的工作原理</a><ul>
                        
                <li>
                    <a href="#%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86" aria-label="非对称加密">非对称加密</a></li>
                <li>
                    <a href="#%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86" aria-label="对称加密">对称加密</a></li>
                <li>
                    <a href="#%e5%85%ac%e9%92%a5%e4%bc%a0%e8%be%93%e7%9a%84%e4%bf%a1%e8%b5%96%e6%80%a7" aria-label="公钥传输的信赖性">公钥传输的信赖性</a></li>
                <li>
                    <a href="#%e6%95%b0%e5%ad%97%e7%ad%be%e5%90%8d" aria-label="数字签名">数字签名</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93-1" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#http10-%e5%92%8c-http11-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="HTTP/1.0 和 HTTP/1.1 有什么区别？">HTTP/1.0 和 HTTP/1.1 有什么区别？</a><ul>
                        
                <li>
                    <a href="#%e5%93%8d%e5%ba%94%e7%8a%b6%e6%80%81%e7%a0%81" aria-label="响应状态码">响应状态码</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%ad%98%e5%a4%84%e7%90%86" aria-label="缓存处理">缓存处理</a><ul>
                        
                <li>
                    <a href="#http10" aria-label="HTTP/1.0">HTTP/1.0</a></li>
                <li>
                    <a href="#http11" aria-label="HTTP/1.1">HTTP/1.1</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%9e%e6%8e%a5%e6%96%b9%e5%bc%8f" aria-label="连接方式">连接方式</a></li>
                <li>
                    <a href="#host-%e5%a4%b4%e5%a4%84%e7%90%86" aria-label="Host 头处理">Host 头处理</a></li>
                <li>
                    <a href="#%e5%b8%a6%e5%ae%bd%e4%bc%98%e5%8c%96" aria-label="带宽优化">带宽优化</a><ul>
                        
                <li>
                    <a href="#%e8%8c%83%e5%9b%b4%e8%af%b7%e6%b1%82" aria-label="范围请求">范围请求</a></li>
                <li>
                    <a href="#%e7%8a%b6%e6%80%81%e7%a0%81-100" aria-label="状态码 100">状态码 100</a></li>
                <li>
                    <a href="#%e5%8e%8b%e7%bc%a9" aria-label="压缩">压缩</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93-2" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#http11-%e5%92%8c-http20-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="HTTP/1.1 和 HTTP/2.0 有什么区别？">HTTP/1.1 和 HTTP/2.0 有什么区别？</a></li>
                <li>
                    <a href="#http20-%e5%92%8c-http30-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="HTTP/2.0 和 HTTP/3.0 有什么区别？">HTTP/2.0 和 HTTP/3.0 有什么区别？</a></li>
                <li>
                    <a href="#http-%e6%98%af%e4%b8%8d%e4%bf%9d%e5%ad%98%e7%8a%b6%e6%80%81%e7%9a%84%e5%8d%8f%e8%ae%ae-%e5%a6%82%e4%bd%95%e4%bf%9d%e5%ad%98%e7%94%a8%e6%88%b7%e7%8a%b6%e6%80%81" aria-label="HTTP 是不保存状态的协议, 如何保存用户状态?">HTTP 是不保存状态的协议, 如何保存用户状态?</a></li>
                <li>
                    <a href="#uri-%e5%92%8c-url-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="URI 和 URL 的区别是什么?">URI 和 URL 的区别是什么?</a></li></ul>
                </li>
                <li>
                    <a href="#ping" aria-label="PING">PING</a><ul>
                        
                <li>
                    <a href="#ping-%e5%91%bd%e4%bb%a4%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88" aria-label="PING 命令的作用是什么？">PING 命令的作用是什么？</a></li>
                <li>
                    <a href="#ping-%e5%91%bd%e4%bb%a4%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88" aria-label="PING 命令的工作原理是什么？">PING 命令的工作原理是什么？</a></li></ul>
                </li>
                <li>
                    <a href="#dns-1" aria-label="DNS">DNS</a><ul>
                        
                <li>
                    <a href="#dns-%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88" aria-label="DNS 的作用是什么？">DNS 的作用是什么？</a></li>
                <li>
                    <a href="#dns-%e6%9c%8d%e5%8a%a1%e5%99%a8%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="DNS 服务器有哪些？">DNS 服务器有哪些？</a></li>
                <li>
                    <a href="#dns%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b" aria-label="DNS工作流程">DNS工作流程</a></li>
                <li>
                    <a href="#dns%e6%8a%a5%e6%96%87%e6%a0%bc%e5%bc%8f" aria-label="DNS报文格式">DNS报文格式</a></li>
                <li>
                    <a href="#dns-%e8%ae%b0%e5%bd%95" aria-label="DNS 记录">DNS 记录</a></li></ul>
                </li>
                <li>
                    <a href="#tcp-%e5%92%8c-udp" aria-label="TCP 和 UDP">TCP 和 UDP</a><ul>
                        
                <li>
                    <a href="#tcp-%e4%b8%8e-udp-%e7%9a%84%e5%8c%ba%e5%88%ab%e9%87%8d%e8%a6%81" aria-label="TCP 与 UDP 的区别（重要）">TCP 与 UDP 的区别（重要）</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e9%80%89%e6%8b%a9-tcp%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e9%80%89-udp" aria-label="什么时候选择 TCP，什么时候选 UDP?">什么时候选择 TCP，什么时候选 UDP?</a></li>
                <li>
                    <a href="#http-%e5%9f%ba%e4%ba%8e-tcp-%e8%bf%98%e6%98%af-udp" aria-label="HTTP 基于 TCP 还是 UDP？">HTTP 基于 TCP 还是 UDP？</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-tcp-%e7%9a%84%e5%8d%8f%e8%ae%ae%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bd%bf%e7%94%a8-udp-%e7%9a%84%e5%8d%8f%e8%ae%ae%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?">使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</a></li>
                <li>
                    <a href="#tcp-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b%e5%92%8c%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e4%bc%a0%e8%be%93%e5%b1%82" aria-label="TCP 三次握手和四次挥手（传输层）">TCP 三次握手和四次挥手（传输层）</a><ul>
                        
                <li>
                    <a href="#%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5-tcp-%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b" aria-label="建立连接-TCP 三次握手">建立连接-TCP 三次握手</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b" aria-label="为什么要三次握手?">为什么要三次握手?</a></li>
                <li>
                    <a href="#%e7%ac%ac-2-%e6%ac%a1%e6%8f%a1%e6%89%8b%e4%bc%a0%e5%9b%9e%e4%ba%86-ack%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%98%e8%a6%81%e4%bc%a0%e5%9b%9e-syn" aria-label="第 2 次握手传回了 ACK，为什么还要传回 SYN？">第 2 次握手传回了 ACK，为什么还要传回 SYN？</a></li>
                <li>
                    <a href="#%e6%96%ad%e5%bc%80%e8%bf%9e%e6%8e%a5-tcp-%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b" aria-label="断开连接-TCP 四次挥手">断开连接-TCP 四次挥手</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b" aria-label="为什么要四次挥手？">为什么要四次挥手？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e8%83%bd%e6%8a%8a%e6%9c%8d%e5%8a%a1%e5%99%a8%e5%8f%91%e9%80%81%e7%9a%84-ack-%e5%92%8c-fin-%e5%90%88%e5%b9%b6%e8%b5%b7%e6%9d%a5%e5%8f%98%e6%88%90%e4%b8%89%e6%ac%a1%e6%8c%a5%e6%89%8b" aria-label="为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？">为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</a></li>
                <li>
                    <a href="#%e5%a6%82%e6%9e%9c%e7%ac%ac%e4%ba%8c%e6%ac%a1%e6%8c%a5%e6%89%8b%e6%97%b6%e6%9c%8d%e5%8a%a1%e5%99%a8%e7%9a%84-ack-%e6%b2%a1%e6%9c%89%e9%80%81%e8%be%be%e5%ae%a2%e6%88%b7%e7%ab%af%e4%bc%9a%e6%80%8e%e6%a0%b7" aria-label="如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？">如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e7%ac%ac%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e5%ae%a2%e6%88%b7%e7%ab%af%e9%9c%80%e8%a6%81%e7%ad%89%e5%be%85-2msl%e6%8a%a5%e6%96%87%e6%ae%b5%e6%9c%80%e9%95%bf%e5%af%bf%e5%91%bd%e6%97%b6%e9%97%b4%e5%90%8e%e6%89%8d%e8%bf%9b%e5%85%a5-closed-%e7%8a%b6%e6%80%81" aria-label="为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？">为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</a></li></ul>
                </li>
                <li>
                    <a href="#tcp-%e4%bc%a0%e8%be%93%e5%8f%af%e9%9d%a0%e6%80%a7%e4%bf%9d%e9%9a%9c%e4%bc%a0%e8%be%93%e5%b1%82" aria-label="TCP 传输可靠性保障（传输层）">TCP 传输可靠性保障（传输层）</a><ul>
                        
                <li>
                    <a href="#tcp-%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e4%bc%a0%e8%be%93%e7%9a%84%e5%8f%af%e9%9d%a0%e6%80%a7" aria-label="TCP 如何保证传输的可靠性？">TCP 如何保证传输的可靠性？</a></li>
                <li>
                    <a href="#tcp-%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6" aria-label="TCP 如何实现流量控制？">TCP 如何实现流量控制？</a></li>
                <li>
                    <a href="#tcp-%e7%9a%84%e6%8b%a5%e5%a1%9e%e6%8e%a7%e5%88%b6%e6%98%af%e6%80%8e%e4%b9%88%e5%ae%9e%e7%8e%b0%e7%9a%84" aria-label="TCP 的拥塞控制是怎么实现的？">TCP 的拥塞控制是怎么实现的？</a></li>
                <li>
                    <a href="#arq-%e5%8d%8f%e8%ae%ae%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="ARQ 协议了解吗?">ARQ 协议了解吗?</a><ul>
                        
                <li>
                    <a href="#%e5%81%9c%e6%ad%a2%e7%ad%89%e5%be%85-arq-%e5%8d%8f%e8%ae%ae" aria-label="停止等待 ARQ 协议">停止等待 ARQ 协议</a></li>
                <li>
                    <a href="#%e8%bf%9e%e7%bb%ad-arq-%e5%8d%8f%e8%ae%ae" aria-label="连续 ARQ 协议">连续 ARQ 协议</a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#ip" aria-label="IP">IP</a><ul>
                        
                <li>
                    <a href="#ip-%e5%8d%8f%e8%ae%ae%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88" aria-label="IP 协议的作用是什么？">IP 协议的作用是什么？</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-ip-%e5%9c%b0%e5%9d%80ip-%e5%af%bb%e5%9d%80%e5%a6%82%e4%bd%95%e5%b7%a5%e4%bd%9c" aria-label="什么是 IP 地址？IP 寻址如何工作？">什么是 IP 地址？IP 寻址如何工作？</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-ip-%e5%9c%b0%e5%9d%80%e8%bf%87%e6%bb%a4" aria-label="什么是 IP 地址过滤？">什么是 IP 地址过滤？</a></li>
                <li>
                    <a href="#ipv4-%e5%92%8c-ipv6-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="IPv4 和 IPv6 有什么区别？">IPv4 和 IPv6 有什么区别？</a></li>
                <li>
                    <a href="#nat-%e7%9a%84%e4%bd%9c%e7%94%a8%e6%98%af%e4%bb%80%e4%b9%88" aria-label="NAT 的作用是什么？">NAT 的作用是什么？</a><ul>
                        
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="应用场景">应用场景</a></li>
                <li>
                    <a href="#%e7%bb%86%e8%8a%82" aria-label="细节">细节</a></li>
                <li>
                    <a href="#%e5%88%92%e9%87%8d%e7%82%b9" aria-label="划重点">划重点</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#arp" aria-label="ARP">ARP</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-mac-%e5%9c%b0%e5%9d%80" aria-label="什么是 Mac 地址？">什么是 Mac 地址？</a></li>
                <li>
                    <a href="#arp-%e5%8d%8f%e8%ae%ae%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86" aria-label="ARP 协议工作原理">ARP 协议工作原理</a><ul>
                        
                <li>
                    <a href="#%e5%90%8c%e4%b8%80%e5%b1%80%e5%9f%9f%e7%bd%91%e5%86%85%e7%9a%84-mac-%e5%af%bb%e5%9d%80" aria-label="同一局域网内的 MAC 寻址">同一局域网内的 MAC 寻址</a></li>
                <li>
                    <a href="#%e4%b8%8d%e5%90%8c%e5%b1%80%e5%9f%9f%e7%bd%91%e5%86%85%e7%9a%84-mac-%e5%af%bb%e5%9d%80" aria-label="不同局域网内的 MAC 寻址">不同局域网内的 MAC 寻址</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c%e6%94%bb%e5%87%bb%e5%b8%b8%e8%a7%81%e6%89%8b%e6%ae%b5" aria-label="网络攻击常见手段">网络攻击常见手段</a><ul>
                        
                <li>
                    <a href="#ip-%e6%ac%ba%e9%aa%97" aria-label="IP 欺骗">IP 欺骗</a><ul>
                        
                <li>
                    <a href="#ip-%e6%98%af%e4%bb%80%e4%b9%88" aria-label="IP 是什么?">IP 是什么?</a></li>
                <li>
                    <a href="#%e9%80%9a%e8%bf%87-ip-%e5%9c%b0%e5%9d%80%e6%88%91%e4%bb%ac%e8%83%bd%e7%9f%a5%e9%81%93%e4%bb%80%e4%b9%88" aria-label="通过 IP 地址我们能知道什么？">通过 IP 地址我们能知道什么？</a></li>
                <li>
                    <a href="#ip-%e6%ac%ba%e9%aa%97%e6%8a%80%e6%9c%af%e6%98%af%e4%bb%80%e4%b9%88" aria-label="IP 欺骗技术是什么？">IP 欺骗技术是什么？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e7%bc%93%e8%a7%a3-ip-%e6%ac%ba%e9%aa%97" aria-label="如何缓解 IP 欺骗？">如何缓解 IP 欺骗？</a></li></ul>
                </li>
                <li>
                    <a href="#syn-flood%e6%b4%aa%e6%b0%b4" aria-label="SYN Flood(洪水)">SYN Flood(洪水)</a><ul>
                        
                <li>
                    <a href="#tcp-syn-flood-%e6%94%bb%e5%87%bb%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88" aria-label="TCP SYN Flood 攻击原理是什么？">TCP SYN Flood 攻击原理是什么？</a></li>
                <li>
                    <a href="#syn-flood-%e7%9a%84%e5%b8%b8%e8%a7%81%e5%bd%a2%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="SYN Flood 的常见形式有哪些？">SYN Flood 的常见形式有哪些？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e7%bc%93%e8%a7%a3-syn-flood" aria-label="如何缓解 SYN Flood？">如何缓解 SYN Flood？</a></li></ul>
                </li>
                <li>
                    <a href="#udp-flood%e6%b4%aa%e6%b0%b4" aria-label="UDP Flood(洪水)">UDP Flood(洪水)</a><ul>
                        
                <li>
                    <a href="#udp-flood-%e6%94%bb%e5%87%bb%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88" aria-label="UDP Flood 攻击原理是什么？">UDP Flood 攻击原理是什么？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e7%bc%93%e8%a7%a3-udp-flooding" aria-label="如何缓解 UDP Flooding？">如何缓解 UDP Flooding？</a></li></ul>
                </li>
                <li>
                    <a href="#http-flood%e6%b4%aa%e6%b0%b4" aria-label="HTTP Flood(洪水)">HTTP Flood(洪水)</a><ul>
                        
                <li>
                    <a href="#http-flood-%e7%9a%84%e6%94%bb%e5%87%bb%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88" aria-label="HTTP Flood 的攻击原理是什么？">HTTP Flood 的攻击原理是什么？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e9%98%b2%e6%8a%a4-http-flood" aria-label="如何防护 HTTP Flood？">如何防护 HTTP Flood？</a></li></ul>
                </li>
                <li>
                    <a href="#dns-flood%e6%b4%aa%e6%b0%b4" aria-label="DNS Flood(洪水)">DNS Flood(洪水)</a><ul>
                        
                <li>
                    <a href="#dns-flood-%e7%9a%84%e6%94%bb%e5%87%bb%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88" aria-label="DNS Flood 的攻击原理是什么？">DNS Flood 的攻击原理是什么？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e9%98%b2%e6%8a%a4-dns-flood" aria-label="如何防护 DNS Flood?">如何防护 DNS Flood?</a></li></ul>
                </li>
                <li>
                    <a href="#tcp-%e9%87%8d%e7%bd%ae%e6%94%bb%e5%87%bb" aria-label="TCP 重置攻击">TCP 重置攻击</a></li>
                <li>
                    <a href="#%e6%a8%a1%e6%8b%9f%e6%94%bb%e5%87%bb" aria-label="模拟攻击">模拟攻击</a></li>
                <li>
                    <a href="#%e4%b8%ad%e9%97%b4%e4%ba%ba%e6%94%bb%e5%87%bb" aria-label="中间人攻击">中间人攻击</a><ul>
                        
                <li>
                    <a href="#%e4%b8%ad%e9%97%b4%e4%ba%ba%e6%94%bb%e5%87%bb%e7%9a%84%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88" aria-label="中间人攻击的原理是什么？">中间人攻击的原理是什么？</a></li>
                <li>
                    <a href="#%e6%9c%89%e5%93%aa%e4%ba%9b%e5%b8%b8%e7%94%a8%e7%9a%84%e6%91%98%e8%a6%81%e7%ae%97%e6%b3%95%e5%91%a2" aria-label="有哪些常用的摘要算法呢？">有哪些常用的摘要算法呢？</a></li>
                <li>
                    <a href="#%e6%95%b0%e5%ad%97%e8%af%81%e4%b9%a6%e5%92%8c%e7%ad%be%e5%90%8d%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8" aria-label="数字证书和签名有什么用？">数字证书和签名有什么用？</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86" aria-label="什么是对称加密？">什么是对称加密？</a></li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e7%9a%84%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="常见的对称加密算法有哪些？">常见的对称加密算法有哪些？</a></li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e7%9a%84%e9%9d%9e%e5%af%b9%e7%a7%b0%e5%8a%a0%e5%af%86%e7%ae%97%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="常见的非对称加密算法有哪些？">常见的非对称加密算法有哪些？</a></li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e7%9a%84%e6%95%a3%e5%88%97%e7%ae%97%e6%b3%95%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="常见的散列算法有哪些？">常见的散列算法有哪些？</a></li>
                <li>
                    <a href="#%e7%ac%ac%e4%b8%89%e6%96%b9%e6%9c%ba%e6%9e%84%e5%92%8c%e8%af%81%e4%b9%a6%e6%9c%ba%e5%88%b6%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8" aria-label="第三方机构和证书机制有什么用？">第三方机构和证书机制有什么用？</a></li>
                <li>
                    <a href="#%e4%b8%ad%e9%97%b4%e4%ba%ba%e6%94%bb%e5%87%bb%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d" aria-label="中间人攻击如何避免?">中间人攻击如何避免?</a></li></ul>
                </li>
                <li>
                    <a href="#ddos" aria-label="DDoS">DDoS</a><ul>
                        
                <li>
                    <a href="#ddos%e7%a9%b6%e7%ab%9f%e6%98%af%e4%bb%80%e4%b9%88" aria-label="DDoS究竟是什么">DDoS究竟是什么</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%ba%94%e5%af%b9-ddos-%e6%94%bb%e5%87%bb" aria-label="如何应对 DDoS 攻击？">如何应对 DDoS 攻击？</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="计算机网络基础">计算机网络基础<a hidden class="anchor" aria-hidden="true" href="#计算机网络基础">#</a></h1>
<h2 id="网络分层模型">网络分层模型<a hidden class="anchor" aria-hidden="true" href="#网络分层模型">#</a></h2>
<h3 id="osi-七层模型是什么每一层的作用是什么">OSI 七层模型是什么？每一层的作用是什么？<a hidden class="anchor" aria-hidden="true" href="#osi-七层模型是什么每一层的作用是什么">#</a></h3>
<p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/osi-7-model.png"></p>
<p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p>
<p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p>
<p>上面这种图可能比较抽象，再来一个比较生动的图片。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/osi%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B2.png"></p>
<p><strong>既然 OSI 七层模型这么厉害，为什么干不过 TCP/IP 四 层模型呢？</strong></p>
<p>的确，OSI 七层模型当时一直被一些大公司甚至一些国家政府支持。这样的背景下，为什么会失败呢？我觉得主要有下面几方面原因：</p>
<ol>
<li>OSI 的专家缺乏实际经验，他们在完成 OSI 标准时缺乏商业驱动力</li>
<li>OSI 的协议实现起来过分复杂，而且运行效率很低</li>
<li>OSI 制定标准的周期太长，因而使得按 OSI 标准生产的设备无法及时进入市场（20 世纪 90 年代初期，虽然整套的 OSI 国际标准都已经制定出来，但基于 TCP/IP 的互联网已经抢先在全球相当大的范围成功运行了）</li>
<li>OSI 的层次划分不太合理，有些功能在多个层次中重复出现。</li>
</ol>
<p>OSI 七层模型虽然失败了，但是却提供了很多不错的理论基础。为了更好地去了解网络分层，OSI 七层模型还是非常有必要学习的。</p>
<p>最后再分享一个关于 OSI 七层模型非常不错的总结图片！</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/osi-model-detail.png"></p>
<h3 id="tcpip-四层模型是什么每一层的作用是什么">TCP/IP 四层模型是什么？每一层的作用是什么？<a hidden class="anchor" aria-hidden="true" href="#tcpip-四层模型是什么每一层的作用是什么">#</a></h3>
<p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型，我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<p>需要注意的是，我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/tcp-ip-4-model.png"></p>
<h4 id="应用层application-layer">应用层（Application layer）<a hidden class="anchor" aria-hidden="true" href="#应用层application-layer">#</a></h4>
<p><strong>应用层位于传输层之上，主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。</strong> 我们把应用层交互的数据单元称为报文。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/network-five-layer-sample-diagram.png"></p>
<p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p>
<h4 id="传输层transport-layer">传输层（Transport layer）<a hidden class="anchor" aria-hidden="true" href="#传输层transport-layer">#</a></h4>
<p><strong>传输层的主要任务就是负责向两台终端设备进程之间的通信提供通用的数据传输服务。</strong> 应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
<p><strong>传输层常见协议</strong>：</p>
<ul>
<li>
<p><strong>TCP（Transmisson Control Protocol，传输控制协议 ）</strong>：提供 <strong>面向连接</strong> 的，<strong>可靠</strong> 的数据传输服务。</p>
</li>
<li>
<p><strong>UDP（User Datagram Protocol，用户数据协议）</strong>：提供 <strong>无连接</strong> 的，<strong>尽最大努力</strong> 的数据传输服务（不保证数据传输的可靠性），简单高效。</p>
</li>
</ul>
<h4 id="网络层network-layer">网络层（Network layer）<a hidden class="anchor" aria-hidden="true" href="#网络层network-layer">#</a></h4>
<p><strong>网络层负责为分组交换网上的不同主机提供通信服务。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<p>⚠️ 注意：<strong>不要把运输层的“用户数据报 UDP”和网络层的“IP 数据报”弄混</strong>。</p>
<p><strong>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分组，能通过网络层中的路由器找到目的主机。</strong></p>
<p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称。</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做 <strong>网际层</strong> 或 <strong>IP 层</strong>。</p>
<h4 id="网络接口层network-interface-layer">网络接口层（Network interface layer）<a hidden class="anchor" aria-hidden="true" href="#网络接口层network-interface-layer">#</a></h4>
<p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p>
<ol>
<li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。<strong>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</strong></li>
<li><strong>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</strong></li>
</ol>
<h4 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h4>
<p>简单总结一下每一层包含的协议和核心技术:</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/network-protocol-overview.png"></p>
<p><strong>应用层协议</strong> :</p>
<ul>
<li>HTTP（Hypertext Transfer Protocol，超文本传输协议）</li>
<li>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）</li>
<li>POP3/IMAP（邮件接收协议）</li>
<li>FTP（File Transfer Protocol，文件传输协议）</li>
<li>Telnet（远程登陆协议）</li>
<li>SSH（Secure Shell Protocol，安全的网络传输协议）</li>
<li>RTP（Real-time Transport Protocol，实时传输协议）</li>
<li>DNS（Domain Name System，域名管理系统）</li>
<li>&hellip;&hellip;</li>
</ul>
<p><strong>传输层协议</strong> :</p>
<ul>
<li>TCP 协议
<ul>
<li>报文段结构</li>
<li>可靠数据传输</li>
<li>流量控制</li>
<li>拥塞控制</li>
</ul>
</li>
<li>UDP 协议
<ul>
<li>报文段结构</li>
<li>RDT（可靠数据传输协议）</li>
</ul>
</li>
</ul>
<p><strong>网络层协议</strong> :</p>
<ul>
<li>IP（Internet Protocol，网际协议）</li>
<li>ARP（Address Resolution Protocol，地址解析协议）</li>
<li>ICMP 协议（控制报文协议，用于发送控制消息）</li>
<li>NAT（Network Address Translation，网络地址转换协议）</li>
<li>OSPF（Open Shortest Path First，开放式最短路径优先）</li>
<li>RIP(Routing Information Protocol，路由信息协议）</li>
<li>BGP（Border Gateway Protocol，边界网关协议）</li>
<li>&hellip;&hellip;</li>
</ul>
<p><strong>网络接口层</strong> :</p>
<ul>
<li>差错检测技术</li>
<li>多路访问协议（信道复用技术）</li>
<li>CSMA/CD 协议</li>
<li>MAC 协议</li>
<li>以太网技术</li>
<li>&hellip;&hellip;</li>
</ul>
<h3 id="为什么网络要分层">为什么网络要分层？<a hidden class="anchor" aria-hidden="true" href="#为什么网络要分层">#</a></h3>
<p>说到分层，我们先从我们平时使用框架开发一个后台程序来说，我们往往会按照每一层做不同的事情的原则将系统分为三层（复杂的系统分层会更多）:</p>
<ol>
<li>Repository（数据库操作）</li>
<li>Service（业务操作）</li>
<li>Controller（前后端数据交互）</li>
</ol>
<p><strong>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</strong></p>
<p>好了，再来说回：“为什么网络要分层？”。我觉得主要有 3 方面的原因：</p>
<ol>
<li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li>
<li><strong>提高了整体灵活性</strong>：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li>
<li><strong>大问题化小</strong>：分层可以将复杂的网络问题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li>
</ol>
<p>我想到了计算机世界非常非常有名的一句话，这里分享一下：</p>
<blockquote>
<p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决，计算机整个体系从上到下都是按照严格的层次结构设计的。</p>
</blockquote>
<h2 id="常见网络协议">常见网络协议<a hidden class="anchor" aria-hidden="true" href="#常见网络协议">#</a></h2>
<h3 id="应用层有哪些常见的协议">应用层有哪些常见的协议？<a hidden class="anchor" aria-hidden="true" href="#应用层有哪些常见的协议">#</a></h3>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/application-layer-protocol.png"></p>
<h4 id="http">HTTP<a hidden class="anchor" aria-hidden="true" href="#http">#</a></h4>
<p><strong>HTTP（Hypertext Transfer Protocol，超文本传输协议）</strong>：基于 TCP 协议，是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</p>
<p>HTTP 使用客户端-服务器模型，客户端向服务器发送 HTTP Request（请求），服务器响应请求并返回 HTTP Response（响应），整个过程如下图所示。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/450px-HTTP-Header.png"></p>
<p>HTTP 协议基于 TCP 协议，发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。目前使用的 HTTP 协议大部分都是 1.1。在 1.1 的协议里面，默认是开启了 Keep-Alive 的，这样的话建立的连接就可以在多次请求中被复用了。</p>
<p>另外， HTTP 协议是”无状态”的协议，它无法记录客户端用户的状态，一般我们都是通过 Session 来记录客户端用户的状态。</p>
<h4 id="smtp">SMTP<a hidden class="anchor" aria-hidden="true" href="#smtp">#</a></h4>
<p><strong>SMTP（Simple Mail Transfer Protocol，简单邮件发送协议）</strong>：基于 TCP 协议，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/what-is-smtp.png"></p>
<p>SMTP 协议这块涉及的内容比较多，下面这两个问题比较重要：</p>
<ol>
<li>电子邮件的发送过程</li>
<li>如何判断邮箱是真正存在的？</li>
</ol>
<p><strong>电子邮件的发送过程？</strong></p>
<p>比如我的邮箱是“dabai@cszhinan.com”，我要向“xiaoma@qq.com”发送邮件，整个过程可以简单分为下面几步：</p>
<ol>
<li>通过 <strong>SMTP</strong> 协议，我将我写好的邮件交给 163 邮箱服务器（邮局）。</li>
<li>163 邮箱服务器发现我发送的邮箱是 qq 邮箱，然后它使用 SMTP 协议将我的邮件转发到 qq 邮箱服务器。</li>
<li>qq 邮箱服务器接收邮件之后就通知邮箱为“xiaoma@qq.com”的用户来收邮件，然后用户就通过 <strong>POP3/IMAP</strong> 协议将邮件取出。</li>
</ol>
<p><strong>如何判断邮箱是真正存在的？</strong></p>
<p>很多场景(比如邮件营销)下面我们需要判断我们要发送的邮箱地址是否真的存在，这个时候我们可以利用 SMTP 协议来检测：</p>
<ol>
<li>查找邮箱域名对应的 SMTP 服务器地址</li>
<li>尝试与服务器建立连接</li>
<li>连接成功后尝试向需要验证的邮箱发送邮件</li>
<li>根据返回结果判定邮箱地址的真实性</li>
</ol>
<p>推荐几个在线邮箱是否有效检测工具：</p>
<ol>
<li><a href="https://verify-email.org/">https://verify-email.org/</a></li>
<li><a href="http://tool.chacuo.net/mailverify">http://tool.chacuo.net/mailverify</a></li>
<li><a href="https://www.emailcamel.com/">https://www.emailcamel.com/</a></li>
</ol>
<h4 id="pop3imap">POP3/IMAP<a hidden class="anchor" aria-hidden="true" href="#pop3imap">#</a></h4>
<p><strong>POP3/IMAP（邮件接收协议）</strong>：基于 TCP 协议，两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</p>
<h4 id="ftp">FTP<a hidden class="anchor" aria-hidden="true" href="#ftp">#</a></h4>
<p><strong>FTP（File Transfer Protocol，文件传输协议）</strong> : 基于 TCP 协议，是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。</p>
<p>FTP 是基于客户—服务器（C/S）模型而设计的，在客户端与 FTP 服务器之间建立两个连接。如果我们要基于 FTP 协议开发一个文件传输的软件的话，首先需要搞清楚 FTP 的原理。关于 FTP 的原理，很多书籍上已经描述的非常详细了：</p>
<blockquote>
<p>FTP 的独特的优势同时也是与其它客户服务器程序最大的不同点就在于它在两台通信的主机之间使用了两条 TCP 连接（其它客户服务器应用程序一般只有一条 TCP 连接）：</p>
<ol>
<li>控制连接：用于传送控制信息（命令和响应）</li>
<li>数据连接：用于数据传送；</li>
</ol>
<p>这种将命令和数据分开传送的思想大大提高了 FTP 的效率。</p>
</blockquote>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/ftp.png"></p>
<p>注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。因此，FTP 传输的文件可能会被窃听或篡改。建议在传输敏感数据时使用更安全的协议，如 SFTP（一种基于 SSH 协议的安全文件传输协议，用于在网络上安全地传输文件）。</p>
<h4 id="telnet">Telnet<a hidden class="anchor" aria-hidden="true" href="#telnet">#</a></h4>
<p><strong>Telnet（远程登陆协议）</strong>：基于 TCP 协议，用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/Telnet_is_vulnerable_to_eavesdropping-2.png"></p>
<h4 id="ssh">SSH<a hidden class="anchor" aria-hidden="true" href="#ssh">#</a></h4>
<p><strong>SSH（Secure Shell Protocol，安全的网络传输协议）</strong>：基于 TCP 协议，通过加密和认证机制实现安全的访问和文件传输等业务</p>
<p>SSH 的经典用途是登录到远程电脑中执行命令。除此之外，SSH 也支持隧道协议、端口映射和 X11 连接。借助 SFTP 或 SCP 协议，SSH 还可以传输文件。</p>
<p>SSH 使用客户端-服务器模型，默认端口是 22。SSH 是一个守护进程，负责实时监听客户端请求，并进行处理。大多数现代操作系统都提供了 SSH。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/ssh-client-server.png"></p>
<h4 id="rtp">RTP<a hidden class="anchor" aria-hidden="true" href="#rtp">#</a></h4>
<p><strong>RTP（Real-time Transport Protocol，实时传输协议）</strong>：通常基于 UDP 协议，但也支持 TCP 协议。它提供了端到端的实时传输数据的功能，但不包含资源预留存、不保证实时传输质量，这些功能由 WebRTC 实现。</p>
<p>RTP 协议分为两种子协议：</p>
<ul>
<li><strong>RTP（Real-time Transport Protocol，实时传输协议）</strong>：传输具有实时特性的数据。</li>
<li><strong>RTCP（RTP Control Protocol，RTP 控制协议）</strong>：提供实时传输过程中的统计信息（如网络延迟、丢包率等），WebRTC 正是根据这些信息处理丢包</li>
</ul>
<h4 id="dns">DNS<a hidden class="anchor" aria-hidden="true" href="#dns">#</a></h4>
<p><strong>DNS（Domain Name System，域名管理系统）</strong>: 基于 UDP 协议，用于解决域名和 IP 地址的映射问题。</p>
<h3 id="传输层有哪些常见的协议">传输层有哪些常见的协议？<a hidden class="anchor" aria-hidden="true" href="#传输层有哪些常见的协议">#</a></h3>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/transport-layer-protocol.png"></p>
<p><strong>TCP（Transmission Control Protocol，传输控制协议 ）</strong>：提供 <strong>面向连接</strong> 的，<strong>可靠</strong> 的数据传输服务。</p>
<p><strong>UDP（User Datagram Protocol，用户数据协议）</strong>：提供 <strong>无连接</strong> 的，<strong>尽最大努力</strong> 的数据传输服务（不保证数据传输的可靠性），简单高效。</p>
<h3 id="网络层有哪些常见的协议">网络层有哪些常见的协议？<a hidden class="anchor" aria-hidden="true" href="#网络层有哪些常见的协议">#</a></h3>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/nerwork-layer-protocol-040eb203.png"></p>
<p><strong>IP（Internet Protocol，网际协议）</strong>：TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</p>
<p><strong>ARP（Address Resolution Protocol，地址解析协议）</strong>：ARP 协议解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</p>
<p><strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>：一种用于传输网络状态和错误消息的协议，常用于网络诊断和故障排除。例如，Ping 工具就使用了 ICMP 协议来测试网络连通性。</p>
<p><strong>NAT（Network Address Translation，网络地址转换协议）</strong>：NAT 协议的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</p>
<p><strong>OSPF（Open Shortest Path First，开放式最短路径优先）</strong> ）：一种内部网关协议（Interior Gateway Protocol，IGP），也是广泛使用的一种动态路由协议，基于链路状态算法，考虑了链路的带宽、延迟等因素来选择最佳路径。</p>
<p><strong>RIP(Routing Information Protocol，路由信息协议）</strong>：一种内部网关协议（Interior Gateway Protocol，IGP），也是一种动态路由协议，基于距离向量算法，使用固定的跳数作为度量标准，选择跳数最少的路径作为最佳路径。</p>
<p><strong>BGP（Border Gateway Protocol，边界网关协议）</strong>：一种用来在路由选择域之间交换网络层可达性信息（Network Layer Reachability Information，NLRI）的路由选择协议，具有高度的灵活性和可扩展性。</p>
<h1 id="http-1">HTTP<a hidden class="anchor" aria-hidden="true" href="#http-1">#</a></h1>
<h2 id="从输入-url-到页面展示到底发生了什么非常重要">从输入 URL 到页面展示到底发生了什么？（非常重要）<a hidden class="anchor" aria-hidden="true" href="#从输入-url-到页面展示到底发生了什么非常重要">#</a></h2>
<p>图解（图片来源：《图解 HTTP》）：</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/url%E8%BE%93%E5%85%A5%E5%88%B0%E5%B1%95%E7%A4%BA%E5%87%BA%E6%9D%A5%E7%9A%84%E8%BF%87%E7%A8%8B.png"></p>
<blockquote>
<p>上图有一个错误，请注意，是 OSPF 不是 OPSF。 OSPF（Open Shortest Path First，ospf）开放最短路径优先协议, 是由 Internet 工程任务组开发的路由选择协议</p>
</blockquote>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS 解析</li>
<li>TCP 连接</li>
<li>发送 HTTP 请求</li>
<li>服务器处理请求并返回 HTTP 报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ol>
<p>具体可以参考下面这两篇文章：</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000006879700">从输入 URL 到页面加载发生了什么？</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1879758">浏览器从输入网址到页面展示的过程</a></li>
</ul>
<h2 id="http状态码有哪些">HTTP状态码有哪些<a hidden class="anchor" aria-hidden="true" href="#http状态码有哪些">#</a></h2>
<p>HTTP 状态码用于描述 HTTP 请求的结果，比如 2xx 就代表请求被成功处理。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/http-status-code.png"></p>
<h3 id="1xx-informational信息性状态码">1xx Informational（信息性状态码）<a hidden class="anchor" aria-hidden="true" href="#1xx-informational信息性状态码">#</a></h3>
<p>相比于其他类别状态码来说，1xx 你平时你大概率不会碰到，所以这里直接跳过。</p>
<h3 id="2xx-success成功状态码">2xx Success（成功状态码）<a hidden class="anchor" aria-hidden="true" href="#2xx-success成功状态码">#</a></h3>
<ul>
<li><strong>200 OK</strong>：请求被成功处理。比如我们发送一个查询用户数据的 HTTP 请求到服务端，服务端正确返回了用户数据。这个是我们平时最常见的一个 HTTP 状态码。</li>
<li><strong>201 Created</strong>：请求被成功处理并且在服务端创建了一个新的资源。比如我们通过 POST 请求创建一个新的用户。</li>
<li><strong>202 Accepted</strong>：服务端已经接收到了请求，但是还未处理。</li>
<li><strong>204 No Content</strong>：服务端已经成功处理了请求，但是没有返回任何内容。</li>
</ul>
<p>这里格外提一下 204 状态码，平时学习/工作中见到的次数并不多。</p>
<h3 id="3xx-redirection重定向状态码">3xx Redirection（重定向状态码）<a hidden class="anchor" aria-hidden="true" href="#3xx-redirection重定向状态码">#</a></h3>
<ul>
<li><strong>301 Moved Permanently</strong>：资源被永久重定向了。比如你的网站的网址更换了。</li>
<li><strong>302 Found</strong>：资源被临时重定向了。比如你的网站的某些资源被暂时转移到另外一个网址。</li>
</ul>
<h3 id="4xx-client-error客户端错误状态码">4xx Client Error（客户端错误状态码）<a hidden class="anchor" aria-hidden="true" href="#4xx-client-error客户端错误状态码">#</a></h3>
<ul>
<li><strong>400 Bad Request</strong>：发送的 HTTP 请求存在问题。比如请求参数不合法、请求方法错误。</li>
<li><strong>401 Unauthorized</strong>：未认证却请求需要认证之后才能访问的资源。</li>
<li><strong>403 Forbidden</strong>：直接拒绝 HTTP 请求，不处理。一般用来针对非法请求。</li>
<li><strong>404 Not Found</strong>：你请求的资源未在服务端找到。比如你请求某个用户的信息，服务端并没有找到指定的用户。</li>
<li><strong>409 Conflict</strong>：表示请求的资源与服务端当前的状态存在冲突，请求无法被处理。</li>
</ul>
<h3 id="5xx-server-error服务端错误状态码">5xx Server Error（服务端错误状态码）<a hidden class="anchor" aria-hidden="true" href="#5xx-server-error服务端错误状态码">#</a></h3>
<ul>
<li><strong>500 Internal Server Error</strong>：服务端出问题了（通常是服务端出 Bug 了）。比如你服务端处理请求的时候突然抛出异常，但是异常并未在服务端被正确处理。</li>
<li><strong>502 Bad Gateway</strong>：我们的网关将请求转发到服务端，但是服务端返回的却是一个错误的响应。</li>
</ul>
<h2 id="http-header-中常见的字段有哪些">HTTP Header 中常见的字段有哪些？<a hidden class="anchor" aria-hidden="true" href="#http-header-中常见的字段有哪些">#</a></h2>
<table>
<thead>
<tr>
<th style="text-align:left">请求头字段名</th>
<th style="text-align:left">说明</th>
<th style="text-align:left">示例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Accept</td>
<td style="text-align:left">能够接受的回应内容类型（Content-Types）。</td>
<td style="text-align:left">Accept: text/plain</td>
</tr>
<tr>
<td style="text-align:left">Accept-Charset</td>
<td style="text-align:left">能够接受的字符集</td>
<td style="text-align:left">Accept-Charset: utf-8</td>
</tr>
<tr>
<td style="text-align:left">Accept-Datetime</td>
<td style="text-align:left">能够接受的按照时间来表示的版本</td>
<td style="text-align:left">Accept-Datetime: Thu, 31 May 2007 20:35:00 GMT</td>
</tr>
<tr>
<td style="text-align:left">Accept-Encoding</td>
<td style="text-align:left">能够接受的编码方式列表。参考 HTTP 压缩。</td>
<td style="text-align:left">Accept-Encoding: gzip, deflate</td>
</tr>
<tr>
<td style="text-align:left">Accept-Language</td>
<td style="text-align:left">能够接受的回应内容的自然语言列表。</td>
<td style="text-align:left">Accept-Language: en-US</td>
</tr>
<tr>
<td style="text-align:left">Authorization</td>
<td style="text-align:left">用于超文本传输协议的认证的认证信息</td>
<td style="text-align:left">Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td style="text-align:left">Cache-Control</td>
<td style="text-align:left">用来指定在这次的请求/响应链中的所有缓存机制 都必须 遵守的指令</td>
<td style="text-align:left">Cache-Control: no-cache</td>
</tr>
<tr>
<td style="text-align:left">Connection</td>
<td style="text-align:left">该浏览器想要优先使用的连接类型</td>
<td style="text-align:left">Connection: keep-alive Connection: Upgrade</td>
</tr>
<tr>
<td style="text-align:left">Content-Length</td>
<td style="text-align:left">以 八位字节数组 （8 位的字节）表示的请求体的长度</td>
<td style="text-align:left">Content-Length: 348</td>
</tr>
<tr>
<td style="text-align:left">Content-MD5</td>
<td style="text-align:left">请求体的内容的二进制 MD5 散列值，以 Base64 编码的结果</td>
<td style="text-align:left">Content-MD5: Q2hlY2sgSW50ZWdyaXR5IQ==</td>
</tr>
<tr>
<td style="text-align:left">Content-Type</td>
<td style="text-align:left">请求体的 多媒体类型 （用于 POST 和 PUT 请求中）</td>
<td style="text-align:left">Content-Type: application/x-www-form-urlencoded</td>
</tr>
<tr>
<td style="text-align:left">Cookie</td>
<td style="text-align:left">之前由服务器通过 Set- Cookie （下文详述）发送的一个 超文本传输协议 Cookie</td>
<td style="text-align:left">Cookie: $Version=1; Skin=new;</td>
</tr>
<tr>
<td style="text-align:left">Date</td>
<td style="text-align:left">发送该消息的日期和时间(按照 RFC 7231 中定义的&quot;超文本传输协议日期&quot;格式来发送)</td>
<td style="text-align:left">Date: Tue, 15 Nov 1994 08:12:31 GMT</td>
</tr>
<tr>
<td style="text-align:left">Expect</td>
<td style="text-align:left">表明客户端要求服务器做出特定的行为</td>
<td style="text-align:left">Expect: 100-continue</td>
</tr>
<tr>
<td style="text-align:left">From</td>
<td style="text-align:left">发起此请求的用户的邮件地址</td>
<td style="text-align:left">From: <a href="mailto:user@example.com">user@example.com</a></td>
</tr>
<tr>
<td style="text-align:left">Host</td>
<td style="text-align:left">服务器的域名(用于虚拟主机 )，以及服务器所监听的传输控制协议端口号。如果所请求的端口是对应的服务的标准端口，则端口号可被省略。</td>
<td style="text-align:left">Host: en.wikipedia.org:80</td>
</tr>
<tr>
<td style="text-align:left">If-Match</td>
<td style="text-align:left">仅当客户端提供的实体与服务器上对应的实体相匹配时，才进行对应的操作。主要作用时，用作像 PUT 这样的方法中，仅当从用户上次更新某个资源以来，该资源未被修改的情况下，才更新该资源。</td>
<td style="text-align:left">If-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td style="text-align:left">If-Modified-Since</td>
<td style="text-align:left">允许在对应的内容未被修改的情况下返回 304 未修改（ 304 Not Modified ）</td>
<td style="text-align:left">If-Modified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td>
</tr>
<tr>
<td style="text-align:left">If-None-Match</td>
<td style="text-align:left">允许在对应的内容未被修改的情况下返回 304 未修改（ 304 Not Modified ）</td>
<td style="text-align:left">If-None-Match: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td style="text-align:left">If-Range</td>
<td style="text-align:left">如果该实体未被修改过，则向我发送我所缺少的那一个或多个部分；否则，发送整个新的实体</td>
<td style="text-align:left">If-Range: “737060cd8c284d8af7ad3082f209582d”</td>
</tr>
<tr>
<td style="text-align:left">If-Unmodified-Since</td>
<td style="text-align:left">仅当该实体自某个特定时间已来未被修改的情况下，才发送回应。</td>
<td style="text-align:left">If-Unmodified-Since: Sat, 29 Oct 1994 19:43:31 GMT</td>
</tr>
<tr>
<td style="text-align:left">Max-Forwards</td>
<td style="text-align:left">限制该消息可被代理及网关转发的次数。</td>
<td style="text-align:left">Max-Forwards: 10</td>
</tr>
<tr>
<td style="text-align:left">Origin</td>
<td style="text-align:left">发起一个针对 跨来源资源共享 的请求。</td>
<td style="text-align:left">Origin: <a href="http://www.example-social-network.com/">http://www.example-social-network.com</a></td>
</tr>
<tr>
<td style="text-align:left">Pragma</td>
<td style="text-align:left">与具体的实现相关，这些字段可能在请求/回应链中的任何时候产生多种效果。</td>
<td style="text-align:left">Pragma: no-cache</td>
</tr>
<tr>
<td style="text-align:left">Proxy-Authorization</td>
<td style="text-align:left">用来向代理进行认证的认证信息。</td>
<td style="text-align:left">Proxy-Authorization: Basic QWxhZGRpbjpvcGVuIHNlc2FtZQ==</td>
</tr>
<tr>
<td style="text-align:left">Range</td>
<td style="text-align:left">仅请求某个实体的一部分。字节偏移以 0 开始。参见字节服务。</td>
<td style="text-align:left">Range: bytes=500-999</td>
</tr>
<tr>
<td style="text-align:left">Referer</td>
<td style="text-align:left">表示浏览器所访问的前一个页面，正是那个页面上的某个链接将浏览器带到了当前所请求的这个页面。</td>
<td style="text-align:left">Referer: <a href="https://en.wikipedia.org/wiki/Main_Page">http://en.wikipedia.org/wiki/Main_Page</a></td>
</tr>
<tr>
<td style="text-align:left">TE</td>
<td style="text-align:left">浏览器预期接受的传输编码方式：可使用回应协议头 Transfer-Encoding 字段中的值；</td>
<td style="text-align:left">TE: trailers, deflate</td>
</tr>
<tr>
<td style="text-align:left">Upgrade</td>
<td style="text-align:left">要求服务器升级到另一个协议。</td>
<td style="text-align:left">Upgrade: HTTP/2.0, SHTTP/1.3, IRC/6.9, RTA/x11</td>
</tr>
<tr>
<td style="text-align:left">User-Agent</td>
<td style="text-align:left">浏览器的浏览器身份标识字符串</td>
<td style="text-align:left">User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:12.0) Gecko/20100101 Firefox/21.0</td>
</tr>
<tr>
<td style="text-align:left">Via</td>
<td style="text-align:left">向服务器告知，这个请求是由哪些代理发出的。</td>
<td style="text-align:left">Via: 1.0 fred, 1.1 example.com (Apache/1.1)</td>
</tr>
<tr>
<td style="text-align:left">Warning</td>
<td style="text-align:left">一个一般性的警告，告知，在实体内容体中可能存在错误。</td>
<td style="text-align:left">Warning: 199 Miscellaneous warning</td>
</tr>
</tbody>
</table>
<h2 id="http-和-https-有什么区别应用层">HTTP 和 HTTPS 有什么区别？（应用层）<a hidden class="anchor" aria-hidden="true" href="#http-和-https-有什么区别应用层">#</a></h2>
<h3 id="http协议介绍">HTTP协议介绍<a hidden class="anchor" aria-hidden="true" href="#http协议介绍">#</a></h3>
<p>HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来规范超文本的传输，超文本，也就是网络上的包括文本在内的各式各样的消息，具体来说，主要是来规范浏览器和服务器端的行为的。</p>
<p>并且，HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。</p>
<h3 id="http-协议通信过程">HTTP 协议通信过程<a hidden class="anchor" aria-hidden="true" href="#http-协议通信过程">#</a></h3>
<p>HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 通信过程主要如下：</p>
<ol>
<li>服务器在 80 端口等待客户的请求。</li>
<li>浏览器发起到服务器的 TCP 连接（创建套接字 Socket）。</li>
<li>服务器接收来自浏览器的 TCP 连接。</li>
<li>浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）交换 HTTP 消息。</li>
<li>关闭 TCP 连接。</li>
</ol>
<h3 id="https-协议介绍">HTTPS 协议介绍<a hidden class="anchor" aria-hidden="true" href="#https-协议介绍">#</a></h3>
<p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.</p>
<p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 40 比特或 128 比特。</p>
<h3 id="https-的核心ssltls-协议">HTTPS 的核心—SSL/TLS 协议<a hidden class="anchor" aria-hidden="true" href="#https-的核心ssltls-协议">#</a></h3>
<p>HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密，解决了 HTTP 数据透明的问题。接下来重点介绍一下 SSL/TLS 的工作原理。</p>
<h3 id="ssl-和-tls-的区别">SSL 和 TLS 的区别？<a hidden class="anchor" aria-hidden="true" href="#ssl-和-tls-的区别">#</a></h3>
<p><strong>SSL 和 TLS 没有太大的区别。</strong></p>
<p>SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，<strong>新版本被命名为 TLS 1.0</strong>。因此，TLS 是基于 SSL 之上的，但由于习惯叫法，通常把 HTTPS 中的核心加密协议混称为 SSL/TLS。</p>
<h3 id="ssltls-的工作原理">SSL/TLS 的工作原理<a hidden class="anchor" aria-hidden="true" href="#ssltls-的工作原理">#</a></h3>
<h4 id="非对称加密">非对称加密<a hidden class="anchor" aria-hidden="true" href="#非对称加密">#</a></h4>
<p>SSL/TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，</p>
<blockquote>
<p>在某个自助邮局，每个通信信道都是一个邮箱，每一个邮箱所有者都在旁边立了一个牌子，上面挂着一把钥匙：这是我的公钥，发送者请将信件放入我的邮箱，并用公钥锁好。</p>
<p>但是公钥只能加锁，并不能解锁。解锁只能由邮箱的所有者——因为只有他保存着私钥。</p>
<p>这样，通信信息就不会被其他人截获了，这依赖于私钥的保密性。</p>
</blockquote>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/public-key-cryptography-22f51898.png"></p>
<p>非对称加密的公钥和私钥需要采用一种复杂的数学机制生成（密码学认为，为了较高的安全性，尽量不要自己创造加密方案）。公私钥对的生成算法依赖于单向陷门函数。</p>
<blockquote>
<p>单向函数：已知单向函数 f，给定任意一个输入 x，易计算输出 y=f(x)；而给定一个输出 y，假设存在 f(x)=y，很难根据 f 来计算出 x。</p>
<p>单向陷门函数：一个较弱的单向函数。已知单向陷门函数 f，陷门 h，给定任意一个输入 x，易计算出输出 y=f(x;h)；而给定一个输出 y，假设存在 f(x;h)=y，很难根据 f 来计算出 x，但可以根据 f 和 h 来推导出 x。</p>
</blockquote>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/OWF-03d24071.png"></p>
<p>上图就是一个单向函数（不是单项陷门函数），假设有一个绝世秘籍，任何知道了这个秘籍的人都可以把苹果汁榨成苹果，那么这个秘籍就是“陷门”了吧。</p>
<p>在这里，函数 f 的计算方法相当于公钥，陷门 h 相当于私钥。公钥 f 是公开的，任何人对已有输入，都可以用 f 加密，而要想根据加密信息还原出原信息，必须要有私钥才行。</p>
<h4 id="对称加密">对称加密<a hidden class="anchor" aria-hidden="true" href="#对称加密">#</a></h4>
<p>使用 SSL/TLS 进行通信的双方需要使用非对称加密方案来通信，但是非对称加密设计了较为复杂的数学算法，在实际通信过程中，计算的代价较高，效率太低，因此，SSL/TLS 实际对消息的加密使用的是对称加密。</p>
<blockquote>
<p>对称加密：通信双方共享唯一密钥 k，加解密算法已知，加密方利用密钥 k 加密，解密方利用密钥 k 解密，保密性依赖于密钥 k 的保密性。</p>
</blockquote>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/symmetric-encryption-20454cea.png"></p>
<p>对称加密的密钥生成代价比公私钥对的生成代价低得多，那么有的人会问了，为什么 SSL/TLS 还需要使用非对称加密呢？因为对称加密的保密性完全依赖于密钥的保密性。在双方通信之前，需要商量一个用于对称加密的密钥。我们知道网络通信的信道是不安全的，传输报文对任何人是可见的，密钥的交换肯定不能直接在网络信道中传输。因此，使用非对称加密，对对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要一次非对称加密，交换对称加密的密钥，在之后的信息通信中，使用绝对安全的密钥，对信息进行对称加密，即可保证传输消息的保密性。</p>
<h4 id="公钥传输的信赖性">公钥传输的信赖性<a hidden class="anchor" aria-hidden="true" href="#公钥传输的信赖性">#</a></h4>
<p>SSL/TLS 介绍到这里，了解信息安全的朋友又会想到一个安全隐患，设想一个下面的场景：</p>
<blockquote>
<p>客户端 C 和服务器 S 想要使用 SSL/TLS 通信，由上述 SSL/TLS 通信原理，C 需要先知道 S 的公钥，而 S 公钥的唯一获取途径，就是把 S 公钥在网络信道中传输。要注意网络信道通信中有几个前提：</p>
<ol>
<li>任何人都可以捕获通信包</li>
<li>通信包的保密性由发送者设计</li>
<li>保密算法设计方案默认为公开，而（解密）密钥默认是安全的</li>
</ol>
<p>因此，假设 S 公钥不做加密，在信道中传输，那么很有可能存在一个攻击者 A，发送给 C 一个诈包，假装是 S 公钥，其实是诱饵服务器 AS 的公钥。当 C 收获了 AS 的公钥（却以为是 S 的公钥），C 后续就会使用 AS 公钥对数据进行加密，并在公开信道传输，那么 A 将捕获这些加密包，用 AS 的私钥解密，就截获了 C 本要给 S 发送的内容，而 C 和 S 二人全然不知。</p>
<p>同样的，S 公钥即使做加密，也难以避免这种信任性问题，C 被 AS 拐跑了！</p>
</blockquote>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/attack1-48b62b2e.png"></p>
<p>为了公钥传输的信赖性问题，第三方机构应运而生——证书颁发机构（CA，Certificate Authority）。CA 默认是受信任的第三方。CA 会给各个服务器颁发证书，证书存储在服务器上，并附有 CA 的<strong>电子签名</strong>（见下节）。</p>
<p>当客户端（浏览器）向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。</p>
<h4 id="数字签名">数字签名<a hidden class="anchor" aria-hidden="true" href="#数字签名">#</a></h4>
<p>好，到这一小节，已经是 SSL/TLS 的尾声了。上一小节提到了数字签名，数字签名要解决的问题，是防止证书被伪造。第三方信赖机构 CA 之所以能被信赖，就是 <strong>靠数字签名技术</strong> 。</p>
<p>数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下：</p>
<blockquote>
<p>CA 知道服务器的公钥，对证书采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。</p>
<p>现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。</p>
<p>客户端对证书数据（包含服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。</p>
</blockquote>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/digital-signature-c80badfc.png"></p>
<p>总结来说，带有证书的公钥传输机制如下：</p>
<ol>
<li>设有服务器 S，客户端 C，和第三方信赖机构 CA。</li>
<li>S 信任 CA，CA 是知道 S 公钥的，CA 向 S 颁发证书。并附上 CA 私钥对消息摘要的加密签名。</li>
<li>S 获得 CA 颁发的证书，将该证书传递给 C。</li>
<li>C 获得 S 的证书，信任 CA 并知晓 CA 公钥，使用 CA 公钥对 S 证书上的签名解密，同时对消息进行散列处理，得到摘要。比较摘要，验证 S 证书的真实性。</li>
<li>如果 C 验证 S 证书是真实的，则信任 S 的公钥（在 S 证书中）。</li>
</ol>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/public-key-transmission-a8809fd8.png"></p>
<p>对于数字签名，我这里讲的比较简单，如果你没有搞清楚的话，强烈推荐你看看<a href="https://www.bilibili.com/video/BV18N411X7ty/">数字签名及数字证书原理</a>这个视频，这是我看过最清晰的讲解。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220321121814946.png"></p>
<h3 id="总结-1">总结<a hidden class="anchor" aria-hidden="true" href="#总结-1">#</a></h3>
<ul>
<li><strong>端口号</strong>：HTTP 默认是 80，HTTPS 默认是 443。</li>
<li><strong>URL 前缀</strong>：HTTP 的 URL 前缀是 <code>http://</code>，HTTPS 的 URL 前缀是 <code>https://</code>。</li>
<li><strong>安全性和资源消耗</strong>：HTTP 协议运行在 TCP 之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS 是运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS 高，但是 HTTPS 比 HTTP 耗费更多服务器资源。</li>
</ul>
<h2 id="http10-和-http11-有什么区别">HTTP/1.0 和 HTTP/1.1 有什么区别？<a hidden class="anchor" aria-hidden="true" href="#http10-和-http11-有什么区别">#</a></h2>
<p>以下面几个维度来对比 HTTP 1.0 和 HTTP 1.1：</p>
<ul>
<li>响应状态码</li>
<li>缓存处理</li>
<li>连接方式</li>
<li>Host 头处理</li>
<li>带宽优化</li>
</ul>
<h3 id="响应状态码">响应状态码<a hidden class="anchor" aria-hidden="true" href="#响应状态码">#</a></h3>
<p>HTTP/1.0 仅定义了 16 种状态码。HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</p>
<h3 id="缓存处理">缓存处理<a hidden class="anchor" aria-hidden="true" href="#缓存处理">#</a></h3>
<p>缓存技术通过避免用户与源服务器的频繁交互，节约了大量的网络带宽，降低了用户接收信息的延迟。</p>
<h4 id="http10">HTTP/1.0<a hidden class="anchor" aria-hidden="true" href="#http10">#</a></h4>
<p>HTTP/1.0 提供的缓存机制非常简单。服务器端使用<code>Expires</code>标签来标志（时间）一个响应体，在<code>Expires</code>标志时间内的请求，都会获得该响应体缓存。服务器端在初次返回给客户端的响应体中，有一个<code>Last-Modified</code>标签，该标签标记了被请求资源在服务器端的最后一次修改。在请求头中，使用<code>If-Modified-Since</code>标签，该标签标志一个时间，意为客户端向服务器进行问询：“该时间之后，我要请求的资源是否有被修改过？”通常情况下，请求头中的<code>If-Modified-Since</code>的值即为上一次获得该资源时，响应体中的<code>Last-Modified</code>的值。</p>
<p>如果服务器接收到了请求头，并判断<code>If-Modified-Since</code>时间后，资源确实没有修改过，则返回给客户端一个<code>304 not modified</code>响应头，表示”缓冲可用，你从浏览器里拿吧！”。</p>
<p>如果服务器判断<code>If-Modified-Since</code>时间后，资源被修改过，则返回给客户端一个<code>200 OK</code>的响应体，并附带全新的资源内容，表示”你要的我已经改过的，给你一份新的”。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP1.0cache1-2f2b7eac.png"></p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP1.0cache2-7430070e.png"></p>
<h4 id="http11">HTTP/1.1<a hidden class="anchor" aria-hidden="true" href="#http11">#</a></h4>
<p>HTTP/1.1 的缓存机制在 HTTP/1.0 的基础上，大大增加了灵活性和扩展性。基本工作原理和 HTTP/1.0 保持不变，而是增加了更多细致的特性。其中，请求头中最常见的特性就是<code>Cache-Control</code>，详见 MDN Web 文档 <a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Cache-Control">Cache-Control</a></p>
<h3 id="连接方式">连接方式<a hidden class="anchor" aria-hidden="true" href="#连接方式">#</a></h3>
<p><strong>HTTP/1.0 默认使用短连接</strong> ，也就是说，客户端和服务器每进行一次 HTTP 操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个 HTML 或其他类型的 Web 页中包含有其他的 Web 资源（如 JavaScript 文件、图像文件、CSS 文件等），每遇到这样一个 Web 资源，浏览器就会重新建立一个 TCP 连接，这样就会导致有大量的“握手报文”和“挥手报文”占用了带宽。</p>
<p><strong>为了解决 HTTP/1.0 存在的资源浪费的问题， HTTP/1.1 优化为默认长连接模式 。</strong> 采用长连接模式的请求报文会通知服务端：“我向你请求连接，并且连接成功建立后，请不要关闭”。因此，该 TCP 连接将持续打开，为后续的客户端-服务端的数据交互服务。也就是说在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。</p>
<p>如果 TCP 连接一直保持的话也是对资源的浪费，因此，一些服务器软件（如 Apache）还会支持超时时间的时间。在超时时间之内没有新的请求达到，TCP 连接才会被关闭。</p>
<p>有必要说明的是，HTTP/1.0 仍提供了长连接选项，即在请求头中加入<code>Connection: Keep-alive</code>。同样的，在 HTTP/1.1 中，如果不希望使用长连接选项，也可以在请求头中加入<code>Connection: close</code>，这样会通知服务器端：“我不需要长连接，连接成功后即可关闭”。</p>
<p><strong>HTTP 协议的长连接和短连接，实质上是 TCP 协议的长连接和短连接。</strong></p>
<p><strong>实现长连接需要客户端和服务端都支持长连接。</strong></p>
<h3 id="host-头处理">Host 头处理<a hidden class="anchor" aria-hidden="true" href="#host-头处理">#</a></h3>
<p>域名系统（DNS）允许多个主机名绑定到同一个 IP 地址上，但是 HTTP/1.0 并没有考虑这个问题，假设我们有一个资源 URL 是http://example1.org/home.html，HTTP/1.0的请求报文中，将会请求的是<code>GET /home.html HTTP/1.0</code>.也就是不会加入主机名。这样的报文送到服务器端，服务器是理解不了客户端想请求的真正网址。</p>
<p>因此，HTTP/1.1 在请求头中加入了<code>Host</code>字段。加入<code>Host</code>字段的报文头部将会是：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>GET /home.html HTTP/1.1
</span></span><span style="display:flex;"><span>Host: example1.org
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样，服务器端就可以确定客户端想要请求的真正的网址了。</p>
<h3 id="带宽优化">带宽优化<a hidden class="anchor" aria-hidden="true" href="#带宽优化">#</a></h3>
<h4 id="范围请求">范围请求<a hidden class="anchor" aria-hidden="true" href="#范围请求">#</a></h4>
<p>HTTP/1.1 引入了范围请求（range request）机制，以避免带宽的浪费。当客户端想请求一个文件的一部分，或者需要继续下载一个已经下载了部分但被终止的文件，HTTP/1.1 可以在请求中加入<code>Range</code>头部，以请求（并只能请求字节型数据）数据的一部分。服务器端可以忽略<code>Range</code>头部，也可以返回若干<code>Range</code>响应。</p>
<p>如果一个响应包含部分数据的话，那么将带有<code>206 (Partial Content)</code>状态码。该状态码的意义在于避免了 HTTP/1.0 代理缓存错误地把该响应认为是一个完整的数据响应，从而把他当作为一个请求的响应缓存。</p>
<p>在范围响应中，<code>Content-Range</code>头部标志指示出了该数据块的偏移量和数据块的长度。</p>
<h4 id="状态码-100">状态码 100<a hidden class="anchor" aria-hidden="true" href="#状态码-100">#</a></h4>
<p>HTTP/1.1 中新加入了状态码<code>100</code>。该状态码的使用场景为，存在某些较大的文件请求，服务器可能不愿意响应这种请求，此时状态码<code>100</code>可以作为指示请求是否会被正常响应，过程如下图：</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP1.1continue1.png"></p>
<p><img loading="lazy" src="HTTP1.1continue2.png"></p>
<p>然而在 HTTP/1.0 中，并没有<code>100 (Continue)</code>状态码，要想触发这一机制，可以发送一个<code>Expect</code>头部，其中包含一个<code>100-continue</code>的值。</p>
<h4 id="压缩">压缩<a hidden class="anchor" aria-hidden="true" href="#压缩">#</a></h4>
<p>许多格式的数据在传输时都会做预压缩处理。数据的压缩可以大幅优化带宽的利用。然而，HTTP/1.0 对数据压缩的选项提供的不多，不支持压缩细节的选择，也无法区分端到端（end-to-end）压缩或者是逐跳（hop-by-hop）压缩。</p>
<p>HTTP/1.1 则对内容编码（content-codings）和传输编码（transfer-codings）做了区分。内容编码总是端到端的，传输编码总是逐跳的。</p>
<p>HTTP/1.0 包含了<code>Content-Encoding</code>头部，对消息进行端到端编码。HTTP/1.1 加入了<code>Transfer-Encoding</code>头部，可以对消息进行逐跳传输编码。HTTP/1.1 还加入了<code>Accept-Encoding</code>头部，是客户端用来指示他能处理什么样的内容编码。</p>
<h3 id="总结-2">总结<a hidden class="anchor" aria-hidden="true" href="#总结-2">#</a></h3>
<ol>
<li><strong>连接方式</strong> : HTTP 1.0 为短连接，HTTP 1.1 支持长连接。</li>
<li><strong>状态响应码</strong> : HTTP/1.1 中新加入了大量的状态码，光是错误响应状态码就新增了 24 种。比如说，<code>100 (Continue)</code>——在请求大资源前的预热请求，<code>206 (Partial Content)</code>——范围请求的标识码，<code>409 (Conflict)</code>——请求与当前资源的规定冲突，<code>410 (Gone)</code>——资源已被永久转移，而且没有任何已知的转发地址。</li>
<li><strong>缓存处理</strong> : 在 HTTP1.0 中主要使用 header 里的 If-Modified-Since,Expires 来做为缓存判断的标准，HTTP1.1 则引入了更多的缓存控制策略例如 Entity tag，If-Unmodified-Since, If-Match, If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>Host 头处理</strong> : HTTP/1.1 在请求头中加入了<code>Host</code>字段。</li>
</ol>
<h2 id="http11-和-http20-有什么区别">HTTP/1.1 和 HTTP/2.0 有什么区别？<a hidden class="anchor" aria-hidden="true" href="#http11-和-http20-有什么区别">#</a></h2>
<p><strong>IO 多路复用（Multiplexing）</strong>：HTTP/2.0 在同一连接上可以同时传输多个请求和响应（可以看作是 HTTP/1.1 中长链接的升级版本）。HTTP/1.1 则使用串行方式，每个请求和响应都需要独立的连接。这使得 HTTP/2.0 在处理多个请求时更加高效，减少了网络延迟和提高了性能。</p>
<p><strong>二进制帧（Binary Frames）</strong>：HTTP/2.0 使用二进制帧进行数据传输，而 HTTP/1.1 则使用文本格式的报文。二进制帧更加紧凑和高效，减少了传输的数据量和带宽消耗。</p>
<p><strong>头部压缩（Header Compression）</strong>：HTTP/1.1 支持<code>Body</code>压缩，<code>Header</code>不支持压缩。HTTP/2.0 支持对<code>Header</code>压缩，减少了网络开销。</p>
<p><strong>服务器推送（Server Push）</strong>：HTTP/2.0 支持服务器推送，可以在客户端请求一个资源时，将其他相关资源一并推送给客户端，从而减少了客户端的请求次数和延迟。而 HTTP/1.1 需要客户端自己发送请求来获取相关资源。</p>
<h2 id="http20-和-http30-有什么区别">HTTP/2.0 和 HTTP/3.0 有什么区别？<a hidden class="anchor" aria-hidden="true" href="#http20-和-http30-有什么区别">#</a></h2>
<p><strong>传输协议</strong>：HTTP/2.0 是基于 TCP 协议实现的，HTTP/3.0 新增了 QUIC（Quick UDP Internet Connections） 协议来实现可靠的传输，提供与 TLS/SSL 相当的安全性，具有较低的连接和传输延迟。你可以将 QUIC 看作是 UDP 的升级版本，在其基础上新增了很多功能比如加密、重传等等。HTTP/3.0 之前名为 HTTP-over-QUIC，从这个名字中我们也可以发现，HTTP/3 最大的改造就是使用了 QUIC。</p>
<p><strong>连接建立</strong>：HTTP/2.0 需要经过经典的 TCP 三次握手过程（由于安全的 HTTPS 连接建立还需要 TLS 握手，共需要大约 3 个 RTT）。由于 QUIC 协议的特性（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。</p>
<p><strong>队头阻塞</strong>：HTTP/2.0 多请求复用一个 TCP 连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。由于 QUIC 协议的特性，HTTP/3.0 在一定程度上解决了队头阻塞（Head-of-Line blocking, 简写：HOL blocking）问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。</p>
<p><strong>错误恢复</strong>：HTTP/3.0 具有更好的错误恢复机制，当出现丢包、延迟等网络问题时，可以更快地进行恢复和重传。而 HTTP/2.0 则需要依赖于 TCP 的错误恢复机制。</p>
<p><strong>安全性</strong>：HTTP/2.0 和 HTTP/3.0 在安全性上都有较高的要求，支持加密通信，但在实现上有所不同。HTTP/2.0 使用 TLS 协议进行加密，而 HTTP/3.0 基于 QUIC 协议，包含了内置的加密和身份验证机制，可以提供更强的安全性。</p>
<h2 id="http-是不保存状态的协议-如何保存用户状态">HTTP 是不保存状态的协议, 如何保存用户状态?<a hidden class="anchor" aria-hidden="true" href="#http-是不保存状态的协议-如何保存用户状态">#</a></h2>
<p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p>
<p><strong>Cookie 被禁用怎么办?</strong></p>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p>
<h2 id="uri-和-url-的区别是什么">URI 和 URL 的区别是什么?<a hidden class="anchor" aria-hidden="true" href="#uri-和-url-的区别是什么">#</a></h2>
<ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p>
<h1 id="ping">PING<a hidden class="anchor" aria-hidden="true" href="#ping">#</a></h1>
<h2 id="ping-命令的作用是什么">PING 命令的作用是什么？<a hidden class="anchor" aria-hidden="true" href="#ping-命令的作用是什么">#</a></h2>
<p>PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。</p>
<p>这里简单举一个例子，我们来 PING 一下百度。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 发送4个PING请求数据包到 www.baidu.com</span>
</span></span><span style="display:flex;"><span>❯ ping -c <span style="color:#ff0;font-weight:bold">4</span> www.baidu.com
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PING www.a.shifen.com (14.119.104.189): <span style="color:#ff0;font-weight:bold">56</span> data bytes
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">64</span> bytes from 14.119.104.189: icmp_seq=<span style="color:#ff0;font-weight:bold">0</span> ttl=<span style="color:#ff0;font-weight:bold">54</span> time=27.867 ms
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">64</span> bytes from 14.119.104.189: icmp_seq=<span style="color:#ff0;font-weight:bold">1</span> ttl=<span style="color:#ff0;font-weight:bold">54</span> time=28.732 ms
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">64</span> bytes from 14.119.104.189: icmp_seq=<span style="color:#ff0;font-weight:bold">2</span> ttl=<span style="color:#ff0;font-weight:bold">54</span> time=27.571 ms
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">64</span> bytes from 14.119.104.189: icmp_seq=<span style="color:#ff0;font-weight:bold">3</span> ttl=<span style="color:#ff0;font-weight:bold">54</span> time=27.581 ms
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>--- www.a.shifen.com ping statistics ---
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">4</span> packets transmitted, <span style="color:#ff0;font-weight:bold">4</span> packets received, 0.0% packet loss
</span></span><span style="display:flex;"><span>round-trip min/avg/max/stddev = 27.571/27.938/28.732/0.474 ms
</span></span></code></pre></td></tr></table>
</div>
</div><p>PING 命令的输出结果通常包括以下几部分信息：</p>
<ol>
<li><strong>ICMP Echo Request（请求报文）信息</strong>：序列号、TTL（Time to Live）值。</li>
<li><strong>目标主机的域名或 IP 地址</strong>：输出结果的第一行。</li>
<li><strong>往返时间（RTT，Round-Trip Time）</strong>：从发送 ICMP Echo Request（请求报文）到接收到 ICMP Echo Reply（响应报文）的总时间，用来衡量网络连接的延迟。</li>
<li><strong>统计结果（Statistics）</strong>：包括发送的 ICMP 请求数据包数量、接收到的 ICMP 响应数据包数量、丢包率、往返时间（RTT）的最小、平均、最大和标准偏差值。</li>
</ol>
<p>如果 PING 对应的目标主机无法得到正确的响应，则表明这两个主机之间的连通性存在问题。如果往返时间（RTT）过高，则表明网络延迟过高。</p>
<h2 id="ping-命令的工作原理是什么">PING 命令的工作原理是什么？<a hidden class="anchor" aria-hidden="true" href="#ping-命令的工作原理是什么">#</a></h2>
<p>PING 基于网络层的 <strong>ICMP（Internet Control Message Protocol，互联网控制报文协议）</strong>，其主要原理就是通过在网络上发送和接收 ICMP 报文实现的。</p>
<p>ICMP 报文中包含了类型字段，用于标识 ICMP 报文类型。ICMP 报文的类型有很多种，但大致可以分为两类：</p>
<ul>
<li><strong>查询报文类型</strong>：向目标主机发送请求并期望得到响应。</li>
<li><strong>差错报文类型</strong>：向源主机发送错误信息，用于报告网络中的错误情况。</li>
</ul>
<p>PING 用到的 ICMP Echo Request（类型为 8 ） 和 ICMP Echo Reply（类型为 0） 属于查询报文类型 。</p>
<ul>
<li>PING 命令会向目标主机发送 ICMP Echo Request。</li>
<li>如果两个主机的连通性正常，目标主机会返回一个对应的 ICMP Echo Reply。</li>
</ul>
<h1 id="dns-1">DNS<a hidden class="anchor" aria-hidden="true" href="#dns-1">#</a></h1>
<h2 id="dns-的作用是什么">DNS 的作用是什么？<a hidden class="anchor" aria-hidden="true" href="#dns-的作用是什么">#</a></h2>
<p>DNS（Domain Name System）域名管理系统，是当用户使用浏览器访问网址之后，使用的第一个重要协议。DNS 要解决的是<strong>域名和 IP 地址的映射问题</strong>。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/dns-overview.png"></p>
<p>在实际使用中，有一种情况下，浏览器是可以不必动用 DNS 就可以获知域名和 IP 地址的映射的。浏览器在本地会维护一个<code>hosts</code>列表，一般来说浏览器要先查看要访问的域名是否在<code>hosts</code>列表中，如果有的话，直接提取对应的 IP 地址记录，就好了。如果本地<code>hosts</code>列表内没有域名-IP 对应记录的话，那么 DNS 就闪亮登场了。</p>
<p>目前 DNS 的设计采用的是分布式、层次数据库结构，<strong>DNS 是应用层协议，基于 UDP 协议之上，端口为 53</strong> 。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/network-protocol-overview.png"></p>
<h2 id="dns-服务器有哪些">DNS 服务器有哪些？<a hidden class="anchor" aria-hidden="true" href="#dns-服务器有哪些">#</a></h2>
<p>DNS 服务器自底向上可以依次分为以下几个层级(所有 DNS 服务器都属于以下四个类别之一):</p>
<ul>
<li>根 DNS 服务器。根 DNS 服务器提供 TLD 服务器的 IP 地址。目前世界上只有 13 组根服务器，我国境内目前仍没有根服务器。</li>
<li>顶级域 DNS 服务器（TLD 服务器）。顶级域是指域名的后缀，如<code>com</code>、<code>org</code>、<code>net</code>和<code>edu</code>等。国家也有自己的顶级域，如<code>uk</code>、<code>fr</code>和<code>ca</code>。TLD 服务器提供了权威 DNS 服务器的 IP 地址。</li>
<li>权威 DNS 服务器。在因特网上具有公共可访问主机的每个组织机构必须提供公共可访问的 DNS 记录，这些记录将这些主机的名字映射为 IP 地址。</li>
<li>本地 DNS 服务器。每个 ISP（互联网服务提供商）都有一个自己的本地 DNS 服务器。当主机发出 DNS 请求时，该请求被发往本地 DNS 服务器，它起着代理的作用，并将该请求转发到 DNS 层次结构中。严格说来，不属于 DNS 层级结构</li>
</ul>
<h2 id="dns工作流程">DNS工作流程<a hidden class="anchor" aria-hidden="true" href="#dns工作流程">#</a></h2>
<p>以下图为例，介绍 DNS 的查询解析过程。DNS 的查询解析过程分为两种模式：</p>
<ul>
<li><strong>迭代</strong></li>
<li><strong>递归</strong></li>
</ul>
<p>下图是实践中常采用的方式，从请求主机到本地 DNS 服务器的查询是递归的，其余的查询时迭代的。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/DNS-process.png"></p>
<p>现在，主机<code>cis.poly.edu</code>想知道<code>gaia.cs.umass.edu</code>的 IP 地址。假设主机<code>cis.poly.edu</code>的本地 DNS 服务器为<code>dns.poly.edu</code>，并且<code>gaia.cs.umass.edu</code>的权威 DNS 服务器为<code>dns.cs.umass.edu</code>。</p>
<ol>
<li>首先，主机<code>cis.poly.edu</code>向本地 DNS 服务器<code>dns.poly.edu</code>发送一个 DNS 请求，该查询报文包含被转换的域名<code>gaia.cs.umass.edu</code>。</li>
<li>本地 DNS 服务器<code>dns.poly.edu</code>检查本机缓存，发现并无记录，也不知道<code>gaia.cs.umass.edu</code>的 IP 地址该在何处，不得不向根服务器发送请求。</li>
<li>根服务器注意到请求报文中含有<code>edu</code>顶级域，因此告诉本地 DNS，你可以向<code>edu</code>的 TLD DNS 发送请求，因为目标域名的 IP 地址很可能在那里。</li>
<li>本地 DNS 获取到了<code>edu</code>的 TLD DNS 服务器地址，向其发送请求，询问<code>gaia.cs.umass.edu</code>的 IP 地址。</li>
<li><code>edu</code>的 TLD DNS 服务器仍不清楚请求域名的 IP 地址，但是它注意到该域名有<code>umass.edu</code>前缀，因此返回告知本地 DNS，<code>umass.edu</code>的权威服务器可能记录了目标域名的 IP 地址。</li>
<li>这一次，本地 DNS 将请求发送给权威 DNS 服务器<code>dns.cs.umass.edu</code>。</li>
<li>终于，由于<code>gaia.cs.umass.edu</code>向权威 DNS 服务器备案过，在这里有它的 IP 地址记录，权威 DNS 成功地将 IP 地址返回给本地 DNS。</li>
<li>最后，本地 DNS 获取到了目标域名的 IP 地址，将其返回给请求主机。</li>
</ol>
<p>除了迭代式查询，还有一种递归式查询如下图，具体过程和上述类似，只是顺序有所不同。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/DNS-process2.png"></p>
<p>另外，DNS 的缓存位于本地 DNS 服务器。由于全世界的根服务器甚少，只有 400 多台，分为 13 组，且顶级域的数量也在一个可数的范围内，因此本地 DNS 通常已经缓存了很多 TLD DNS 服务器，所以在实际查找过程中，无需访问根服务器。根服务器通常是被跳过的，不请求的。</p>
<h2 id="dns报文格式">DNS报文格式<a hidden class="anchor" aria-hidden="true" href="#dns报文格式">#</a></h2>
<p>DNS 的报文格式如下图所示：</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/DNS-packet.png"></p>
<p>DNS 报文分为查询和回答报文，两种形式的报文结构相同。</p>
<ul>
<li>标识符。16 比特，用于标识该查询。这个标识符会被复制到对查询的回答报文中，以便让客户用它来匹配发送的请求和接收到的回答。</li>
<li>标志。1 比特的”查询/回答“标识位，<code>0</code>表示查询报文，<code>1</code>表示回答报文；1 比特的”权威的“标志位（当某 DNS 服务器是所请求名字的权威 DNS 服务器时，且是回答报文，使用”权威的“标志）；1 比特的”希望递归“标志位，显式地要求执行递归查询；1 比特的”递归可用“标志位，用于回答报文中，表示 DNS 服务器支持递归查询。</li>
<li>问题数、回答 RR 数、权威 RR 数、附加 RR 数。分别指示了后面 4 类数据区域出现的数量。</li>
<li>问题区域。包含正在被查询的主机名字，以及正被询问的问题类型。</li>
<li>回答区域。包含了对最初请求的名字的资源记录。<strong>在回答报文的回答区域中可以包含多条 RR，因此一个主机名能够有多个 IP 地址。</strong></li>
<li>权威区域。包含了其他权威服务器的记录。</li>
<li>附加区域。包含了其他有帮助的记录。</li>
</ul>
<h2 id="dns-记录">DNS 记录<a hidden class="anchor" aria-hidden="true" href="#dns-记录">#</a></h2>
<p>DNS 服务器在响应查询时，需要查询自己的数据库，数据库中的条目被称为<strong>资源记录(Resource Record，RR)</strong>。RR 提供了主机名到 IP 地址的映射。RR 是一个包含了<code>Name</code>, <code>Value</code>, <code>Type</code>, <code>TTL</code>四个字段的四元组。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/20210506174303797.png"></p>
<p><code>TTL</code>是该记录的生存时间，它决定了资源记录应当从缓存中删除的时间。</p>
<p><code>Name</code>和<code>Value</code>字段的取值取决于<code>Type</code>：</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/20210506170307897.png"></p>
<ul>
<li>如果<code>Type=A</code>，则<code>Name</code>是主机名信息，<code>Value</code> 是该主机名对应的 IP 地址。这样的 RR 记录了一条主机名到 IP 地址的映射。</li>
<li>如果 <code>Type=AAAA</code> （与 <code>A</code> 记录非常相似），唯一的区别是 A 记录使用的是 IPv4，而 <code>AAAA</code> 记录使用的是 IPv6。</li>
<li>如果<code>Type=CNAME</code> (Canonical Name Record,真实名称记录) ，则<code>Value</code>是别名为<code>Name</code>的主机对应的规范主机名。<code>Value</code>值才是规范主机名。<code>CNAME</code> 记录将一个主机名映射到另一个主机名。<code>CNAME</code> 记录用于为现有的 <code>A</code> 记录创建别名。下文有示例。</li>
<li>如果<code>Type=NS</code>，则<code>Name</code>是个域，而<code>Value</code>是个知道如何获得该域中主机 IP 地址的权威 DNS 服务器的主机名。通常这样的 RR 是由 TLD 服务器发布的。</li>
<li>如果<code>Type=MX</code> ，则<code>Value</code>是个别名为<code>Name</code>的邮件服务器的规范主机名。既然有了 <code>MX</code> 记录，那么邮件服务器可以和其他服务器使用相同的别名。为了获得邮件服务器的规范主机名，需要请求 <code>MX</code> 记录；为了获得其他服务器的规范主机名，需要请求 <code>CNAME</code> 记录。</li>
</ul>
<p><code>CNAME</code>记录总是指向另一则域名，而非 IP 地址。假设有下述 DNS zone：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>NAME                    TYPE   VALUE
</span></span><span style="display:flex;"><span>--------------------------------------------------
</span></span><span style="display:flex;"><span>bar.example.com.        CNAME  foo.example.com.
</span></span><span style="display:flex;"><span>foo.example.com.        A      192.0.2.23
</span></span></code></pre></td></tr></table>
</div>
</div><p>当用户查询 <code>bar.example.com</code> 的时候，DNS Server 实际返回的是 <code>foo.example.com</code> 的 IP 地址。</p>
<h1 id="tcp-和-udp">TCP 和 UDP<a hidden class="anchor" aria-hidden="true" href="#tcp-和-udp">#</a></h1>
<h2 id="tcp-与-udp-的区别重要">TCP 与 UDP 的区别（重要）<a hidden class="anchor" aria-hidden="true" href="#tcp-与-udp-的区别重要">#</a></h2>
<ol>
<li><strong>是否面向连接</strong>：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li>
<li><strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li>
<li><strong>是否有状态</strong>：这个和上面的“是否可靠传输”相对应。TCP 传输是有状态的，这个有状态说的是 TCP 会去记录自己发送消息的状态比如消息是否发送了、是否被接收了等等。为此 ，TCP 需要维持复杂的连接状态表。而 UDP 是无状态服务，简单来说就是不管发出去之后的事情了（<strong>这很渣男！</strong>）。</li>
<li><strong>传输效率</strong>：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li>
<li><strong>传输形式</strong>：TCP 是面向字节流的，UDP 是面向报文的。</li>
<li><strong>首部开销</strong>：TCP 首部开销（20 ～ 60 字节）比 UDP 首部开销（8 字节）要大。</li>
<li><strong>是否提供广播或多播服务</strong>：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；</li>
<li>&hellip;&hellip;</li>
</ol>
<table>
<thead>
<tr>
<th></th>
<th>TCP</th>
<th>UDP</th>
</tr>
</thead>
<tbody>
<tr>
<td>是否面向连接</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否可靠</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>是否有状态</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>传输效率</td>
<td>较慢</td>
<td>较快</td>
</tr>
<tr>
<td>传输形式</td>
<td>字节流</td>
<td>数据报文段</td>
</tr>
<tr>
<td>首部开销</td>
<td>20 ～ 60 bytes</td>
<td>8 bytes</td>
</tr>
<tr>
<td>是否提供广播或多播服务</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<h2 id="什么时候选择-tcp什么时候选-udp">什么时候选择 TCP，什么时候选 UDP?<a hidden class="anchor" aria-hidden="true" href="#什么时候选择-tcp什么时候选-udp">#</a></h2>
<ul>
<li><strong>UDP 一般用于即时通信</strong>，比如：语音、 视频、直播等等。这些场景对传输数据的准确性要求不是特别高，比如你看视频即使少个一两帧，实际给人的感觉区别也不大。</li>
<li><strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</li>
</ul>
<h2 id="http-基于-tcp-还是-udp">HTTP 基于 TCP 还是 UDP？<a hidden class="anchor" aria-hidden="true" href="#http-基于-tcp-还是-udp">#</a></h2>
<p><del><strong>HTTP 协议是基于 TCP 协议的</strong>，所以发送 HTTP 请求之前首先要建立 TCP 连接也就是要经历 3 次握手。</del></p>
<p>🐛 修正（参见 <a href="https://github.com/Snailclimb/JavaGuide/issues/1915">issue#1915</a>）：</p>
<p>HTTP/3.0 之前是基于 TCP 协议的，而 HTTP/3.0 将弃用 TCP，改用 <strong>基于 UDP 的 QUIC 协议</strong> 。</p>
<p>此变化解决了 HTTP/2 中存在的队头阻塞问题。队头阻塞是指在 HTTP/2.0 中，多个 HTTP 请求和响应共享一个 TCP 连接，如果其中一个请求或响应因为网络拥塞或丢包而被阻塞，那么后续的请求或响应也无法发送，导致整个连接的效率降低。这是由于 HTTP/2.0 在单个 TCP 连接上使用了多路复用，受到 TCP 拥塞控制的影响，少量的丢包就可能导致整个 TCP 连接上的所有流被阻塞。HTTP/3.0 在一定程度上解决了队头阻塞问题，一个连接建立多个不同的数据流，这些数据流之间独立互不影响，某个数据流发生丢包了，其数据流不受影响（本质上是多路复用+轮询）。</p>
<p>除了解决队头阻塞问题，HTTP/3.0 还可以减少握手过程的延迟。在 HTTP/2.0 中，如果要建立一个安全的 HTTPS 连接，需要经过 TCP 三次握手和 TLS 握手：</p>
<ol>
<li>TCP 三次握手：客户端和服务器交换 SYN 和 ACK 包，建立一个 TCP 连接。这个过程需要 1.5 个 RTT（round-trip time），即一个数据包从发送到接收的时间。</li>
<li>TLS 握手：客户端和服务器交换密钥和证书，建立一个 TLS 加密层。这个过程需要至少 1 个 RTT（TLS 1.3）或者 2 个 RTT（TLS 1.2）。</li>
</ol>
<p>所以，HTTP/2.0 的连接建立就至少需要 2.5 个 RTT（TLS 1.3）或者 3.5 个 RTT（TLS 1.2）。而在 HTTP/3.0 中，使用的 QUIC 协议（TLS 1.3，TLS 1.3 除了支持 1 个 RTT 的握手，还支持 0 个 RTT 的握手）连接建立仅需 0-RTT 或者 1-RTT。这意味着 QUIC 在最佳情况下不需要任何的额外往返时间就可以建立新连接。</p>
<p>相关证明可以参考下面这两个链接：</p>
<ul>
<li><a href="https://zh.wikipedia.org/zh/HTTP/3">https://zh.wikipedia.org/zh/HTTP/3</a></li>
<li><a href="https://datatracker.ietf.org/doc/rfc9114/">https://datatracker.ietf.org/doc/rfc9114/</a></li>
</ul>
<h2 id="使用-tcp-的协议有哪些使用-udp-的协议有哪些">使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?<a hidden class="anchor" aria-hidden="true" href="#使用-tcp-的协议有哪些使用-udp-的协议有哪些">#</a></h2>
<p><strong>运行于 TCP 协议之上的协议</strong>：</p>
<ol>
<li><strong>HTTP 协议</strong>：超文本传输协议（HTTP，HyperText Transfer Protocol)是一种用于传输超文本和多媒体内容的协议，主要是为 Web 浏览器与 Web 服务器之间的通信而设计的。当我们使用浏览器浏览网页的时候，我们网页就是通过 HTTP 请求进行加载的。</li>
<li><strong>HTTPS 协议</strong>：更安全的超文本传输协议(HTTPS,Hypertext Transfer Protocol Secure)，身披 SSL 外衣的 HTTP 协议</li>
<li><strong>FTP 协议</strong>：文件传输协议 FTP（File Transfer Protocol）是一种用于在计算机之间传输文件的协议，可以屏蔽操作系统和文件存储方式。注意 ⚠️：FTP 是一种不安全的协议，因为它在传输过程中不会对数据进行加密。建议在传输敏感数据时使用更安全的协议，如 SFTP。</li>
<li><strong>SMTP 协议</strong>：简单邮件传输协议（SMTP，Simple Mail Transfer Protocol）的缩写，是一种用于发送电子邮件的协议。注意 ⚠️：SMTP 协议只负责邮件的发送，而不是接收。要从邮件服务器接收邮件，需要使用 POP3 或 IMAP 协议。</li>
<li><strong>POP3/IMAP 协议</strong>：两者都是负责邮件接收的协议。IMAP 协议是比 POP3 更新的协议，它在功能和性能上都更加强大。IMAP 支持邮件搜索、标记、分类、归档等高级功能，而且可以在多个设备之间同步邮件状态。几乎所有现代电子邮件客户端和服务器都支持 IMAP。</li>
<li><strong>Telnet 协议</strong>：用于通过一个终端登陆到其他服务器。Telnet 协议的最大缺点之一是所有数据（包括用户名和密码）均以明文形式发送，这有潜在的安全风险。这就是为什么如今很少使用 Telnet，而是使用一种称为 SSH 的非常安全的网络传输协议的主要原因。</li>
<li><strong>SSH 协议</strong> : SSH（ Secure Shell）是目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。利用 SSH 协议可以有效防止远程管理过程中的信息泄露问题。SSH 建立在可靠的传输协议 TCP 之上。</li>
<li>&hellip;&hellip;</li>
</ol>
<p><strong>运行于 UDP 协议之上的协议</strong>：</p>
<ol>
<li><strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址</li>
<li><strong>DNS</strong>：<strong>域名系统（DNS，Domain Name System）将人类可读的域名 (例如，www.baidu.com) 转换为机器可读的 IP 地址 (例如，220.181.38.148)。</strong> 我们可以将其理解为专为互联网设计的电话薄。实际上 DNS 同时支持 UDP 和 TCP 协议。</li>
<li>&hellip;&hellip;</li>
</ol>
<h2 id="tcp-三次握手和四次挥手传输层">TCP 三次握手和四次挥手（传输层）<a hidden class="anchor" aria-hidden="true" href="#tcp-三次握手和四次挥手传输层">#</a></h2>
<h3 id="建立连接-tcp-三次握手">建立连接-TCP 三次握手<a hidden class="anchor" aria-hidden="true" href="#建立连接-tcp-三次握手">#</a></h3>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/tcp-shakes-hands-three-times.png"></p>
<p>建立一个 TCP 连接需要“三次握手”，缺一不可：</p>
<ul>
<li><strong>一次握手</strong>:客户端发送带有 SYN（SEQ=x） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li>
<li><strong>二次握手</strong>:服务端发送带有 SYN+ACK(SEQ=y,ACK=x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li>
<li><strong>三次握手</strong>:客户端发送带有 ACK(ACK=y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成 TCP 三次握手。</li>
</ul>
<p>当建立了 3 次握手之后，客户端和服务端就可以传输数据啦！</p>
<h3 id="为什么要三次握手">为什么要三次握手?<a hidden class="anchor" aria-hidden="true" href="#为什么要三次握手">#</a></h3>
<p>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</p>
<ol>
<li><strong>第一次握手</strong>：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li><strong>第二次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li><strong>第三次握手</strong>：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ol>
<p>三次握手就能确认双方收发功能都正常，缺一不可。</p>
<p>更详细的解答可以看这个：<a href="https://www.zhihu.com/question/24853633/answer/115173386">TCP 为什么是三次握手，而不是两次或四次？ - 车小胖的回答 - 知乎</a></p>
<h3 id="第-2-次握手传回了-ack为什么还要传回-syn">第 2 次握手传回了 ACK，为什么还要传回 SYN？<a hidden class="anchor" aria-hidden="true" href="#第-2-次握手传回了-ack为什么还要传回-syn">#</a></h3>
<p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。</p>
<blockquote>
<p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p>
</blockquote>
<h3 id="断开连接-tcp-四次挥手">断开连接-TCP 四次挥手<a hidden class="anchor" aria-hidden="true" href="#断开连接-tcp-四次挥手">#</a></h3>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/tcp-waves-four-times.png"></p>
<p>断开一个 TCP 连接则需要“四次挥手”，缺一不可：</p>
<ol>
<li><strong>第一次挥手</strong>：客户端发送一个 FIN（SEQ=x） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>
<li><strong>第二次挥手</strong>：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （ACK=x+1）标志的数据包-&gt;客户端 。然后，此时服务端进入 <strong>CLOSE-WAIT</strong> 状态，客户端进入 <strong>FIN-WAIT-2</strong> 状态。</li>
<li><strong>第三次挥手</strong>：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入 <strong>LAST-ACK</strong> 状态。</li>
<li><strong>第四次挥手</strong>：客户端发送 ACK (ACK=y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。</li>
</ol>
<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>
<h3 id="为什么要四次挥手">为什么要四次挥手？<a hidden class="anchor" aria-hidden="true" href="#为什么要四次挥手">#</a></h3>
<p>TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后。</p>
<ol>
<li><strong>第一次挥手</strong>：A 说“我没啥要说的了”</li>
<li><strong>第二次挥手</strong>：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li>
<li><strong>第三次挥手</strong>：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li>
<li><strong>第四次挥手</strong>：A 回答“知道了”，这样通话才算结束。</li>
</ol>
<h3 id="为什么不能把服务器发送的-ack-和-fin-合并起来变成三次挥手">为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？<a hidden class="anchor" aria-hidden="true" href="#为什么不能把服务器发送的-ack-和-fin-合并起来变成三次挥手">#</a></h3>
<p>因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p>
<h3 id="如果第二次挥手时服务器的-ack-没有送达客户端会怎样">如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？<a hidden class="anchor" aria-hidden="true" href="#如果第二次挥手时服务器的-ack-没有送达客户端会怎样">#</a></h3>
<p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>
<h3 id="为什么第四次挥手客户端需要等待-2msl报文段最长寿命时间后才进入-closed-状态">为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？<a hidden class="anchor" aria-hidden="true" href="#为什么第四次挥手客户端需要等待-2msl报文段最长寿命时间后才进入-closed-状态">#</a></h3>
<p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>
<blockquote>
<p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p>
</blockquote>
<h2 id="tcp-传输可靠性保障传输层">TCP 传输可靠性保障（传输层）<a hidden class="anchor" aria-hidden="true" href="#tcp-传输可靠性保障传输层">#</a></h2>
<h3 id="tcp-如何保证传输的可靠性">TCP 如何保证传输的可靠性？<a hidden class="anchor" aria-hidden="true" href="#tcp-如何保证传输的可靠性">#</a></h3>
<ol>
<li><strong>基于数据块传输</strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li>
<li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li>
<li><strong>校验和</strong> : TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li><strong>超时重传</strong> : 当发送方发送数据之后，它启动一个定时器，等待目的端确认收到这个报文段。接收端实体对已成功收到的包发回一个相应的确认信息（ACK）。如果发送端实体在合理的往返时延（RTT）内未收到确认消息，那么对应的数据包就被假设为<a href="https://zh.wikipedia.org/wiki/%E4%B8%A2%E5%8C%85">已丢失</a>并进行重传。</li>
<li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</li>
<li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</li>
</ol>
<h3 id="tcp-如何实现流量控制">TCP 如何实现流量控制？<a hidden class="anchor" aria-hidden="true" href="#tcp-如何实现流量控制">#</a></h3>
<p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>
<p><strong>为什么需要流量控制?</strong> 这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p>
<p>这里需要注意的是（常见误区）：</p>
<ul>
<li>发送端不等同于客户端</li>
<li>接收端不等同于服务端</li>
</ul>
<p>TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是服务端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP 传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同</p>
<p><strong>TCP 发送窗口可以划分成四个部分</strong>：</p>
<ol>
<li>已经发送并且确认的 TCP 段（已经发送并确认）；</li>
<li>已经发送但是没有确认的 TCP 段（已经发送未确认）；</li>
<li>未发送但是接收方准备接收的 TCP 段（可以发送）；</li>
<li>未发送并且接收方也并未准备接受的 TCP 段（不可发送）。</li>
</ol>
<p><strong>TCP 发送窗口结构图示</strong>：</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/tcp-send-window.png"></p>
<ul>
<li><strong>SND.WND</strong>：发送窗口。</li>
<li><strong>SND.UNA</strong>：Send Unacknowledged 指针，指向发送窗口的第一个字节。</li>
<li><strong>SND.NXT</strong>：Send Next 指针，指向可用窗口的第一个字节。</li>
</ul>
<p><strong>可用窗口大小</strong> = <code>SND.UNA + SND.WND - SND.NXT</code> 。</p>
<p><strong>TCP 接收窗口可以划分成三个部分</strong>：</p>
<ol>
<li>已经接收并且已经确认的 TCP 段（已经接收并确认）；</li>
<li>等待接收且允许发送方发送 TCP 段（可以接收未确认）；</li>
<li>不可接收且不允许发送方发送 TCP 段（不可接收）。</li>
</ol>
<p><strong>TCP 接收窗口结构图示</strong>：</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/tcp-receive-window.png"></p>
<p><strong>接收窗口的大小是根据接收端处理数据的速度动态调整的。</strong> 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。</p>
<p>另外，这里的滑动窗口大小只是为了演示使用，实际窗口大小通常会远远大于这个值。</p>
<h3 id="tcp-的拥塞控制是怎么实现的">TCP 的拥塞控制是怎么实现的？<a hidden class="anchor" aria-hidden="true" href="#tcp-的拥塞控制是怎么实现的">#</a></h3>
<p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/tcp-congestion-control.png"></p>
<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong>、 <strong>拥塞避免</strong>、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>
<ul>
<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>
<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.</li>
<li><strong>快重传与快恢复：</strong> 在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>
</ul>
<h3 id="arq-协议了解吗">ARQ 协议了解吗?<a hidden class="anchor" aria-hidden="true" href="#arq-协议了解吗">#</a></h3>
<p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息（Acknowledgements，就是我们常说的 ACK），它通常会重新发送，直到收到确认或者重试超过一定的次数。</p>
<p>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p>
<h4 id="停止等待-arq-协议">停止等待 ARQ 协议<a hidden class="anchor" aria-hidden="true" href="#停止等待-arq-协议">#</a></h4>
<p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p><strong>1) 无差错情况:</strong></p>
<p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p>
<p><strong>2) 出现差错情况（超时重传）:</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<p><strong>3) 确认丢失和确认迟到</strong></p>
<ul>
<li><strong>确认丢失</strong>：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</li>
<li><strong>确认迟到</strong>：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li>
</ul>
<h4 id="连续-arq-协议">连续 ARQ 协议<a hidden class="anchor" aria-hidden="true" href="#连续-arq-协议">#</a></h4>
<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p>
<p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p>
<h1 id="ip">IP<a hidden class="anchor" aria-hidden="true" href="#ip">#</a></h1>
<h2 id="ip-协议的作用是什么">IP 协议的作用是什么？<a hidden class="anchor" aria-hidden="true" href="#ip-协议的作用是什么">#</a></h2>
<p><strong>IP（Internet Protocol，网际协议）</strong> 是 TCP/IP 协议中最重要的协议之一，属于网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。</p>
<p>目前 IP 协议主要分为两种，一种是过去的 IPv4，另一种是较新的 IPv6，目前这两种协议都在使用，但后者已经被提议来取代前者。</p>
<h2 id="什么是-ip-地址ip-寻址如何工作">什么是 IP 地址？IP 寻址如何工作？<a hidden class="anchor" aria-hidden="true" href="#什么是-ip-地址ip-寻址如何工作">#</a></h2>
<p>每个连入互联网的设备或域（如计算机、服务器、路由器等）都被分配一个 <strong>IP 地址（Internet Protocol address）</strong>，作为唯一标识符。每个 IP 地址都是一个字符序列，如 192.168.1.1（IPv4）、2001:0db8:85a3:0000:0000:8a2e:0370:7334（IPv6） 。</p>
<p>当网络设备发送 IP 数据包时，数据包中包含了 <strong>源 IP 地址</strong> 和 <strong>目的 IP 地址</strong> 。源 IP 地址用于标识数据包的发送方设备或域，而目的 IP 地址则用于标识数据包的接收方设备或域。这类似于一封邮件中同时包含了目的地地址和回邮地址。</p>
<p>网络设备根据目的 IP 地址来判断数据包的目的地，并将数据包转发到正确的目的地网络或子网络，从而实现了设备间的通信。</p>
<p>这种基于 IP 地址的寻址方式是互联网通信的基础，它允许数据包在不同的网络之间传递，从而实现了全球范围内的网络互联互通。IP 地址的唯一性和全局性保证了网络中的每个设备都可以通过其独特的 IP 地址进行标识和寻址。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/internet_protocol_ip_address_diagram.png"></p>
<h2 id="什么是-ip-地址过滤">什么是 IP 地址过滤？<a hidden class="anchor" aria-hidden="true" href="#什么是-ip-地址过滤">#</a></h2>
<p><strong>IP 地址过滤（IP Address Filtering）</strong> 简单来说就是限制或阻止特定 IP 地址或 IP 地址范围的访问。例如，你有一个图片服务突然被某一个 IP 地址攻击，那我们就可以禁止这个 IP 地址访问图片服务。</p>
<p>IP 地址过滤是一种简单的网络安全措施，实际应用中一般会结合其他网络安全措施，如认证、授权、加密等一起使用。单独使用 IP 地址过滤并不能完全保证网络的安全。</p>
<h2 id="ipv4-和-ipv6-有什么区别">IPv4 和 IPv6 有什么区别？<a hidden class="anchor" aria-hidden="true" href="#ipv4-和-ipv6-有什么区别">#</a></h2>
<p><strong>IPv4（Internet Protocol version 4）</strong> 是目前广泛使用的 IP 地址版本，其格式是四组由点分隔的数字，例如：123.89.46.72。IPv4 使用 32 位地址作为其 Internet 地址，这意味着共有约 42 亿（ 2^32）个可用 IP 地址。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/Figure-1-IPv4Addressformatwithdotteddecimalnotation-29c824f6a451d48d8c27759799f0c995.png"></p>
<p>这么少当然不够用啦！为了解决 IP 地址耗尽的问题，最根本的办法是采用具有更大地址空间的新版本 IP 协议 - <strong>IPv6（Internet Protocol version 6）</strong>。IPv6 地址使用更复杂的格式，该格式使用由单或双冒号分隔的一组数字和字母，例如：2001:0db8:85a3:0000:0000:8a2e:0370:7334 。IPv6 使用 128 位互联网地址，这意味着越有 2^128（3 开头的 39 位数字，恐怖如斯） 个可用 IP 地址。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/Figure-2-IPv6Addressformatwithhexadecimalnotation.png"></p>
<p>除了更大的地址空间之外，IPv6 的优势还包括：</p>
<ul>
<li><strong>无状态地址自动配置（Stateless Address Autoconfiguration，简称 SLAAC）</strong>：主机可以直接通过根据接口标识和网络前缀生成全局唯一的 IPv6 地址，而无需依赖 DHCP（Dynamic Host Configuration Protocol）服务器，简化了网络配置和管理。</li>
<li><strong>NAT（Network Address Translation，网络地址转换） 成为可选项</strong>：IPv6 地址资源充足，可以给全球每个设备一个独立的地址。</li>
<li><strong>对标头结构进行了改进</strong>：IPv6 标头结构相较于 IPv4 更加简化和高效，减少了处理开销，提高了网络性能。</li>
<li><strong>可选的扩展头</strong>：允许在 IPv6 标头中添加不同的扩展头（Extension Headers），用于实现不同类型的功能和选项。</li>
<li><strong>ICMPv6（Internet Control Message Protocol for IPv6）</strong>：IPv6 中的 ICMPv6 相较于 IPv4 中的 ICMP 有了一些改进，如邻居发现、路径 MTU 发现等功能的改进，从而提升了网络的可靠性和性能。</li>
</ul>
<h2 id="nat-的作用是什么">NAT 的作用是什么？<a hidden class="anchor" aria-hidden="true" href="#nat-的作用是什么">#</a></h2>
<p><strong>NAT（Network Address Translation，网络地址转换）</strong> 主要用于在不同网络之间转换 IP 地址。它允许将私有 IP 地址（如在局域网中使用的 IP 地址）映射为公有 IP 地址（在互联网中使用的 IP 地址）或者反向映射，从而实现局域网内的多个设备通过单一公有 IP 地址访问互联网。</p>
<p>NAT 不光可以缓解 IPv4 地址资源短缺的问题，还可以隐藏内部网络的实际拓扑结构，使得外部网络无法直接访问内部网络中的设备，从而提高了内部网络的安全性。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/network-address-translation.png"></p>
<h3 id="应用场景">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景">#</a></h3>
<p><strong>NAT 协议（Network Address Translation）</strong> 的应用场景如同它的名称——网络地址转换，应用于内部网到外部网的地址转换过程中。具体地说，在一个小的子网（局域网，Local Area Network，LAN）内，各主机使用的是同一个 LAN 下的 IP 地址，但在该 LAN 以外，在广域网（Wide Area Network，WAN）中，需要一个统一的 IP 地址来标识该 LAN 在整个 Internet 上的位置。</p>
<p>这个场景其实不难理解。随着一个个小型办公室、家庭办公室（Small Office, Home Office, SOHO）的出现，为了管理这些 SOHO，一个个子网被设计出来，从而在整个 Internet 中的主机数量将非常庞大。如果每个主机都有一个“绝对唯一”的 IP 地址，那么 IPv4 地址的表达能力可能很快达到上限（$2^{32}$）。因此，实际上，SOHO 子网中的 IP 地址是“相对的”，这在一定程度上也缓解了 IPv4 地址的分配压力。</p>
<p>SOHO 子网的“代理人”，也就是和外界的窗口，通常由路由器扮演。路由器的 LAN 一侧管理着一个小子网，而它的 WAN 接口才是真正参与到 Internet 中的接口，也就有一个“绝对唯一的地址”。NAT 协议，正是在 LAN 中的主机在与 LAN 外界通信时，起到了地址转换的关键作用。</p>
<h3 id="细节">细节<a hidden class="anchor" aria-hidden="true" href="#细节">#</a></h3>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/nat-demo.png"></p>
<p>假设当前场景如上图。中间是一个路由器，它的右侧组织了一个 LAN，网络号为<code>10.0.0/24</code>。LAN 侧接口的 IP 地址为<code>10.0.0.4</code>，并且该子网内有至少三台主机，分别是<code>10.0.0.1</code>，<code>10.0.0.2</code>和<code>10.0.0.3</code>。路由器的左侧连接的是 WAN，WAN 侧接口的 IP 地址为<code>138.76.29.7</code>。</p>
<p>首先，针对以上信息，我们有如下事实需要说明：</p>
<ol>
<li>路由器的右侧子网的网络号为<code>10.0.0/24</code>，主机号为<code>10.0.0/8</code>，三台主机地址，以及路由器的 LAN 侧接口地址，均由 DHCP 协议规定。而且，该 DHCP 运行在路由器内部（路由器自维护一个小 DHCP 服务器），从而为子网内提供 DHCP 服务。</li>
<li>路由器的 WAN 侧接口地址同样由 DHCP 协议规定，但该地址是路由器从 ISP（网络服务提供商）处获得，也就是该 DHCP 通常运行在路由器所在区域的 DHCP 服务器上。</li>
</ol>
<p>现在，路由器内部还运行着 NAT 协议，从而为 LAN-WAN 间通信提供地址转换服务。为此，一个很重要的结构是 <strong>NAT 转换表</strong>。为了说明 NAT 的运行细节，假设有以下请求发生：</p>
<ol>
<li>主机<code>10.0.0.1</code>向 IP 地址为<code>128.119.40.186</code>的 Web 服务器（端口 80）发送了 HTTP 请求（如请求页面）。此时，主机<code>10.0.0.1</code>将随机指派一个端口，如<code>3345</code>，作为本次请求的源端口号，将该请求发送到路由器中（目的地址将是<code>128.119.40.186</code>，但会先到达<code>10.0.0.4</code>）。</li>
<li><code>10.0.0.4</code>即路由器的 LAN 接口收到<code>10.0.0.1</code>的请求。路由器将为该请求指派一个新的源端口号，如<code>5001</code>，并将请求报文发送给 WAN 接口<code>138.76.29.7</code>。同时，在 NAT 转换表中记录一条转换记录<strong>138.76.29.7:5001——10.0.0.1:3345</strong>。</li>
<li>请求报文到达 WAN 接口，继续向目的主机<code>128.119.40.186</code>发送。</li>
</ol>
<p>之后，将会有如下响应发生：</p>
<ol>
<li>主机<code>128.119.40.186</code>收到请求，构造响应报文，并将其发送给目的地<code>138.76.29.7:5001</code>。</li>
<li>响应报文到达路由器的 WAN 接口。路由器查询 NAT 转换表，发现<code>138.76.29.7:5001</code>在转换表中有记录，从而将其目的地址和目的端口转换成为<code>10.0.0.1:3345</code>，再发送到<code>10.0.0.4</code>上。</li>
<li>被转换的响应报文到达路由器的 LAN 接口，继而被转发至目的地<code>10.0.0.1</code>。</li>
</ol>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/nat-demo2.png"></p>
<p>修正（参见：<a href="https://github.com/Snailclimb/JavaGuide/issues/2009">issue#2009</a>）：上图第四步的 Dest 值应该为 <code>10.0.0.1:3345</code> 而不是~~<code>138.76.29.7:5001</code>~~，这里笔误了。</p>
<h3 id="划重点">划重点<a hidden class="anchor" aria-hidden="true" href="#划重点">#</a></h3>
<p>针对以上过程，有以下几个重点需要强调：</p>
<ol>
<li>当请求报文到达路由器，并被指定了新端口号时，由于端口号有 16 位，因此，通常来说，一个路由器管理的 LAN 中的最大主机数 $≈65500$（$2^{16}$ 的地址空间），但通常 SOHO 子网内不会有如此多的主机数量。</li>
<li>对于目的服务器来说，从来不知道“到底是哪个主机给我发送的请求”，它只知道是来自<code>138.76.29.7:5001</code>的路由器转发的请求。因此，可以说，**路由器在 WAN 和 LAN 之间起到了屏蔽作用，**所有内部主机发送到外部的报文，都具有同一个 IP 地址（不同的端口号），所有外部发送到内部的报文，也都只有一个目的地（不同端口号），是经过了 NAT 转换后，外部报文才得以正确地送达内部主机。</li>
<li>在报文穿过路由器，发生 NAT 转换时，如果 LAN 主机 IP 已经在 NAT 转换表中注册过了，则不需要路由器新指派端口，而是直接按照转换记录穿过路由器。同理，外部报文发送至内部时也如此。</li>
</ol>
<p>总结 NAT 协议的特点，有以下几点：</p>
<ol>
<li>NAT 协议通过对 WAN 屏蔽 LAN，有效地缓解了 IPv4 地址分配压力。</li>
<li>LAN 主机 IP 地址的变更，无需通告 WAN。</li>
<li>WAN 的 ISP 变更接口地址时，无需通告 LAN 内主机。</li>
<li>LAN 主机对 WAN 不可见，不可直接寻址，可以保证一定程度的安全性。</li>
</ol>
<p>然而，NAT 协议由于其独特性，存在着一些争议。比如，可能你已经注意到了，**NAT 协议在 LAN 以外，标识一个内部主机时，使用的是端口号，因为 IP 地址都是相同的。**这种将端口号作为主机寻址的行为，可能会引发一些误会。此外，路由器作为网络层的设备，修改了传输层的分组内容（修改了源 IP 地址和端口号），同样是不规范的行为。但是，尽管如此，NAT 协议作为 IPv4 时代的产物，极大地方便了一些本来棘手的问题，一直被沿用至今。</p>
<h1 id="arp">ARP<a hidden class="anchor" aria-hidden="true" href="#arp">#</a></h1>
<p>每当我们学习一个新的网络协议的时候，都要把他结合到 OSI 七层模型中，或者是 TCP/IP 协议栈中来学习，一是要学习该协议在整个网络协议栈中的位置，二是要学习该协议解决了什么问题，地位如何？三是要学习该协议的工作原理，以及一些更深入的细节。</p>
<p><strong>ARP 协议</strong>，可以说是在协议栈中属于一个<strong>偏底层的、非常重要的、又非常简单的</strong>通信协议。</p>
<p>开始阅读这篇文章之前，你可以先看看下面几个问题：</p>
<ol>
<li><strong>ARP 协议在协议栈中的位置？</strong> ARP 协议在协议栈中的位置非常重要，在理解了它的工作原理之后，也很难说它到底是网络层协议，还是链路层协议，因为它恰恰串联起了网络层和链路层。国外的大部分教程通常将 ARP 协议放在网络层。</li>
<li><strong>ARP 协议解决了什么问题，地位如何？</strong> ARP 协议，全称 <strong>地址解析协议（Address Resolution Protocol）</strong>，它解决的是网络层地址和链路层地址之间的转换问题。因为一个 IP 数据报在物理上传输的过程中，总是需要知道下一跳（物理上的下一个目的地）该去往何处，但 IP 地址属于逻辑地址，而 MAC 地址才是物理地址，ARP 协议解决了 IP 地址转 MAC 地址的一些问题。</li>
<li><strong>ARP 工作原理？</strong> 只希望大家记住几个关键词：<strong>ARP 表、广播问询、单播响应</strong>。</li>
</ol>
<h2 id="什么是-mac-地址">什么是 Mac 地址？<a hidden class="anchor" aria-hidden="true" href="#什么是-mac-地址">#</a></h2>
<p>MAC 地址的全称是 <strong>媒体访问控制地址（Media Access Control Address）</strong>。如果说，互联网中每一个资源都由 IP 地址唯一标识（IP 协议内容），那么一切网络设备都由 MAC 地址唯一标识。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/mac%E5%9C%B0%E5%9D%80.png"></p>
<p>可以理解为，MAC 地址是一个网络设备真正的身份证号，IP 地址只是一种不重复的定位方式（比如说住在某省某市某街道的张三，这种逻辑定位是 IP 地址，他的身份证号才是他的 MAC 地址），也可以理解为 MAC 地址是身份证号，IP 地址是邮政地址。MAC 地址也有一些别称，如 LAN 地址、物理地址、以太网地址等。</p>
<blockquote>
<p>还有一点要知道的是，不仅仅是网络资源才有 IP 地址，网络设备也有 IP 地址，比如路由器。但从结构上说，路由器等网络设备的作用是组成一个网络，而且通常是内网，所以它们使用的 IP 地址通常是内网 IP，内网的设备在与内网以外的设备进行通信时，需要用到 NAT 协议。</p>
</blockquote>
<p>MAC 地址的长度为 6 字节（48 比特），地址空间大小有 280 万亿之多（$2^{48}$），MAC 地址由 IEEE 统一管理与分配，理论上，一个网络设备中的网卡上的 MAC 地址是永久的。不同的网卡生产商从 IEEE 那里购买自己的 MAC 地址空间（MAC 的前 24 比特），也就是前 24 比特由 IEEE 统一管理，保证不会重复。而后 24 比特，由各家生产商自己管理，同样保证生产的两块网卡的 MAC 地址不会重复。</p>
<p>MAC 地址具有可携带性、永久性，身份证号永久地标识一个人的身份，不论他到哪里都不会改变。而 IP 地址不具有这些性质，当一台设备更换了网络，它的 IP 地址也就可能发生改变，也就是它在互联网中的定位发生了变化。</p>
<p>最后，记住，MAC 地址有一个特殊地址：FF-FF-FF-FF-FF-FF（全 1 地址），该地址表示广播地址。</p>
<h2 id="arp-协议工作原理">ARP 协议工作原理<a hidden class="anchor" aria-hidden="true" href="#arp-协议工作原理">#</a></h2>
<p>ARP 协议工作时有一个大前提，那就是 <strong>ARP 表</strong>。</p>
<p>在一个局域网内，每个网络设备都自己维护了一个 ARP 表，ARP 表记录了某些其他网络设备的 IP 地址-MAC 地址映射关系，该映射关系以 <code>&lt;IP, MAC, TTL&gt;</code> 三元组的形式存储。其中，TTL 为该映射关系的生存周期，典型值为 20 分钟，超过该时间，该条目将被丢弃。</p>
<p>ARP 的工作原理将分两种场景讨论：</p>
<ol>
<li><strong>同一局域网内的 MAC 寻址</strong>；</li>
<li><strong>从一个局域网到另一个局域网中的网络设备的寻址</strong>。</li>
</ol>
<h3 id="同一局域网内的-mac-寻址">同一局域网内的 MAC 寻址<a hidden class="anchor" aria-hidden="true" href="#同一局域网内的-mac-寻址">#</a></h3>
<p>假设当前有如下场景：IP 地址为<code>137.196.7.23</code>的主机 A，想要给同一局域网内的 IP 地址为<code>137.196.7.14</code>主机 B，发送 IP 数据报文。</p>
<blockquote>
<p>再次强调，当主机发送 IP 数据报文时（网络层），仅知道目的地的 IP 地址，并不清楚目的地的 MAC 地址，而 ARP 协议就是解决这一问题的。</p>
</blockquote>
<p>为了达成这一目标，主机 A 将不得不通过 ARP 协议来获取主机 B 的 MAC 地址，并将 IP 报文封装成链路层帧，发送到下一跳上。在该局域网内，关于此将按照时间顺序，依次发生如下事件：</p>
<ol>
<li>
<p>主机 A 检索自己的 ARP 表，发现 ARP 表中并无主机 B 的 IP 地址对应的映射条目，也就无从知道主机 B 的 MAC 地址。</p>
</li>
<li>
<p>主机 A 将构造一个 ARP 查询分组，并将其广播到所在的局域网中。</p>
<p>ARP 分组是一种特殊报文，ARP 分组有两类，一种是查询分组，另一种是响应分组，它们具有相同的格式，均包含了发送和接收的 IP 地址、发送和接收的 MAC 地址。当然了，查询分组中，发送的 IP 地址，即为主机 A 的 IP 地址，接收的 IP 地址即为主机 B 的 IP 地址，发送的 MAC 地址也是主机 A 的 MAC 地址，但接收的 MAC 地址绝不会是主机 B 的 MAC 地址（因为这正是我们要问询的！），而是一个特殊值——<code>FF-FF-FF-FF-FF-FF</code>，之前说过，该 MAC 地址是广播地址，也就是说，查询分组将广播给该局域网内的所有设备。</p>
</li>
<li>
<p>主机 A 构造的查询分组将在该局域网内广播，理论上，每一个设备都会收到该分组，并检查查询分组的接收 IP 地址是否为自己的 IP 地址，如果是，说明查询分组已经到达了主机 B，否则，该查询分组对当前设备无效，丢弃之。</p>
</li>
<li>
<p>主机 B 收到了查询分组之后，验证是对自己的问询，接着构造一个 ARP 响应分组，该分组的目的地只有一个——主机 A，发送给主机 A。同时，主机 B 提取查询分组中的 IP 地址和 MAC 地址信息，在自己的 ARP 表中构造一条主机 A 的 IP-MAC 映射记录。</p>
<p>ARP 响应分组具有和 ARP 查询分组相同的构造，不同的是，发送和接受的 IP 地址恰恰相反，发送的 MAC 地址为发送者本身，目标 MAC 地址为查询分组的发送者，也就是说，ARP 响应分组只有一个目的地，而非广播。</p>
</li>
<li>
<p>主机 A 终将收到主机 B 的响应分组，提取出该分组中的 IP 地址和 MAC 地址后，构造映射信息，加入到自己的 ARP 表中。</p>
</li>
</ol>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/arp_same_lan-008bdaef.png"></p>
<p>在整个过程中，有几点需要补充说明的是：</p>
<ol>
<li>主机 A 想要给主机 B 发送 IP 数据报，如果主机 B 的 IP-MAC 映射信息已经存在于主机 A 的 ARP 表中，那么主机 A 无需广播，只需提取 MAC 地址并构造链路层帧发送即可。</li>
<li>ARP 表中的映射信息是有生存周期的，典型值为 20 分钟。</li>
<li>目标主机接收到了问询主机构造的问询报文后，将先把问询主机的 IP-MAC 映射存进自己的 ARP 表中，这样才能获取到响应的目标 MAC 地址，顺利的发送响应分组。</li>
</ol>
<p>总结来说，ARP 协议是一个<strong>广播问询，单播响应</strong>协议。</p>
<h3 id="不同局域网内的-mac-寻址">不同局域网内的 MAC 寻址<a hidden class="anchor" aria-hidden="true" href="#不同局域网内的-mac-寻址">#</a></h3>
<p>更复杂的情况是，发送主机 A 和接收主机 B 不在同一个子网中，假设一个一般场景，两台主机所在的子网由一台路由器联通。这里需要注意的是，一般情况下，我们说网络设备都有一个 IP 地址和一个 MAC 地址，这里说的网络设备，更严谨的说法应该是一个接口。路由器作为互联设备，具有多个接口，每个接口同样也应该具备不重复的 IP 地址和 MAC 地址。因此，在讨论 ARP 表时，路由器的多个接口都各自维护一个 ARP 表，而非一个路由器只维护一个 ARP 表。</p>
<p>接下来，回顾同一子网内的 MAC 寻址，如果主机 A 发送一个广播问询分组，那么 A 所在的子网内所有设备（接口）都将会捕获该分组，因为该分组的目的 IP 与发送主机A的IP在同一个子网中。但是当目的IP与A不在同一子网时，A所在子网内将不会有设备成功接收该分组。那么，主机 A 应该发送怎样的查询分组呢？整个过程按照时间顺序发生的事件如下：</p>
<ol>
<li>
<p>主机 A 查询 ARP 表，期望寻找到目标路由器的本子网接口的 MAC 地址。</p>
<p>目标路由器指的是，根据目的主机 B 的 IP 地址，分析出 B 所在的子网，能够把报文转发到 B 所在子网的那个路由器。</p>
</li>
<li>
<p>主机 A 未能找到目标路由器的本子网接口的 MAC 地址，将采用 ARP 协议，问询到该 MAC 地址，由于目标接口与主机 A 在同一个子网内，该过程与同一局域网内的 MAC 寻址相同。</p>
</li>
<li>
<p>主机 A 获取到目标接口的 MAC 地址，先构造 IP 数据报，其中源 IP 是 A 的 IP 地址，目的 IP 地址是 B 的 IP 地址，再构造链路层帧，其中源 MAC 地址是 A 的 MAC 地址，目的 MAC 地址是<strong>本子网内与路由器连接的接口的 MAC 地址</strong>。主机 A 将把这个链路层帧，以单播的方式，发送给目标接口。</p>
</li>
<li>
<p>目标接口接收到了主机 A 发过来的链路层帧，解析，根据目的 IP 地址，查询转发表，将该 IP 数据报转发到与主机 B 所在子网相连的接口上。</p>
<p>到此，该帧已经从主机 A 所在的子网，转移到了主机 B 所在的子网了。</p>
</li>
<li>
<p>路由器接口查询 ARP 表，期望寻找到主机 B 的 MAC 地址。</p>
</li>
<li>
<p>路由器接口如未能找到主机 B 的 MAC 地址，将采用 ARP 协议，广播问询，单播响应，获取到主机 B 的 MAC 地址。</p>
</li>
<li>
<p>路由器接口将对 IP 数据报重新封装成链路层帧，目标 MAC 地址为主机 B 的 MAC 地址，单播发送，直到目的地。</p>
</li>
</ol>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/arp_different_lan-ad156523.png"></p>
<h1 id="网络攻击常见手段">网络攻击常见手段<a hidden class="anchor" aria-hidden="true" href="#网络攻击常见手段">#</a></h1>
<p>这篇文章的内容主要是介绍 TCP/IP 常见攻击手段，尤其是 DDoS 攻击，也会补充一些其他的常见网络攻击手段。</p>
<h2 id="ip-欺骗">IP 欺骗<a hidden class="anchor" aria-hidden="true" href="#ip-欺骗">#</a></h2>
<h3 id="ip-是什么">IP 是什么?<a hidden class="anchor" aria-hidden="true" href="#ip-是什么">#</a></h3>
<p>在网络中，所有的设备都会分配一个地址。这个地址就仿佛小蓝的家地址「<strong>多少号多少室</strong>」，这个号就是分配给整个子网的，「<strong>室</strong>」对应的号码即分配给子网中计算机的，这就是网络中的地址。「号」对应的号码为网络号，「<strong>室</strong>」对应的号码为主机号，这个地址的整体就是 <strong>IP 地址</strong>。</p>
<h3 id="通过-ip-地址我们能知道什么">通过 IP 地址我们能知道什么？<a hidden class="anchor" aria-hidden="true" href="#通过-ip-地址我们能知道什么">#</a></h3>
<p>通过 IP 地址，我们就可以知道判断访问对象服务器的位置，从而将消息发送到服务器。一般发送者发出的消息首先经过子网的集线器，转发到最近的路由器，然后根据路由位置访问下一个路由器的位置，直到终点</p>
<p><strong>IP 头部格式</strong> :</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/tplv-k3u1fbpfcp-zoom-1.png"></p>
<h3 id="ip-欺骗技术是什么">IP 欺骗技术是什么？<a hidden class="anchor" aria-hidden="true" href="#ip-欺骗技术是什么">#</a></h3>
<p>IP 欺骗技术就是<strong>伪造</strong>某台主机的 IP 地址的技术。通过 IP 地址的伪装使得某台主机能够<strong>伪装</strong>另外的一台主机，而这台主机往往具有某种特权或者被另外的主机所信任。</p>
<p>假设现在有一个合法用户 <strong>(1.1.1.1)</strong> 已经同服务器建立正常的连接，攻击者构造攻击的 TCP 数据，伪装自己的 IP 为 <strong>1.1.1.1</strong>，并向服务器发送一个带有 RSI 位的 TCP 数据段。服务器接收到这样的数据后，认为从 <strong>1.1.1.1</strong> 发送的连接有错误，就会清空缓冲区中建立好的连接。</p>
<p>这时，如果合法用户 <strong>1.1.1.1</strong> 再发送合法数据，服务器就已经没有这样的连接了，该用户就必须从新开始建立连接。攻击时，伪造大量的 IP 地址，向目标发送 RST 数据，使服务器不对合法用户服务。虽然 IP 地址欺骗攻击有着相当难度，但我们应该清醒地意识到，这种攻击非常广泛，入侵往往从这种攻击开始。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/ip%E6%AC%BA%E9%AA%97DDoS%E6%94%BB%E5%87%BB.png"></p>
<h3 id="如何缓解-ip-欺骗">如何缓解 IP 欺骗？<a hidden class="anchor" aria-hidden="true" href="#如何缓解-ip-欺骗">#</a></h3>
<p>虽然无法预防 IP 欺骗，但可以采取措施来阻止伪造数据包渗透网络。<strong>入口过滤</strong> 是防范欺骗的一种极为常见的防御措施，如 BCP38（通用最佳实践文档）所示。入口过滤是一种数据包过滤形式，通常在<a href="https://www.cloudflare.com/learning/serverless/glossary/what-is-edge-computing/">网络边缘</a>设备上实施，用于检查传入的 IP 数据包并确定其源标头。如果这些数据包的源标头与其来源不匹配或者看上去很可疑，则拒绝这些数据包。一些网络还实施出口过滤，检查退出网络的 IP 数据包，确保这些数据包具有合法源标头，以防止网络内部用户使用 IP 欺骗技术发起出站恶意攻击。</p>
<h2 id="syn-flood洪水">SYN Flood(洪水)<a hidden class="anchor" aria-hidden="true" href="#syn-flood洪水">#</a></h2>
<p>SYN Flood 是互联网上最原始、最经典的 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击之一，旨在耗尽可用服务器资源，致使服务器无法传输合法流量</p>
<p>SYN Flood 利用了 TCP 协议的三次握手机制，攻击者通常利用工具或者控制僵尸主机向服务器发送海量的变源 IP 地址或变源端口的 TCP SYN 报文，服务器响应了这些报文后就会生成大量的半连接，当系统资源被耗尽后，服务器将无法提供正常的服务。 增加服务器性能，提供更多的连接能力对于 SYN Flood 的海量报文来说杯水车薪，防御 SYN Flood 的关键在于判断哪些连接请求来自于真实源，屏蔽非真实源的请求以保障正常的业务请求能得到服务。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/synFlood.png"></p>
<h3 id="tcp-syn-flood-攻击原理是什么">TCP SYN Flood 攻击原理是什么？<a hidden class="anchor" aria-hidden="true" href="#tcp-syn-flood-攻击原理是什么">#</a></h3>
<p><strong>TCP SYN Flood</strong> 攻击利用的是 <strong>TCP</strong> 的三次握手（<strong>SYN -&gt; SYN/ACK -&gt; ACK</strong>），假设连接发起方是 A，连接接受方是 B，即 B 在某个端口（<strong>Port</strong>）上监听 A 发出的连接请求，过程如下图所示，左边是 A，右边是 B。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TcpSynFlood.png"></p>
<p>A 首先发送 <strong>SYN</strong>（Synchronization）消息给 B，要求 B 做好接收数据的准备；B 收到后反馈 <strong>SYN-ACK</strong>（Synchronization-Acknowledgement） 消息给 A，这个消息的目的有两个：</p>
<ul>
<li>向 A 确认已做好接收数据的准备，</li>
<li>同时要求 A 也做好接收数据的准备，此时 B 已向 A 确认好接收状态，并等待 A 的确认，连接处于<strong>半开状态（Half-Open）</strong>，顾名思义只开了一半；A 收到后再次发送 <strong>ACK</strong> (Acknowledgement) 消息给 B，向 B 确认也做好了接收数据的准备，至此三次握手完成，「<strong>连接</strong>」就建立了，</li>
</ul>
<p>大家注意到没有，最关键的一点在于双方是否都按对方的要求进入了<strong>可以接收消息</strong>的状态。而这个状态的确认主要是双方将要使用的<strong>消息序号(**SequenceNum)，**TCP** 为保证消息按发送顺序抵达接收方的上层应用，需要用**消息序号</strong>来标记消息的发送先后顺序的。</p>
<p><strong>TCP</strong>是「<strong>双工</strong>」(Duplex)连接，同时支持双向通信，也就是双方同时可向对方发送消息，其中 <strong>SYN</strong> 和 <strong>SYN-ACK</strong> 消息开启了 A→B 的单向通信通道（B 获知了 A 的消息序号）；<strong>SYN-ACK</strong> 和 <strong>ACK</strong> 消息开启了 B→A 单向通信通道（A 获知了 B 的消息序号）。</p>
<p>上面讨论的是双方在诚实守信，正常情况下的通信。</p>
<p>但实际情况是，网络可能不稳定会丢包，使握手消息不能抵达对方，也可能是对方故意不按规矩来，故意延迟或不发送握手确认消息。</p>
<p>假设 B 通过某 <strong>TCP</strong> 端口提供服务，B 在收到 A 的 <strong>SYN</strong> 消息时，积极的反馈了 <strong>SYN-ACK</strong> 消息，使连接进入<strong>半开状态</strong>，因为 B 不确定自己发给 A 的 <strong>SYN-ACK</strong> 消息或 A 反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接都设一个<strong>Timer</strong>，如果超过时间还没有收到 A 的 <strong>ACK</strong> 消息，则重新发送一次 <strong>SYN-ACK</strong> 消息给 A，直到重试超过一定次数时才会放弃。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/TcpSynFlood2.png"></p>
<p>B 为帮助 A 能顺利连接，需要<strong>分配内核资源</strong>维护半开连接，那么当 B 面临海量的连接 A 时，如上图所示，<strong>SYN Flood</strong> 攻击就形成了。攻击方 A 可以控制肉鸡向 B 发送大量 SYN 消息但不响应 ACK 消息，或者干脆伪造 SYN 消息中的 <strong>Source IP</strong>，使 B 反馈的 <strong>SYN-ACK</strong> 消息石沉大海，导致 B 被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。</p>
<h3 id="syn-flood-的常见形式有哪些">SYN Flood 的常见形式有哪些？<a hidden class="anchor" aria-hidden="true" href="#syn-flood-的常见形式有哪些">#</a></h3>
<p><strong>恶意用户可通过三种不同方式发起 SYN Flood 攻击</strong>：</p>
<ol>
<li><strong>直接攻击：</strong> 不伪造 IP 地址的 SYN 洪水攻击称为直接攻击。在此类攻击中，攻击者完全不屏蔽其 IP 地址。由于攻击者使用具有真实 IP 地址的单一源设备发起攻击，因此很容易发现并清理攻击者。为使目标机器呈现半开状态，黑客将阻止个人机器对服务器的 SYN-ACK 数据包做出响应。为此，通常采用以下两种方式实现：部署防火墙规则，阻止除 SYN 数据包以外的各类传出数据包；或者，对传入的所有 SYN-ACK 数据包进行过滤，防止其到达恶意用户机器。实际上，这种方法很少使用（即便使用过也不多见），因为此类攻击相当容易缓解 – 只需阻止每个恶意系统的 IP 地址。哪怕攻击者使用僵尸网络（如 <a href="https://www.cloudflare.com/learning/ddos/glossary/mirai-botnet/">Mirai 僵尸网络</a>），通常也不会刻意屏蔽受感染设备的 IP。</li>
<li><strong>欺骗攻击：</strong> 恶意用户还可以伪造其发送的各个 SYN 数据包的 IP 地址，以便阻止缓解措施并加大身份暴露难度。虽然数据包可能经过伪装，但还是可以通过这些数据包追根溯源。此类检测工作很难开展，但并非不可实现；特别是，如果 Internet 服务提供商 (ISP) 愿意提供帮助，则更容易实现。</li>
<li><strong>分布式攻击（DDoS）：</strong> 如果使用僵尸网络发起攻击，则追溯攻击源头的可能性很低。随着混淆级别的攀升，攻击者可能还会命令每台分布式设备伪造其发送数据包的 IP 地址。哪怕攻击者使用僵尸网络（如 Mirai 僵尸网络），通常也不会刻意屏蔽受感染设备的 IP。</li>
</ol>
<h3 id="如何缓解-syn-flood">如何缓解 SYN Flood？<a hidden class="anchor" aria-hidden="true" href="#如何缓解-syn-flood">#</a></h3>
<p><strong>扩展积压工作队列</strong></p>
<p>目标设备安装的每个操作系统都允许具有一定数量的半开连接。若要响应大量 SYN 数据包，一种方法是增加操作系统允许的最大半开连接数目。为成功扩展最大积压工作，系统必须额外预留内存资源以处理各类新请求。如果系统没有足够的内存，无法应对增加的积压工作队列规模，将对系统性能产生负面影响，但仍然好过拒绝服务。</p>
<p><strong>回收最先创建的 TCP 半开连接</strong></p>
<p>另一种缓解策略是在填充积压工作后覆盖最先创建的半开连接。这项策略要求完全建立合法连接的时间低于恶意 SYN 数据包填充积压工作的时间。当攻击量增加或积压工作规模小于实际需求时，这项特定的防御措施将不奏效。</p>
<p><strong>SYN Cookie</strong></p>
<p>此策略要求服务器创建 Cookie。为避免在填充积压工作时断开连接，服务器使用 SYN-ACK 数据包响应每一项连接请求，而后从积压工作中删除 SYN 请求，同时从内存中删除请求，保证端口保持打开状态并做好重新建立连接的准备。如果连接是合法请求并且已将最后一个 ACK 数据包从客户端机器发回服务器，服务器将重建（存在一些限制）SYN 积压工作队列条目。虽然这项缓解措施势必会丢失一些 TCP 连接信息，但好过因此导致对合法用户发起拒绝服务攻击。</p>
<h2 id="udp-flood洪水">UDP Flood(洪水)<a hidden class="anchor" aria-hidden="true" href="#udp-flood洪水">#</a></h2>
<p><strong>UDP Flood</strong> 也是一种拒绝服务攻击，将大量的用户数据报协议（<strong>UDP</strong>）数据包发送到目标服务器，目的是压倒该设备的处理和响应能力。防火墙保护目标服务器也可能因 <strong>UDP</strong> 泛滥而耗尽，从而导致对合法流量的拒绝服务。</p>
<h3 id="udp-flood-攻击原理是什么">UDP Flood 攻击原理是什么？<a hidden class="anchor" aria-hidden="true" href="#udp-flood-攻击原理是什么">#</a></h3>
<p><strong>UDP Flood</strong> 主要通过利用服务器响应发送到其中一个端口的 <strong>UDP</strong> 数据包所采取的步骤。在正常情况下，当服务器在特定端口接收到 <strong>UDP</strong> 数据包时，会经过两个步骤：</p>
<ul>
<li>服务器首先检查是否正在运行正在侦听指定端口的请求的程序。</li>
<li>如果没有程序在该端口接收数据包，则服务器使用 <strong>ICMP</strong>（ping）数据包进行响应，以通知发送方目的地不可达。</li>
</ul>
<p>举个例子。假设今天要联系酒店的小蓝，酒店客服接到电话后先查看房间的列表来确保小蓝在客房内，随后转接给小蓝。</p>
<p>首先，接待员接收到呼叫者要求连接到特定房间的电话。接待员然后需要查看所有房间的清单，以确保客人在房间中可用，并愿意接听电话。碰巧的是，此时如果突然间所有的电话线同时亮起来，那么他们就会很快就变得不堪重负了。</p>
<p>当服务器接收到每个新的 <strong>UDP</strong> 数据包时，它将通过步骤来处理请求，并利用该过程中的服务器资源。发送 <strong>UDP</strong> 报文时，每个报文将包含源设备的 <strong>IP</strong> 地址。在这种类型的 <strong>DDoS</strong> 攻击期间，攻击者通常不会使用自己的真实 <strong>IP</strong> 地址，而是会欺骗 <strong>UDP</strong> 数据包的源 <strong>IP</strong> 地址，从而阻止攻击者的真实位置被暴露并潜在地饱和来自目标的响应数据包服务器。</p>
<p>由于目标服务器利用资源检查并响应每个接收到的 <strong>UDP</strong> 数据包的结果，当接收到大量 <strong>UDP</strong> 数据包时，目标的资源可能会迅速耗尽，导致对正常流量的拒绝服务</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/UDP_Flood.png"></p>
<h3 id="如何缓解-udp-flooding">如何缓解 UDP Flooding？<a hidden class="anchor" aria-hidden="true" href="#如何缓解-udp-flooding">#</a></h3>
<p>大多数操作系统部分限制了 <strong>ICMP</strong> 报文的响应速率，以中断需要 ICMP 响应的 <strong>DDoS</strong> 攻击。这种缓解的一个缺点是在攻击过程中，合法的数据包也可能被过滤。如果 <strong>UDP Flood</strong> 的容量足够高以使目标服务器的防火墙的状态表饱和，则在服务器级别发生的任何缓解都将不足以应对目标设备上游的瓶颈。</p>
<h2 id="http-flood洪水">HTTP Flood(洪水)<a hidden class="anchor" aria-hidden="true" href="#http-flood洪水">#</a></h2>
<p>HTTP Flood 是一种大规模的 DDoS（Distributed Denial of Service，分布式拒绝服务）攻击，旨在利用 HTTP 请求使目标服务器不堪重负。目标因请求而达到饱和，且无法响应正常流量后，将出现拒绝服务，拒绝来自实际用户的其他请求。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/HTTP_Flood.png"></p>
<h3 id="http-flood-的攻击原理是什么">HTTP Flood 的攻击原理是什么？<a hidden class="anchor" aria-hidden="true" href="#http-flood-的攻击原理是什么">#</a></h3>
<p>HTTP 洪水攻击是“第 7 层”DDoS 攻击的一种。第 7 层是 OSI 模型的应用程序层，指的是 HTTP 等互联网协议。HTTP 是基于浏览器的互联网请求的基础，通常用于加载网页或通过互联网发送表单内容。缓解应用程序层攻击特别复杂，因为恶意流量和正常流量很难区分。</p>
<p>为了获得最大效率，恶意行为者通常会利用或创建僵尸网络，以最大程度地扩大攻击的影响。通过利用感染了恶意软件的多台设备，攻击者可以发起大量攻击流量来进行攻击。</p>
<p>HTTP 洪水攻击有两种：</p>
<ul>
<li><strong>HTTP GET 攻击</strong>：在这种攻击形式下，多台计算机或其他设备相互协调，向目标服务器发送对图像、文件或其他资产的多个请求。当目标被传入的请求和响应所淹没时，来自正常流量源的其他请求将被拒绝服务。</li>
<li><strong>HTTP POST 攻击</strong>：一般而言，在网站上提交表单时，服务器必须处理传入的请求并将数据推送到持久层（通常是数据库）。与发送 POST 请求所需的处理能力和带宽相比，处理表单数据和运行必要数据库命令的过程相对密集。这种攻击利用相对资源消耗的差异，直接向目标服务器发送许多 POST 请求，直到目标服务器的容量饱和并拒绝服务为止。</li>
</ul>
<h3 id="如何防护-http-flood">如何防护 HTTP Flood？<a hidden class="anchor" aria-hidden="true" href="#如何防护-http-flood">#</a></h3>
<p>如前所述，缓解第 7 层攻击非常复杂，而且通常要从多方面进行。一种方法是对发出请求的设备实施质询，以测试它是否是机器人，这与在线创建帐户时常用的 CAPTCHA 测试非常相似。通过提出 JavaScript 计算挑战之类的要求，可以缓解许多攻击。</p>
<p>其他阻止 HTTP 洪水攻击的途径包括使用 Web 应用程序防火墙 (WAF)、管理 IP 信誉数据库以跟踪和有选择地阻止恶意流量，以及由工程师进行动态分析。Cloudflare 具有超过 2000 万个互联网设备的规模优势，能够分析来自各种来源的流量并通过快速更新的 WAF 规则和其他防护策略来缓解潜在的攻击，从而消除应用程序层 DDoS 流量。</p>
<h2 id="dns-flood洪水">DNS Flood(洪水)<a hidden class="anchor" aria-hidden="true" href="#dns-flood洪水">#</a></h2>
<p>域名系统（DNS）服务器是互联网的“电话簿“；互联网设备通过这些服务器来查找特定 Web 服务器以便访问互联网内容。DNS Flood 攻击是一种分布式拒绝服务（DDoS）攻击，攻击者用大量流量淹没某个域的 DNS 服务器，以尝试中断该域的 DNS 解析。如果用户无法找到电话簿，就无法查找到用于调用特定资源的地址。通过中断 DNS 解析，DNS Flood 攻击将破坏网站、API 或 Web 应用程序响应合法流量的能力。很难将 DNS Flood 攻击与正常的大流量区分开来，因为这些大规模流量往往来自多个唯一地址，查询该域的真实记录，模仿合法流量。</p>
<h3 id="dns-flood-的攻击原理是什么">DNS Flood 的攻击原理是什么？<a hidden class="anchor" aria-hidden="true" href="#dns-flood-的攻击原理是什么">#</a></h3>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/DNS_Flood.png"></p>
<p>域名系统的功能是将易于记忆的名称（例如 example.com）转换成难以记住的网站服务器地址（例如 192.168.0.1），因此成功攻击 DNS 基础设施将导致大多数人无法使用互联网。DNS Flood 攻击是一种相对较新的基于 DNS 的攻击，这种攻击是在高带宽<a href="https://www.cloudflare.com/learning/ddos/glossary/internet-of-things-iot/">物联网（IoT）</a><a href="https://www.cloudflare.com/learning/ddos/what-is-a-ddos-botnet/">僵尸网络</a>（如 <a href="https://www.cloudflare.com/learning/ddos/glossary/mirai-botnet/">Mirai</a>）兴起后激增的。DNS Flood 攻击使用 IP 摄像头、DVR 盒和其他 IoT 设备的高带宽连接直接淹没主要提供商的 DNS 服务器。来自 IoT 设备的大量请求淹没 DNS 提供商的服务，阻止合法用户访问提供商的 DNS 服务器。</p>
<p>DNS Flood 攻击不同于 <a href="https://www.cloudflare.com/zh-cn/learning/ddos/dns-amplification-ddos-attack/">DNS 放大攻击</a>。与 DNS Flood 攻击不同，DNS 放大攻击反射并放大不安全 DNS 服务器的流量，以便隐藏攻击的源头并提高攻击的有效性。DNS 放大攻击使用连接带宽较小的设备向不安全的 DNS 服务器发送无数请求。这些设备对非常大的 DNS 记录发出小型请求，但在发出请求时，攻击者伪造返回地址为目标受害者。这种放大效果让攻击者能借助有限的攻击资源来破坏较大的目标。</p>
<h3 id="如何防护-dns-flood">如何防护 DNS Flood?<a hidden class="anchor" aria-hidden="true" href="#如何防护-dns-flood">#</a></h3>
<p>DNS Flood 对传统上基于放大的攻击方法做出了改变。借助轻易获得的高带宽僵尸网络，攻击者现能针对大型组织发动攻击。除非被破坏的 IoT 设备得以更新或替换，否则抵御这些攻击的唯一方法是使用一个超大型、高度分布式的 DNS 系统，以便实时监测、吸收和阻止攻击流量。</p>
<h2 id="tcp-重置攻击">TCP 重置攻击<a hidden class="anchor" aria-hidden="true" href="#tcp-重置攻击">#</a></h2>
<p>在 <strong>TCP</strong> 重置攻击中，攻击者通过向通信的一方或双方发送伪造的消息，告诉它们立即断开连接，从而使通信双方连接中断。正常情况下，如果客户端收发现到达的报文段对于相关连接而言是不正确的，<strong>TCP</strong> 就会发送一个重置报文段，从而导致 <strong>TCP</strong> 连接的快速拆卸。</p>
<p><strong>TCP</strong> 重置攻击利用这一机制，通过向通信方发送伪造的重置报文段，欺骗通信双方提前关闭 TCP 连接。如果伪造的重置报文段完全逼真，接收者就会认为它有效，并关闭 <strong>TCP</strong> 连接，防止连接被用来进一步交换信息。服务端可以创建一个新的 <strong>TCP</strong> 连接来恢复通信，但仍然可能会被攻击者重置连接。万幸的是，攻击者需要一定的时间来组装和发送伪造的报文，所以一般情况下这种攻击只对长连接有杀伤力，对于短连接而言，你还没攻击呢，人家已经完成了信息交换。</p>
<p>从某种意义上来说，伪造 <strong>TCP</strong> 报文段是很容易的，因为 <strong>TCP/IP</strong> 都没有任何内置的方法来验证服务端的身份。有些特殊的 IP 扩展协议（例如 <code>IPSec</code>）确实可以验证身份，但并没有被广泛使用。客户端只能接收报文段，并在可能的情况下使用更高级别的协议（如 <code>TLS</code>）来验证服务端的身份。但这个方法对 <strong>TCP</strong> 重置包并不适用，因为 <strong>TCP</strong> 重置包是 <strong>TCP</strong> 协议本身的一部分，无法使用更高级别的协议进行验证。</p>
<h2 id="模拟攻击">模拟攻击<a hidden class="anchor" aria-hidden="true" href="#模拟攻击">#</a></h2>
<blockquote>
<p>以下实验是在 <code>OSX</code> 系统中完成的，其他系统请自行测试。</p>
</blockquote>
<p>现在来总结一下伪造一个 <strong>TCP</strong> 重置报文要做哪些事情：</p>
<ul>
<li>嗅探通信双方的交换信息。</li>
<li>截获一个 <code>ACK</code> 标志位置位 1 的报文段，并读取其 <code>ACK</code> 号。</li>
<li>伪造一个 TCP 重置报文段（<code>RST</code> 标志位置为 1），其序列号等于上面截获的报文的 <code>ACK</code> 号。这只是理想情况下的方案，假设信息交换的速度不是很快。大多数情况下为了增加成功率，可以连续发送序列号不同的重置报文。</li>
<li>将伪造的重置报文发送给通信的一方或双方，时其中断连接。</li>
</ul>
<p>为了实验简单，我们可以使用本地计算机通过 <code>localhost</code> 与自己通信，然后对自己进行 TCP 重置攻击。需要以下几个步骤：</p>
<ul>
<li>在两个终端之间建立一个 TCP 连接。</li>
<li>编写一个能嗅探通信双方数据的攻击程序。</li>
<li>修改攻击程序，伪造并发送重置报文。</li>
</ul>
<p>下面正式开始实验。</p>
<blockquote>
<p>建立 TCP 连接</p>
</blockquote>
<p>可以使用 netcat 工具来建立 TCP 连接，这个工具很多操作系统都预装了。打开第一个终端窗口，运行以下命令：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ nc -nvl <span style="color:#ff0;font-weight:bold">8000</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个命令会启动一个 TCP 服务，监听端口为 <code>8000</code>。接着再打开第二个终端窗口，运行以下命令：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>$ nc 127.0.0.1 <span style="color:#ff0;font-weight:bold">8000</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该命令会尝试与上面的服务建立连接，在其中一个窗口输入一些字符，就会通过 TCP 连接发送给另一个窗口并打印出来。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/1.gif"></p>
<blockquote>
<p>嗅探流量</p>
</blockquote>
<p>编写一个攻击程序，使用 Python 网络库 <code>scapy</code> 来读取两个终端窗口之间交换的数据，并将其打印到终端上。代码比较长，下面为一部份，完整代码后台回复 TCP 攻击，代码的核心是调用 <code>scapy</code> 的嗅探方法：</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%97%85%E6%8E%A2%E6%B5%81%E9%87%8F.png"></p>
<p>这段代码告诉 <code>scapy</code> 在 <code>lo0</code> 网络接口上嗅探数据包，并记录所有 TCP 连接的详细信息。</p>
<ul>
<li><strong>iface</strong> : 告诉 scapy 在 <code>lo0</code>（localhost）网络接口上进行监听。</li>
<li><strong>lfilter</strong> : 这是个过滤器，告诉 scapy 忽略所有不属于指定的 TCP 连接（通信双方皆为 <code>localhost</code>，且端口号为 <code>8000</code>）的数据包。</li>
<li><strong>prn</strong> : scapy 通过这个函数来操作所有符合 <code>lfilter</code> 规则的数据包。上面的例子只是将数据包打印到终端，下文将会修改函数来伪造重置报文。</li>
<li><strong>count</strong> : scapy 函数返回之前需要嗅探的数据包数量。</li>
</ul>
<blockquote>
<p>发送伪造的重置报文</p>
</blockquote>
<p>下面开始修改程序，发送伪造的 TCP 重置报文来进行 TCP 重置攻击。根据上面的解读，只需要修改 prn 函数就行了，让其检查数据包，提取必要参数，并利用这些参数来伪造 TCP 重置报文并发送。</p>
<p>例如，假设该程序截获了一个从（<code>src_ip</code>, <code>src_port</code>）发往 （<code>dst_ip</code>, <code>dst_port</code>）的报文段，该报文段的 ACK 标志位已置为 1，ACK 号为 <code>100,000</code>。攻击程序接下来要做的是：</p>
<ul>
<li>由于伪造的数据包是对截获的数据包的响应，所以伪造数据包的源 <code>IP/Port</code> 应该是截获数据包的目的 <code>IP/Port</code>，反之亦然。</li>
<li>将伪造数据包的 <code>RST</code> 标志位置为 1，以表示这是一个重置报文。</li>
<li>将伪造数据包的序列号设置为截获数据包的 ACK 号，因为这是发送方期望收到的下一个序列号。</li>
<li>调用 <code>scapy</code> 的 <code>send</code> 方法，将伪造的数据包发送给截获数据包的发送方。</li>
</ul>
<p>对于我的程序而言，只需将这一行取消注释，并注释这一行的上面一行，就可以全面攻击了。按照步骤 1 的方法设置 TCP 连接，打开第三个窗口运行攻击程序，然后在 TCP 连接的其中一个终端输入一些字符串，你会发现 TCP 连接被中断了！</p>
<blockquote>
<p>进一步实验</p>
</blockquote>
<ol>
<li>可以继续使用攻击程序进行实验，将伪造数据包的序列号加减 1 看看会发生什么，是不是确实需要和截获数据包的 <code>ACK</code> 号完全相同。</li>
<li>打开 <code>Wireshark</code>，监听 lo0 网络接口，并使用过滤器 <code>ip.src == 127.0.0.1 &amp;&amp; ip.dst == 127.0.0.1 &amp;&amp; tcp.port == 8000</code> 来过滤无关数据。你可以看到 TCP 连接的所有细节。</li>
<li>在连接上更快速地发送数据流，使攻击更难执行。</li>
</ol>
<h2 id="中间人攻击">中间人攻击<a hidden class="anchor" aria-hidden="true" href="#中间人攻击">#</a></h2>
<p>攻击中间人攻击英文名叫 Man-in-the-MiddleAttack，简称「MITM 攻击」。指攻击者与通讯的两端分别创建独立的联系，并交换其所收到的数据，使通讯的两端认为他们正在通过一个私密的连接与对方 直接对话，但事实上整个会话都被攻击者完全控制。我们画一张图：</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%B8%AD%E9%97%B4%E4%BA%BA.png"></p>
<h3 id="中间人攻击的原理是什么">中间人攻击的原理是什么？<a hidden class="anchor" aria-hidden="true" href="#中间人攻击的原理是什么">#</a></h3>
<p>举个例子，我和公司签了一个一份劳动合同，一人一份合同。不晓得哪个可能改了合同内容，不知道真假了，怎么搞？只好找专业的机构来鉴定，自然就要花钱。</p>
<p>在安全领域有句话：<strong>我们没有办法杜绝网络犯罪，只好想办法提高网络犯罪的成本</strong>。既然没法杜绝这种情况，那我们就想办法提高作案的成本，今天我们就简单了解下基本的网络安全知识，也是面试中的高频面试题了。</p>
<p>为了避免双方说活不算数的情况，双方引入第三家机构，将合同原文给可信任的第三方机构，只要这个机构不监守自盗，合同就相对安全。</p>
<p><strong>如果第三方机构内部不严格或容易出现纰漏？</strong></p>
<p>虽然我们将合同原文给第三方机构了，为了防止内部人员的更改，需要采取什么措施呢</p>
<p>一种可行的办法是引入 <strong>摘要算法</strong> 。即合同和摘要一起，为了简单的理解摘要。大家可以想象这个摘要为一个函数，这个函数对原文进行了加密，会产生一个唯一的散列值，一旦原文发生一点点变化，那么这个散列值将会变化。</p>
<h3 id="有哪些常用的摘要算法呢">有哪些常用的摘要算法呢？<a hidden class="anchor" aria-hidden="true" href="#有哪些常用的摘要算法呢">#</a></h3>
<p>目前比较常用的加密算法有消息摘要算法和安全散列算法(<strong>SHA</strong>)。<strong>MD5</strong> 是将任意长度的文章转化为一个 128 位的散列值，可是在 2004 年，<strong>MD5</strong> 被证实了容易发生碰撞，即两篇原文产生相同的摘要。这样的话相当于直接给黑客一个后门，轻松伪造摘要。</p>
<p>所以在大部分的情况下都会选择 <strong>SHA 算法</strong> 。</p>
<p><strong>出现内鬼了怎么办？</strong></p>
<p>看似很安全的场面了，理论上来说杜绝了篡改合同的做法。主要某个员工同时具有修改合同和摘要的权利，那搞事儿就是时间的问题了，毕竟没哪个系统可以完全的杜绝员工接触敏感信息，除非敏感信息都不存在。所以能不能考虑将合同和摘要分开存储呢</p>
<p><strong>那如何确保员工不会修改合同呢？</strong></p>
<p>这确实蛮难的，不过办法总比困难多。我们将合同放在双方手中，摘要放在第三方机构，篡改难度进一步加大</p>
<p><strong>那么员工万一和某个用户串通好了呢？</strong></p>
<p>看来放在第三方的机构还是不好使，同样存在不小风险。所以还需要寻找新的方案，这就出现了 <strong>数字签名和证书</strong>。</p>
<h3 id="数字证书和签名有什么用">数字证书和签名有什么用？<a hidden class="anchor" aria-hidden="true" href="#数字证书和签名有什么用">#</a></h3>
<p>同样的，举个例子。Sum 和 Mike 两个人签合同。Sum 首先用 <strong>SHA</strong> 算法计算合同的摘要，然后用自己私钥将摘要加密，得到数字签名。Sum 将合同原文、签名，以及公钥三者都交给 Mike</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D.png"></p>
<p>如果 Sum 想要证明合同是 Mike 的，那么就要使用 Mike 的公钥，将这个签名解密得到摘要 x，然后 Mike 计算原文的 sha 摘要 Y，随后对比 x 和 y，如果两者相等，就认为数据没有被篡改</p>
<p>在这样的过程中，Mike 是不能更改 Sum 的合同，因为要修改合同不仅仅要修改原文还要修改摘要，修改摘要需要提供 Mike 的私钥，私钥即 Sum 独有的密码，公钥即 Sum 公布给他人使用的密码</p>
<p>总之，公钥加密的数据只能私钥可以解密。私钥加密的数据只有公钥可以解密，这就是 <strong>非对称加密</strong> 。</p>
<p>隐私保护？不是吓唬大家，信息是透明的兄 die，不过尽量去维护个人的隐私吧，今天学习对称加密和非对称加密。</p>
<p>大家先读读这个字&quot;钥&quot;,是读&quot;yao&quot;，我以前也是，其实读&quot;yue&quot;</p>
<h3 id="什么是对称加密">什么是对称加密？<a hidden class="anchor" aria-hidden="true" href="#什么是对称加密">#</a></h3>
<p>对称加密，顾名思义，加密方与解密方使用同一钥匙(秘钥)。具体一些就是，发送方通过使用相应的加密算法和秘钥，对将要发送的信息进行加密；对于接收方而言，使用解密算法和相同的秘钥解锁信息，从而有能力阅读信息。</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86.png"></p>
<h3 id="常见的对称加密算法有哪些">常见的对称加密算法有哪些？<a hidden class="anchor" aria-hidden="true" href="#常见的对称加密算法有哪些">#</a></h3>
<p><strong>DES</strong></p>
<p>DES 使用的密钥表面上是 64 位的，然而只有其中的 56 位被实际用于算法，其余 8 位可以被用于奇偶校验，并在算法中被丢弃。因此，<strong>DES</strong> 的有效密钥长度为 56 位，通常称 <strong>DES</strong> 的密钥长度为 56 位。假设秘钥为 56 位，采用暴力破 Jie 的方式，其秘钥个数为 2 的 56 次方，那么每纳秒执行一次解密所需要的时间差不多 1 年的样子。当然，没人这么干。<strong>DES</strong> 现在已经不是一种安全的加密方法，主要因为它使用的 56 位密钥过短。</p>
<p><strong>IDEA</strong></p>
<p>国际数据加密算法(International Data Encryption Algorithm)。秘钥长度 128 位，优点没有专利的限制。</p>
<p><strong>AES</strong></p>
<p>当 DES 被破解以后，没过多久推出了 <strong>AES</strong> 算法，提供了三种长度供选择，128 位、192 位和 256，为了保证性能不受太大的影响，选择 128 即可。</p>
<p><strong>SM1 和 SM4</strong></p>
<p>之前几种都是国外的，我们国内自行研究了国密 **SM1 **和 <strong>SM4</strong>。其中 S 都属于国家标准，算法公开。优点就是国家的大力支持和认可</p>
<p><strong>总结</strong>：</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93.png"></p>
<h3 id="常见的非对称加密算法有哪些">常见的非对称加密算法有哪些？<a hidden class="anchor" aria-hidden="true" href="#常见的非对称加密算法有哪些">#</a></h3>
<p>在对称加密中，发送方与接收方使用相同的秘钥。那么在非对称加密中则是发送方与接收方使用的不同的秘钥。其主要解决的问题是防止在秘钥协商的过程中发生泄漏。比如在对称加密中，小蓝将需要发送的消息加密，然后告诉你密码是 123balala,ok,对于其他人而言，很容易就能劫持到密码是 123balala。那么在非对称的情况下，小蓝告诉所有人密码是 123balala,对于中间人而言，拿到也没用，因为没有私钥。所以，非对称密钥其实主要解决了密钥分发的难题。如下图</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%9D%9E%E5%AF%B9%E7%A7%B0%E5%8A%A0%E5%AF%86%E6%B5%81%E7%A8%8B.png"></p>
<p>其实我们经常都在使用非对称加密，比如使用多台服务器搭建大数据平台 hadoop，为了方便多台机器设置免密登录，是不是就会涉及到秘钥分发。再比如搭建 docker 集群也会使用相关非对称加密算法。</p>
<p>常见的非对称加密算法：</p>
<ul>
<li>RSA（RSA 加密算法，RSA Algorithm）：优势是性能比较快，如果想要较高的加密难度，需要很长的秘钥。</li>
<li>ECC：基于椭圆曲线提出。是目前加密强度最高的非对称加密算法</li>
<li>SM2：同样基于椭圆曲线问题设计。最大优势就是国家认可和大力支持。</li>
</ul>
<h3 id="常见的散列算法有哪些">常见的散列算法有哪些？<a hidden class="anchor" aria-hidden="true" href="#常见的散列算法有哪些">#</a></h3>
<p>这个大家应该更加熟悉了，比如我们平常使用的 MD5 校验，在很多时候，我并不是拿来进行加密，而是用来获得唯一性 ID。在做系统的过程中，存储用户的各种密码信息，通常都会通过散列算法，最终存储其散列值。</p>
<p><strong>MD5</strong></p>
<p>MD5 可以用来生成一个 128 位的消息摘要，它是目前应用比较普遍的散列算法，具体的应用场景你可以自行  参阅。虽然，因为算法的缺陷，它的唯一性已经被破解了，但是大部分场景下，这并不会构成安全问题。但是，如果不是长度受限（32 个字符），我还是不推荐你继续使用 <strong>MD5</strong> 的。</p>
<p><strong>SHA</strong></p>
<p>安全散列算法。<strong>SHA</strong> 分为 <strong>SHA1</strong> 和 <strong>SH2</strong> 两个版本。该算法的思想是接收一段明文，然后以一种不可逆的方式将它转换成一段（通常更小）密文，也可以简单的理解为取一串输入码（称为预映射或信息），并把它们转化为长度较短、位数固定的输出序列即散列值（也称为信息摘要或信息认证代码）的过程。</p>
<p><strong>SM3</strong></p>
<p>国密算法<strong>SM3</strong>。加密强度和 SHA-256 想不多。主要是收到国家的支持。</p>
<p><strong>大部分情况下使用对称加密，具有比较不错的安全性。如果需要分布式进行秘钥分发，考虑非对称。如果不需要可逆计算则散列算法。</strong></p>
<h3 id="第三方机构和证书机制有什么用">第三方机构和证书机制有什么用？<a hidden class="anchor" aria-hidden="true" href="#第三方机构和证书机制有什么用">#</a></h3>
<p>问题还有，此时如果 Sum 否认给过 Mike 的公钥和合同，不久 gg 了</p>
<p>所以需要 Sum 过的话做过的事儿需要足够的信誉，这就引入了 <strong>第三方机构和证书机制</strong> 。</p>
<p>证书之所以会有信用，是因为证书的签发方拥有信用。所以如果 Sum 想让 Mike 承认自己的公钥，Sum 不会直接将公钥给 Mike ，而是提供由第三方机构，含有公钥的证书。如果 Mike 也信任这个机构，法律都认可，那 ik，信任关系成立</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%BA%E6%9E%84%E8%AF%81%E4%B9%A6.png"></p>
<p>如上图所示，Sum 将自己的申请提交给机构，产生证书的原文。机构用自己的私钥签名 Sum 的申请原文（先根据原文内容计算摘要，再用私钥加密），得到带有签名信息的证书。Mike 拿到带签名信息的证书，通过第三方机构的公钥进行解密，获得 Sum 证书的摘要、证书的原文。有了 Sum 证书的摘要和原文，Mike 就可以进行验签。验签通过，Mike 就可以确认 Sum 的证书的确是第三方机构签发的。</p>
<p>用上面这样一个机制，合同的双方都无法否认合同。这个解决方案的核心在于需要第三方信用服务机构提供信用背书。这里产生了一个最基础的信任链，如果第三方机构的信任崩溃，比如被黑客攻破，那整条信任链条也就断裂了</p>
<p>为了让这个信任条更加稳固，就需要环环相扣，打造更长的信任链，避免单点信任风险</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E7%AC%AC%E4%B8%89%E6%96%B9%E6%9C%BA%E6%9E%84%E8%AF%81%E4%B9%A62.png"></p>
<p>上图中，由信誉最好的根证书机构提供根证书，然后根证书机构去签发二级机构的证书；二级机构去签发三级机构的证书；最后有由三级机构去签发 Sum 证书。</p>
<p>如果要验证 Sum 证书的合法性，就需要用三级机构证书中的公钥去解密 Sum 证书的数字签名。</p>
<p>如果要验证三级机构证书的合法性，就需要用二级机构的证书去解密三级机构证书的数字签名。</p>
<p>如果要验证二级结构证书的合法性，就需要用根证书去解密。</p>
<p>以上，就构成了一个相对长一些的信任链。如果其中一方想要作弊是非常困难的，除非链条中的所有机构同时联合起来，进行欺诈。</p>
<h3 id="中间人攻击如何避免">中间人攻击如何避免?<a hidden class="anchor" aria-hidden="true" href="#中间人攻击如何避免">#</a></h3>
<p>既然知道了中间人攻击的原理也知道了他的危险，现在我们看看如何避免。相信我们都遇到过下面这种状况：</p>
<p><img loading="lazy" src="/en/posts/interview/7_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E9%9D%A2%E8%AF%95%E9%A2%98/%E9%81%BF%E5%85%8D%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB.png"></p>
<p>出现这个界面的很多情况下，都是遇到了中间人攻击的现象，需要对安全证书进行及时地监测。而且大名鼎鼎的 github 网站，也曾遭遇过中间人攻击：</p>
<p>想要避免中间人攻击的方法目前主要有两个：</p>
<ul>
<li>客户端不要轻易相信证书：因为这些证书极有可能是中间人。</li>
<li>App 可以提前预埋证书在本地：意思是我们本地提前有一些证书，这样其他证书就不能再起作用了。</li>
</ul>
<h2 id="ddos">DDoS<a hidden class="anchor" aria-hidden="true" href="#ddos">#</a></h2>
<p>通过上面的描述，大部分攻击都是 <strong>DDOS</strong> 攻击，所以简单总结下这个攻击相关内容。</p>
<p>其实，像全球互联网各大公司，均遭受过大量的 <strong>DDoS</strong>。</p>
<p>2018 年，GitHub 在一瞬间遭到高达 1.35Tbps 的带宽攻击。这次 DDoS 攻击几乎可以堪称是互联网有史以来规模最大、威力最大的 DDoS 攻击了。在 GitHub 遭到攻击后，仅仅一周后，DDoS 攻击又开始对 Google、亚马逊甚至 Pornhub 等网站进行了 DDoS 攻击。后续的 DDoS 攻击带宽最高也达到了 1Tbps。</p>
<h3 id="ddos究竟是什么">DDoS究竟是什么<a hidden class="anchor" aria-hidden="true" href="#ddos究竟是什么">#</a></h3>
<p>DDos 全名 Distributed Denial of Service，翻译成中文就是<strong>分布式拒绝服务</strong>。指的是处于不同位置的多个攻击者同时向一个或数个目标发动攻击，是一种分布的、协同的大规模攻击方式。单一的 DoS 攻击一般是采用一对一方式的，它利用网络协议和操作系统的一些缺陷，采用<strong>欺骗和伪装</strong>的策略来进行网络攻击，使网站服务器充斥大量要求回复的信息，消耗网络带宽或系统资源，导致网络或系统不胜负荷以至于瘫痪而停止提供正常的网络服务。</p>
<blockquote>
<p>举个例子</p>
</blockquote>
<p>我开了一家有五十个座位的重庆火锅店，由于用料上等，童叟无欺。平时门庭若市，生意特别红火，而对面二狗家的火锅店却无人问津。二狗为了对付我，想了一个办法，叫了五十个人来我的火锅店坐着却不点菜，让别的客人无法吃饭。</p>
<p>上面这个例子讲的就是典型的 DDoS 攻击，一般来说是指攻击者利用“肉鸡”对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。在线游戏、互联网金融等领域是 DDoS 攻击的高发行业。</p>
<p>攻击方式很多，比如 <strong>ICMP Flood</strong>、<strong>UDP Flood</strong>、<strong>NTP Flood</strong>、<strong>SYN Flood</strong>、<strong>CC 攻击</strong>、<strong>DNS Query Flood</strong>等等。</p>
<h3 id="如何应对-ddos-攻击">如何应对 DDoS 攻击？<a hidden class="anchor" aria-hidden="true" href="#如何应对-ddos-攻击">#</a></h3>
<p><strong>高防服务器</strong></p>
<p>还是拿开的重庆火锅店举例，高防服务器就是我给重庆火锅店增加了两名保安，这两名保安可以让保护店铺不受流氓骚扰，并且还会定期在店铺周围巡逻防止流氓骚扰。</p>
<p>高防服务器主要是指能独立硬防御 50Gbps 以上的服务器，能够帮助网站拒绝服务攻击，定期扫描网络主节点等，这东西是不错，就是贵~</p>
<p><strong>黑名单</strong></p>
<p>面对火锅店里面的流氓，我一怒之下将他们拍照入档，并禁止他们踏入店铺，但是有的时候遇到长得像的人也会禁止他进入店铺。这个就是设置黑名单，此方法秉承的就是“错杀一千，也不放一百”的原则，会封锁正常流量，影响到正常业务。</p>
<p><strong>DDoS 清洗</strong></p>
<p><strong>DDos</strong> 清洗，就是我发现客人进店几分钟以后，但是一直不点餐，我就把他踢出店里。</p>
<p><strong>DDoS</strong> 清洗会对用户请求数据进行实时监控，及时发现 <strong>DOS</strong> 攻击等异常流量，在不影响正常业务开展的情况下清洗掉这些异常流量。</p>
<p><strong>CDN 加速</strong></p>
<p>CDN 加速，我们可以这么理解：为了减少流氓骚扰，我干脆将火锅店开到了线上，承接外卖服务，这样流氓找不到店在哪里，也耍不来流氓了。</p>
<p>在现实中，CDN 服务将网站访问流量分配到了各个节点中，这样一方面隐藏网站的真实 IP，另一方面即使遭遇 <strong>DDoS</strong> 攻击，也可以将流量分散到各个节点中，防止源站崩溃。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://funny-toffee-4aa7c3.netlify.app/en/tags/interview/">Interview</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://funny-toffee-4aa7c3.netlify.app/en/">Wjy&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>