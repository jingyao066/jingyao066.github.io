<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>初识算法 | Wjy&#39;s Blog</title>
<meta name="keywords" content="算法">
<meta name="description" content="初识算法 算法无处不在 当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖基本逻辑，这些逻辑在">
<meta name="author" content="Wjy">
<link rel="canonical" href="https://funny-toffee-4aa7c3.netlify.app/posts/%E7%AE%97%E6%B3%95/%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://funny-toffee-4aa7c3.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://funny-toffee-4aa7c3.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://funny-toffee-4aa7c3.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://funny-toffee-4aa7c3.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://funny-toffee-4aa7c3.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="初识算法" />
<meta property="og:description" content="初识算法 算法无处不在 当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖基本逻辑，这些逻辑在" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://funny-toffee-4aa7c3.netlify.app/posts/%E7%AE%97%E6%B3%95/%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-04-30T12:03:30+00:00" />
<meta property="article:modified_time" content="2024-04-30T12:03:30+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="初识算法"/>
<meta name="twitter:description" content="初识算法 算法无处不在 当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖基本逻辑，这些逻辑在"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://funny-toffee-4aa7c3.netlify.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "初识算法",
      "item": "https://funny-toffee-4aa7c3.netlify.app/posts/%E7%AE%97%E6%B3%95/%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "初识算法",
  "name": "初识算法",
  "description": "初识算法 算法无处不在 当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖基本逻辑，这些逻辑在",
  "keywords": [
    "算法"
  ],
  "articleBody": "初识算法 算法无处不在 当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖基本逻辑，这些逻辑在我们的日常生活中处处可见。\n在正式探讨算法之前，有一个有趣的事实值得分享：你已经在不知不觉中学会了许多算法，并习惯将它们应用到日常生活中了。下面我将举几个具体的例子来证实这一点。\n例一：查字典。在字典里，每个汉字都对应一个拼音，而字典是按照拼音字母顺序排列的。假设我们需要查找一个拼音首字母为 𝑟 的字，通常会按照图 1-1 所示的方式实现。\n翻开字典约一半的页数，查看该页的首字母是什么，假设首字母为 𝑚 。 由于在拼音字母表中 𝑟 位于 𝑚 之后，所以排除字典前半部分，查找范围缩小到后半部分。 不断重复步骤 1. 和 步骤 2. ，直至找到拼音首字母为 𝑟 的页码为止。 个小学生必备技能，实际上就是著名的“二分查找”算法。从数据结构的角度，我们可以把字典视为一个已排序的“数组”；从算法的角度，我们可以将上述查字典的一系列操作看作“二分查找”。\n例二：整理扑克。我们在打牌时，每局都需要整理手中的扑克牌，使其从小到大排列，实现流程如图 1-2 所示。\n将扑克牌划分为“有序”和“无序”两部分，并假设初始状态下最左 1 张扑克牌已经有序。 在无序部分抽出一张扑克牌，插入至有序部分的正确位置；完成后最左 2 张扑克已经有序。 不断循环步骤 2. ，每一轮将一张扑克牌从无序部分插入至有序部分，直至所有扑克牌都有序。 上述整理扑克牌的方法本质上是“插入排序”算法，它在处理小型数据集时非常高效。许多编程语言的排序库函数中都有插入排序的身影。\n例三：货币找零。假设我们在超市购买了 69 元的商品，给了收银员 100 元，则收银员需要找我们 31 元。他会很自然地完成如图 1-3 所示的思考。\n可选项是比 31 元面值更小的货币，包括 1 元、5 元、10 元、20 元。 从可选项中拿出最大的 20 元，剩余 31−20=11 元。 从剩余可选项中拿出最大的 10 元，剩余 11−10=1 元。 从剩余可选项中拿出最大的 1 元，剩余 1−1=0 元。 完成找零，方案为 20+10+1=31 元。 在以上步骤中，我们每一步都采取当前看来最好的选择（尽可能用大面额的货币），最终得到了可行的找零方案。从数据结构与算法的角度看，这种方法本质上是“贪心”算法。\n小到烹饪一道菜，大到星际航行，几乎所有问题的解决都离不开算法。计算机的出现使得我们能够通过编程将数据结构存储在内存中，同时编写代码调用 CPU 和 GPU 执行算法。这样一来，我们就能把生活中的问题转移到计算机上，以更高效的方式解决各种复杂问题。\n算法是什么 算法定义 算法（algorithm）是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性。\n问题是明确的，包含清晰的输入和输出定义。 具有可行性，能够在有限步骤、时间和内存空间下完成。 各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。 数据结构定义 数据结构（data structure）是计算机中组织和存储数据的方式，具有以下设计目标。\n空间占用尽量少，以节省计算机内存。 数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。 提供简洁的数据表示和逻辑信息，以便算法高效运行。 数据结构设计是一个充满权衡的过程。如果想在某方面取得提升，往往需要在另一方面作出妥协。下面举两个例子。\n链表相较于数组，在数据添加和删除操作上更加便捷，但牺牲了数据访问速度。 图相较于链表，提供了更丰富的逻辑信息，但需要占用更大的内存空间。 数据结构与算法的关系 数据结构与算法高度相关、紧密结合，具体表现在以下三个方面。\n数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。 算法是数据结构发挥作用的舞台。数据结构本身仅存储数据信息，结合算法才能解决特定问题。 算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。 值得说明的是，数据结构与算法是独立于编程语言的。\n小结 算法在日常生活中无处不在，并不是遥不可及的高深知识。实际上，我们已经在不知不觉中学会了许多算法，用以解决生活中的大小问题。 查字典的原理与二分查找算法相一致。二分查找算法体现了分而治之的重要算法思想。 整理扑克的过程与插入排序算法非常类似。插入排序算法适合排序小型数据集。 货币找零的步骤本质上是贪心算法，每一步都采取当前看来最好的选择。 算法是在有限时间内解决特定问题的一组指令或操作步骤，而数据结构是计算机中组织和存储数据的方式。 数据结构与算法紧密相连。数据结构是算法的基石，而算法是数据结构发挥作用的舞台。 我们可以将数据结构与算法类比为拼装积木，积木代表数据，积木的形状和连接方式等代表数据结构，拼装积木的步骤则对应算法。 Q\u0026A Q：作为一名程序员，我在日常工作中从未用算法解决过问题，常用算法都被编程语言封装好了，直接用就可以了；这是否意味着我们工作中的问题还没有到达需要算法的程度？\n如果把具体的工作技能比作是武功的“招式”的话，那么基础科目应该更像是“内功”。\n我认为学算法（以及其他基础科目）的意义不是在于在工作中从零实现它，而是基于学到的知识，在解决问题时能够作出专业的反应和判断，从而提升工作的整体质量。举一个简单例子，每种编程语言都内置了排序函数：\n如果我们没有学过数据结构与算法，那么给定任何数据，我们可能都塞给这个排序函数去做了。运行顺畅、性能不错，看上去并没有什么问题。 但如果学过算法，我们就会知道内置排序函数的时间复杂度是 𝑂(𝑛log⁡𝑛) ；而如果给定的数据是固定位数的整数（例如学号），那么我们就可以用效率更高的“基数排序”来做，将时间复杂度降为 𝑂(𝑛𝑘) ，其中 𝑘 为位数。当数据体量很大时，节省出来的运行时间就能创造较大价值（成本降低、体验变好等）。 在工程领域中，大量问题是难以达到最优解的，许多问题只是被“差不多”地解决了。问题的难易程度一方面取决于问题本身的性质，另一方面也取决于观测问题的人的知识储备。人的知识越完备、经验越多，分析问题就会越深入，问题就能被解决得更优雅。\n复杂度分析 算法效率评估 在算法设计中，我们先后追求以下两个层面的目标。\n找到问题解法：算法需要在规定的输入范围内可靠地求得问题的正确解。 寻求最优解法：同一个问题可能存在多种解法，我们希望找到尽可能高效的算法。 也就是说，在能够解决问题的前提下，算法效率已成为衡量算法优劣的主要评价指标，它包括以下两个维度。\n时间效率：算法运行速度的快慢。 空间效率：算法占用内存空间的大小。 简而言之，我们的目标是设计“既快又省”的数据结构与算法。而有效地评估算法效率至关重要，因为只有这样，我们才能将各种算法进行对比，进而指导算法设计与优化过程。\n效率评估方法主要分为两种：实际测试、理论估算。\n实际测试 假设我们现在有算法 A 和算法 B ，它们都能解决同一问题，现在需要对比这两个算法的效率。最直接的方法是找一台计算机，运行这两个算法，并监控记录它们的运行时间和内存占用情况。这种评估方式能够反映真实情况，但也存在较大的局限性。\n一方面，难以排除测试环境的干扰因素。硬件配置会影响算法的性能。比如在某台计算机中，算法 A 的运行时间比算法 B 短；但在另一台配置不同的计算机中，可能得到相反的测试结果。这意味着我们需要在各种机器上进行测试，统计平均效率，而这是不现实的。\n另一方面，展开完整测试非常耗费资源。随着输入数据量的变化，算法会表现出不同的效率。例如，在输入数据量较小时，算法 A 的运行时间比算法 B 短；而在输入数据量较大时，测试结果可能恰恰相反。因此，为了得到有说服力的结论，我们需要测试各种规模的输入数据，而这需要耗费大量的计算资源。\n理论估算 由于实际测试具有较大的局限性，因此我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。\n复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系。它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势。这个定义有些拗口，我们可以将其分为三个重点来理解。\n“时间和空间资源”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。 “随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。 “时间和空间的增长趋势”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”。 复杂度分析克服了实际测试方法的弊端，体现在以下两个方面。\n它独立于测试环境，分析结果适用于所有运行平台。 它可以体现不同数据量下的算法效率，尤其是在大数据量下的算法性能。 复杂度分析为我们提供了一把评估算法效率的“标尺”，使我们可以衡量执行某个算法所需的时间和空间资源，对比不同算法之间的效率。\n复杂度是个数学概念，对于初学者可能比较抽象，学习难度相对较高。从这个角度看，复杂度分析可能不太适合作为最先介绍的内容。然而，当我们讨论某个数据结构或算法的特点时，难以避免要分析其运行速度和空间使用情况。\n综上所述，建议你在深入学习数据结构与算法之前，先对复杂度分析建立初步的了解，以便能够完成简单算法的复杂度分析。\n迭代与递归 在算法中，重复执行某个任务是很常见的，它与复杂度分析息息相关。因此，在介绍时间复杂度和空间复杂度之前，我们先来了解如何在程序中实现重复执行任务，即两种基本的程序控制结构：迭代、递归。\n迭代 迭代（iteration）是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。\nfor 循环 for 循环是最常见的迭代形式之一，适合在预先知道迭代次数时使用。以下函数基于 for 循环实现了求和 1+2+⋯+𝑛 ，求和结果使用变量 res 记录。\n1 2 3 4 5 6 7 8 9 /* for 循环 */ int forLoop(int n) { int res = 0; // 循环求和 1, 2, ..., n-1, n for (int i = 1; i \u003c= n; i++) { res += i; } return res; } 下图是是该求和函数的流程框图。\n此求和函数的操作数量与输入数据大小 𝑛 成正比，或者说成“线性关系”。实际上，时间复杂度描述的就是这个“线性关系”。\nwhile循环 与 for 循环类似，while 循环也是一种实现迭代的方法。在 while 循环中，程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环。下面我们用 while 循环来实现求和 1+2+⋯+𝑛 ：\n1 2 3 4 5 6 7 8 9 10 11 /* while 循环 */ int whileLoop(int n) { int res = 0; int i = 1; // 初始化条件变量 // 循环求和 1, 2, ..., n-1, n while (i \u003c= n) { res += i; i++; // 更新条件变量 } return res; } while 循环比 for 循环的自由度更高。在 while 循环中，我们可以自由地设计条件变量的初始化和更新步骤。\n例如在以下代码中，条件变量 𝑖 每轮进行两次更新，这种情况就不太方便用 for 循环实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* while 循环（两次更新） */ int whileLoopII(int n) { int res = 0; int i = 1; // 初始化条件变量 // 循环求和 1, 4, 10, ... while (i \u003c= n) { res += i; // 更新条件变量 i++; i *= 2; } return res; } 总的来说，for 循环的代码更加紧凑，while 循环更加灵活，两者都可以实现迭代结构。选择使用哪一个应该根据特定问题的需求来决定。\n嵌套循环 我们可以在一个循环结构内嵌套另一个循环结构，下面以 for 循环为例：\n1 2 3 4 5 6 7 8 9 10 11 12 /* 双层 for 循环 */ String nestedForLoop(int n) { StringBuilder res = new StringBuilder(); // 循环 i = 1, 2, ..., n-1, n for (int i = 1; i \u003c= n; i++) { // 循环 j = 1, 2, ..., n-1, n for (int j = 1; j \u003c= n; j++) { res.append(\"(\" + i + \", \" + j + \"), \"); } } return res.toString(); } 下图是该嵌套循环的流程框图。\n在这种情况下，函数的操作数量与 𝑛2 成正比，或者说算法运行时间和输入数据大小 𝑛 成“平方关系”。我们可以继续添加嵌套循环，每一次嵌套都是一次“升维”，将会使时间复杂度提高至“立方关系”“四次方关系”，以此类推。\n递归 递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。\n递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。 归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。 而从实现的角度看，递归代码主要包含三个要素。\n终止条件：用于决定什么时候由“递”转“归”。 递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数。 返回结果：对应“归”，将当前递归层级的结果返回至上一层。 观察以下代码，我们只需调用函数 recur(n) ，就可以完成 1+2+⋯+𝑛 的计算：\n1 2 3 4 5 6 7 8 9 10 11 /* 递归 */ int recur(int n) { // 终止条件 if (n == 1){ return 1; } // 递：递归调用 int res = recur(n - 1); // 归：返回结果 return n + res; } 图 2-3 展示了该函数的递归过程。\n虽然从计算角度看，迭代与递归可以得到相同的结果，但它们代表了两种完全不同的思考和解决问题的范式。\n迭代：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。 递归：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。 以上述求和函数为例，设问题 𝑓(𝑛)=1+2+⋯+𝑛 。\n迭代：在循环中模拟求和过程，从 1 遍历到 𝑛 ，每轮执行求和操作，即可求得 𝑓(𝑛) 。 递归：将问题分解为子问题 𝑓(𝑛)=𝑛+𝑓(𝑛−1) ，不断（递归地）分解下去，直至基本情况 𝑓(1)=1 时终止。 调用栈 递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。\n函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，递归通常比迭代更加耗费内存空间。 递归调用函数会产生额外的开销。因此递归通常比循环的时间效率更低。 如图 2-4 所示，在触发终止条件前，同时存在 𝑛 个未返回的递归函数，递归深度为 𝑛 。\n在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出错误。\n尾递归 有趣的是，如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。\n普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。 尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。 以计算 1+2+⋯+𝑛 为例，我们可以将结果变量 res 设为函数参数，从而实现尾递归：\n1 2 3 4 5 6 7 8 /* 尾递归 */ int tailRecur(int n, int res) { // 终止条件 if (n == 0) return res; // 尾递归调用 return tailRecur(n - 1, res + n); } 尾递归的执行过程如图 2-5 所示。对比普通递归和尾递归，两者的求和操作的执行点是不同的。\n普通递归：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。 尾递归：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。 递归树 当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。以“斐波那契数列”为例。\n给定一个斐波那契数列 0,1,1,2,3,5,8,13,… ，求该数列的第 𝑛 个数字。\n设斐波那契数列的第 𝑛 个数字为 𝑓(𝑛) ，易得两个结论。\n数列的前两个数字为 𝑓(1)=0 和 𝑓(2)=1 。 数列中的每个数字是前两个数字的和，即 𝑓(𝑛)=𝑓(𝑛−1)+𝑓(𝑛−2) 。 按照递推关系进行递归调用，将前两个数字作为终止条件，便可写出递归代码。调用 fib(n) 即可得到斐波那契数列的第 𝑛 个数字：\n1 2 3 4 5 6 7 8 9 10 /* 斐波那契数列：递归 */ int fib(int n) { // 终止条件 f(1) = 0, f(2) = 1 if (n == 1 || n == 2) return n - 1; // 递归调用 f(n) = f(n-1) + f(n-2) int res = fib(n - 1) + fib(n - 2); // 返回结果 f(n) return res; } 观察以上代码，我们在函数内递归调用了两个函数，这意味着从一个调用产生了两个调用分支。如图 2-6 所示，这样不断递归调用下去，最终将产生一棵层数为 𝑛 的递归树（recursion tree）。\n从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。\n从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。 从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。 迭代和递归的对比 总结以上内容，如表 2-1 所示，迭代和递归在实现、性能和适用性上有所不同。\n表 2-1 迭代与递归特点对比\n迭代 递归 实现方式 循环结构 函数调用自身 时间效率 效率通常较高，无函数调用开销 每次函数调用都会产生开销 内存使用 通常使用固定大小的内存空间 累积函数调用可能使用大量的栈帧空间 适用问题 适用于简单循环任务，代码直观、可读性好 适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰 那么，迭代和递归具有什么内在联系呢？以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，这种工作机制与栈的“先入后出”原则异曲同工。\n事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。\n递：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。 归：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。 因此，我们可以使用一个显式的栈来模拟调用栈的行为，从而将递归转化为迭代形式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 使用迭代模拟递归 */ int forLoopRecur(int n) { // 使用一个显式的栈来模拟系统调用栈 Stack stack = new Stack\u003c\u003e(); int res = 0; // 递：递归调用 for (int i = n; i \u003e 0; i--) { // 通过“入栈操作”模拟“递” stack.push(i); } // 归：返回结果 while (!stack.isEmpty()) { // 通过“出栈操作”模拟“归” res += stack.pop(); } // res = 1+2+3+...+n return res; } 观察以上代码，当递归转化为迭代后，代码变得更加复杂了。尽管迭代和递归在很多情况下可以互相转化，但不一定值得这样做，有以下两点原因。\n转化后的代码可能更加难以理解，可读性更差。 对于某些复杂问题，模拟系统调用栈的行为可能非常困难。 总之，选择迭代还是递归取决于特定问题的性质。在编程实践中，权衡两者的优劣并根据情境选择合适的方法至关重要。\n时间复杂度 运行时间可以直观且准确地反映算法的效率。如果我们想准确预估一段代码的运行时间，应该如何操作呢？\n确定运行平台，包括硬件配置、编程语言、系统环境等，这些因素都会影响代码的运行效率。 评估各种计算操作所需的运行时间，例如加法操作 + 需要 1 ns ，乘法操作 * 需要 10 ns ，打印操作 print() 需要 5 ns 等。 统计代码中所有的计算操作，并将所有操作的执行时间求和，从而得到运行时间。 例如在以下代码中，输入数据大小为 𝑛 ：\n1 2 3 4 5 6 7 8 9 10 // 在某运行平台下 void algorithm(int n) { int a = 2; // 1 ns a = a + 1; // 1 ns a = a * 2; // 10 ns // 循环 n 次 for (int i = 0; i \u003c n; i++) { // 1 ns ，每轮都要执行 i++ System.out.println(0); // 5 ns } } 根据以上方法，可以得到算法的运行时间为 (6𝑛+12) ns ：\n1+1+10+(1+5)×𝑛=6𝑛+12\n但实际上，统计算法的运行时间既不合理也不现实。首先，我们不希望将预估时间和运行平台绑定，因为算法需要在各种不同的平台上运行。其次，我们很难获知每种操作的运行时间，这给预估过程带来了极大的难度。\n统计时间增长趋势 时间复杂度分析统计的不是算法运行时间，而是算法运行时间随着数据量变大时的增长趋势。\n“时间增长趋势”这个概念比较抽象，我们通过一个例子来加以理解。假设输入数据大小为 𝑛 ，给定三个算法 A、B 和 C ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // 算法 A 的时间复杂度：常数阶 void algorithm_A(int n) { System.out.println(0); } // 算法 B 的时间复杂度：线性阶 void algorithm_B(int n) { for (int i = 0; i \u003c n; i++) { System.out.println(0); } } // 算法 C 的时间复杂度：常数阶 void algorithm_C(int n) { for (int i = 0; i \u003c 1000000; i++) { System.out.println(0); } } 图 2-7 展示了以上三个算法函数的时间复杂度。\n算法 A 只有 1 个打印操作，算法运行时间不随着 𝑛 增大而增长。我们称此算法的时间复杂度为“常数阶”。 算法 B 中的打印操作需要循环 𝑛 次，算法运行时间随着 𝑛 增大呈线性增长。此算法的时间复杂度被称为“线性阶”。 算法 C 中的打印操作需要循环 1000000 次，虽然运行时间很长，但它与输入数据大小 𝑛 无关。因此 C 的时间复杂度和 A 相同，仍为“常数阶”。 相较于直接统计算法的运行时间，时间复杂度分析有哪些特点呢？\n时间复杂度能够有效评估算法效率。例如，算法 B 的运行时间呈线性增长，在 𝑛\u003e1 时比算法 A 更慢，在 𝑛\u003e1000000 时比算法 C 更慢。事实上，只要输入数据大小 𝑛 足够大，复杂度为“常数阶”的算法一定优于“线性阶”的算法，这正是时间增长趋势的含义。 时间复杂度的推算方法更简便。显然，运行平台和计算操作类型都与算法运行时间的增长趋势无关。因此在时间复杂度分析中，我们可以简单地将所有计算操作的执行时间视为相同的“单位时间”，从而将“计算操作运行时间统计”简化为“计算操作数量统计”，这样一来估算难度就大大降低了。 时间复杂度也存在一定的局限性。例如，尽管算法 A 和 C 的时间复杂度相同，但实际运行时间差别很大。同样，尽管算法 B 的时间复杂度比 C 高，但在输入数据大小 𝑛 较小时，算法 B 明显优于算法 C 。在这些情况下，我们很难仅凭时间复杂度判断算法效率的高低。当然，尽管存在上述问题，复杂度分析仍然是评判算法效率最有效且常用的方法。 函数渐进上届 给定一个输入大小为 𝑛 的函数：\n1 2 3 4 5 6 7 8 9 void algorithm(int n) { int a = 1; // +1 a = a + 1; // +1 a = a * 2; // +1 // 循环 n 次 for (int i = 0; i \u003c n; i++) { // +1（每轮都执行 i ++） System.out.println(0); // +1 } } 设算法的操作数量是一个关于输入数据大小 𝑛 的函数，记为 𝑇(𝑛) ，则以上函数的操作数量为：\n𝑇(𝑛)=3+2𝑛\n𝑇(𝑛) 是一次函数，说明其运行时间的增长趋势是线性的，因此它的时间复杂度是线性阶。\n我们将线性阶的时间复杂度记为 𝑂(𝑛) ，这个数学符号称为大 𝑂 记号（big-𝑂 notation），表示函数 𝑇(𝑛) 的渐近上界（asymptotic upper bound）。\n时间复杂度分析本质上是计算“操作数量 𝑇(𝑛)”的渐近上界，它具有明确的数学定义。\n函数渐近上界\n若存在正实数 𝑐 和实数 𝑛0 ，使得对于所有的 𝑛\u003e𝑛0 ，均有 𝑇(𝑛)≤𝑐⋅𝑓(𝑛) ，则可认为 𝑓(𝑛) 给出了 𝑇(𝑛) 的一个渐近上界，记为 𝑇(𝑛)=𝑂(𝑓(𝑛)) 。\n如图 2-8 所示，计算渐近上界就是寻找一个函数 𝑓(𝑛) ，使得当 𝑛 趋向于无穷大时，𝑇(𝑛) 和 𝑓(𝑛) 处于相同的增长级别，仅相差一个常数项 𝑐 的倍数。\n推算方法 渐近上界的数学味儿有点重，如果你感觉没有完全理解，也无须担心。我们可以先掌握推算方法，在不断的实践中，就可以逐渐领悟其数学意义。\n根据定义，确定 𝑓(𝑛) 之后，我们便可得到时间复杂度 𝑂(𝑓(𝑛)) 。那么如何确定渐近上界 𝑓(𝑛) 呢？总体分为两步：首先统计操作数量，然后判断渐近上界。\n第一步：统计操作数量 针对代码，逐行从上到下计算即可。然而，由于上述 𝑐⋅𝑓(𝑛) 中的常数项 𝑐 可以取任意大小，因此操作数量 𝑇(𝑛) 中的各种系数、常数项都可以忽略。根据此原则，可以总结出以下计数简化技巧。\n忽略 𝑇(𝑛) 中的常数项。因为它们都与 𝑛 无关，所以对时间复杂度不产生影响。 省略所有系数。例如，循环 2𝑛 次、5𝑛+1 次等，都可以简化记为 𝑛 次，因为 𝑛 前面的系数对时间复杂度没有影响。 循环嵌套时使用乘法。总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然可以分别套用第 1. 点和第 2. 点的技巧。 给定一个函数，我们可以用上述技巧来统计操作数量：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 void algorithm(int n) { int a = 1; // +0（技巧 1） a = a + n; // +0（技巧 1） // +n（技巧 2） for (int i = 0; i \u003c 5 * n + 1; i++) { System.out.println(0); } // +n*n（技巧 3） for (int i = 0; i \u003c 2 * n; i++) { for (int j = 0; j \u003c n + 1; j++) { System.out.println(0); } } } 以下公式展示了使用上述技巧前后的统计结果，两者推算出的时间复杂度都为 𝑂(𝑛2 ) 。\n1 2 3 𝑇(𝑛) = 2𝑛(𝑛 + 1) + (5𝑛 + 1) + 2 完整统计 (‑.‑|||) = 2𝑛2 + 7𝑛 + 3 𝑇(𝑛) = 𝑛2 + 𝑛 偷懒统计 (o.O) 第二步：判断渐近上界\n时间复杂度由 𝑇(𝑛) 中最高阶的项来决定。这是因为在 𝑛 趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以忽略。\n表 2-2 展示了一些例子，其中一些夸张的值是为了强调“系数无法撼动阶数”这一结论。当 𝑛 趋于无穷大时，这些常数变得无足轻重。\n表 2-2 不同操作数量对应的时间复杂度\n操作数量 𝑇(𝑛) 时间复杂度 𝑂(𝑓(𝑛)) 100000 𝑂(1) 3𝑛+2 𝑂(𝑛) 2𝑛2+3𝑛+2 𝑂(𝑛2) 𝑛3+10000𝑛2 𝑂(𝑛3) 2𝑛+10000𝑛10000 𝑂(2𝑛) 常见类型 设输入数据大小为 𝑛 ，常见的时间复杂度类型如图 2‑9 所示（按照从低到高的顺序排列）。\n1 2 𝑂(1) \u003c 𝑂(log 𝑛) \u003c 𝑂(𝑛) \u003c 𝑂(𝑛 log 𝑛) \u003c 𝑂(𝑛2 ) \u003c 𝑂(2𝑛) \u003c 𝑂(𝑛!) 常数阶 \u003c 对数阶 \u003c 线性阶 \u003c 线性对数阶 \u003c 平方阶 \u003c 指数阶 \u003c 阶乘阶 常数阶 𝑂(1) 常数阶的操作数量与输入数据大小 𝑛 无关，即不随着 𝑛 的变化而变化。\n在以下函数中，尽管操作数量 size 可能很大，但由于其与输入数据大小 𝑛 无关，因此时间复杂度仍为 𝑂(1) ：\n1 2 3 4 5 6 7 8 /* 常数阶 */ int constant(int n) { int count = 0; int size = 100000; for (int i = 0; i \u003c size; i++) count++; return count; } 线性阶 𝑂(𝑛) 线性阶的操作数量相对于输入数据大小 𝑛 以线性级别增长。线性阶通常出现在单层循环中：\n1 2 3 4 5 6 7 /* 线性阶 */ int linear(int n) { int count = 0; for (int i = 0; i \u003c n; i++) count++; return count; } 遍历数组和遍历链表等操作的时间复杂度均为 𝑂(𝑛) ，其中 𝑛 为数组或链表的长度：\n1 2 3 4 5 6 7 8 9 /* 线性阶（遍历数组） */ int arrayTraversal(int[] nums) { int count = 0; // 循环次数与数组长度成正比 for (int num : nums) { count++; } return count; } 值得注意的是，输入数据大小 𝑛 需根据输入数据的类型来具体确定。比如在第一个示例中，变量 𝑛 为输入数据大小；在第二个示例中，数组长度 𝑛 为数据大小。\n平方阶 𝑂(𝑛2) 平方阶的操作数量相对于输入数据大小 𝑛 以平方级别增长。平方阶通常出现在嵌套循环中，外层循环和内层循环的时间复杂度都为 𝑂(𝑛) ，因此总体的时间复杂度为 𝑂(𝑛2) ：\n1 2 3 4 5 6 7 8 9 10 11 /* 平方阶 */ int quadratic(int n) { int count = 0; // 循环次数与数据大小 n 成平方关系 for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c n; j++) { count++; } } return count; } 图 2-10 对比了常数阶、线性阶和平方阶三种时间复杂度。\n以冒泡排序为例，外层循环执行 𝑛−1 次，内层循环执行 𝑛−1、𝑛−2、…、2、1 次，平均为 𝑛/2 次，因此时间复杂度为 𝑂((𝑛−1)𝑛/2)=𝑂(𝑛2) ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 平方阶（冒泡排序） */ int bubbleSort(int[] nums) { int count = 0; // 计数器 // 外循环：未排序区间为 [0, i] for (int i = nums.length - 1; i \u003e 0; i--) { // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端 for (int j = 0; j \u003c i; j++) { if (nums[j] \u003e nums[j + 1]) { // 交换 nums[j] 与 nums[j + 1] int tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; count += 3; // 元素交换包含 3 个单元操作 } } } return count; } 指数阶 𝑂(2𝑛) 生物学的“细胞分裂”是指数阶增长的典型例子：初始状态为 1 个细胞，分裂一轮后变为 2 个，分裂两轮后变为 4 个，以此类推，分裂 𝑛 轮后有 2𝑛 个细胞。\n图 2-11 和以下代码模拟了细胞分裂的过程，时间复杂度为 𝑂(2𝑛) ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* 指数阶（循环实现） */ int exponential(int n) { int count = 0, base = 1; // 细胞每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1) for (int i = 0; i \u003c n; i++) { for (int j = 0; j \u003c base; j++) { count++; } base *= 2; } // count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1 return count; } 在实际算法中，指数阶常出现于递归函数中。例如在以下代码中，其递归地一分为二，经过 𝑛 次分裂后停止：\n1 2 3 4 5 6 /* 指数阶（递归实现） */ int expRecur(int n) { if (n == 1) return 1; return expRecur(n - 1) + expRecur(n - 1) + 1; } 指数阶增长非常迅速，在穷举法（暴力搜索、回溯等）中比较常见。对于数据规模较大的问题，指数阶是不可接受的，通常需要使用动态规划或贪心算法等来解决。\n对数阶 𝑂(log⁡𝑛) 与指数阶相反，对数阶反映了“每轮缩减到一半”的情况。设输入数据大小为 𝑛 ，由于每轮缩减到一半，因此循环次数是 log2⁡𝑛 ，即 2𝑛 的反函数。\n图 2-12 和以下代码模拟了“每轮缩减到一半”的过程，时间复杂度为 𝑂(log2⁡𝑛) ，简记为 𝑂(log⁡𝑛) ：\n1 2 3 4 5 6 7 8 9 /* 对数阶（循环实现） */ int logarithmic(int n) { int count = 0; while (n \u003e 1) { n = n / 2; count++; } return count; } 与指数阶类似，对数阶也常出现于递归函数中。以下代码形成了一棵高度为 log2⁡𝑛 的递归树：\n1 2 3 4 5 6 /* 对数阶（递归实现） */ int logRecur(int n) { if (n \u003c= 1) return 0; return logRecur(n / 2) + 1; } 对数阶常出现于基于分治策略的算法中，体现了“一分为多”和“化繁为简”的算法思想。它增长缓慢，是仅次于常数阶的理想的时间复杂度。\n𝑂(log 𝑛) 的底数是多少？\n准确来说，“一分为 𝑚”对应的时间复杂度是 𝑂(log𝑚 𝑛) 。而通过对数换底公式，我们可以得到具有 不同底数、相等的时间复杂度： 𝑂(log𝑚 𝑛) = 𝑂(log𝑘 𝑛/ log𝑘 𝑚) = 𝑂(log𝑘 𝑛) 也就是说，底数 𝑚 可以在不影响复杂度的前提下转换。因此我们通常会省略底数 𝑚 ，将对数阶直接 记为 𝑂(log 𝑛) 。\n线性对数阶 𝑂(𝑛log⁡𝑛) 线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 𝑂(log⁡𝑛) 和 𝑂(𝑛) 。相关代码如下：\n1 2 3 4 5 6 7 8 9 10 /* 线性对数阶 */ int linearLogRecur(int n) { if (n \u003c= 1) return 1; int count = linearLogRecur(n / 2) + linearLogRecur(n / 2); for (int i = 0; i \u003c n; i++) { count++; } return count; } 图 2-13 展示了线性对数阶的生成方式。二叉树的每一层的操作总数都为 𝑛 ，树共有 log2⁡𝑛+1 层，因此时间复杂度为 𝑂(𝑛log⁡𝑛) 。\n主流排序算法的时间复杂度通常为 𝑂(𝑛log⁡𝑛) ，例如快速排序、归并排序、堆排序等。\n阶乘阶 𝑂(𝑛!) 阶乘阶对应数学上的“全排列”问题。给定 𝑛 个互不重复的元素，求其所有可能的排列方案，方案数量为：\n𝑛! = 𝑛 × (𝑛 − 1) × (𝑛 − 2) × ⋯ × 2 × 1\n阶乘通常使用递归实现。如图 2‑14 和以下代码所示，第一层分裂出 𝑛 个，第二层分裂出 𝑛 − 1 个，以此类 推，直至第 𝑛 层时停止分裂：\n1 2 3 4 5 6 7 8 9 10 11 /* 阶乘阶（递归实现） */ int factorialRecur(int n) { if (n == 0) return 1; int count = 0; // 从 1 个分裂出 n 个 for (int i = 0; i \u003c n; i++) { count += factorialRecur(n - 1); } return count; } 请注意，因为当 𝑛 ≥ 4 时恒有 𝑛! \u003e 2𝑛 ，所以阶乘阶比指数阶增长得更快，在 𝑛 较大时也是不可接受的。\n最差、最佳、平均时间复杂度 算法的时间效率往往不是固定的，而是与输入数据的分布有关。假设输入一个长度为 𝑛 的数组 nums ，其中 nums 由从 1 至 𝑛 的数字组成，每个数字只出现一次；但元素顺序是随机打乱的，任务目标是返回元素 1 的索引。我们可以得出以下结论。\n当 nums = [?, ?, ..., 1] ，即当末尾元素是 1 时，需要完整遍历数组，达到最差时间复杂度 𝑂(𝑛) 。 当 nums = [1, ?, ?, ...] ，即当首个元素为 1 时，无论数组多长都不需要继续遍历，达到最佳时间复杂度 Ω(1) 。 “最差时间复杂度”对应函数渐近上界，使用大 𝑂 记号表示。相应地，“最佳时间复杂度”对应函数渐近下界，用 Ω 记号表示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* 生成一个数组，元素为 { 1, 2, ..., n }，顺序被打乱 */ int[] randomNumbers(int n) { Integer[] nums = new Integer[n]; // 生成数组 nums = { 1, 2, 3, ..., n } for (int i = 0; i \u003c n; i++) { nums[i] = i + 1; } // 随机打乱数组元素 Collections.shuffle(Arrays.asList(nums)); // Integer[] -\u003e int[] int[] res = new int[n]; for (int i = 0; i \u003c n; i++) { res[i] = nums[i]; } return res; } /* 查找数组 nums 中数字 1 所在索引 */ int findOne(int[] nums) { for (int i = 0; i \u003c nums.length; i++) { // 当元素 1 在数组头部时，达到最佳时间复杂度 O(1) // 当元素 1 在数组尾部时，达到最差时间复杂度 O(n) if (nums[i] == 1) return i; } return -1; } 值得说明的是，我们在实际中很少使用最佳时间复杂度，因为通常只有在很小概率下才能达到，可能会带来一定的误导性。而最差时间复杂度更为实用，因为它给出了一个效率安全值，让我们可以放心地使用算法。\n从上述示例可以看出，最差时间复杂度和最佳时间复杂度只出现于“特殊的数据分布”，这些情况的出现概率可能很小，并不能真实地反映算法运行效率。相比之下，平均时间复杂度可以体现算法在随机输入数据下的运行效率，用 Θ 记号来表示。\n对于部分算法，我们可以简单地推算出随机数据分布下的平均情况。比如上述示例，由于输入数组是被打乱的，因此元素 1 出现在任意索引的概率都是相等的，那么算法的平均循环次数就是数组长度的一半 𝑛/2 ，平均时间复杂度为 Θ(𝑛/2)=Θ(𝑛) 。\n但对于较为复杂的算法，计算平均时间复杂度往往比较困难，因为很难分析出在数据分布下的整体数学期望。在这种情况下，我们通常使用最差时间复杂度作为算法效率的评判标准。\n为什么很少看到 Θ 符号？\n可能由于 𝑂 符号过于朗朗上口，因此我们常常使用它来表示平均时间复杂度。但从严格意义上讲，这 种做法并不规范。在本书和其他资料中，若遇到类似“平均时间复杂度 𝑂(𝑛)”的表述，请将其直接 理解为 Θ(𝑛) 。\n",
  "wordCount" : "12899",
  "inLanguage": "en",
  "datePublished": "2024-04-30T12:03:30Z",
  "dateModified": "2024-04-30T12:03:30Z",
  "author":{
    "@type": "Person",
    "name": "Wjy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://funny-toffee-4aa7c3.netlify.app/posts/%E7%AE%97%E6%B3%95/%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Wjy's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://funny-toffee-4aa7c3.netlify.app/favicon.ico"
    }
  }
}
</script>

  <script id="MathJax-script" async src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-chtml-full.min.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath:  [['\\(', '\\)'], ['$', '$']],  
    }
  };
</script>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://funny-toffee-4aa7c3.netlify.app/" accesskey="h" title="Wjy&#39;s Blog (Alt + H)">Wjy&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://funny-toffee-4aa7c3.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://funny-toffee-4aa7c3.netlify.app/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      初识算法
    </h1>
    <div class="post-meta"><span title='2024-04-30 12:03:30 +0000 UTC'>2024-04-30</span>&nbsp;·&nbsp;Wjy

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%88%9d%e8%af%86%e7%ae%97%e6%b3%95" aria-label="初识算法">初识算法</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%97%a0%e5%a4%84%e4%b8%8d%e5%9c%a8" aria-label="算法无处不在">算法无处不在</a></li>
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%98%af%e4%bb%80%e4%b9%88" aria-label="算法是什么">算法是什么</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e5%ae%9a%e4%b9%89" aria-label="算法定义">算法定义</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%ae%9a%e4%b9%89" aria-label="数据结构定义">数据结构定义</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%e7%9a%84%e5%85%b3%e7%b3%bb" aria-label="数据结构与算法的关系">数据结构与算法的关系</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b0%8f%e7%bb%93" aria-label="小结">小结</a></li>
                <li>
                    <a href="#qa" aria-label="Q&amp;A">Q&amp;A</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90" aria-label="复杂度分析">复杂度分析</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%95%88%e7%8e%87%e8%af%84%e4%bc%b0" aria-label="算法效率评估">算法效率评估</a><ul>
                        
                <li>
                    <a href="#%e5%ae%9e%e9%99%85%e6%b5%8b%e8%af%95" aria-label="实际测试">实际测试</a></li>
                <li>
                    <a href="#%e7%90%86%e8%ae%ba%e4%bc%b0%e7%ae%97" aria-label="理论估算">理论估算</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%ad%e4%bb%a3%e4%b8%8e%e9%80%92%e5%bd%92" aria-label="迭代与递归">迭代与递归</a><ul>
                        
                <li>
                    <a href="#%e8%bf%ad%e4%bb%a3" aria-label="迭代">迭代</a><ul>
                        
                <li>
                    <a href="#for-%e5%be%aa%e7%8e%af" aria-label="for 循环">for 循环</a></li>
                <li>
                    <a href="#while%e5%be%aa%e7%8e%af" aria-label="while循环">while循环</a></li>
                <li>
                    <a href="#%e5%b5%8c%e5%a5%97%e5%be%aa%e7%8e%af" aria-label="嵌套循环">嵌套循环</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%80%92%e5%bd%92" aria-label="递归">递归</a><ul>
                        
                <li>
                    <a href="#%e8%b0%83%e7%94%a8%e6%a0%88" aria-label="调用栈">调用栈</a></li>
                <li>
                    <a href="#%e5%b0%be%e9%80%92%e5%bd%92" aria-label="尾递归">尾递归</a></li>
                <li>
                    <a href="#%e9%80%92%e5%bd%92%e6%a0%91" aria-label="递归树">递归树</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%ad%e4%bb%a3%e5%92%8c%e9%80%92%e5%bd%92%e7%9a%84%e5%af%b9%e6%af%94" aria-label="迭代和递归的对比">迭代和递归的对比</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6" aria-label="时间复杂度">时间复杂度</a><ul>
                        
                <li>
                    <a href="#%e7%bb%9f%e8%ae%a1%e6%97%b6%e9%97%b4%e5%a2%9e%e9%95%bf%e8%b6%8b%e5%8a%bf" aria-label="统计时间增长趋势">统计时间增长趋势</a></li>
                <li>
                    <a href="#%e5%87%bd%e6%95%b0%e6%b8%90%e8%bf%9b%e4%b8%8a%e5%b1%8a" aria-label="函数渐进上届">函数渐进上届</a></li>
                <li>
                    <a href="#%e6%8e%a8%e7%ae%97%e6%96%b9%e6%b3%95" aria-label="推算方法">推算方法</a></li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e7%b1%bb%e5%9e%8b" aria-label="常见类型">常见类型</a><ul>
                        
                <li>
                    <a href="#%e5%b8%b8%e6%95%b0%e9%98%b6-%f0%9d%91%821" aria-label="常数阶 𝑂(1)">常数阶 𝑂(1)</a></li>
                <li>
                    <a href="#%e7%ba%bf%e6%80%a7%e9%98%b6-%f0%9d%91%82%f0%9d%91%9b" aria-label="线性阶 𝑂(𝑛)">线性阶 𝑂(𝑛)</a></li>
                <li>
                    <a href="#%e5%b9%b3%e6%96%b9%e9%98%b6-%f0%9d%91%82%f0%9d%91%9b2" aria-label="平方阶 𝑂(𝑛2)">平方阶 𝑂(𝑛2)</a></li>
                <li>
                    <a href="#%e6%8c%87%e6%95%b0%e9%98%b6-%f0%9d%91%822%f0%9d%91%9b" aria-label="指数阶 𝑂(2𝑛)">指数阶 𝑂(2𝑛)</a></li>
                <li>
                    <a href="#%e5%af%b9%e6%95%b0%e9%98%b6-%f0%9d%91%82log%f0%9d%91%9b" aria-label="对数阶 𝑂(log⁡𝑛)">对数阶 𝑂(log⁡𝑛)</a></li>
                <li>
                    <a href="#%e7%ba%bf%e6%80%a7%e5%af%b9%e6%95%b0%e9%98%b6-%f0%9d%91%82%f0%9d%91%9blog%f0%9d%91%9b" aria-label="线性对数阶 𝑂(𝑛log⁡𝑛)">线性对数阶 𝑂(𝑛log⁡𝑛)</a></li>
                <li>
                    <a href="#%e9%98%b6%e4%b9%98%e9%98%b6-%f0%9d%91%82%f0%9d%91%9b" aria-label="阶乘阶 𝑂(𝑛!)">阶乘阶 𝑂(𝑛!)</a></li>
                <li>
                    <a href="#%e6%9c%80%e5%b7%ae%e6%9c%80%e4%bd%b3%e5%b9%b3%e5%9d%87%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6" aria-label="最差、最佳、平均时间复杂度">最差、最佳、平均时间复杂度</a>
                </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="初识算法">初识算法<a hidden class="anchor" aria-hidden="true" href="#初识算法">#</a></h1>
<h2 id="算法无处不在">算法无处不在<a hidden class="anchor" aria-hidden="true" href="#算法无处不在">#</a></h2>
<p>当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖基本逻辑，这些逻辑在我们的日常生活中处处可见。</p>
<p>在正式探讨算法之前，有一个有趣的事实值得分享：<strong>你已经在不知不觉中学会了许多算法，并习惯将它们应用到日常生活中了</strong>。下面我将举几个具体的例子来证实这一点。</p>
<p><strong>例一：查字典</strong>。在字典里，每个汉字都对应一个拼音，而字典是按照拼音字母顺序排列的。假设我们需要查找一个拼音首字母为 𝑟 的字，通常会按照图 1-1 所示的方式实现。</p>
<ol>
<li>翻开字典约一半的页数，查看该页的首字母是什么，假设首字母为 𝑚 。</li>
<li>由于在拼音字母表中 𝑟 位于 𝑚 之后，所以排除字典前半部分，查找范围缩小到后半部分。</li>
<li>不断重复步骤 <code>1.</code> 和 步骤 <code>2.</code> ，直至找到拼音首字母为 𝑟 的页码为止。</li>
</ol>
<p><img loading="lazy" src="binary_search_dictionary_step1.png" alt=""  />
</p>
<p><img loading="lazy" src="binary_search_dictionary_step2.png" alt=""  />
</p>
<p><img loading="lazy" src="binary_search_dictionary_step3.png" alt=""  />
</p>
<p><img loading="lazy" src="binary_search_dictionary_step4.png" alt=""  />
</p>
<p><img loading="lazy" src="binary_search_dictionary_step5.png" alt=""  />
</p>
<p>个小学生必备技能，实际上就是著名的“二分查找”算法。从数据结构的角度，我们可以把字典视为一个已排序的“数组”；从算法的角度，我们可以将上述查字典的一系列操作看作“二分查找”。</p>
<p><strong>例二：整理扑克</strong>。我们在打牌时，每局都需要整理手中的扑克牌，使其从小到大排列，实现流程如图 1-2 所示。</p>
<ol>
<li>将扑克牌划分为“有序”和“无序”两部分，并假设初始状态下最左 1 张扑克牌已经有序。</li>
<li>在无序部分抽出一张扑克牌，插入至有序部分的正确位置；完成后最左 2 张扑克已经有序。</li>
<li>不断循环步骤 <code>2.</code> ，每一轮将一张扑克牌从无序部分插入至有序部分，直至所有扑克牌都有序。</li>
</ol>
<p><img loading="lazy" src="playing_cards_sorting.png" alt=""  />
</p>
<p>上述整理扑克牌的方法本质上是“插入排序”算法，它在处理小型数据集时非常高效。许多编程语言的排序库函数中都有插入排序的身影。</p>
<p><strong>例三：货币找零</strong>。假设我们在超市购买了 69 元的商品，给了收银员 100 元，则收银员需要找我们 31 元。他会很自然地完成如图 1-3 所示的思考。</p>
<ol>
<li>可选项是比 31 元面值更小的货币，包括 1 元、5 元、10 元、20 元。</li>
<li>从可选项中拿出最大的 20 元，剩余 31−20=11 元。</li>
<li>从剩余可选项中拿出最大的 10 元，剩余 11−10=1 元。</li>
<li>从剩余可选项中拿出最大的 1 元，剩余 1−1=0 元。</li>
<li>完成找零，方案为 20+10+1=31 元。</li>
</ol>
<p><img loading="lazy" src="greedy_change.png" alt=""  />
</p>
<p>在以上步骤中，我们每一步都采取当前看来最好的选择（尽可能用大面额的货币），最终得到了可行的找零方案。从数据结构与算法的角度看，这种方法本质上是“贪心”算法。</p>
<p>小到烹饪一道菜，大到星际航行，几乎所有问题的解决都离不开算法。计算机的出现使得我们能够通过编程将数据结构存储在内存中，同时编写代码调用 CPU 和 GPU 执行算法。这样一来，我们就能把生活中的问题转移到计算机上，以更高效的方式解决各种复杂问题。</p>
<h2 id="算法是什么">算法是什么<a hidden class="anchor" aria-hidden="true" href="#算法是什么">#</a></h2>
<h3 id="算法定义">算法定义<a hidden class="anchor" aria-hidden="true" href="#算法定义">#</a></h3>
<p>算法（algorithm）是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性。</p>
<ul>
<li>问题是明确的，包含清晰的输入和输出定义。</li>
<li>具有可行性，能够在有限步骤、时间和内存空间下完成。</li>
<li>各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。</li>
</ul>
<h3 id="数据结构定义">数据结构定义<a hidden class="anchor" aria-hidden="true" href="#数据结构定义">#</a></h3>
<p>数据结构（data structure）是计算机中组织和存储数据的方式，具有以下设计目标。</p>
<ul>
<li>空间占用尽量少，以节省计算机内存。</li>
<li>数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。</li>
<li>提供简洁的数据表示和逻辑信息，以便算法高效运行。</li>
</ul>
<p><strong>数据结构设计是一个充满权衡的过程</strong>。如果想在某方面取得提升，往往需要在另一方面作出妥协。下面举两个例子。</p>
<ul>
<li>链表相较于数组，在数据添加和删除操作上更加便捷，但牺牲了数据访问速度。</li>
<li>图相较于链表，提供了更丰富的逻辑信息，但需要占用更大的内存空间。</li>
</ul>
<h3 id="数据结构与算法的关系">数据结构与算法的关系<a hidden class="anchor" aria-hidden="true" href="#数据结构与算法的关系">#</a></h3>
<p>数据结构与算法高度相关、紧密结合，具体表现在以下三个方面。</p>
<ul>
<li>数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。</li>
<li>算法是数据结构发挥作用的舞台。数据结构本身仅存储数据信息，结合算法才能解决特定问题。</li>
<li>算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。</li>
</ul>
<p><img loading="lazy" src="relationship_between_data_structure_and_algorithm.png" alt=""  />
</p>
<p>值得说明的是，数据结构与算法是独立于编程语言的。</p>
<h2 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h2>
<ul>
<li>算法在日常生活中无处不在，并不是遥不可及的高深知识。实际上，我们已经在不知不觉中学会了许多算法，用以解决生活中的大小问题。</li>
<li>查字典的原理与二分查找算法相一致。二分查找算法体现了分而治之的重要算法思想。</li>
<li>整理扑克的过程与插入排序算法非常类似。插入排序算法适合排序小型数据集。</li>
<li>货币找零的步骤本质上是贪心算法，每一步都采取当前看来最好的选择。</li>
<li>算法是在有限时间内解决特定问题的一组指令或操作步骤，而数据结构是计算机中组织和存储数据的方式。</li>
<li>数据结构与算法紧密相连。数据结构是算法的基石，而算法是数据结构发挥作用的舞台。</li>
<li>我们可以将数据结构与算法类比为拼装积木，积木代表数据，积木的形状和连接方式等代表数据结构，拼装积木的步骤则对应算法。</li>
</ul>
<h2 id="qa">Q&amp;A<a hidden class="anchor" aria-hidden="true" href="#qa">#</a></h2>
<p><strong>Q</strong>：作为一名程序员，我在日常工作中从未用算法解决过问题，常用算法都被编程语言封装好了，直接用就可以了；这是否意味着我们工作中的问题还没有到达需要算法的程度？</p>
<p>如果把具体的工作技能比作是武功的“招式”的话，那么基础科目应该更像是“内功”。</p>
<p>我认为学算法（以及其他基础科目）的意义不是在于在工作中从零实现它，而是基于学到的知识，在解决问题时能够作出专业的反应和判断，从而提升工作的整体质量。举一个简单例子，每种编程语言都内置了排序函数：</p>
<ul>
<li>如果我们没有学过数据结构与算法，那么给定任何数据，我们可能都塞给这个排序函数去做了。运行顺畅、性能不错，看上去并没有什么问题。</li>
<li>但如果学过算法，我们就会知道内置排序函数的时间复杂度是 𝑂(𝑛log⁡𝑛) ；而如果给定的数据是固定位数的整数（例如学号），那么我们就可以用效率更高的“基数排序”来做，将时间复杂度降为 𝑂(𝑛𝑘) ，其中 𝑘 为位数。当数据体量很大时，节省出来的运行时间就能创造较大价值（成本降低、体验变好等）。</li>
</ul>
<p>在工程领域中，大量问题是难以达到最优解的，许多问题只是被“差不多”地解决了。问题的难易程度一方面取决于问题本身的性质，另一方面也取决于观测问题的人的知识储备。人的知识越完备、经验越多，分析问题就会越深入，问题就能被解决得更优雅。</p>
<h1 id="复杂度分析">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析">#</a></h1>
<h2 id="算法效率评估">算法效率评估<a hidden class="anchor" aria-hidden="true" href="#算法效率评估">#</a></h2>
<p>在算法设计中，我们先后追求以下两个层面的目标。</p>
<ol>
<li><strong>找到问题解法</strong>：算法需要在规定的输入范围内可靠地求得问题的正确解。</li>
<li><strong>寻求最优解法</strong>：同一个问题可能存在多种解法，我们希望找到尽可能高效的算法。</li>
</ol>
<p>也就是说，在能够解决问题的前提下，算法效率已成为衡量算法优劣的主要评价指标，它包括以下两个维度。</p>
<ul>
<li><strong>时间效率</strong>：算法运行速度的快慢。</li>
<li><strong>空间效率</strong>：算法占用内存空间的大小。</li>
</ul>
<p>简而言之，<strong>我们的目标是设计“既快又省”的数据结构与算法</strong>。而有效地评估算法效率至关重要，因为只有这样，我们才能将各种算法进行对比，进而指导算法设计与优化过程。</p>
<p>效率评估方法主要分为两种：实际测试、理论估算。</p>
<h3 id="实际测试">实际测试<a hidden class="anchor" aria-hidden="true" href="#实际测试">#</a></h3>
<p>假设我们现在有算法 <code>A</code> 和算法 <code>B</code> ，它们都能解决同一问题，现在需要对比这两个算法的效率。最直接的方法是找一台计算机，运行这两个算法，并监控记录它们的运行时间和内存占用情况。这种评估方式能够反映真实情况，但也存在较大的局限性。</p>
<p>一方面，<strong>难以排除测试环境的干扰因素</strong>。硬件配置会影响算法的性能。比如在某台计算机中，算法 <code>A</code> 的运行时间比算法 <code>B</code> 短；但在另一台配置不同的计算机中，可能得到相反的测试结果。这意味着我们需要在各种机器上进行测试，统计平均效率，而这是不现实的。</p>
<p>另一方面，<strong>展开完整测试非常耗费资源</strong>。随着输入数据量的变化，算法会表现出不同的效率。例如，在输入数据量较小时，算法 <code>A</code> 的运行时间比算法 <code>B</code> 短；而在输入数据量较大时，测试结果可能恰恰相反。因此，为了得到有说服力的结论，我们需要测试各种规模的输入数据，而这需要耗费大量的计算资源。</p>
<h3 id="理论估算">理论估算<a hidden class="anchor" aria-hidden="true" href="#理论估算">#</a></h3>
<p>由于实际测试具有较大的局限性，因此我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。</p>
<p>复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系。<strong>它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势</strong>。这个定义有些拗口，我们可以将其分为三个重点来理解。</p>
<ul>
<li>“时间和空间资源”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。</li>
<li>“随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。</li>
<li>“时间和空间的增长趋势”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”。</li>
</ul>
<p><strong>复杂度分析克服了实际测试方法的弊端</strong>，体现在以下两个方面。</p>
<ul>
<li>它独立于测试环境，分析结果适用于所有运行平台。</li>
<li>它可以体现不同数据量下的算法效率，尤其是在大数据量下的算法性能。</li>
</ul>
<p>复杂度分析为我们提供了一把评估算法效率的“标尺”，使我们可以衡量执行某个算法所需的时间和空间资源，对比不同算法之间的效率。</p>
<p>复杂度是个数学概念，对于初学者可能比较抽象，学习难度相对较高。从这个角度看，复杂度分析可能不太适合作为最先介绍的内容。然而，当我们讨论某个数据结构或算法的特点时，难以避免要分析其运行速度和空间使用情况。</p>
<p>综上所述，建议你在深入学习数据结构与算法之前，<strong>先对复杂度分析建立初步的了解，以便能够完成简单算法的复杂度分析</strong>。</p>
<h2 id="迭代与递归">迭代与递归<a hidden class="anchor" aria-hidden="true" href="#迭代与递归">#</a></h2>
<p>在算法中，重复执行某个任务是很常见的，它与复杂度分析息息相关。因此，在介绍时间复杂度和空间复杂度之前，我们先来了解如何在程序中实现重复执行任务，即两种基本的程序控制结构：迭代、递归。</p>
<h3 id="迭代">迭代<a hidden class="anchor" aria-hidden="true" href="#迭代">#</a></h3>
<p>迭代（iteration）是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。</p>
<h4 id="for-循环">for 循环<a hidden class="anchor" aria-hidden="true" href="#for-循环">#</a></h4>
<p><code>for</code> 循环是最常见的迭代形式之一，<strong>适合在预先知道迭代次数时使用</strong>。以下函数基于 <code>for</code> 循环实现了求和 1+2+⋯+𝑛 ，求和结果使用变量 <code>res</code> 记录。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* for 循环 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> forLoop(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> res = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 循环求和 1, 2, ..., n-1, n
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt;= n; i++) {
</span></span><span style="display:flex;"><span>        res += i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>下图是是该求和函数的流程框图。</p>
<p><img loading="lazy" src="iteration.png" alt=""  />
</p>
<p>此求和函数的操作数量与输入数据大小 𝑛 成正比，或者说成“线性关系”。实际上，<strong>时间复杂度描述的就是这个“线性关系”</strong>。</p>
<h4 id="while循环">while循环<a hidden class="anchor" aria-hidden="true" href="#while循环">#</a></h4>
<p>与 <code>for</code> 循环类似，<code>while</code> 循环也是一种实现迭代的方法。在 <code>while</code> 循环中，程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环。下面我们用 <code>while</code> 循环来实现求和 1+2+⋯+𝑛 ：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* while 循环 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> whileLoop(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> res = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; <span style="color:#007f7f">// 初始化条件变量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 循环求和 1, 2, ..., n-1, n
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">while</span> (i &lt;= n) {
</span></span><span style="display:flex;"><span>        res += i;
</span></span><span style="display:flex;"><span>        i++; <span style="color:#007f7f">// 更新条件变量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong><code>while</code> 循环比 <code>for</code> 循环的自由度更高</strong>。在 <code>while</code> 循环中，我们可以自由地设计条件变量的初始化和更新步骤。</p>
<p>例如在以下代码中，条件变量 𝑖 每轮进行两次更新，这种情况就不太方便用 <code>for</code> 循环实现：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* while 循环（两次更新） */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> whileLoopII(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> res = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; <span style="color:#007f7f">// 初始化条件变量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 循环求和 1, 4, 10, ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">while</span> (i &lt;= n) {
</span></span><span style="display:flex;"><span>        res += i;
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 更新条件变量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        i++;
</span></span><span style="display:flex;"><span>        i *= <span style="color:#ff0;font-weight:bold">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>总的来说，<strong><code>for</code> 循环的代码更加紧凑，<code>while</code> 循环更加灵活</strong>，两者都可以实现迭代结构。选择使用哪一个应该根据特定问题的需求来决定。</p>
<h4 id="嵌套循环">嵌套循环<a hidden class="anchor" aria-hidden="true" href="#嵌套循环">#</a></h4>
<p>我们可以在一个循环结构内嵌套另一个循环结构，下面以 <code>for</code> 循环为例：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 双层 for 循环 */</span>
</span></span><span style="display:flex;"><span>String nestedForLoop(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    StringBuilder res = <span style="color:#fff;font-weight:bold">new</span> StringBuilder();
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 循环 i = 1, 2, ..., n-1, n
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt;= n; i++) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 循环 j = 1, 2, ..., n-1, n
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = <span style="color:#ff0;font-weight:bold">1</span>; j &lt;= n; j++) {
</span></span><span style="display:flex;"><span>            res.<span style="color:#007f7f">append</span>(<span style="color:#0ff;font-weight:bold">&#34;(&#34;</span> + i + <span style="color:#0ff;font-weight:bold">&#34;, &#34;</span> + j + <span style="color:#0ff;font-weight:bold">&#34;), &#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> res.<span style="color:#007f7f">toString</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>下图是该嵌套循环的流程框图。</p>
<p><img loading="lazy" src="nested_iteration.png" alt=""  />
</p>
<p>在这种情况下，函数的操作数量与 𝑛2 成正比，或者说算法运行时间和输入数据大小 𝑛 成“平方关系”。我们可以继续添加嵌套循环，每一次嵌套都是一次“升维”，将会使时间复杂度提高至“立方关系”“四次方关系”，以此类推。</p>
<h3 id="递归">递归<a hidden class="anchor" aria-hidden="true" href="#递归">#</a></h3>
<p>递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。</p>
<ol>
<li><strong>递</strong>：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li>
<li><strong>归</strong>：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li>
</ol>
<p>而从实现的角度看，递归代码主要包含三个要素。</p>
<ol>
<li><strong>终止条件</strong>：用于决定什么时候由“递”转“归”。</li>
<li><strong>递归调用</strong>：对应“递”，函数调用自身，通常输入更小或更简化的参数。</li>
<li><strong>返回结果</strong>：对应“归”，将当前递归层级的结果返回至上一层。</li>
</ol>
<p>观察以下代码，我们只需调用函数 <code>recur(n)</code> ，就可以完成 1+2+⋯+𝑛 的计算：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 递归 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> recur(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 终止条件
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (n == <span style="color:#ff0;font-weight:bold">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 递：递归调用
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> res = recur(n - <span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 归：返回结果
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> n + res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>图 2-3 展示了该函数的递归过程。</p>
<p><img loading="lazy" src="recursion_sum.png" alt="图 2-3 求和函数的递归过程"  />
</p>
<p>虽然从计算角度看，迭代与递归可以得到相同的结果，<strong>但它们代表了两种完全不同的思考和解决问题的范式</strong>。</p>
<ul>
<li><strong>迭代</strong>：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。</li>
<li><strong>递归</strong>：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。</li>
</ul>
<p>以上述求和函数为例，设问题 𝑓(𝑛)=1+2+⋯+𝑛 。</p>
<ul>
<li><strong>迭代</strong>：在循环中模拟求和过程，从 1 遍历到 𝑛 ，每轮执行求和操作，即可求得 𝑓(𝑛) 。</li>
<li><strong>递归</strong>：将问题分解为子问题 𝑓(𝑛)=𝑛+𝑓(𝑛−1) ，不断（递归地）分解下去，直至基本情况 𝑓(1)=1 时终止。</li>
</ul>
<h4 id="调用栈">调用栈<a hidden class="anchor" aria-hidden="true" href="#调用栈">#</a></h4>
<p>递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。</p>
<ul>
<li>函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，<strong>递归通常比迭代更加耗费内存空间</strong>。</li>
<li>递归调用函数会产生额外的开销。<strong>因此递归通常比循环的时间效率更低</strong>。</li>
</ul>
<p>如图 2-4 所示，在触发终止条件前，同时存在 𝑛 个未返回的递归函数，<strong>递归深度为 𝑛</strong> 。</p>
<p><img loading="lazy" src="recursion_sum_depth.png" alt="图 2-4  递归调用深度"  />
</p>
<p>在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出错误。</p>
<h4 id="尾递归">尾递归<a hidden class="anchor" aria-hidden="true" href="#尾递归">#</a></h4>
<p>有趣的是，<strong>如果函数在返回前的最后一步才进行递归调用</strong>，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。</p>
<ul>
<li><strong>普通递归</strong>：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。</li>
<li><strong>尾递归</strong>：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。</li>
</ul>
<p>以计算 1+2+⋯+𝑛 为例，我们可以将结果变量 <code>res</code> 设为函数参数，从而实现尾递归：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 尾递归 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> tailRecur(<span style="color:#fff;font-weight:bold">int</span> n, <span style="color:#fff;font-weight:bold">int</span> res) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 终止条件
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (n == <span style="color:#ff0;font-weight:bold">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 尾递归调用
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> tailRecur(n - <span style="color:#ff0;font-weight:bold">1</span>, res + n);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>尾递归的执行过程如图 2-5 所示。对比普通递归和尾递归，两者的求和操作的执行点是不同的。</p>
<ul>
<li><strong>普通递归</strong>：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。</li>
<li><strong>尾递归</strong>：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。</li>
</ul>
<p><img loading="lazy" src="tail_recursion_sum.png" alt=""  />
</p>
<h4 id="递归树">递归树<a hidden class="anchor" aria-hidden="true" href="#递归树">#</a></h4>
<p>当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。以“斐波那契数列”为例。</p>
<p>给定一个斐波那契数列 0,1,1,2,3,5,8,13,… ，求该数列的第 𝑛 个数字。</p>
<p>设斐波那契数列的第 𝑛 个数字为 𝑓(𝑛) ，易得两个结论。</p>
<ul>
<li>数列的前两个数字为 𝑓(1)=0 和 𝑓(2)=1 。</li>
<li>数列中的每个数字是前两个数字的和，即 𝑓(𝑛)=𝑓(𝑛−1)+𝑓(𝑛−2) 。</li>
</ul>
<p>按照递推关系进行递归调用，将前两个数字作为终止条件，便可写出递归代码。调用 <code>fib(n)</code> 即可得到斐波那契数列的第 𝑛 个数字：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 斐波那契数列：递归 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> fib(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 终止条件 f(1) = 0, f(2) = 1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (n == <span style="color:#ff0;font-weight:bold">1</span> || n == <span style="color:#ff0;font-weight:bold">2</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> n - <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 递归调用 f(n) = f(n-1) + f(n-2)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> res = fib(n - <span style="color:#ff0;font-weight:bold">1</span>) + fib(n - <span style="color:#ff0;font-weight:bold">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 返回结果 f(n)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>观察以上代码，我们在函数内递归调用了两个函数，<strong>这意味着从一个调用产生了两个调用分支</strong>。如图 2-6 所示，这样不断递归调用下去，最终将产生一棵层数为 𝑛 的递归树（recursion tree）。</p>
<p><img loading="lazy" src="recursion_tree.png" alt=""  />
</p>
<p>从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。</p>
<ul>
<li>从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。</li>
<li>从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。</li>
</ul>
<h3 id="迭代和递归的对比">迭代和递归的对比<a hidden class="anchor" aria-hidden="true" href="#迭代和递归的对比">#</a></h3>
<p>总结以上内容，如表 2-1 所示，迭代和递归在实现、性能和适用性上有所不同。</p>
<p>表 2-1  迭代与递归特点对比</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">迭代</th>
<th style="text-align:left">递归</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">实现方式</td>
<td style="text-align:left">循环结构</td>
<td style="text-align:left">函数调用自身</td>
</tr>
<tr>
<td style="text-align:left">时间效率</td>
<td style="text-align:left">效率通常较高，无函数调用开销</td>
<td style="text-align:left">每次函数调用都会产生开销</td>
</tr>
<tr>
<td style="text-align:left">内存使用</td>
<td style="text-align:left">通常使用固定大小的内存空间</td>
<td style="text-align:left">累积函数调用可能使用大量的栈帧空间</td>
</tr>
<tr>
<td style="text-align:left">适用问题</td>
<td style="text-align:left">适用于简单循环任务，代码直观、可读性好</td>
<td style="text-align:left">适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰</td>
</tr>
</tbody>
</table>
<p>那么，迭代和递归具有什么内在联系呢？以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，<strong>这种工作机制与栈的“先入后出”原则异曲同工</strong>。</p>
<p>事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。</p>
<ol>
<li><strong>递</strong>：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。</li>
<li><strong>归</strong>：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。</li>
</ol>
<p>因此，<strong>我们可以使用一个显式的栈来模拟调用栈的行为</strong>，从而将递归转化为迭代形式：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 使用迭代模拟递归 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> forLoopRecur(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 使用一个显式的栈来模拟系统调用栈
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    Stack&lt;Integer&gt; stack = <span style="color:#fff;font-weight:bold">new</span> Stack&lt;&gt;();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> res = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 递：递归调用
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = n; i &gt; <span style="color:#ff0;font-weight:bold">0</span>; i--) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 通过“入栈操作”模拟“递”
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        stack.<span style="color:#007f7f">push</span>(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 归：返回结果
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">while</span> (!stack.<span style="color:#007f7f">isEmpty</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 通过“出栈操作”模拟“归”
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        res += stack.<span style="color:#007f7f">pop</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// res = 1+2+3+...+n
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>观察以上代码，当递归转化为迭代后，代码变得更加复杂了。尽管迭代和递归在很多情况下可以互相转化，但不一定值得这样做，有以下两点原因。</p>
<ul>
<li>转化后的代码可能更加难以理解，可读性更差。</li>
<li>对于某些复杂问题，模拟系统调用栈的行为可能非常困难。</li>
</ul>
<p>总之，<strong>选择迭代还是递归取决于特定问题的性质</strong>。在编程实践中，权衡两者的优劣并根据情境选择合适的方法至关重要。</p>
<h2 id="时间复杂度">时间复杂度<a hidden class="anchor" aria-hidden="true" href="#时间复杂度">#</a></h2>
<p>运行时间可以直观且准确地反映算法的效率。如果我们想准确预估一段代码的运行时间，应该如何操作呢？</p>
<ol>
<li><strong>确定运行平台</strong>，包括硬件配置、编程语言、系统环境等，这些因素都会影响代码的运行效率。</li>
<li><strong>评估各种计算操作所需的运行时间</strong>，例如加法操作 <code>+</code> 需要 1 ns ，乘法操作 <code>*</code> 需要 10 ns ，打印操作 <code>print()</code> 需要 5 ns 等。</li>
<li><strong>统计代码中所有的计算操作</strong>，并将所有操作的执行时间求和，从而得到运行时间。</li>
</ol>
<p>例如在以下代码中，输入数据大小为 𝑛 ：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">// 在某运行平台下
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">void</span> algorithm(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> a = <span style="color:#ff0;font-weight:bold">2</span>;  <span style="color:#007f7f">// 1 ns
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    a = a + <span style="color:#ff0;font-weight:bold">1</span>;  <span style="color:#007f7f">// 1 ns
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    a = a * <span style="color:#ff0;font-weight:bold">2</span>;  <span style="color:#007f7f">// 10 ns
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 循环 n 次
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; i++) {  <span style="color:#007f7f">// 1 ns ，每轮都要执行 i++
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#ff0;font-weight:bold">0</span>);     <span style="color:#007f7f">// 5 ns
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>根据以上方法，可以得到算法的运行时间为 (6𝑛+12) ns ：</p>
<p><code>1+1+10+(1+5)×𝑛=6𝑛+12</code></p>
<p>但实际上，<strong>统计算法的运行时间既不合理也不现实</strong>。首先，我们不希望将预估时间和运行平台绑定，因为算法需要在各种不同的平台上运行。其次，我们很难获知每种操作的运行时间，这给预估过程带来了极大的难度。</p>
<h3 id="统计时间增长趋势">统计时间增长趋势<a hidden class="anchor" aria-hidden="true" href="#统计时间增长趋势">#</a></h3>
<p>时间复杂度分析统计的不是算法运行时间，<strong>而是算法运行时间随着数据量变大时的增长趋势</strong>。</p>
<p>“时间增长趋势”这个概念比较抽象，我们通过一个例子来加以理解。假设输入数据大小为 𝑛 ，给定三个算法 <code>A</code>、<code>B</code> 和 <code>C</code> ：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">// 算法 A 的时间复杂度：常数阶
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">void</span> algorithm_A(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 算法 B 的时间复杂度：线性阶
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">void</span> algorithm_B(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; i++) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 算法 C 的时间复杂度：常数阶
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">void</span> algorithm_C(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; <span style="color:#ff0;font-weight:bold">1000000</span>; i++) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>图 2-7 展示了以上三个算法函数的时间复杂度。</p>
<ul>
<li>算法 <code>A</code> 只有 1 个打印操作，算法运行时间不随着 𝑛 增大而增长。我们称此算法的时间复杂度为“常数阶”。</li>
<li>算法 <code>B</code> 中的打印操作需要循环 𝑛 次，算法运行时间随着 𝑛 增大呈线性增长。此算法的时间复杂度被称为“线性阶”。</li>
<li>算法 <code>C</code> 中的打印操作需要循环 1000000 次，虽然运行时间很长，但它与输入数据大小 𝑛 无关。因此 <code>C</code> 的时间复杂度和 <code>A</code> 相同，仍为“常数阶”。</li>
</ul>
<p><img loading="lazy" src="time_complexity_simple_example.png" alt=""  />
</p>
<p>相较于直接统计算法的运行时间，时间复杂度分析有哪些特点呢？</p>
<ul>
<li><strong>时间复杂度能够有效评估算法效率</strong>。例如，算法 <code>B</code> 的运行时间呈线性增长，在 𝑛&gt;1 时比算法 <code>A</code> 更慢，在 𝑛&gt;1000000 时比算法 <code>C</code> 更慢。事实上，只要输入数据大小 𝑛 足够大，复杂度为“常数阶”的算法一定优于“线性阶”的算法，这正是时间增长趋势的含义。</li>
<li><strong>时间复杂度的推算方法更简便</strong>。显然，运行平台和计算操作类型都与算法运行时间的增长趋势无关。因此在时间复杂度分析中，我们可以简单地将所有计算操作的执行时间视为相同的“单位时间”，从而将“计算操作运行时间统计”简化为“计算操作数量统计”，这样一来估算难度就大大降低了。</li>
<li><strong>时间复杂度也存在一定的局限性</strong>。例如，尽管算法 <code>A</code> 和 <code>C</code> 的时间复杂度相同，但实际运行时间差别很大。同样，尽管算法 <code>B</code> 的时间复杂度比 <code>C</code> 高，但在输入数据大小 𝑛 较小时，算法 <code>B</code> 明显优于算法 <code>C</code> 。在这些情况下，我们很难仅凭时间复杂度判断算法效率的高低。当然，尽管存在上述问题，复杂度分析仍然是评判算法效率最有效且常用的方法。</li>
</ul>
<h3 id="函数渐进上届">函数渐进上届<a hidden class="anchor" aria-hidden="true" href="#函数渐进上届">#</a></h3>
<p>给定一个输入大小为 𝑛 的函数：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> algorithm(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> a = <span style="color:#ff0;font-weight:bold">1</span>;  <span style="color:#007f7f">// +1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    a = a + <span style="color:#ff0;font-weight:bold">1</span>;  <span style="color:#007f7f">// +1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    a = a * <span style="color:#ff0;font-weight:bold">2</span>;  <span style="color:#007f7f">// +1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 循环 n 次
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; i++) { <span style="color:#007f7f">// +1（每轮都执行 i ++）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#ff0;font-weight:bold">0</span>);    <span style="color:#007f7f">// +1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>设算法的操作数量是一个关于输入数据大小 𝑛 的函数，记为 𝑇(𝑛) ，则以上函数的操作数量为：</p>
<p><code>𝑇(𝑛)=3+2𝑛</code></p>
<p>𝑇(𝑛) 是一次函数，说明其运行时间的增长趋势是线性的，因此它的时间复杂度是线性阶。</p>
<p>我们将线性阶的时间复杂度记为 𝑂(𝑛) ，这个数学符号称为大 𝑂 记号（big-𝑂 notation），表示函数 𝑇(𝑛) 的渐近上界（asymptotic upper bound）。</p>
<p>时间复杂度分析本质上是计算“操作数量 𝑇(𝑛)”的渐近上界，它具有明确的数学定义。</p>
<blockquote>
<p>函数渐近上界</p>
<p>若存在正实数 𝑐 和实数 𝑛0 ，使得对于所有的 𝑛&gt;𝑛0 ，均有 𝑇(𝑛)≤𝑐⋅𝑓(𝑛) ，则可认为 𝑓(𝑛) 给出了 𝑇(𝑛) 的一个渐近上界，记为 𝑇(𝑛)=𝑂(𝑓(𝑛)) 。</p>
</blockquote>
<p>如图 2-8 所示，计算渐近上界就是寻找一个函数 𝑓(𝑛) ，使得当 𝑛 趋向于无穷大时，𝑇(𝑛) 和 𝑓(𝑛) 处于相同的增长级别，仅相差一个常数项 𝑐 的倍数。</p>
<p><img loading="lazy" src="asymptotic_upper_bound.png" alt=""  />
</p>
<h3 id="推算方法">推算方法<a hidden class="anchor" aria-hidden="true" href="#推算方法">#</a></h3>
<p>渐近上界的数学味儿有点重，如果你感觉没有完全理解，也无须担心。我们可以先掌握推算方法，在不断的实践中，就可以逐渐领悟其数学意义。</p>
<p>根据定义，确定 𝑓(𝑛) 之后，我们便可得到时间复杂度 𝑂(𝑓(𝑛)) 。那么如何确定渐近上界 𝑓(𝑛) 呢？总体分为两步：首先统计操作数量，然后判断渐近上界。</p>
<ol>
<li>第一步：统计操作数量</li>
</ol>
<p>针对代码，逐行从上到下计算即可。然而，由于上述 𝑐⋅𝑓(𝑛) 中的常数项 𝑐 可以取任意大小，<strong>因此操作数量 𝑇(𝑛) 中的各种系数、常数项都可以忽略</strong>。根据此原则，可以总结出以下计数简化技巧。</p>
<ol>
<li><strong>忽略 𝑇(𝑛) 中的常数项</strong>。因为它们都与 𝑛 无关，所以对时间复杂度不产生影响。</li>
<li><strong>省略所有系数</strong>。例如，循环 2𝑛 次、5𝑛+1 次等，都可以简化记为 𝑛 次，因为 𝑛 前面的系数对时间复杂度没有影响。</li>
<li><strong>循环嵌套时使用乘法</strong>。总操作数量等于外层循环和内层循环操作数量之积，每一层循环依然可以分别套用第 <code>1.</code> 点和第 <code>2.</code> 点的技巧。</li>
</ol>
<p>给定一个函数，我们可以用上述技巧来统计操作数量：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> algorithm(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> a = <span style="color:#ff0;font-weight:bold">1</span>;  <span style="color:#007f7f">// +0（技巧 1）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    a = a + n;  <span style="color:#007f7f">// +0（技巧 1）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// +n（技巧 2）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; <span style="color:#ff0;font-weight:bold">5</span> * n + <span style="color:#ff0;font-weight:bold">1</span>; i++) {
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// +n*n（技巧 3）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; <span style="color:#ff0;font-weight:bold">2</span> * n; i++) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = <span style="color:#ff0;font-weight:bold">0</span>; j &lt; n + <span style="color:#ff0;font-weight:bold">1</span>; j++) {
</span></span><span style="display:flex;"><span>            System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#ff0;font-weight:bold">0</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>以下公式展示了使用上述技巧前后的统计结果，两者推算出的时间复杂度都为 𝑂(𝑛2 ) 。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>𝑇(𝑛) = 2𝑛(𝑛 + 1) + (5𝑛 + 1) + 2 完整统计 (‑.‑|||) 
</span></span><span style="display:flex;"><span>	 = 2𝑛2 + 7𝑛 + 3
</span></span><span style="display:flex;"><span>𝑇(𝑛) = 𝑛2 + 𝑛             	    偷懒统计 (o.O)
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二步：判断渐近上界</p>
<p><strong>时间复杂度由 𝑇(𝑛) 中最高阶的项来决定</strong>。这是因为在 𝑛 趋于无穷大时，最高阶的项将发挥主导作用，其他项的影响都可以忽略。</p>
<p>表 2-2 展示了一些例子，其中一些夸张的值是为了强调“系数无法撼动阶数”这一结论。当 𝑛 趋于无穷大时，这些常数变得无足轻重。</p>
<p>表 2-2  不同操作数量对应的时间复杂度</p>
<table>
<thead>
<tr>
<th style="text-align:left">操作数量 𝑇(𝑛)</th>
<th style="text-align:left">时间复杂度 𝑂(𝑓(𝑛))</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">100000</td>
<td style="text-align:left">𝑂(1)</td>
</tr>
<tr>
<td style="text-align:left">3𝑛+2</td>
<td style="text-align:left">𝑂(𝑛)</td>
</tr>
<tr>
<td style="text-align:left">2𝑛2+3𝑛+2</td>
<td style="text-align:left">𝑂(𝑛2)</td>
</tr>
<tr>
<td style="text-align:left">𝑛3+10000𝑛2</td>
<td style="text-align:left">𝑂(𝑛3)</td>
</tr>
<tr>
<td style="text-align:left">2𝑛+10000𝑛10000</td>
<td style="text-align:left">𝑂(2𝑛)</td>
</tr>
</tbody>
</table>
<h3 id="常见类型">常见类型<a hidden class="anchor" aria-hidden="true" href="#常见类型">#</a></h3>
<p>设输入数据大小为 𝑛 ，常见的时间复杂度类型如图 2‑9 所示（按照从低到高的顺序排列）。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>𝑂(1) &lt; 𝑂(log 𝑛) &lt; 𝑂(𝑛) &lt; 𝑂(𝑛 log 𝑛) &lt; 𝑂(𝑛2 ) &lt; 𝑂(2𝑛) &lt; 𝑂(𝑛!)
</span></span><span style="display:flex;"><span>常数阶 &lt; 对数阶 &lt; 线性阶 &lt; 线性对数阶 &lt; 平方阶 &lt; 指数阶 &lt; 阶乘阶
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="time_complexity_common_types.png" alt="图 2-9  常见的时间复杂度类型"  />
</p>
<h4 id="常数阶-𝑂1">常数阶 𝑂(1)<a hidden class="anchor" aria-hidden="true" href="#常数阶-𝑂1">#</a></h4>
<p>常数阶的操作数量与输入数据大小 𝑛 无关，即不随着 𝑛 的变化而变化。</p>
<p>在以下函数中，尽管操作数量 <code>size</code> 可能很大，但由于其与输入数据大小 𝑛 无关，因此时间复杂度仍为 𝑂(1) ：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 常数阶 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> constant(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> count = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> size = <span style="color:#ff0;font-weight:bold">100000</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; size; i++)
</span></span><span style="display:flex;"><span>        count++;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> count;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="线性阶-𝑂𝑛">线性阶 𝑂(𝑛)<a hidden class="anchor" aria-hidden="true" href="#线性阶-𝑂𝑛">#</a></h4>
<p>线性阶的操作数量相对于输入数据大小 𝑛 以线性级别增长。线性阶通常出现在单层循环中：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 线性阶 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> linear(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> count = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; i++)
</span></span><span style="display:flex;"><span>        count++;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> count;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>遍历数组和遍历链表等操作的时间复杂度均为 𝑂(𝑛) ，其中 𝑛 为数组或链表的长度：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 线性阶（遍历数组） */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> arrayTraversal(<span style="color:#fff;font-weight:bold">int</span>[] nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> count = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 循环次数与数组长度成正比
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> num : nums) {
</span></span><span style="display:flex;"><span>        count++;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> count;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>值得注意的是，<strong>输入数据大小 𝑛 需根据输入数据的类型来具体确定</strong>。比如在第一个示例中，变量 𝑛 为输入数据大小；在第二个示例中，数组长度 𝑛 为数据大小。</p>
<h4 id="平方阶-𝑂𝑛2">平方阶 𝑂(𝑛2)<a hidden class="anchor" aria-hidden="true" href="#平方阶-𝑂𝑛2">#</a></h4>
<p>平方阶的操作数量相对于输入数据大小 𝑛 以平方级别增长。平方阶通常出现在嵌套循环中，外层循环和内层循环的时间复杂度都为 𝑂(𝑛) ，因此总体的时间复杂度为 𝑂(𝑛2) ：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 平方阶 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> quadratic(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> count = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 循环次数与数据大小 n 成平方关系
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; i++) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = <span style="color:#ff0;font-weight:bold">0</span>; j &lt; n; j++) {
</span></span><span style="display:flex;"><span>            count++;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> count;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>图 2-10 对比了常数阶、线性阶和平方阶三种时间复杂度。</p>
<p><img loading="lazy" src="time_complexity_constant_linear_quadratic.png" alt="图 2-10  常数阶、线性阶和平方阶的时间复杂度"  />
</p>
<p>以冒泡排序为例，外层循环执行 𝑛−1 次，内层循环执行 𝑛−1、𝑛−2、…、2、1 次，平均为 𝑛/2 次，因此时间复杂度为 𝑂((𝑛−1)𝑛/2)=𝑂(𝑛2) ：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 平方阶（冒泡排序） */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> bubbleSort(<span style="color:#fff;font-weight:bold">int</span>[] nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> count = <span style="color:#ff0;font-weight:bold">0</span>; <span style="color:#007f7f">// 计数器
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 外循环：未排序区间为 [0, i]
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = nums.<span style="color:#007f7f">length</span> - <span style="color:#ff0;font-weight:bold">1</span>; i &gt; <span style="color:#ff0;font-weight:bold">0</span>; i--) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = <span style="color:#ff0;font-weight:bold">0</span>; j &lt; i; j++) {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">if</span> (nums[j] &gt; nums[j + <span style="color:#ff0;font-weight:bold">1</span>]) {
</span></span><span style="display:flex;"><span>                <span style="color:#007f7f">// 交换 nums[j] 与 nums[j + 1]
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>                <span style="color:#fff;font-weight:bold">int</span> tmp = nums[j];
</span></span><span style="display:flex;"><span>                nums[j] = nums[j + <span style="color:#ff0;font-weight:bold">1</span>];
</span></span><span style="display:flex;"><span>                nums[j + <span style="color:#ff0;font-weight:bold">1</span>] = tmp;
</span></span><span style="display:flex;"><span>                count += <span style="color:#ff0;font-weight:bold">3</span>; <span style="color:#007f7f">// 元素交换包含 3 个单元操作
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> count;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="指数阶-𝑂2𝑛">指数阶 𝑂(2𝑛)<a hidden class="anchor" aria-hidden="true" href="#指数阶-𝑂2𝑛">#</a></h4>
<p>生物学的“细胞分裂”是指数阶增长的典型例子：初始状态为 1 个细胞，分裂一轮后变为 2 个，分裂两轮后变为 4 个，以此类推，分裂 𝑛 轮后有 2𝑛 个细胞。</p>
<p>图 2-11 和以下代码模拟了细胞分裂的过程，时间复杂度为 𝑂(2𝑛) ：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 指数阶（循环实现） */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> exponential(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> count = <span style="color:#ff0;font-weight:bold">0</span>, base = <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 细胞每轮一分为二，形成数列 1, 2, 4, 8, ..., 2^(n-1)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; i++) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = <span style="color:#ff0;font-weight:bold">0</span>; j &lt; base; j++) {
</span></span><span style="display:flex;"><span>            count++;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        base *= <span style="color:#ff0;font-weight:bold">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// count = 1 + 2 + 4 + 8 + .. + 2^(n-1) = 2^n - 1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> count;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="time_complexity_exponential.png" alt="图 2-11  指数阶的时间复杂度"  />
</p>
<p>在实际算法中，指数阶常出现于递归函数中。例如在以下代码中，其递归地一分为二，经过 𝑛 次分裂后停止：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 指数阶（递归实现） */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> expRecur(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (n == <span style="color:#ff0;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> expRecur(n - <span style="color:#ff0;font-weight:bold">1</span>) + expRecur(n - <span style="color:#ff0;font-weight:bold">1</span>) + <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>指数阶增长非常迅速，在穷举法（暴力搜索、回溯等）中比较常见。对于数据规模较大的问题，指数阶是不可接受的，通常需要使用动态规划或贪心算法等来解决。</p>
<h4 id="对数阶-𝑂log𝑛">对数阶 𝑂(log⁡𝑛)<a hidden class="anchor" aria-hidden="true" href="#对数阶-𝑂log𝑛">#</a></h4>
<p>与指数阶相反，对数阶反映了“每轮缩减到一半”的情况。设输入数据大小为 𝑛 ，由于每轮缩减到一半，因此循环次数是 log2⁡𝑛 ，即 2𝑛 的反函数。</p>
<p>图 2-12 和以下代码模拟了“每轮缩减到一半”的过程，时间复杂度为 𝑂(log2⁡𝑛) ，简记为 𝑂(log⁡𝑛) ：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 对数阶（循环实现） */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> logarithmic(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> count = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> (n &gt; <span style="color:#ff0;font-weight:bold">1</span>) {
</span></span><span style="display:flex;"><span>        n = n / <span style="color:#ff0;font-weight:bold">2</span>;
</span></span><span style="display:flex;"><span>        count++;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> count;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="time_complexity_logarithmic.png" alt="图 2-12  对数阶的时间复杂度"  />
</p>
<p>与指数阶类似，对数阶也常出现于递归函数中。以下代码形成了一棵高度为 log2⁡𝑛 的递归树：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 对数阶（递归实现） */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> logRecur(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (n &lt;= <span style="color:#ff0;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> logRecur(n / <span style="color:#ff0;font-weight:bold">2</span>) + <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>对数阶常出现于基于分治策略的算法中，体现了“一分为多”和“化繁为简”的算法思想。它增长缓慢，是仅次于常数阶的理想的时间复杂度。</p>
<blockquote>
<p>𝑂(log 𝑛) 的底数是多少？</p>
<p>准确来说，“一分为 𝑚”对应的时间复杂度是 𝑂(log𝑚 𝑛) 。而通过对数换底公式，我们可以得到具有 不同底数、相等的时间复杂度： 𝑂(log𝑚 𝑛) = 𝑂(log𝑘 𝑛/ log𝑘 𝑚) = 𝑂(log𝑘 𝑛) 也就是说，底数 𝑚 可以在不影响复杂度的前提下转换。因此我们通常会省略底数 𝑚 ，将对数阶直接 记为 𝑂(log 𝑛) 。</p>
</blockquote>
<h4 id="线性对数阶-𝑂𝑛log𝑛">线性对数阶 𝑂(𝑛log⁡𝑛)<a hidden class="anchor" aria-hidden="true" href="#线性对数阶-𝑂𝑛log𝑛">#</a></h4>
<p>线性对数阶常出现于嵌套循环中，两层循环的时间复杂度分别为 𝑂(log⁡𝑛) 和 𝑂(𝑛) 。相关代码如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 线性对数阶 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> linearLogRecur(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (n &lt;= <span style="color:#ff0;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> count = linearLogRecur(n / <span style="color:#ff0;font-weight:bold">2</span>) + linearLogRecur(n / <span style="color:#ff0;font-weight:bold">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; i++) {
</span></span><span style="display:flex;"><span>        count++;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> count;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>图 2-13 展示了线性对数阶的生成方式。二叉树的每一层的操作总数都为 𝑛 ，树共有 log2⁡𝑛+1 层，因此时间复杂度为 𝑂(𝑛log⁡𝑛) 。</p>
<p><img loading="lazy" src="time_complexity_logarithmic_linear.png" alt=""  />
</p>
<p>主流排序算法的时间复杂度通常为 𝑂(𝑛log⁡𝑛) ，例如快速排序、归并排序、堆排序等。</p>
<h4 id="阶乘阶-𝑂𝑛">阶乘阶 𝑂(𝑛!)<a hidden class="anchor" aria-hidden="true" href="#阶乘阶-𝑂𝑛">#</a></h4>
<p>阶乘阶对应数学上的“全排列”问题。给定 𝑛 个互不重复的元素，求其所有可能的排列方案，方案数量为：</p>
<p><code>𝑛! = 𝑛 × (𝑛 − 1) × (𝑛 − 2) × ⋯ × 2 × 1</code></p>
<p>阶乘通常使用递归实现。如图 2‑14 和以下代码所示，第一层分裂出 𝑛 个，第二层分裂出 𝑛 − 1 个，以此类 推，直至第 𝑛 层时停止分裂：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 阶乘阶（递归实现） */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> factorialRecur(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (n == <span style="color:#ff0;font-weight:bold">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> count = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 从 1 个分裂出 n 个
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; i++) {
</span></span><span style="display:flex;"><span>        count += factorialRecur(n - <span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> count;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="time_complexity_factorial.png" alt=""  />
</p>
<p>请注意，因为当 𝑛 ≥ 4 时恒有 𝑛! &gt; 2𝑛 ，所以阶乘阶比指数阶增长得更快，在 𝑛 较大时也是不可接受的。</p>
<h4 id="最差最佳平均时间复杂度">最差、最佳、平均时间复杂度<a hidden class="anchor" aria-hidden="true" href="#最差最佳平均时间复杂度">#</a></h4>
<p><strong>算法的时间效率往往不是固定的，而是与输入数据的分布有关</strong>。假设输入一个长度为 𝑛 的数组 <code>nums</code> ，其中 <code>nums</code> 由从 1 至 𝑛 的数字组成，每个数字只出现一次；但元素顺序是随机打乱的，任务目标是返回元素 1 的索引。我们可以得出以下结论。</p>
<ul>
<li>当 <code>nums = [?, ?, ..., 1]</code> ，即当末尾元素是 1 时，需要完整遍历数组，<strong>达到最差时间复杂度 𝑂(𝑛)</strong> 。</li>
<li>当 <code>nums = [1, ?, ?, ...]</code> ，即当首个元素为 1 时，无论数组多长都不需要继续遍历，<strong>达到最佳时间复杂度 Ω(1)</strong> 。</li>
</ul>
<p>“最差时间复杂度”对应函数渐近上界，使用大 𝑂 记号表示。相应地，“最佳时间复杂度”对应函数渐近下界，用 Ω 记号表示：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 生成一个数组，元素为 { 1, 2, ..., n }，顺序被打乱 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span>[] randomNumbers(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    Integer[] nums = <span style="color:#fff;font-weight:bold">new</span> Integer[n];
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 生成数组 nums = { 1, 2, 3, ..., n }
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; i++) {
</span></span><span style="display:flex;"><span>        nums[i] = i + <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 随机打乱数组元素
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    Collections.<span style="color:#007f7f">shuffle</span>(Arrays.<span style="color:#007f7f">asList</span>(nums));
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// Integer[] -&gt; int[]
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span>[] res = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">int</span>[n];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; n; i++) {
</span></span><span style="display:flex;"><span>        res[i] = nums[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* 查找数组 nums 中数字 1 所在索引 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> findOne(<span style="color:#fff;font-weight:bold">int</span>[] nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; nums.<span style="color:#007f7f">length</span>; i++) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 当元素 1 在数组头部时，达到最佳时间复杂度 O(1)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#007f7f">// 当元素 1 在数组尾部时，达到最差时间复杂度 O(n)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">if</span> (nums[i] == <span style="color:#ff0;font-weight:bold">1</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span> i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> -<span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>值得说明的是，我们在实际中很少使用最佳时间复杂度，因为通常只有在很小概率下才能达到，可能会带来一定的误导性。<strong>而最差时间复杂度更为实用，因为它给出了一个效率安全值</strong>，让我们可以放心地使用算法。</p>
<p>从上述示例可以看出，最差时间复杂度和最佳时间复杂度只出现于“特殊的数据分布”，这些情况的出现概率可能很小，并不能真实地反映算法运行效率。相比之下，<strong>平均时间复杂度可以体现算法在随机输入数据下的运行效率</strong>，用 Θ 记号来表示。</p>
<p>对于部分算法，我们可以简单地推算出随机数据分布下的平均情况。比如上述示例，由于输入数组是被打乱的，因此元素 1 出现在任意索引的概率都是相等的，那么算法的平均循环次数就是数组长度的一半 𝑛/2 ，平均时间复杂度为 Θ(𝑛/2)=Θ(𝑛) 。</p>
<p>但对于较为复杂的算法，计算平均时间复杂度往往比较困难，因为很难分析出在数据分布下的整体数学期望。在这种情况下，我们通常使用最差时间复杂度作为算法效率的评判标准。</p>
<blockquote>
<p>为什么很少看到 Θ 符号？</p>
<p>可能由于 𝑂 符号过于朗朗上口，因此我们常常使用它来表示平均时间复杂度。但从严格意义上讲，这 种做法并不规范。在本书和其他资料中，若遇到类似“平均时间复杂度 𝑂(𝑛)”的表述，请将其直接 理解为 Θ(𝑛) 。</p>
</blockquote>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://funny-toffee-4aa7c3.netlify.app/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://funny-toffee-4aa7c3.netlify.app/">Wjy&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>