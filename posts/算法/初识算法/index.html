<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>初识算法 | Wjy&#39;s Blog</title>
<meta name="keywords" content="算法">
<meta name="description" content="初识算法 算法无处不在 当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖基本逻辑，这些逻辑在">
<meta name="author" content="">
<link rel="canonical" href="https://funny-toffee-4aa7c3.netlify.app/posts/%E7%AE%97%E6%B3%95/%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://funny-toffee-4aa7c3.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://funny-toffee-4aa7c3.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://funny-toffee-4aa7c3.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://funny-toffee-4aa7c3.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://funny-toffee-4aa7c3.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="初识算法" />
<meta property="og:description" content="初识算法 算法无处不在 当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖基本逻辑，这些逻辑在" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://funny-toffee-4aa7c3.netlify.app/posts/%E7%AE%97%E6%B3%95/%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-04-30T12:03:30+00:00" />
<meta property="article:modified_time" content="2024-04-30T12:03:30+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="初识算法"/>
<meta name="twitter:description" content="初识算法 算法无处不在 当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖基本逻辑，这些逻辑在"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://funny-toffee-4aa7c3.netlify.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "初识算法",
      "item": "https://funny-toffee-4aa7c3.netlify.app/posts/%E7%AE%97%E6%B3%95/%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "初识算法",
  "name": "初识算法",
  "description": "初识算法 算法无处不在 当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖基本逻辑，这些逻辑在",
  "keywords": [
    "算法"
  ],
  "articleBody": "初识算法 算法无处不在 当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖基本逻辑，这些逻辑在我们的日常生活中处处可见。\n在正式探讨算法之前，有一个有趣的事实值得分享：你已经在不知不觉中学会了许多算法，并习惯将它们应用到日常生活中了。下面我将举几个具体的例子来证实这一点。\n例一：查字典。在字典里，每个汉字都对应一个拼音，而字典是按照拼音字母顺序排列的。假设我们需要查找一个拼音首字母为 𝑟 的字，通常会按照图 1-1 所示的方式实现。\n翻开字典约一半的页数，查看该页的首字母是什么，假设首字母为 𝑚 。 由于在拼音字母表中 𝑟 位于 𝑚 之后，所以排除字典前半部分，查找范围缩小到后半部分。 不断重复步骤 1. 和 步骤 2. ，直至找到拼音首字母为 𝑟 的页码为止。 查字典这个小学生必备技能，实际上就是著名的“二分查找”算法。从数据结构的角度，我们可以把字典视为一个已排序的“数组”；从算法的角度，我们可以将上述查字典的一系列操作看作“二分查找”。\n例二：整理扑克。我们在打牌时，每局都需要整理手中的扑克牌，使其从小到大排列，实现流程如图 1-2 所示。\n将扑克牌划分为“有序”和“无序”两部分，并假设初始状态下最左 1 张扑克牌已经有序。 在无序部分抽出一张扑克牌，插入至有序部分的正确位置；完成后最左 2 张扑克已经有序。 不断循环步骤 2. ，每一轮将一张扑克牌从无序部分插入至有序部分，直至所有扑克牌都有序。 上述整理扑克牌的方法本质上是“插入排序”算法，它在处理小型数据集时非常高效。许多编程语言的排序库函数中都有插入排序的身影。\n例三：货币找零。假设我们在超市购买了 69 元的商品，给了收银员 100 元，则收银员需要找我们 31 元。他会很自然地完成如图 1-3 所示的思考。\n可选项是比 31 元面值更小的货币，包括 1 元、5 元、10 元、20 元。 从可选项中拿出最大的 20 元，剩余 31−20=11 元。 从剩余可选项中拿出最大的 10 元，剩余 11−10=1 元。 从剩余可选项中拿出最大的 1 元，剩余 1−1=0 元。 完成找零，方案为 20+10+1=31 元。 在以上步骤中，我们每一步都采取当前看来最好的选择（尽可能用大面额的货币），最终得到了可行的找零方案。从数据结构与算法的角度看，这种方法本质上是“贪心”算法。\n小到烹饪一道菜，大到星际航行，几乎所有问题的解决都离不开算法。计算机的出现使得我们能够通过编程将数据结构存储在内存中，同时编写代码调用 CPU 和 GPU 执行算法。这样一来，我们就能把生活中的问题转移到计算机上，以更高效的方式解决各种复杂问题。\n算法是什么 算法定义 算法（algorithm）是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性。\n问题是明确的，包含清晰的输入和输出定义。 具有可行性，能够在有限步骤、时间和内存空间下完成。 各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。 数据结构定义 数据结构（data structure）是计算机中组织和存储数据的方式，具有以下设计目标。\n空间占用尽量少，以节省计算机内存。 数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。 提供简洁的数据表示和逻辑信息，以便算法高效运行。 数据结构设计是一个充满权衡的过程。如果想在某方面取得提升，往往需要在另一方面作出妥协。下面举两个例子。\n链表相较于数组，在数据添加和删除操作上更加便捷，但牺牲了数据访问速度。 图相较于链表，提供了更丰富的逻辑信息，但需要占用更大的内存空间。 数据结构与算法的关系 数据结构与算法高度相关、紧密结合，具体表现在以下三个方面。\n数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。 算法是数据结构发挥作用的舞台。数据结构本身仅存储数据信息，结合算法才能解决特定问题。 算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。 值得说明的是，数据结构与算法是独立于编程语言的。\n小结 算法在日常生活中无处不在，并不是遥不可及的高深知识。实际上，我们已经在不知不觉中学会了许多算法，用以解决生活中的大小问题。 查字典的原理与二分查找算法相一致。二分查找算法体现了分而治之的重要算法思想。 整理扑克的过程与插入排序算法非常类似。插入排序算法适合排序小型数据集。 货币找零的步骤本质上是贪心算法，每一步都采取当前看来最好的选择。 算法是在有限时间内解决特定问题的一组指令或操作步骤，而数据结构是计算机中组织和存储数据的方式。 数据结构与算法紧密相连。数据结构是算法的基石，而算法是数据结构发挥作用的舞台。 我们可以将数据结构与算法类比为拼装积木，积木代表数据，积木的形状和连接方式等代表数据结构，拼装积木的步骤则对应算法。 Q\u0026A Q：作为一名程序员，我在日常工作中从未用算法解决过问题，常用算法都被编程语言封装好了，直接用就可以了；这是否意味着我们工作中的问题还没有到达需要算法的程度？\n如果把具体的工作技能比作是武功的“招式”的话，那么基础科目应该更像是“内功”。\n我认为学算法（以及其他基础科目）的意义不是在于在工作中从零实现它，而是基于学到的知识，在解决问题时能够作出专业的反应和判断，从而提升工作的整体质量。举一个简单例子，每种编程语言都内置了排序函数：\n如果我们没有学过数据结构与算法，那么给定任何数据，我们可能都塞给这个排序函数去做了。运行顺畅、性能不错，看上去并没有什么问题。 但如果学过算法，我们就会知道内置排序函数的时间复杂度是 𝑂(𝑛log⁡𝑛) ；而如果给定的数据是固定位数的整数（例如学号），那么我们就可以用效率更高的“基数排序”来做，将时间复杂度降为 𝑂(𝑛𝑘) ，其中 𝑘 为位数。当数据体量很大时，节省出来的运行时间就能创造较大价值（成本降低、体验变好等）。 在工程领域中，大量问题是难以达到最优解的，许多问题只是被“差不多”地解决了。问题的难易程度一方面取决于问题本身的性质，另一方面也取决于观测问题的人的知识储备。人的知识越完备、经验越多，分析问题就会越深入，问题就能被解决得更优雅。\n复杂度分析 算法效率评估 在算法设计中，我们先后追求以下两个层面的目标。\n找到问题解法：算法需要在规定的输入范围内可靠地求得问题的正确解。 寻求最优解法：同一个问题可能存在多种解法，我们希望找到尽可能高效的算法。 也就是说，在能够解决问题的前提下，算法效率已成为衡量算法优劣的主要评价指标，它包括以下两个维度。\n时间效率：算法运行速度的快慢。 空间效率：算法占用内存空间的大小。 简而言之，我们的目标是设计“既快又省”的数据结构与算法。而有效地评估算法效率至关重要，因为只有这样，我们才能将各种算法进行对比，进而指导算法设计与优化过程。\n效率评估方法主要分为两种：实际测试、理论估算。\n实际测试 假设我们现在有算法 A 和算法 B ，它们都能解决同一问题，现在需要对比这两个算法的效率。最直接的方法是找一台计算机，运行这两个算法，并监控记录它们的运行时间和内存占用情况。这种评估方式能够反映真实情况，但也存在较大的局限性。\n一方面，难以排除测试环境的干扰因素。硬件配置会影响算法的性能。比如在某台计算机中，算法 A 的运行时间比算法 B 短；但在另一台配置不同的计算机中，可能得到相反的测试结果。这意味着我们需要在各种机器上进行测试，统计平均效率，而这是不现实的。\n另一方面，展开完整测试非常耗费资源。随着输入数据量的变化，算法会表现出不同的效率。例如，在输入数据量较小时，算法 A 的运行时间比算法 B 短；而在输入数据量较大时，测试结果可能恰恰相反。因此，为了得到有说服力的结论，我们需要测试各种规模的输入数据，而这需要耗费大量的计算资源。\n理论估算 由于实际测试具有较大的局限性，因此我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。\n复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系。它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势。这个定义有些拗口，我们可以将其分为三个重点来理解。\n“时间和空间资源”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。 “随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。 “时间和空间的增长趋势”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”。 复杂度分析克服了实际测试方法的弊端，体现在以下两个方面。\n它独立于测试环境，分析结果适用于所有运行平台。 它可以体现不同数据量下的算法效率，尤其是在大数据量下的算法性能。 复杂度分析为我们提供了一把评估算法效率的“标尺”，使我们可以衡量执行某个算法所需的时间和空间资源，对比不同算法之间的效率。\n复杂度是个数学概念，对于初学者可能比较抽象，学习难度相对较高。从这个角度看，复杂度分析可能不太适合作为最先介绍的内容。然而，当我们讨论某个数据结构或算法的特点时，难以避免要分析其运行速度和空间使用情况。\n综上所述，建议你在深入学习数据结构与算法之前，先对复杂度分析建立初步的了解，以便能够完成简单算法的复杂度分析。\n迭代与递归 在算法中，重复执行某个任务是很常见的，它与复杂度分析息息相关。因此，在介绍时间复杂度和空间复杂度之前，我们先来了解如何在程序中实现重复执行任务，即两种基本的程序控制结构：迭代、递归。\n迭代 迭代（iteration）是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。\nfor 循环 for 循环是最常见的迭代形式之一，适合在预先知道迭代次数时使用。以下函数基于 for 循环实现了求和 1+2+⋯+𝑛 ，求和结果使用变量 res 记录。\n1 2 3 4 5 6 7 8 9 /* for 循环 */ int forLoop(int n) { int res = 0; // 循环求和 1, 2, ..., n-1, n for (int i = 1; i \u003c= n; i++) { res += i; } return res; } 下图是是该求和函数的流程框图。\n此求和函数的操作数量与输入数据大小 𝑛 成正比，或者说成“线性关系”。实际上，时间复杂度描述的就是这个“线性关系”。\nwhile循环 与 for 循环类似，while 循环也是一种实现迭代的方法。在 while 循环中，程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环。下面我们用 while 循环来实现求和 1+2+⋯+𝑛 ：\n1 2 3 4 5 6 7 8 9 10 11 /* while 循环 */ int whileLoop(int n) { int res = 0; int i = 1; // 初始化条件变量 // 循环求和 1, 2, ..., n-1, n while (i \u003c= n) { res += i; i++; // 更新条件变量 } return res; } while 循环比 for 循环的自由度更高。在 while 循环中，我们可以自由地设计条件变量的初始化和更新步骤。\n例如在以下代码中，条件变量 𝑖 每轮进行两次更新，这种情况就不太方便用 for 循环实现：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* while 循环（两次更新） */ int whileLoopII(int n) { int res = 0; int i = 1; // 初始化条件变量 // 循环求和 1, 4, 10, ... while (i \u003c= n) { res += i; // 更新条件变量 i++; i *= 2; } return res; } 总的来说，for 循环的代码更加紧凑，while 循环更加灵活，两者都可以实现迭代结构。选择使用哪一个应该根据特定问题的需求来决定。\n嵌套循环 我们可以在一个循环结构内嵌套另一个循环结构，下面以 for 循环为例：\n1 2 3 4 5 6 7 8 9 10 11 12 /* 双层 for 循环 */ String nestedForLoop(int n) { StringBuilder res = new StringBuilder(); // 循环 i = 1, 2, ..., n-1, n for (int i = 1; i \u003c= n; i++) { // 循环 j = 1, 2, ..., n-1, n for (int j = 1; j \u003c= n; j++) { res.append(\"(\" + i + \", \" + j + \"), \"); } } return res.toString(); } 下图是该嵌套循环的流程框图。\n在这种情况下，函数的操作数量与 𝑛2 成正比，或者说算法运行时间和输入数据大小 𝑛 成“平方关系”。我们可以继续添加嵌套循环，每一次嵌套都是一次“升维”，将会使时间复杂度提高至“立方关系”“四次方关系”，以此类推。\n递归 递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。\n递：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。 归：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。 而从实现的角度看，递归代码主要包含三个要素。\n终止条件：用于决定什么时候由“递”转“归”。 递归调用：对应“递”，函数调用自身，通常输入更小或更简化的参数。 返回结果：对应“归”，将当前递归层级的结果返回至上一层。 观察以下代码，我们只需调用函数 recur(n) ，就可以完成 1+2+⋯+𝑛 的计算：\n1 2 3 4 5 6 7 8 9 10 11 /* 递归 */ int recur(int n) { // 终止条件 if (n == 1){ return 1; } // 递：递归调用 int res = recur(n - 1); // 归：返回结果 return n + res; } 图 2-3 展示了该函数的递归过程。\n虽然从计算角度看，迭代与递归可以得到相同的结果，但它们代表了两种完全不同的思考和解决问题的范式。\n迭代：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。 递归：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。 以上述求和函数为例，设问题 𝑓(𝑛)=1+2+⋯+𝑛 。\n迭代：在循环中模拟求和过程，从 1 遍历到 𝑛 ，每轮执行求和操作，即可求得 𝑓(𝑛) 。 递归：将问题分解为子问题 𝑓(𝑛)=𝑛+𝑓(𝑛−1) ，不断（递归地）分解下去，直至基本情况 𝑓(1)=1 时终止。 调用栈 递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。\n函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，递归通常比迭代更加耗费内存空间。 递归调用函数会产生额外的开销。因此递归通常比循环的时间效率更低。 如图 2-4 所示，在触发终止条件前，同时存在 𝑛 个未返回的递归函数，递归深度为 𝑛 。\n在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出错误。\n尾递归 有趣的是，如果函数在返回前的最后一步才进行递归调用，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。\n普通递归：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。 尾递归：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。 以计算 1+2+⋯+𝑛 为例，我们可以将结果变量 res 设为函数参数，从而实现尾递归：\n1 2 3 4 5 6 7 8 /* 尾递归 */ int tailRecur(int n, int res) { // 终止条件 if (n == 0) return res; // 尾递归调用 return tailRecur(n - 1, res + n); } 尾递归的执行过程如图 2-5 所示。对比普通递归和尾递归，两者的求和操作的执行点是不同的。\n普通递归：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。 尾递归：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。 递归树 当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。以“斐波那契数列”为例。\n给定一个斐波那契数列 0,1,1,2,3,5,8,13,… ，求该数列的第 𝑛 个数字。\n设斐波那契数列的第 𝑛 个数字为 𝑓(𝑛) ，易得两个结论。\n数列的前两个数字为 𝑓(1)=0 和 𝑓(2)=1 。 数列中的每个数字是前两个数字的和，即 𝑓(𝑛)=𝑓(𝑛−1)+𝑓(𝑛−2) 。 按照递推关系进行递归调用，将前两个数字作为终止条件，便可写出递归代码。调用 fib(n) 即可得到斐波那契数列的第 𝑛 个数字：\n1 2 3 4 5 6 7 8 9 10 /* 斐波那契数列：递归 */ int fib(int n) { // 终止条件 f(1) = 0, f(2) = 1 if (n == 1 || n == 2) return n - 1; // 递归调用 f(n) = f(n-1) + f(n-2) int res = fib(n - 1) + fib(n - 2); // 返回结果 f(n) return res; } 观察以上代码，我们在函数内递归调用了两个函数，这意味着从一个调用产生了两个调用分支。如图 2-6 所示，这样不断递归调用下去，最终将产生一棵层数为 𝑛 的递归树（recursion tree）。\n从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。\n从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。 从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。 迭代和递归的对比 总结以上内容，如表 2-1 所示，迭代和递归在实现、性能和适用性上有所不同。\n表 2-1 迭代与递归特点对比\n迭代 递归 实现方式 循环结构 函数调用自身 时间效率 效率通常较高，无函数调用开销 每次函数调用都会产生开销 内存使用 通常使用固定大小的内存空间 累积函数调用可能使用大量的栈帧空间 适用问题 适用于简单循环任务，代码直观、可读性好 适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰 那么，迭代和递归具有什么内在联系呢？以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，这种工作机制与栈的“先入后出”原则异曲同工。\n事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。\n递：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。 归：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。 因此，我们可以使用一个显式的栈来模拟调用栈的行为，从而将递归转化为迭代形式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 使用迭代模拟递归 */ int forLoopRecur(int n) { // 使用一个显式的栈来模拟系统调用栈 Stack stack = new Stack\u003c\u003e(); int res = 0; // 递：递归调用 for (int i = n; i \u003e 0; i--) { // 通过“入栈操作”模拟“递” stack.push(i); } // 归：返回结果 while (!stack.isEmpty()) { // 通过“出栈操作”模拟“归” res += stack.pop(); } // res = 1+2+3+...+n return res; } 观察以上代码，当递归转化为迭代后，代码变得更加复杂了。尽管迭代和递归在很多情况下可以互相转化，但不一定值得这样做，有以下两点原因。\n转化后的代码可能更加难以理解，可读性更差。 对于某些复杂问题，模拟系统调用栈的行为可能非常困难。 总之，选择迭代还是递归取决于特定问题的性质。在编程实践中，权衡两者的优劣并根据情境选择合适的方法至关重要。\n时间复杂度 ",
  "wordCount" : "7218",
  "inLanguage": "en",
  "datePublished": "2024-04-30T12:03:30Z",
  "dateModified": "2024-04-30T12:03:30Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://funny-toffee-4aa7c3.netlify.app/posts/%E7%AE%97%E6%B3%95/%E5%88%9D%E8%AF%86%E7%AE%97%E6%B3%95/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Wjy's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://funny-toffee-4aa7c3.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://funny-toffee-4aa7c3.netlify.app/" accesskey="h" title="Wjy&#39;s Blog (Alt + H)">Wjy&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://funny-toffee-4aa7c3.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://funny-toffee-4aa7c3.netlify.app/posts/">Posts</a></div>
    <h1 class="post-title">
      初识算法
    </h1>
    <div class="post-meta"><span title='2024-04-30 12:03:30 +0000 UTC'>2024-04-30</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%88%9d%e8%af%86%e7%ae%97%e6%b3%95" aria-label="初识算法">初识算法</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%97%a0%e5%a4%84%e4%b8%8d%e5%9c%a8" aria-label="算法无处不在">算法无处不在</a></li>
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%98%af%e4%bb%80%e4%b9%88" aria-label="算法是什么">算法是什么</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e5%ae%9a%e4%b9%89" aria-label="算法定义">算法定义</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%ae%9a%e4%b9%89" aria-label="数据结构定义">数据结构定义</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%b8%8e%e7%ae%97%e6%b3%95%e7%9a%84%e5%85%b3%e7%b3%bb" aria-label="数据结构与算法的关系">数据结构与算法的关系</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b0%8f%e7%bb%93" aria-label="小结">小结</a></li>
                <li>
                    <a href="#qa" aria-label="Q&amp;amp;A">Q&amp;A</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a4%8d%e6%9d%82%e5%ba%a6%e5%88%86%e6%9e%90" aria-label="复杂度分析">复杂度分析</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%95%88%e7%8e%87%e8%af%84%e4%bc%b0" aria-label="算法效率评估">算法效率评估</a><ul>
                        
                <li>
                    <a href="#%e5%ae%9e%e9%99%85%e6%b5%8b%e8%af%95" aria-label="实际测试">实际测试</a></li>
                <li>
                    <a href="#%e7%90%86%e8%ae%ba%e4%bc%b0%e7%ae%97" aria-label="理论估算">理论估算</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%ad%e4%bb%a3%e4%b8%8e%e9%80%92%e5%bd%92" aria-label="迭代与递归">迭代与递归</a><ul>
                        
                <li>
                    <a href="#%e8%bf%ad%e4%bb%a3" aria-label="迭代">迭代</a><ul>
                        
                <li>
                    <a href="#for-%e5%be%aa%e7%8e%af" aria-label="for 循环">for 循环</a></li>
                <li>
                    <a href="#while%e5%be%aa%e7%8e%af" aria-label="while循环">while循环</a></li>
                <li>
                    <a href="#%e5%b5%8c%e5%a5%97%e5%be%aa%e7%8e%af" aria-label="嵌套循环">嵌套循环</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%80%92%e5%bd%92" aria-label="递归">递归</a><ul>
                        
                <li>
                    <a href="#%e8%b0%83%e7%94%a8%e6%a0%88" aria-label="调用栈">调用栈</a></li>
                <li>
                    <a href="#%e5%b0%be%e9%80%92%e5%bd%92" aria-label="尾递归">尾递归</a></li>
                <li>
                    <a href="#%e9%80%92%e5%bd%92%e6%a0%91" aria-label="递归树">递归树</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bf%ad%e4%bb%a3%e5%92%8c%e9%80%92%e5%bd%92%e7%9a%84%e5%af%b9%e6%af%94" aria-label="迭代和递归的对比">迭代和递归的对比</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%97%b6%e9%97%b4%e5%a4%8d%e6%9d%82%e5%ba%a6" aria-label="时间复杂度">时间复杂度</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="初识算法">初识算法<a hidden class="anchor" aria-hidden="true" href="#初识算法">#</a></h1>
<h2 id="算法无处不在">算法无处不在<a hidden class="anchor" aria-hidden="true" href="#算法无处不在">#</a></h2>
<p>当我们听到“算法”这个词时，很自然地会想到数学。然而实际上，许多算法并不涉及复杂数学，而是更多地依赖基本逻辑，这些逻辑在我们的日常生活中处处可见。</p>
<p>在正式探讨算法之前，有一个有趣的事实值得分享：<strong>你已经在不知不觉中学会了许多算法，并习惯将它们应用到日常生活中了</strong>。下面我将举几个具体的例子来证实这一点。</p>
<p><strong>例一：查字典</strong>。在字典里，每个汉字都对应一个拼音，而字典是按照拼音字母顺序排列的。假设我们需要查找一个拼音首字母为 𝑟 的字，通常会按照图 1-1 所示的方式实现。</p>
<ol>
<li>翻开字典约一半的页数，查看该页的首字母是什么，假设首字母为 𝑚 。</li>
<li>由于在拼音字母表中 𝑟 位于 𝑚 之后，所以排除字典前半部分，查找范围缩小到后半部分。</li>
<li>不断重复步骤 <code>1.</code> 和 步骤 <code>2.</code> ，直至找到拼音首字母为 𝑟 的页码为止。</li>
</ol>
<p><img loading="lazy" src="binary_search_dictionary_step1.png" alt=""  />
</p>
<p><img loading="lazy" src="binary_search_dictionary_step2.png" alt=""  />
</p>
<p><img loading="lazy" src="binary_search_dictionary_step3.png" alt=""  />
</p>
<p><img loading="lazy" src="binary_search_dictionary_step4.png" alt=""  />
</p>
<p><img loading="lazy" src="binary_search_dictionary_step5.png" alt=""  />
</p>
<p>查字典这个小学生必备技能，实际上就是著名的“二分查找”算法。从数据结构的角度，我们可以把字典视为一个已排序的“数组”；从算法的角度，我们可以将上述查字典的一系列操作看作“二分查找”。</p>
<p><strong>例二：整理扑克</strong>。我们在打牌时，每局都需要整理手中的扑克牌，使其从小到大排列，实现流程如图 1-2 所示。</p>
<ol>
<li>将扑克牌划分为“有序”和“无序”两部分，并假设初始状态下最左 1 张扑克牌已经有序。</li>
<li>在无序部分抽出一张扑克牌，插入至有序部分的正确位置；完成后最左 2 张扑克已经有序。</li>
<li>不断循环步骤 <code>2.</code> ，每一轮将一张扑克牌从无序部分插入至有序部分，直至所有扑克牌都有序。</li>
</ol>
<p><img loading="lazy" src="playing_cards_sorting.png" alt=""  />
</p>
<p>上述整理扑克牌的方法本质上是“插入排序”算法，它在处理小型数据集时非常高效。许多编程语言的排序库函数中都有插入排序的身影。</p>
<p><strong>例三：货币找零</strong>。假设我们在超市购买了 69 元的商品，给了收银员 100 元，则收银员需要找我们 31 元。他会很自然地完成如图 1-3 所示的思考。</p>
<ol>
<li>可选项是比 31 元面值更小的货币，包括 1 元、5 元、10 元、20 元。</li>
<li>从可选项中拿出最大的 20 元，剩余 31−20=11 元。</li>
<li>从剩余可选项中拿出最大的 10 元，剩余 11−10=1 元。</li>
<li>从剩余可选项中拿出最大的 1 元，剩余 1−1=0 元。</li>
<li>完成找零，方案为 20+10+1=31 元。</li>
</ol>
<p><img loading="lazy" src="greedy_change.png" alt=""  />
</p>
<p>在以上步骤中，我们每一步都采取当前看来最好的选择（尽可能用大面额的货币），最终得到了可行的找零方案。从数据结构与算法的角度看，这种方法本质上是“贪心”算法。</p>
<p>小到烹饪一道菜，大到星际航行，几乎所有问题的解决都离不开算法。计算机的出现使得我们能够通过编程将数据结构存储在内存中，同时编写代码调用 CPU 和 GPU 执行算法。这样一来，我们就能把生活中的问题转移到计算机上，以更高效的方式解决各种复杂问题。</p>
<h2 id="算法是什么">算法是什么<a hidden class="anchor" aria-hidden="true" href="#算法是什么">#</a></h2>
<h3 id="算法定义">算法定义<a hidden class="anchor" aria-hidden="true" href="#算法定义">#</a></h3>
<p>算法（algorithm）是在有限时间内解决特定问题的一组指令或操作步骤，它具有以下特性。</p>
<ul>
<li>问题是明确的，包含清晰的输入和输出定义。</li>
<li>具有可行性，能够在有限步骤、时间和内存空间下完成。</li>
<li>各步骤都有确定的含义，在相同的输入和运行条件下，输出始终相同。</li>
</ul>
<h3 id="数据结构定义">数据结构定义<a hidden class="anchor" aria-hidden="true" href="#数据结构定义">#</a></h3>
<p>数据结构（data structure）是计算机中组织和存储数据的方式，具有以下设计目标。</p>
<ul>
<li>空间占用尽量少，以节省计算机内存。</li>
<li>数据操作尽可能快速，涵盖数据访问、添加、删除、更新等。</li>
<li>提供简洁的数据表示和逻辑信息，以便算法高效运行。</li>
</ul>
<p><strong>数据结构设计是一个充满权衡的过程</strong>。如果想在某方面取得提升，往往需要在另一方面作出妥协。下面举两个例子。</p>
<ul>
<li>链表相较于数组，在数据添加和删除操作上更加便捷，但牺牲了数据访问速度。</li>
<li>图相较于链表，提供了更丰富的逻辑信息，但需要占用更大的内存空间。</li>
</ul>
<h3 id="数据结构与算法的关系">数据结构与算法的关系<a hidden class="anchor" aria-hidden="true" href="#数据结构与算法的关系">#</a></h3>
<p>数据结构与算法高度相关、紧密结合，具体表现在以下三个方面。</p>
<ul>
<li>数据结构是算法的基石。数据结构为算法提供了结构化存储的数据，以及操作数据的方法。</li>
<li>算法是数据结构发挥作用的舞台。数据结构本身仅存储数据信息，结合算法才能解决特定问题。</li>
<li>算法通常可以基于不同的数据结构实现，但执行效率可能相差很大，选择合适的数据结构是关键。</li>
</ul>
<p><img loading="lazy" src="relationship_between_data_structure_and_algorithm.png" alt=""  />
</p>
<p>值得说明的是，数据结构与算法是独立于编程语言的。</p>
<h2 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h2>
<ul>
<li>算法在日常生活中无处不在，并不是遥不可及的高深知识。实际上，我们已经在不知不觉中学会了许多算法，用以解决生活中的大小问题。</li>
<li>查字典的原理与二分查找算法相一致。二分查找算法体现了分而治之的重要算法思想。</li>
<li>整理扑克的过程与插入排序算法非常类似。插入排序算法适合排序小型数据集。</li>
<li>货币找零的步骤本质上是贪心算法，每一步都采取当前看来最好的选择。</li>
<li>算法是在有限时间内解决特定问题的一组指令或操作步骤，而数据结构是计算机中组织和存储数据的方式。</li>
<li>数据结构与算法紧密相连。数据结构是算法的基石，而算法是数据结构发挥作用的舞台。</li>
<li>我们可以将数据结构与算法类比为拼装积木，积木代表数据，积木的形状和连接方式等代表数据结构，拼装积木的步骤则对应算法。</li>
</ul>
<h2 id="qa">Q&amp;A<a hidden class="anchor" aria-hidden="true" href="#qa">#</a></h2>
<p><strong>Q</strong>：作为一名程序员，我在日常工作中从未用算法解决过问题，常用算法都被编程语言封装好了，直接用就可以了；这是否意味着我们工作中的问题还没有到达需要算法的程度？</p>
<p>如果把具体的工作技能比作是武功的“招式”的话，那么基础科目应该更像是“内功”。</p>
<p>我认为学算法（以及其他基础科目）的意义不是在于在工作中从零实现它，而是基于学到的知识，在解决问题时能够作出专业的反应和判断，从而提升工作的整体质量。举一个简单例子，每种编程语言都内置了排序函数：</p>
<ul>
<li>如果我们没有学过数据结构与算法，那么给定任何数据，我们可能都塞给这个排序函数去做了。运行顺畅、性能不错，看上去并没有什么问题。</li>
<li>但如果学过算法，我们就会知道内置排序函数的时间复杂度是 𝑂(𝑛log⁡𝑛) ；而如果给定的数据是固定位数的整数（例如学号），那么我们就可以用效率更高的“基数排序”来做，将时间复杂度降为 𝑂(𝑛𝑘) ，其中 𝑘 为位数。当数据体量很大时，节省出来的运行时间就能创造较大价值（成本降低、体验变好等）。</li>
</ul>
<p>在工程领域中，大量问题是难以达到最优解的，许多问题只是被“差不多”地解决了。问题的难易程度一方面取决于问题本身的性质，另一方面也取决于观测问题的人的知识储备。人的知识越完备、经验越多，分析问题就会越深入，问题就能被解决得更优雅。</p>
<h1 id="复杂度分析">复杂度分析<a hidden class="anchor" aria-hidden="true" href="#复杂度分析">#</a></h1>
<h2 id="算法效率评估">算法效率评估<a hidden class="anchor" aria-hidden="true" href="#算法效率评估">#</a></h2>
<p>在算法设计中，我们先后追求以下两个层面的目标。</p>
<ol>
<li><strong>找到问题解法</strong>：算法需要在规定的输入范围内可靠地求得问题的正确解。</li>
<li><strong>寻求最优解法</strong>：同一个问题可能存在多种解法，我们希望找到尽可能高效的算法。</li>
</ol>
<p>也就是说，在能够解决问题的前提下，算法效率已成为衡量算法优劣的主要评价指标，它包括以下两个维度。</p>
<ul>
<li><strong>时间效率</strong>：算法运行速度的快慢。</li>
<li><strong>空间效率</strong>：算法占用内存空间的大小。</li>
</ul>
<p>简而言之，<strong>我们的目标是设计“既快又省”的数据结构与算法</strong>。而有效地评估算法效率至关重要，因为只有这样，我们才能将各种算法进行对比，进而指导算法设计与优化过程。</p>
<p>效率评估方法主要分为两种：实际测试、理论估算。</p>
<h3 id="实际测试">实际测试<a hidden class="anchor" aria-hidden="true" href="#实际测试">#</a></h3>
<p>假设我们现在有算法 <code>A</code> 和算法 <code>B</code> ，它们都能解决同一问题，现在需要对比这两个算法的效率。最直接的方法是找一台计算机，运行这两个算法，并监控记录它们的运行时间和内存占用情况。这种评估方式能够反映真实情况，但也存在较大的局限性。</p>
<p>一方面，<strong>难以排除测试环境的干扰因素</strong>。硬件配置会影响算法的性能。比如在某台计算机中，算法 <code>A</code> 的运行时间比算法 <code>B</code> 短；但在另一台配置不同的计算机中，可能得到相反的测试结果。这意味着我们需要在各种机器上进行测试，统计平均效率，而这是不现实的。</p>
<p>另一方面，<strong>展开完整测试非常耗费资源</strong>。随着输入数据量的变化，算法会表现出不同的效率。例如，在输入数据量较小时，算法 <code>A</code> 的运行时间比算法 <code>B</code> 短；而在输入数据量较大时，测试结果可能恰恰相反。因此，为了得到有说服力的结论，我们需要测试各种规模的输入数据，而这需要耗费大量的计算资源。</p>
<h3 id="理论估算">理论估算<a hidden class="anchor" aria-hidden="true" href="#理论估算">#</a></h3>
<p>由于实际测试具有较大的局限性，因此我们可以考虑仅通过一些计算来评估算法的效率。这种估算方法被称为渐近复杂度分析（asymptotic complexity analysis），简称复杂度分析。</p>
<p>复杂度分析能够体现算法运行所需的时间和空间资源与输入数据大小之间的关系。<strong>它描述了随着输入数据大小的增加，算法执行所需时间和空间的增长趋势</strong>。这个定义有些拗口，我们可以将其分为三个重点来理解。</p>
<ul>
<li>“时间和空间资源”分别对应时间复杂度（time complexity）和空间复杂度（space complexity）。</li>
<li>“随着输入数据大小的增加”意味着复杂度反映了算法运行效率与输入数据体量之间的关系。</li>
<li>“时间和空间的增长趋势”表示复杂度分析关注的不是运行时间或占用空间的具体值，而是时间或空间增长的“快慢”。</li>
</ul>
<p><strong>复杂度分析克服了实际测试方法的弊端</strong>，体现在以下两个方面。</p>
<ul>
<li>它独立于测试环境，分析结果适用于所有运行平台。</li>
<li>它可以体现不同数据量下的算法效率，尤其是在大数据量下的算法性能。</li>
</ul>
<p>复杂度分析为我们提供了一把评估算法效率的“标尺”，使我们可以衡量执行某个算法所需的时间和空间资源，对比不同算法之间的效率。</p>
<p>复杂度是个数学概念，对于初学者可能比较抽象，学习难度相对较高。从这个角度看，复杂度分析可能不太适合作为最先介绍的内容。然而，当我们讨论某个数据结构或算法的特点时，难以避免要分析其运行速度和空间使用情况。</p>
<p>综上所述，建议你在深入学习数据结构与算法之前，<strong>先对复杂度分析建立初步的了解，以便能够完成简单算法的复杂度分析</strong>。</p>
<h2 id="迭代与递归">迭代与递归<a hidden class="anchor" aria-hidden="true" href="#迭代与递归">#</a></h2>
<p>在算法中，重复执行某个任务是很常见的，它与复杂度分析息息相关。因此，在介绍时间复杂度和空间复杂度之前，我们先来了解如何在程序中实现重复执行任务，即两种基本的程序控制结构：迭代、递归。</p>
<h3 id="迭代">迭代<a hidden class="anchor" aria-hidden="true" href="#迭代">#</a></h3>
<p>迭代（iteration）是一种重复执行某个任务的控制结构。在迭代中，程序会在满足一定的条件下重复执行某段代码，直到这个条件不再满足。</p>
<h4 id="for-循环">for 循环<a hidden class="anchor" aria-hidden="true" href="#for-循环">#</a></h4>
<p><code>for</code> 循环是最常见的迭代形式之一，<strong>适合在预先知道迭代次数时使用</strong>。以下函数基于 <code>for</code> 循环实现了求和 1+2+⋯+𝑛 ，求和结果使用变量 <code>res</code> 记录。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* for 循环 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> forLoop(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> res = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 循环求和 1, 2, ..., n-1, n
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt;= n; i++) {
</span></span><span style="display:flex;"><span>        res += i;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>下图是是该求和函数的流程框图。</p>
<p><img loading="lazy" src="iteration.png" alt=""  />
</p>
<p>此求和函数的操作数量与输入数据大小 𝑛 成正比，或者说成“线性关系”。实际上，<strong>时间复杂度描述的就是这个“线性关系”</strong>。</p>
<h4 id="while循环">while循环<a hidden class="anchor" aria-hidden="true" href="#while循环">#</a></h4>
<p>与 <code>for</code> 循环类似，<code>while</code> 循环也是一种实现迭代的方法。在 <code>while</code> 循环中，程序每轮都会先检查条件，如果条件为真，则继续执行，否则就结束循环。下面我们用 <code>while</code> 循环来实现求和 1+2+⋯+𝑛 ：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* while 循环 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> whileLoop(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> res = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; <span style="color:#007f7f">// 初始化条件变量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 循环求和 1, 2, ..., n-1, n
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">while</span> (i &lt;= n) {
</span></span><span style="display:flex;"><span>        res += i;
</span></span><span style="display:flex;"><span>        i++; <span style="color:#007f7f">// 更新条件变量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong><code>while</code> 循环比 <code>for</code> 循环的自由度更高</strong>。在 <code>while</code> 循环中，我们可以自由地设计条件变量的初始化和更新步骤。</p>
<p>例如在以下代码中，条件变量 𝑖 每轮进行两次更新，这种情况就不太方便用 <code>for</code> 循环实现：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* while 循环（两次更新） */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> whileLoopII(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> res = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; <span style="color:#007f7f">// 初始化条件变量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#007f7f">// 循环求和 1, 4, 10, ...
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">while</span> (i &lt;= n) {
</span></span><span style="display:flex;"><span>        res += i;
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 更新条件变量
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        i++;
</span></span><span style="display:flex;"><span>        i *= <span style="color:#ff0;font-weight:bold">2</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>总的来说，<strong><code>for</code> 循环的代码更加紧凑，<code>while</code> 循环更加灵活</strong>，两者都可以实现迭代结构。选择使用哪一个应该根据特定问题的需求来决定。</p>
<h4 id="嵌套循环">嵌套循环<a hidden class="anchor" aria-hidden="true" href="#嵌套循环">#</a></h4>
<p>我们可以在一个循环结构内嵌套另一个循环结构，下面以 <code>for</code> 循环为例：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 双层 for 循环 */</span>
</span></span><span style="display:flex;"><span>String nestedForLoop(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    StringBuilder res = <span style="color:#fff;font-weight:bold">new</span> StringBuilder();
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 循环 i = 1, 2, ..., n-1, n
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">1</span>; i &lt;= n; i++) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 循环 j = 1, 2, ..., n-1, n
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = <span style="color:#ff0;font-weight:bold">1</span>; j &lt;= n; j++) {
</span></span><span style="display:flex;"><span>            res.<span style="color:#007f7f">append</span>(<span style="color:#0ff;font-weight:bold">&#34;(&#34;</span> + i + <span style="color:#0ff;font-weight:bold">&#34;, &#34;</span> + j + <span style="color:#0ff;font-weight:bold">&#34;), &#34;</span>);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> res.<span style="color:#007f7f">toString</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>下图是该嵌套循环的流程框图。</p>
<p><img loading="lazy" src="nested_iteration.png" alt=""  />
</p>
<p>在这种情况下，函数的操作数量与 𝑛2 成正比，或者说算法运行时间和输入数据大小 𝑛 成“平方关系”。我们可以继续添加嵌套循环，每一次嵌套都是一次“升维”，将会使时间复杂度提高至“立方关系”“四次方关系”，以此类推。</p>
<h3 id="递归">递归<a hidden class="anchor" aria-hidden="true" href="#递归">#</a></h3>
<p>递归（recursion）是一种算法策略，通过函数调用自身来解决问题。它主要包含两个阶段。</p>
<ol>
<li><strong>递</strong>：程序不断深入地调用自身，通常传入更小或更简化的参数，直到达到“终止条件”。</li>
<li><strong>归</strong>：触发“终止条件”后，程序从最深层的递归函数开始逐层返回，汇聚每一层的结果。</li>
</ol>
<p>而从实现的角度看，递归代码主要包含三个要素。</p>
<ol>
<li><strong>终止条件</strong>：用于决定什么时候由“递”转“归”。</li>
<li><strong>递归调用</strong>：对应“递”，函数调用自身，通常输入更小或更简化的参数。</li>
<li><strong>返回结果</strong>：对应“归”，将当前递归层级的结果返回至上一层。</li>
</ol>
<p>观察以下代码，我们只需调用函数 <code>recur(n)</code> ，就可以完成 1+2+⋯+𝑛 的计算：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 递归 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> recur(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 终止条件
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (n == <span style="color:#ff0;font-weight:bold">1</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 递：递归调用
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> res = recur(n - <span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 归：返回结果
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> n + res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>图 2-3 展示了该函数的递归过程。</p>
<p><img loading="lazy" src="recursion_sum.png" alt="图 2-3 求和函数的递归过程"  />
</p>
<p>虽然从计算角度看，迭代与递归可以得到相同的结果，<strong>但它们代表了两种完全不同的思考和解决问题的范式</strong>。</p>
<ul>
<li><strong>迭代</strong>：“自下而上”地解决问题。从最基础的步骤开始，然后不断重复或累加这些步骤，直到任务完成。</li>
<li><strong>递归</strong>：“自上而下”地解决问题。将原问题分解为更小的子问题，这些子问题和原问题具有相同的形式。接下来将子问题继续分解为更小的子问题，直到基本情况时停止（基本情况的解是已知的）。</li>
</ul>
<p>以上述求和函数为例，设问题 𝑓(𝑛)=1+2+⋯+𝑛 。</p>
<ul>
<li><strong>迭代</strong>：在循环中模拟求和过程，从 1 遍历到 𝑛 ，每轮执行求和操作，即可求得 𝑓(𝑛) 。</li>
<li><strong>递归</strong>：将问题分解为子问题 𝑓(𝑛)=𝑛+𝑓(𝑛−1) ，不断（递归地）分解下去，直至基本情况 𝑓(1)=1 时终止。</li>
</ul>
<h4 id="调用栈">调用栈<a hidden class="anchor" aria-hidden="true" href="#调用栈">#</a></h4>
<p>递归函数每次调用自身时，系统都会为新开启的函数分配内存，以存储局部变量、调用地址和其他信息等。这将导致两方面的结果。</p>
<ul>
<li>函数的上下文数据都存储在称为“栈帧空间”的内存区域中，直至函数返回后才会被释放。因此，<strong>递归通常比迭代更加耗费内存空间</strong>。</li>
<li>递归调用函数会产生额外的开销。<strong>因此递归通常比循环的时间效率更低</strong>。</li>
</ul>
<p>如图 2-4 所示，在触发终止条件前，同时存在 𝑛 个未返回的递归函数，<strong>递归深度为 𝑛</strong> 。</p>
<p><img loading="lazy" src="recursion_sum_depth.png" alt="图 2-4  递归调用深度"  />
</p>
<p>在实际中，编程语言允许的递归深度通常是有限的，过深的递归可能导致栈溢出错误。</p>
<h4 id="尾递归">尾递归<a hidden class="anchor" aria-hidden="true" href="#尾递归">#</a></h4>
<p>有趣的是，<strong>如果函数在返回前的最后一步才进行递归调用</strong>，则该函数可以被编译器或解释器优化，使其在空间效率上与迭代相当。这种情况被称为尾递归（tail recursion）。</p>
<ul>
<li><strong>普通递归</strong>：当函数返回到上一层级的函数后，需要继续执行代码，因此系统需要保存上一层调用的上下文。</li>
<li><strong>尾递归</strong>：递归调用是函数返回前的最后一个操作，这意味着函数返回到上一层级后，无须继续执行其他操作，因此系统无须保存上一层函数的上下文。</li>
</ul>
<p>以计算 1+2+⋯+𝑛 为例，我们可以将结果变量 <code>res</code> 设为函数参数，从而实现尾递归：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 尾递归 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> tailRecur(<span style="color:#fff;font-weight:bold">int</span> n, <span style="color:#fff;font-weight:bold">int</span> res) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 终止条件
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (n == <span style="color:#ff0;font-weight:bold">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 尾递归调用
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> tailRecur(n - <span style="color:#ff0;font-weight:bold">1</span>, res + n);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>尾递归的执行过程如图 2-5 所示。对比普通递归和尾递归，两者的求和操作的执行点是不同的。</p>
<ul>
<li><strong>普通递归</strong>：求和操作是在“归”的过程中执行的，每层返回后都要再执行一次求和操作。</li>
<li><strong>尾递归</strong>：求和操作是在“递”的过程中执行的，“归”的过程只需层层返回。</li>
</ul>
<p><img loading="lazy" src="tail_recursion_sum.png" alt=""  />
</p>
<h4 id="递归树">递归树<a hidden class="anchor" aria-hidden="true" href="#递归树">#</a></h4>
<p>当处理与“分治”相关的算法问题时，递归往往比迭代的思路更加直观、代码更加易读。以“斐波那契数列”为例。</p>
<p>给定一个斐波那契数列 0,1,1,2,3,5,8,13,… ，求该数列的第 𝑛 个数字。</p>
<p>设斐波那契数列的第 𝑛 个数字为 𝑓(𝑛) ，易得两个结论。</p>
<ul>
<li>数列的前两个数字为 𝑓(1)=0 和 𝑓(2)=1 。</li>
<li>数列中的每个数字是前两个数字的和，即 𝑓(𝑛)=𝑓(𝑛−1)+𝑓(𝑛−2) 。</li>
</ul>
<p>按照递推关系进行递归调用，将前两个数字作为终止条件，便可写出递归代码。调用 <code>fib(n)</code> 即可得到斐波那契数列的第 𝑛 个数字：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 斐波那契数列：递归 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> fib(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 终止条件 f(1) = 0, f(2) = 1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (n == <span style="color:#ff0;font-weight:bold">1</span> || n == <span style="color:#ff0;font-weight:bold">2</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> n - <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 递归调用 f(n) = f(n-1) + f(n-2)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> res = fib(n - <span style="color:#ff0;font-weight:bold">1</span>) + fib(n - <span style="color:#ff0;font-weight:bold">2</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 返回结果 f(n)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>观察以上代码，我们在函数内递归调用了两个函数，<strong>这意味着从一个调用产生了两个调用分支</strong>。如图 2-6 所示，这样不断递归调用下去，最终将产生一棵层数为 𝑛 的递归树（recursion tree）。</p>
<p><img loading="lazy" src="recursion_tree.png" alt=""  />
</p>
<p>从本质上看，递归体现了“将问题分解为更小子问题”的思维范式，这种分治策略至关重要。</p>
<ul>
<li>从算法角度看，搜索、排序、回溯、分治、动态规划等许多重要算法策略直接或间接地应用了这种思维方式。</li>
<li>从数据结构角度看，递归天然适合处理链表、树和图的相关问题，因为它们非常适合用分治思想进行分析。</li>
</ul>
<h3 id="迭代和递归的对比">迭代和递归的对比<a hidden class="anchor" aria-hidden="true" href="#迭代和递归的对比">#</a></h3>
<p>总结以上内容，如表 2-1 所示，迭代和递归在实现、性能和适用性上有所不同。</p>
<p>表 2-1  迭代与递归特点对比</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">迭代</th>
<th style="text-align:left">递归</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">实现方式</td>
<td style="text-align:left">循环结构</td>
<td style="text-align:left">函数调用自身</td>
</tr>
<tr>
<td style="text-align:left">时间效率</td>
<td style="text-align:left">效率通常较高，无函数调用开销</td>
<td style="text-align:left">每次函数调用都会产生开销</td>
</tr>
<tr>
<td style="text-align:left">内存使用</td>
<td style="text-align:left">通常使用固定大小的内存空间</td>
<td style="text-align:left">累积函数调用可能使用大量的栈帧空间</td>
</tr>
<tr>
<td style="text-align:left">适用问题</td>
<td style="text-align:left">适用于简单循环任务，代码直观、可读性好</td>
<td style="text-align:left">适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰</td>
</tr>
</tbody>
</table>
<p>那么，迭代和递归具有什么内在联系呢？以上述递归函数为例，求和操作在递归的“归”阶段进行。这意味着最初被调用的函数实际上是最后完成其求和操作的，<strong>这种工作机制与栈的“先入后出”原则异曲同工</strong>。</p>
<p>事实上，“调用栈”和“栈帧空间”这类递归术语已经暗示了递归与栈之间的密切关系。</p>
<ol>
<li><strong>递</strong>：当函数被调用时，系统会在“调用栈”上为该函数分配新的栈帧，用于存储函数的局部变量、参数、返回地址等数据。</li>
<li><strong>归</strong>：当函数完成执行并返回时，对应的栈帧会被从“调用栈”上移除，恢复之前函数的执行环境。</li>
</ol>
<p>因此，<strong>我们可以使用一个显式的栈来模拟调用栈的行为</strong>，从而将递归转化为迭代形式：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 使用迭代模拟递归 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> forLoopRecur(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 使用一个显式的栈来模拟系统调用栈
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    Stack&lt;Integer&gt; stack = <span style="color:#fff;font-weight:bold">new</span> Stack&lt;&gt;();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> res = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 递：递归调用
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = n; i &gt; <span style="color:#ff0;font-weight:bold">0</span>; i--) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 通过“入栈操作”模拟“递”
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        stack.<span style="color:#007f7f">push</span>(i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 归：返回结果
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">while</span> (!stack.<span style="color:#007f7f">isEmpty</span>()) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 通过“出栈操作”模拟“归”
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        res += stack.<span style="color:#007f7f">pop</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// res = 1+2+3+...+n
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>观察以上代码，当递归转化为迭代后，代码变得更加复杂了。尽管迭代和递归在很多情况下可以互相转化，但不一定值得这样做，有以下两点原因。</p>
<ul>
<li>转化后的代码可能更加难以理解，可读性更差。</li>
<li>对于某些复杂问题，模拟系统调用栈的行为可能非常困难。</li>
</ul>
<p>总之，<strong>选择迭代还是递归取决于特定问题的性质</strong>。在编程实践中，权衡两者的优劣并根据情境选择合适的方法至关重要。</p>
<h2 id="时间复杂度">时间复杂度<a hidden class="anchor" aria-hidden="true" href="#时间复杂度">#</a></h2>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://funny-toffee-4aa7c3.netlify.app/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2024 <a href="https://funny-toffee-4aa7c3.netlify.app/">Wjy&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
