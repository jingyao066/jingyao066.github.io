<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>10_排序 | Wjy&#39;s Blog</title>
<meta name="keywords" content="算法">
<meta name="description" content="排序算法 排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效">
<meta name="author" content="Wjy">
<link rel="canonical" href="https://wjy6.netlify.app/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://wjy6.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://wjy6.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://wjy6.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://wjy6.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://wjy6.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://wjy6.netlify.app/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="https://wjy6.netlify.app/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/">
  <meta property="og:site_name" content="Wjy&#39;s Blog">
  <meta property="og:title" content="10_排序">
  <meta property="og:description" content="排序算法 排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-04T16:27:02+00:00">
    <meta property="article:modified_time" content="2024-06-04T16:27:02+00:00">
    <meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="10_排序">
<meta name="twitter:description" content="排序算法 排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://wjy6.netlify.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "10_排序",
      "item": "https://wjy6.netlify.app/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "10_排序",
  "name": "10_排序",
  "description": "排序算法 排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效",
  "keywords": [
    "算法"
  ],
  "articleBody": "排序算法 排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理。\n如图 11-1 所示，排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则。\n评价维度 运行效率：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。\n就地性：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。\n稳定性：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。\n稳定排序是多级排序场景的必要条件。假设我们有一个存储学生信息的表格，第 1 列和第 2 列分别是姓名和年龄。在这种情况下，非稳定排序可能导致输入数据的有序性丧失：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 # 输入数据是按照姓名排序好的 # (name, age) ('A', 19) ('B', 18) ('C', 21) ('D', 19) ('E', 23) # 假设使用非稳定排序算法按年龄排序列表， # 结果中 ('D', 19) 和 ('A', 19) 的相对位置改变， # 输入数据按姓名排序的性质丢失 ('B', 18) ('D', 19) ('A', 19) ('C', 21) ('E', 23) 自适应性：自适应排序的时间复杂度会受输入数据的影响，即最佳时间复杂度、最差时间复杂度、平均时间复杂度并不完全相等。\n自适应性需要根据具体情况来评估。如果最差时间复杂度差于平均时间复杂度，说明排序算法在某些数据下性能可能劣化，因此被视为负面属性；而如果最佳时间复杂度优于平均时间复杂度，则被视为正面属性。\n是否基于比较：基于比较的排序依赖比较运算符（\u003c、=、\u003e）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为 𝑂(𝑛log⁡𝑛) 。而非比较排序不使用比较运算符，时间复杂度可达 𝑂(𝑛) ，但其通用性相对较差。\n理想排序算法 运行快、原地、稳定、正向自适应、通用性好。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，需要根据具体的数据特点和问题需求来决定。\n接下来，我们将共同学习各种排序算法，并基于上述评价维度对各个排序算法的优缺点进行分析。\n选择排序 选择排序（selection sort）的工作原理非常简单：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。\n设数组的长度为 𝑛 ，选择排序的算法流程如图 11-2 所示。\n初始状态下，所有元素未排序，即未排序（索引）区间为 [0,𝑛−1] 。 选取区间 [0,𝑛−1] 中的最小元素，将其与索引 0 处的元素交换。完成后，数组前 1 个元素已排序。 选取区间 [1,𝑛−1] 中的最小元素，将其与索引 1 处的元素交换。完成后，数组前 2 个元素已排序。 以此类推。经过 𝑛−1 轮选择与交换后，数组前 𝑛−1 个元素已排序。 仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。 在代码中，我们用 𝑘 来记录未排序区间内的最小元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /* 选择排序 */ void selectionSort(int[] nums) { int n = nums.length; // 外循环：未排序区间为 [i, n-1] for (int i = 0; i \u003c n - 1; i++) { // 内循环：找到未排序区间内的最小元素 int k = i; for (int j = i + 1; j \u003c n; j++) { if (nums[j] \u003c nums[k]) k = j; // 记录最小元素的索引 } // 将该最小元素与未排序区间的首个元素交换 int temp = nums[i]; nums[i] = nums[k]; nums[k] = temp; } } 算法特性 时间复杂度为 $𝑂(𝑛^2)$、非自适应排序：外循环共 𝑛−1 轮，第一轮的未排序区间长度为 𝑛 ，最后一轮的未排序区间长度为 2 ，即各轮外循环分别包含 𝑛、𝑛−1、…、3、2 轮内循环，求和为 $(𝑛−1)(𝑛+2) \\over 2$ 。 空间复杂度为 𝑂(1)、原地排序：指针 𝑖 和 𝑗 使用常数大小的额外空间。 非稳定排序：如图 11-3 所示，元素 nums[i] 有可能被交换至与其相等的元素的右边，导致两者的相对顺序发生改变。 冒泡排序 冒泡排序（bubble sort）通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。\n如图 11-4 所示，冒泡过程可以利用元素交换操作来模拟：从数组最左端开始向右遍历，依次比较相邻元素大小，如果“左元素 \u003e 右元素”就交换二者。遍历完成后，最大的元素会被移动到数组的最右端。\n算法流程 设数组的长度为 𝑛 ，冒泡排序的步骤如图 11-5 所示。\n首先，对 𝑛 个元素执行“冒泡”，将数组的最大元素交换至正确位置。 接下来，对剩余 𝑛−1 个元素执行“冒泡”，将第二大元素交换至正确位置。 以此类推，经过 𝑛−1 轮“冒泡”后，前 𝑛−1 大的元素都被交换至正确位置。 仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。 示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* 冒泡排序 */ void bubbleSort(int[] nums) { // 外循环：未排序区间为 [0, i] for (int i = nums.length - 1; i \u003e 0; i--) { // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端 for (int j = 0; j \u003c i; j++) { if (nums[j] \u003e nums[j + 1]) { // 交换 nums[j] 与 nums[j + 1] int tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; } } } } 效率优化 我们发现，如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可以增加一个标志位 flag 来监测这种情况，一旦出现就立即返回。\n经过优化，冒泡排序的最差时间复杂度和平均时间复杂度仍为 $𝑂(𝑛^2)$ ；但当输入数组完全有序时，可达到最佳时间复杂度 𝑂(𝑛) 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 /* 冒泡排序（标志优化） */ void bubbleSortWithFlag(int[] nums) { // 外循环：未排序区间为 [0, i] for (int i = nums.length - 1; i \u003e 0; i--) { boolean flag = false; // 初始化标志位 // 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端 for (int j = 0; j \u003c i; j++) { if (nums[j] \u003e nums[j + 1]) { // 交换 nums[j] 与 nums[j + 1] int tmp = nums[j]; nums[j] = nums[j + 1]; nums[j + 1] = tmp; flag = true; // 记录交换元素 } } if (!flag) break; // 此轮“冒泡”未交换任何元素，直接跳出 } } 算法特性 时间复杂度为 $𝑂(𝑛^2)$、自适应排序：各轮“冒泡”遍历的数组长度依次为 𝑛−1、𝑛−2、…、2、1 ，总和为 (𝑛−1)𝑛/2 。在引入 flag 优化后，最佳时间复杂度可达到 𝑂(𝑛) 。 空间复杂度为 𝑂(1)、原地排序：指针 𝑖 和 𝑗 使用常数大小的额外空间。 稳定排序：由于在“冒泡”中遇到相等元素不交换。 插入排序 插入排序（insertion sort）是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似。\n具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。\n图 11-6 展示了数组插入元素的操作流程。设基准元素为 base ，我们需要将从目标索引到 base 之间的所有元素向右移动一位，然后将 base 赋值给目标索引。\n算法流程 插入排序的整体流程如图 11-7 所示。\n初始状态下，数组的第 1 个元素已完成排序。 选取数组的第 2 个元素作为 base ，将其插入到正确位置后，数组的前 2 个元素已排序。 选取第 3 个元素作为 base ，将其插入到正确位置后，数组的前 3 个元素已排序。 以此类推，在最后一轮中，选取最后一个元素作为 base ，将其插入到正确位置后，所有元素均已排序。 示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /* 插入排序 */ void insertionSort(int[] nums) { // 外循环：已排序区间为 [0, i-1] for (int i = 1; i \u003c nums.length; i++) { int base = nums[i], j = i - 1; // 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置 while (j \u003e= 0 \u0026\u0026 nums[j] \u003e base) { nums[j + 1] = nums[j]; // 将 nums[j] 向右移动一位 j--; } nums[j + 1] = base; // 将 base 赋值到正确位置 } } 算法特性 时间复杂度为 $𝑂(𝑛^2)$、自适应排序：在最差情况下，每次插入操作分别需要循环 𝑛−1、𝑛−2、…、2、1 次，求和得到 (𝑛−1)𝑛/2 ，因此时间复杂度为 $𝑂(𝑛^2)$ 。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度 𝑂(𝑛) 。 空间复杂度为 𝑂(1)、原地排序：指针 𝑖 和 𝑗 使用常数大小的额外空间。 稳定排序：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序。 插入排序的优势 插入排序的时间复杂度为 $𝑂(𝑛^2)$ ，而我们即将学习的快速排序的时间复杂度为 𝑂(𝑛log⁡𝑛) 。尽管插入排序的时间复杂度更高，但在数据量较小的情况下，插入排序通常更快。\n这个结论与线性查找和二分查找的适用情况的结论类似。快速排序这类 𝑂(𝑛log⁡𝑛) 的算法属于基于分治策略的排序算法，往往包含更多单元计算操作。而在数据量较小时，$𝑛^2$ 和 𝑛log⁡𝑛 的数值比较接近，复杂度不占主导地位，每轮中的单元操作数量起到决定性作用。\n实际上，许多编程语言（例如 Java）的内置排序函数采用了插入排序，大致思路为：对于长数组，采用基于分治策略的排序算法，例如快速排序；对于短数组，直接使用插入排序。\n虽然冒泡排序、选择排序和插入排序的时间复杂度都为 $𝑂(𝑛^2)$ ，但在实际情况中，插入排序的使用频率显著高于冒泡排序和选择排序，主要有以下原因。\n冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作；插入排序基于元素赋值实现，仅需 1 个单元操作。因此，冒泡排序的计算开销通常比插入排序更高。 选择排序在任何情况下的时间复杂度都为 $𝑂(𝑛^2)$ 。如果给定一组部分有序的数据，插入排序通常比选择排序效率更高。 选择排序不稳定，无法应用于多级排序。 快速排序 快速排序（quick sort）是一种基于分治策略的排序算法，运行高效，应用广泛。\n快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。具体来说，哨兵划分的流程如图 11-8 所示。\n选取数组最左端元素作为基准数，初始化两个指针 i 和 j 分别指向数组的两端。 设置一个循环，在每轮中使用 i（j）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。 循环执行步骤 2. ，直到 i 和 j 相遇时停止，最后将基准数交换至两个子数组的分界线。 哨兵划分完成后，原数组被划分成三部分：左子数组、基准数、右子数组，且满足“左子数组任意元素 ≤ 基准数 ≤ 右子数组任意元素”。因此，我们接下来只需对这两个子数组进行排序。\n快速排序的分治策略\n哨兵划分的实质是将一个较长数组的排序问题简化为两个较短数组的排序问题。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /* 元素交换 */ void swap(int[] nums, int i, int j) { int tmp = nums[i]; nums[i] = nums[j]; nums[j] = tmp; } /* 哨兵划分 */ int partition(int[] nums, int left, int right) { // 以 nums[left] 为基准数 int i = left, j = right; while (i \u003c j) { while (i \u003c j \u0026\u0026 nums[j] \u003e= nums[left]) j--; // 从右向左找首个小于基准数的元素 while (i \u003c j \u0026\u0026 nums[i] \u003c= nums[left]) i++; // 从左向右找首个大于基准数的元素 swap(nums, i, j); // 交换这两个元素 } swap(nums, i, left); // 将基准数交换至两子数组的分界线 return i; // 返回基准数的索引 } 算法流程 快速排序的整体流程如图 11-9 所示。\n首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。 然后，对左子数组和右子数组分别递归执行“哨兵划分”。 持续递归，直至子数组长度为 1 时终止，从而完成整个数组的排序。 1 2 3 4 5 6 7 8 9 10 11 /* 快速排序 */ void quickSort(int[] nums, int left, int right) { // 子数组长度为 1 时终止递归 if (left \u003e= right) return; // 哨兵划分 int pivot = partition(nums, left, right); // 递归左子数组、右子数组 quickSort(nums, left, pivot - 1); quickSort(nums, pivot + 1, right); } 算法特性 时间复杂度为 𝑂(𝑛log⁡𝑛)、自适应排序：在平均情况下，哨兵划分的递归层数为 log⁡𝑛 ，每层中的总循环数为 𝑛 ，总体使用 𝑂(𝑛log⁡𝑛) 时间。在最差情况下，每轮哨兵划分操作都将长度为 𝑛 的数组划分为长度为 0 和 𝑛−1 的两个子数组，此时递归层数达到 𝑛 ，每层中的循环数为 𝑛 ，总体使用 𝑂(𝑛2) 时间。 空间复杂度为 𝑂(𝑛)、原地排序：在输入数组完全倒序的情况下，达到最差递归深度 𝑛 ，使用 𝑂(𝑛) 栈帧空间。排序操作是在原数组上进行的，未借助额外数组。 非稳定排序：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。 快速排序为什么快 从名称上就能看出，快速排序在效率方面应该具有一定的优势。尽管快速排序的平均时间复杂度与“归并排序”和“堆排序”相同，但通常快速排序的效率更高，主要有以下原因。\n出现最差情况的概率很低：虽然快速排序的最差时间复杂度为 𝑂(𝑛2) ，没有归并排序稳定，但在绝大多数情况下，快速排序能在 𝑂(𝑛log⁡𝑛) 的时间复杂度下运行。 缓存使用效率高：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像“堆排序”这类算法需要跳跃式访问元素，从而缺乏这一特性。 复杂度的常数系数小：在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与“插入排序”比“冒泡排序”更快的原因类似。 基准数优化 快速排序在某些输入下的时间效率可能降低。举一个极端例子，假设输入数组是完全倒序的，由于我们选择最左端元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，导致左子数组长度为 𝑛−1、右子数组长度为 0 。如此递归下去，每轮哨兵划分后都有一个子数组的长度为 0 ，分治策略失效，快速排序退化为“冒泡排序”的近似形式。\n为了尽量避免这种情况发生，我们可以优化哨兵划分中的基准数的选取策略。例如，我们可以随机选取一个元素作为基准数。然而，如果运气不佳，每次都选到不理想的基准数，效率仍然不尽如人意。\n需要注意的是，编程语言通常生成的是“伪随机数”。如果我们针对伪随机数序列构建一个特定的测试样例，那么快速排序的效率仍然可能劣化。\n为了进一步改进，我们可以在数组中选取三个候选元素（通常为数组的首、尾、中点元素），并将这三个候选元素的中位数作为基准数。这样一来，基准数“既不太小也不太大”的概率将大幅提升。当然，我们还可以选取更多候选元素，以进一步提高算法的稳健性。采用这种方法后，时间复杂度劣化至 𝑂(𝑛2) 的概率大大降低。\n示例代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 选取三个候选元素的中位数 */ int medianThree(int[] nums, int left, int mid, int right) { int l = nums[left], m = nums[mid], r = nums[right]; if ((l \u003c= m \u0026\u0026 m \u003c= r) || (r \u003c= m \u0026\u0026 m \u003c= l)) return mid; // m 在 l 和 r 之间 if ((m \u003c= l \u0026\u0026 l \u003c= r) || (r \u003c= l \u0026\u0026 l \u003c= m)) return left; // l 在 m 和 r 之间 return right; } /* 哨兵划分（三数取中值） */ int partition(int[] nums, int left, int right) { // 选取三个候选元素的中位数 int med = medianThree(nums, left, (left + right) / 2, right); // 将中位数交换至数组最左端 swap(nums, left, med); // 以 nums[left] 为基准数 int i = left, j = right; while (i \u003c j) { while (i \u003c j \u0026\u0026 nums[j] \u003e= nums[left]) j--; // 从右向左找首个小于基准数的元素 while (i \u003c j \u0026\u0026 nums[i] \u003c= nums[left]) i++; // 从左向右找首个大于基准数的元素 swap(nums, i, j); // 交换这两个元素 } swap(nums, i, left); // 将基准数交换至两子数组的分界线 return i; // 返回基准数的索引 } 尾递归优化 在某些输入下，快速排序可能占用空间较多。以完全有序的输入数组为例，设递归中的子数组长度为 𝑚 ，每轮哨兵划分操作都将产生长度为 0 的左子数组和长度为 𝑚−1 的右子数组，这意味着每一层递归调用减少的问题规模非常小（只减少一个元素），递归树的高度会达到 𝑛−1 ，此时需要占用 𝑂(𝑛) 大小的栈帧空间。\n为了防止栈帧空间的累积，我们可以在每轮哨兵排序完成后，比较两个子数组的长度，仅对较短的子数组进行递归。由于较短子数组的长度不会超过 𝑛/2 ，因此这种方法能确保递归深度不超过 log⁡𝑛 ，从而将最差空间复杂度优化至 𝑂(log⁡𝑛) 。代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 /* 快速排序（尾递归优化） */ void quickSort(int[] nums, int left, int right) { // 子数组长度为 1 时终止 while (left \u003c right) { // 哨兵划分操作 int pivot = partition(nums, left, right); // 对两个子数组中较短的那个执行快速排序 if (pivot - left \u003c right - pivot) { quickSort(nums, left, pivot - 1); // 递归排序左子数组 left = pivot + 1; // 剩余未排序区间为 [pivot + 1, right] } else { quickSort(nums, pivot + 1, right); // 递归排序右子数组 right = pivot - 1; // 剩余未排序区间为 [left, pivot - 1] } } } 归并排序 归并排序（merge sort）是一种基于分治策略的排序算法，包含图 11-10 所示的“划分”和“合并”阶段。\n划分阶段：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。 合并阶段：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。 算法流程 如图 11-11 所示，“划分阶段”从顶至底递归地将数组从中点切分为两个子数组。\n计算数组中点 mid ，递归划分左子数组（区间 [left, mid] ）和右子数组（区间 [mid + 1, right] ）。 递归执行步骤 1. ，直至子数组区间长度为 1 时终止。 “合并阶段”从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开始合并，合并阶段中的每个子数组都是有序的。\n观察发现，归并排序与二叉树后序遍历的递归顺序是一致的。\n后序遍历：先递归左子树，再递归右子树，最后处理根节点。 归并排序：先递归左子数组，再递归右子数组，最后处理合并。 归并排序的实现如以下代码所示。请注意，nums 的待合并区间为 [left, right] ，而 tmp 的对应区间为 [0, right - left] 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* 合并左子数组和右子数组 */ void merge(int[] nums, int left, int mid, int right) { // 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right] // 创建一个临时数组 tmp ，用于存放合并后的结果 int[] tmp = new int[right - left + 1]; // 初始化左子数组和右子数组的起始索引 int i = left, j = mid + 1, k = 0; // 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中 while (i \u003c= mid \u0026\u0026 j \u003c= right) { if (nums[i] \u003c= nums[j]) tmp[k++] = nums[i++]; else tmp[k++] = nums[j++]; } // 将左子数组和右子数组的剩余元素复制到临时数组中 while (i \u003c= mid) { tmp[k++] = nums[i++]; } while (j \u003c= right) { tmp[k++] = nums[j++]; } // 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间 for (k = 0; k \u003c tmp.length; k++) { nums[left + k] = tmp[k]; } } /* 归并排序 */ void mergeSort(int[] nums, int left, int right) { // 终止条件 if (left \u003e= right) return; // 当子数组长度为 1 时终止递归 // 划分阶段 int mid = left + (right - left) / 2; // 计算中点 mergeSort(nums, left, mid); // 递归左子数组 mergeSort(nums, mid + 1, right); // 递归右子数组 // 合并阶段 merge(nums, left, mid, right); } 算法特性 时间复杂度为 𝑂(𝑛log⁡𝑛)、非自适应排序：划分产生高度为 log⁡𝑛 的递归树，每层合并的总操作数量为 𝑛 ，因此总体时间复杂度为 𝑂(𝑛log⁡𝑛) 。 空间复杂度为 𝑂(𝑛)、非原地排序：递归深度为 log⁡𝑛 ，使用 𝑂(log⁡𝑛) 大小的栈帧空间。合并操作需要借助辅助数组实现，使用 𝑂(𝑛) 大小的额外空间。 稳定排序：在合并过程中，相等元素的次序保持不变。 链表排序 对于链表，归并排序相较于其他排序算法具有显著优势，可以将链表排序任务的空间复杂度优化至 𝑂(1) 。\n划分阶段：可以使用“迭代”替代“递归”来实现链表划分工作，从而省去递归使用的栈帧空间。 合并阶段：在链表中，节点增删操作仅需改变引用（指针）即可实现，因此合并阶段（将两个短有序链表合并为一个长有序链表）无须创建额外链表。 具体实现细节比较复杂，有兴趣的读者可以查阅相关资料进行学习。\n堆排序 堆排序（heap sort）是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和“元素出堆操作”实现堆排序。\n输入数组并建立小顶堆，此时最小元素位于堆顶。 不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列。 以上方法虽然可行，但需要借助一个额外数组来保存弹出的元素，比较浪费空间。在实际中，我们通常使用一种更加优雅的实现方式。\n算法流程¶ 设数组的长度为 𝑛 ，堆排序的流程如图 11-12 所示。\n输入数组并建立大顶堆。完成后，最大元素位于堆顶。 将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减 1 ，已排序元素数量加 1 。 从堆顶元素开始，从顶到底执行堆化操作（sift down）。完成堆化后，堆的性质得到修复。 循环执行第 2. 步和第 3. 步。循环 𝑛−1 轮后，即可完成数组排序。 Tip：实际上，元素出堆操作中也包含第 2. 步和第 3. 步，只是多了一个弹出元素的步骤。\n在代码实现中，我们使用了与“堆”章节相同的从顶至底堆化 sift_down() 函数。值得注意的是，由于堆的长度会随着提取最大元素而减小，因此我们需要给 sift_down() 函数添加一个长度参数 𝑛 ，用于指定堆的当前有效长度。代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */ void siftDown(int[] nums, int n, int i) { while (true) { // 判断节点 i, l, r 中值最大的节点，记为 ma int l = 2 * i + 1; int r = 2 * i + 2; int ma = i; if (l \u003c n \u0026\u0026 nums[l] \u003e nums[ma]) ma = l; if (r \u003c n \u0026\u0026 nums[r] \u003e nums[ma]) ma = r; // 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出 if (ma == i) break; // 交换两节点 int temp = nums[i]; nums[i] = nums[ma]; nums[ma] = temp; // 循环向下堆化 i = ma; } } /* 堆排序 */ void heapSort(int[] nums) { // 建堆操作：堆化除叶节点以外的其他所有节点 for (int i = nums.length / 2 - 1; i \u003e= 0; i--) { siftDown(nums, nums.length, i); } // 从堆中提取最大元素，循环 n-1 轮 for (int i = nums.length - 1; i \u003e 0; i--) { // 交换根节点与最右叶节点（交换首元素与尾元素） int tmp = nums[0]; nums[0] = nums[i]; nums[i] = tmp; // 以根节点为起点，从顶至底进行堆化 siftDown(nums, i, 0); } } 算法特性 时间复杂度为 𝑂(𝑛log⁡𝑛)、非自适应排序：建堆操作使用 𝑂(𝑛) 时间。从堆中提取最大元素的时间复杂度为 𝑂(log⁡𝑛) ，共循环 𝑛−1 轮。 空间复杂度为 𝑂(1)、原地排序：几个指针变量使用 𝑂(1) 空间。元素交换和堆化操作都是在原数组上进行的。 非稳定排序：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化。 桶排序 前述几种排序算法都属于“基于比较的排序算法”，它们通过比较元素间的大小来实现排序。此类排序算法的时间复杂度无法超越 𝑂(𝑛log⁡𝑛) 。接下来，我们将探讨几种“非比较排序算法”，它们的时间复杂度可以达到线性阶。\n桶排序（bucket sort）是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。\n算法流程 考虑一个长度为 𝑛 的数组，其元素是范围 [0,1) 内的浮点数。桶排序的流程如图 11-13 所示。\n初始化 𝑘 个桶，将 𝑛 个元素分配到 𝑘 个桶中。 对每个桶分别执行排序（这里采用编程语言的内置排序函数）。 按照桶从小到大的顺序合并结果。 代码如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 /* 桶排序 */ void bucketSort(float[] nums) { // 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素 int k = nums.length / 2; List",
  "wordCount" : "14240",
  "inLanguage": "en",
  "datePublished": "2024-06-04T16:27:02Z",
  "dateModified": "2024-06-04T16:27:02Z",
  "author":{
    "@type": "Person",
    "name": "Wjy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://wjy6.netlify.app/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Wjy's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://wjy6.netlify.app/favicon.ico"
    }
  }
}
</script>

  <script id="MathJax-script" async src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-chtml.min.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath:  [['\\(', '\\)'], ['$', '$']],  
    }
  };
</script>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://wjy6.netlify.app/" accesskey="h" title="Wjy&#39;s Blog (Alt + H)">Wjy&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://wjy6.netlify.app/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://wjy6.netlify.app/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://wjy6.netlify.app/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://wjy6.netlify.app/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://wjy6.netlify.app/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://wjy6.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://wjy6.netlify.app/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      10_排序
    </h1>
    <div class="post-meta"><span title='2024-06-04 16:27:02 +0000 UTC'>2024-06-04</span>&nbsp;·&nbsp;Wjy

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95" aria-label="排序算法">排序算法</a><ul>
                        
                <li>
                    <a href="#%e8%af%84%e4%bb%b7%e7%bb%b4%e5%ba%a6" aria-label="评价维度">评价维度</a></li>
                <li>
                    <a href="#%e7%90%86%e6%83%b3%e6%8e%92%e5%ba%8f%e7%ae%97%e6%b3%95" aria-label="理想排序算法">理想排序算法</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%80%89%e6%8b%a9%e6%8e%92%e5%ba%8f" aria-label="选择排序">选择排序</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e7%89%b9%e6%80%a7" aria-label="算法特性">算法特性</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%86%92%e6%b3%a1%e6%8e%92%e5%ba%8f" aria-label="冒泡排序">冒泡排序</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%b5%81%e7%a8%8b" aria-label="算法流程">算法流程</a></li>
                <li>
                    <a href="#%e6%95%88%e7%8e%87%e4%bc%98%e5%8c%96" aria-label="效率优化">效率优化</a></li>
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e7%89%b9%e6%80%a7-1" aria-label="算法特性">算法特性</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f" aria-label="插入排序">插入排序</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%b5%81%e7%a8%8b-1" aria-label="算法流程">算法流程</a></li>
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e7%89%b9%e6%80%a7-2" aria-label="算法特性">算法特性</a></li>
                <li>
                    <a href="#%e6%8f%92%e5%85%a5%e6%8e%92%e5%ba%8f%e7%9a%84%e4%bc%98%e5%8a%bf" aria-label="插入排序的优势">插入排序的优势</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f" aria-label="快速排序">快速排序</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%b5%81%e7%a8%8b-2" aria-label="算法流程">算法流程</a></li>
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e7%89%b9%e6%80%a7-3" aria-label="算法特性">算法特性</a></li>
                <li>
                    <a href="#%e5%bf%ab%e9%80%9f%e6%8e%92%e5%ba%8f%e4%b8%ba%e4%bb%80%e4%b9%88%e5%bf%ab" aria-label="快速排序为什么快">快速排序为什么快</a></li>
                <li>
                    <a href="#%e5%9f%ba%e5%87%86%e6%95%b0%e4%bc%98%e5%8c%96" aria-label="基准数优化">基准数优化</a></li>
                <li>
                    <a href="#%e5%b0%be%e9%80%92%e5%bd%92%e4%bc%98%e5%8c%96" aria-label="尾递归优化">尾递归优化</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%bd%92%e5%b9%b6%e6%8e%92%e5%ba%8f" aria-label="归并排序">归并排序</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%b5%81%e7%a8%8b-3" aria-label="算法流程">算法流程</a></li>
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e7%89%b9%e6%80%a7-4" aria-label="算法特性">算法特性</a></li>
                <li>
                    <a href="#%e9%93%be%e8%a1%a8%e6%8e%92%e5%ba%8f" aria-label="链表排序">链表排序</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a0%86%e6%8e%92%e5%ba%8f" aria-label="堆排序">堆排序</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%b5%81%e7%a8%8bhttpswwwhello-algocomchapter_sortingheap_sort1171" aria-label="算法流程¶">算法流程¶</a></li>
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e7%89%b9%e6%80%a7-5" aria-label="算法特性">算法特性</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%a1%b6%e6%8e%92%e5%ba%8f" aria-label="桶排序">桶排序</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%b5%81%e7%a8%8b-4" aria-label="算法流程">算法流程</a></li>
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e7%89%b9%e6%80%a7-6" aria-label="算法特性">算法特性</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%ae%9e%e7%8e%b0%e5%b9%b3%e5%9d%87%e5%88%86%e9%85%8d" aria-label="如何实现平均分配">如何实现平均分配</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%ae%a1%e6%95%b0%e6%8e%92%e5%ba%8f" aria-label="计数排序">计数排序</a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e5%8d%95%e5%ae%9e%e7%8e%b0httpswwwhello-algocomchapter_sortingcounting_sort1191" aria-label="简单实现¶">简单实现¶</a></li>
                <li>
                    <a href="#%e5%ae%8c%e6%95%b4%e5%ae%9e%e7%8e%b0httpswwwhello-algocomchapter_sortingcounting_sort1192" aria-label="完整实现¶">完整实现¶</a></li>
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e7%89%b9%e6%80%a7-7" aria-label="算法特性">算法特性</a></li>
                <li>
                    <a href="#%e5%b1%80%e9%99%90%e6%80%a7" aria-label="局限性">局限性</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9f%ba%e6%95%b0%e6%8e%92%e5%ba%8f" aria-label="基数排序">基数排序</a><ul>
                        
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e6%b5%81%e7%a8%8bhttpswwwhello-algocomchapter_sortingradix_sort11101" aria-label="算法流程¶">算法流程¶</a></li>
                <li>
                    <a href="#%e7%ae%97%e6%b3%95%e7%89%b9%e6%80%a7-8" aria-label="算法特性">算法特性</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b0%8f%e7%bb%93" aria-label="小结">小结</a><ul>
                        
                <li>
                    <a href="#%e9%87%8d%e7%82%b9%e5%9b%9e%e9%a1%be" aria-label="重点回顾">重点回顾</a></li>
                <li>
                    <a href="#q--a" aria-label="Q &amp; A">Q &amp; A</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="排序算法">排序算法<a hidden class="anchor" aria-hidden="true" href="#排序算法">#</a></h1>
<p>排序算法（sorting algorithm）用于对一组数据按照特定顺序进行排列。排序算法有着广泛的应用，因为有序数据通常能够被更高效地查找、分析和处理。</p>
<p>如图 11-1 所示，排序算法中的数据类型可以是整数、浮点数、字符或字符串等。排序的判断规则可根据需求设定，如数字大小、字符 ASCII 码顺序或自定义规则。</p>
<p><img alt="图 11-1  数据类型和判断规则示例" loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/sorting_examples.png"></p>
<h2 id="评价维度">评价维度<a hidden class="anchor" aria-hidden="true" href="#评价维度">#</a></h2>
<p><strong>运行效率</strong>：我们期望排序算法的时间复杂度尽量低，且总体操作数量较少（时间复杂度中的常数项变小）。对于大数据量的情况，运行效率显得尤为重要。</p>
<p><strong>就地性</strong>：顾名思义，原地排序通过在原数组上直接操作实现排序，无须借助额外的辅助数组，从而节省内存。通常情况下，原地排序的数据搬运操作较少，运行速度也更快。</p>
<p><strong>稳定性</strong>：稳定排序在完成排序后，相等元素在数组中的相对顺序不发生改变。</p>
<p>稳定排序是多级排序场景的必要条件。假设我们有一个存储学生信息的表格，第 1 列和第 2 列分别是姓名和年龄。在这种情况下，非稳定排序可能导致输入数据的有序性丧失：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span># 输入数据是按照姓名排序好的
</span></span><span style="display:flex;"><span># (name, age)
</span></span><span style="display:flex;"><span>  (&#39;A&#39;, 19)
</span></span><span style="display:flex;"><span>  (&#39;B&#39;, 18)
</span></span><span style="display:flex;"><span>  (&#39;C&#39;, 21)
</span></span><span style="display:flex;"><span>  (&#39;D&#39;, 19)
</span></span><span style="display:flex;"><span>  (&#39;E&#39;, 23)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span># 假设使用非稳定排序算法按年龄排序列表，
</span></span><span style="display:flex;"><span># 结果中 (&#39;D&#39;, 19) 和 (&#39;A&#39;, 19) 的相对位置改变，
</span></span><span style="display:flex;"><span># 输入数据按姓名排序的性质丢失
</span></span><span style="display:flex;"><span>  (&#39;B&#39;, 18)
</span></span><span style="display:flex;"><span>  (&#39;D&#39;, 19)
</span></span><span style="display:flex;"><span>  (&#39;A&#39;, 19)
</span></span><span style="display:flex;"><span>  (&#39;C&#39;, 21)
</span></span><span style="display:flex;"><span>  (&#39;E&#39;, 23)
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>自适应性</strong>：自适应排序的时间复杂度会受输入数据的影响，即最佳时间复杂度、最差时间复杂度、平均时间复杂度并不完全相等。</p>
<p>自适应性需要根据具体情况来评估。如果最差时间复杂度差于平均时间复杂度，说明排序算法在某些数据下性能可能劣化，因此被视为负面属性；而如果最佳时间复杂度优于平均时间复杂度，则被视为正面属性。</p>
<p><strong>是否基于比较</strong>：基于比较的排序依赖比较运算符（&lt;、=、&gt;）来判断元素的相对顺序，从而排序整个数组，理论最优时间复杂度为 𝑂(𝑛log⁡𝑛) 。而非比较排序不使用比较运算符，时间复杂度可达 𝑂(𝑛) ，但其通用性相对较差。</p>
<h2 id="理想排序算法">理想排序算法<a hidden class="anchor" aria-hidden="true" href="#理想排序算法">#</a></h2>
<p><strong>运行快、原地、稳定、正向自适应、通用性好</strong>。显然，迄今为止尚未发现兼具以上所有特性的排序算法。因此，在选择排序算法时，需要根据具体的数据特点和问题需求来决定。</p>
<p>接下来，我们将共同学习各种排序算法，并基于上述评价维度对各个排序算法的优缺点进行分析。</p>
<h1 id="选择排序">选择排序<a hidden class="anchor" aria-hidden="true" href="#选择排序">#</a></h1>
<p>选择排序（selection sort）的工作原理非常简单：开启一个循环，每轮从未排序区间选择最小的元素，将其放到已排序区间的末尾。</p>
<p>设数组的长度为 𝑛 ，选择排序的算法流程如图 11-2 所示。</p>
<ol>
<li>初始状态下，所有元素未排序，即未排序（索引）区间为 [0,𝑛−1] 。</li>
<li>选取区间 [0,𝑛−1] 中的最小元素，将其与索引 0 处的元素交换。完成后，数组前 1 个元素已排序。</li>
<li>选取区间 [1,𝑛−1] 中的最小元素，将其与索引 1 处的元素交换。完成后，数组前 2 个元素已排序。</li>
<li>以此类推。经过 𝑛−1 轮选择与交换后，数组前 𝑛−1 个元素已排序。</li>
<li>仅剩的一个元素必定是最大元素，无须排序，因此数组排序完成。</li>
</ol>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/selection_sort_step1.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/selection_sort_step2.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/selection_sort_step3.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/selection_sort_step4.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/selection_sort_step5.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/selection_sort_step6.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/selection_sort_step7.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/selection_sort_step8.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/selection_sort_step9.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/selection_sort_step10.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/selection_sort_step11.png"></p>
<p>在代码中，我们用 𝑘 来记录未排序区间内的最小元素：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 选择排序 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> selectionSort(<span style="color:#fff;font-weight:bold">int</span>[] nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> n = nums.<span style="color:#007f7f">length</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 外循环：未排序区间为 [i, n-1]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 0; i &lt; n - 1; i++) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 内循环：找到未排序区间内的最小元素</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> k = i;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = i + 1; j &lt; n; j++) {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">if</span> (nums[j] &lt; nums[k])
</span></span><span style="display:flex;"><span>                k = j; <span style="color:#007f7f">// 记录最小元素的索引</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 将该最小元素与未排序区间的首个元素交换</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> temp = nums[i];
</span></span><span style="display:flex;"><span>        nums[i] = nums[k];
</span></span><span style="display:flex;"><span>        nums[k] = temp;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="算法特性">算法特性<a hidden class="anchor" aria-hidden="true" href="#算法特性">#</a></h2>
<ul>
<li><strong>时间复杂度为 $𝑂(𝑛^2)$、非自适应排序</strong>：外循环共 𝑛−1 轮，第一轮的未排序区间长度为 𝑛 ，最后一轮的未排序区间长度为 2 ，即各轮外循环分别包含 𝑛、𝑛−1、…、3、2 轮内循环，求和为 $(𝑛−1)(𝑛+2) \over 2$ 。</li>
<li><strong>空间复杂度为 𝑂(1)、原地排序</strong>：指针 𝑖 和 𝑗 使用常数大小的额外空间。</li>
<li><strong>非稳定排序</strong>：如图 11-3 所示，元素 <code>nums[i]</code> 有可能被交换至与其相等的元素的右边，导致两者的相对顺序发生改变。</li>
</ul>
<h1 id="冒泡排序">冒泡排序<a hidden class="anchor" aria-hidden="true" href="#冒泡排序">#</a></h1>
<p>冒泡排序（bubble sort）通过连续地比较与交换相邻元素实现排序。这个过程就像气泡从底部升到顶部一样，因此得名冒泡排序。</p>
<p>如图 11-4 所示，冒泡过程可以利用元素交换操作来模拟：从数组最左端开始向右遍历，依次比较相邻元素大小，如果“左元素 &gt; 右元素”就交换二者。遍历完成后，最大的元素会被移动到数组的最右端。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/bubble_operation_step1.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/bubble_operation_step2.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/bubble_operation_step3.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/bubble_operation_step4.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/bubble_operation_step5.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/bubble_operation_step6.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/bubble_operation_step7.png"></p>
<h2 id="算法流程">算法流程<a hidden class="anchor" aria-hidden="true" href="#算法流程">#</a></h2>
<p>设数组的长度为 𝑛 ，冒泡排序的步骤如图 11-5 所示。</p>
<ol>
<li>首先，对 𝑛 个元素执行“冒泡”，<strong>将数组的最大元素交换至正确位置</strong>。</li>
<li>接下来，对剩余 𝑛−1 个元素执行“冒泡”，<strong>将第二大元素交换至正确位置</strong>。</li>
<li>以此类推，经过 𝑛−1 轮“冒泡”后，<strong>前 𝑛−1 大的元素都被交换至正确位置</strong>。</li>
<li>仅剩的一个元素必定是最小元素，无须排序，因此数组排序完成。</li>
</ol>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/bubble_sort_overview.png"></p>
<p>示例代码如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 冒泡排序 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> bubbleSort(<span style="color:#fff;font-weight:bold">int</span>[] nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 外循环：未排序区间为 [0, i]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = nums.<span style="color:#007f7f">length</span> - 1; i &gt; 0; i--) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = 0; j &lt; i; j++) {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">if</span> (nums[j] &gt; nums[j + 1]) {
</span></span><span style="display:flex;"><span>                <span style="color:#007f7f">// 交换 nums[j] 与 nums[j + 1]</span>
</span></span><span style="display:flex;"><span>                <span style="color:#fff;font-weight:bold">int</span> tmp = nums[j];
</span></span><span style="display:flex;"><span>                nums[j] = nums[j + 1];
</span></span><span style="display:flex;"><span>                nums[j + 1] = tmp;
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="效率优化">效率优化<a hidden class="anchor" aria-hidden="true" href="#效率优化">#</a></h2>
<p>我们发现，如果某轮“冒泡”中没有执行任何交换操作，说明数组已经完成排序，可直接返回结果。因此，可以增加一个标志位 <code>flag</code> 来监测这种情况，一旦出现就立即返回。</p>
<p>经过优化，冒泡排序的最差时间复杂度和平均时间复杂度仍为 $𝑂(𝑛^2)$ ；但当输入数组完全有序时，可达到最佳时间复杂度 𝑂(𝑛) 。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 冒泡排序（标志优化） */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> bubbleSortWithFlag(<span style="color:#fff;font-weight:bold">int</span>[] nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 外循环：未排序区间为 [0, i]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = nums.<span style="color:#007f7f">length</span> - 1; i &gt; 0; i--) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">boolean</span> flag = <span style="color:#fff;font-weight:bold">false</span>; <span style="color:#007f7f">// 初始化标志位</span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 内循环：将未排序区间 [0, i] 中的最大元素交换至该区间的最右端</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = 0; j &lt; i; j++) {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">if</span> (nums[j] &gt; nums[j + 1]) {
</span></span><span style="display:flex;"><span>                <span style="color:#007f7f">// 交换 nums[j] 与 nums[j + 1]</span>
</span></span><span style="display:flex;"><span>                <span style="color:#fff;font-weight:bold">int</span> tmp = nums[j];
</span></span><span style="display:flex;"><span>                nums[j] = nums[j + 1];
</span></span><span style="display:flex;"><span>                nums[j + 1] = tmp;
</span></span><span style="display:flex;"><span>                flag = <span style="color:#fff;font-weight:bold">true</span>; <span style="color:#007f7f">// 记录交换元素</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (!flag)
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">break</span>; <span style="color:#007f7f">// 此轮“冒泡”未交换任何元素，直接跳出</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="算法特性-1">算法特性<a hidden class="anchor" aria-hidden="true" href="#算法特性-1">#</a></h2>
<ul>
<li><strong>时间复杂度为 $𝑂(𝑛^2)$、自适应排序</strong>：各轮“冒泡”遍历的数组长度依次为 𝑛−1、𝑛−2、…、2、1 ，总和为 (𝑛−1)𝑛/2 。在引入 <code>flag</code> 优化后，最佳时间复杂度可达到 𝑂(𝑛) 。</li>
<li><strong>空间复杂度为 𝑂(1)、原地排序</strong>：指针 𝑖 和 𝑗 使用常数大小的额外空间。</li>
<li><strong>稳定排序</strong>：由于在“冒泡”中遇到相等元素不交换。</li>
</ul>
<h1 id="插入排序">插入排序<a hidden class="anchor" aria-hidden="true" href="#插入排序">#</a></h1>
<p>插入排序（insertion sort）是一种简单的排序算法，它的工作原理与手动整理一副牌的过程非常相似。</p>
<p>具体来说，我们在未排序区间选择一个基准元素，将该元素与其左侧已排序区间的元素逐一比较大小，并将该元素插入到正确的位置。</p>
<p>图 11-6 展示了数组插入元素的操作流程。设基准元素为 <code>base</code> ，我们需要将从目标索引到 <code>base</code> 之间的所有元素向右移动一位，然后将 <code>base</code> 赋值给目标索引。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/insertion_operation.png"></p>
<h2 id="算法流程-1">算法流程<a hidden class="anchor" aria-hidden="true" href="#算法流程-1">#</a></h2>
<p>插入排序的整体流程如图 11-7 所示。</p>
<ol>
<li>初始状态下，数组的第 1 个元素已完成排序。</li>
<li>选取数组的第 2 个元素作为 <code>base</code> ，将其插入到正确位置后，<strong>数组的前 2 个元素已排序</strong>。</li>
<li>选取第 3 个元素作为 <code>base</code> ，将其插入到正确位置后，<strong>数组的前 3 个元素已排序</strong>。</li>
<li>以此类推，在最后一轮中，选取最后一个元素作为 <code>base</code> ，将其插入到正确位置后，<strong>所有元素均已排序</strong>。</li>
</ol>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/insertion_sort_overview.png"></p>
<p>示例代码如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 插入排序 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> insertionSort(<span style="color:#fff;font-weight:bold">int</span>[] nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 外循环：已排序区间为 [0, i-1]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 1; i &lt; nums.<span style="color:#007f7f">length</span>; i++) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> base = nums[i], j = i - 1;
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 内循环：将 base 插入到已排序区间 [0, i-1] 中的正确位置</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">while</span> (j &gt;= 0 &amp;&amp; nums[j] &gt; base) {
</span></span><span style="display:flex;"><span>            nums[j + 1] = nums[j]; <span style="color:#007f7f">// 将 nums[j] 向右移动一位</span>
</span></span><span style="display:flex;"><span>            j--;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        nums[j + 1] = base;        <span style="color:#007f7f">// 将 base 赋值到正确位置</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="算法特性-2">算法特性<a hidden class="anchor" aria-hidden="true" href="#算法特性-2">#</a></h2>
<ul>
<li><strong>时间复杂度为 $𝑂(𝑛^2)$、自适应排序</strong>：在最差情况下，每次插入操作分别需要循环 𝑛−1、𝑛−2、…、2、1 次，求和得到 (𝑛−1)𝑛/2 ，因此时间复杂度为 $𝑂(𝑛^2)$ 。在遇到有序数据时，插入操作会提前终止。当输入数组完全有序时，插入排序达到最佳时间复杂度 𝑂(𝑛) 。</li>
<li><strong>空间复杂度为 𝑂(1)、原地排序</strong>：指针 𝑖 和 𝑗 使用常数大小的额外空间。</li>
<li><strong>稳定排序</strong>：在插入操作过程中，我们会将元素插入到相等元素的右侧，不会改变它们的顺序。</li>
</ul>
<h2 id="插入排序的优势">插入排序的优势<a hidden class="anchor" aria-hidden="true" href="#插入排序的优势">#</a></h2>
<p>插入排序的时间复杂度为 $𝑂(𝑛^2)$ ，而我们即将学习的快速排序的时间复杂度为 𝑂(𝑛log⁡𝑛) 。尽管插入排序的时间复杂度更高，<strong>但在数据量较小的情况下，插入排序通常更快</strong>。</p>
<p>这个结论与线性查找和二分查找的适用情况的结论类似。快速排序这类 𝑂(𝑛log⁡𝑛) 的算法属于基于分治策略的排序算法，往往包含更多单元计算操作。而在数据量较小时，$𝑛^2$ 和 𝑛log⁡𝑛 的数值比较接近，复杂度不占主导地位，每轮中的单元操作数量起到决定性作用。</p>
<p>实际上，许多编程语言（例如 Java）的内置排序函数采用了插入排序，大致思路为：对于长数组，采用基于分治策略的排序算法，例如快速排序；对于短数组，直接使用插入排序。</p>
<p>虽然冒泡排序、选择排序和插入排序的时间复杂度都为 $𝑂(𝑛^2)$ ，但在实际情况中，<strong>插入排序的使用频率显著高于冒泡排序和选择排序</strong>，主要有以下原因。</p>
<ul>
<li>冒泡排序基于元素交换实现，需要借助一个临时变量，共涉及 3 个单元操作；插入排序基于元素赋值实现，仅需 1 个单元操作。因此，<strong>冒泡排序的计算开销通常比插入排序更高</strong>。</li>
<li>选择排序在任何情况下的时间复杂度都为 $𝑂(𝑛^2)$ 。<strong>如果给定一组部分有序的数据，插入排序通常比选择排序效率更高</strong>。</li>
<li>选择排序不稳定，无法应用于多级排序。</li>
</ul>
<h1 id="快速排序">快速排序<a hidden class="anchor" aria-hidden="true" href="#快速排序">#</a></h1>
<p>快速排序（quick sort）是一种基于分治策略的排序算法，运行高效，应用广泛。</p>
<p>快速排序的核心操作是“哨兵划分”，其目标是：选择数组中的某个元素作为“基准数”，将所有小于基准数的元素移到其左侧，而大于基准数的元素移到其右侧。具体来说，哨兵划分的流程如图 11-8 所示。</p>
<ol>
<li>选取数组最左端元素作为基准数，初始化两个指针 <code>i</code> 和 <code>j</code> 分别指向数组的两端。</li>
<li>设置一个循环，在每轮中使用 <code>i</code>（<code>j</code>）分别寻找第一个比基准数大（小）的元素，然后交换这两个元素。</li>
<li>循环执行步骤 <code>2.</code> ，直到 <code>i</code> 和 <code>j</code> 相遇时停止，最后将基准数交换至两个子数组的分界线。</li>
</ol>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/pivot_division_step1.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/pivot_division_step2.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/pivot_division_step3.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/pivot_division_step4.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/pivot_division_step5.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/pivot_division_step6.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/pivot_division_step7.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/pivot_division_step8.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/pivot_division_step9.png"></p>
<p>哨兵划分完成后，原数组被划分成三部分：左子数组、基准数、右子数组，且满足“左子数组任意元素 ≤ 基准数 ≤ 右子数组任意元素”。因此，我们接下来只需对这两个子数组进行排序。</p>
<blockquote>
<p>快速排序的分治策略</p>
<p>哨兵划分的实质是将一个较长数组的排序问题简化为两个较短数组的排序问题。</p>
</blockquote>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 元素交换 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> swap(<span style="color:#fff;font-weight:bold">int</span>[] nums, <span style="color:#fff;font-weight:bold">int</span> i, <span style="color:#fff;font-weight:bold">int</span> j) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> tmp = nums[i];
</span></span><span style="display:flex;"><span>    nums[i] = nums[j];
</span></span><span style="display:flex;"><span>    nums[j] = tmp;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* 哨兵划分 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> partition(<span style="color:#fff;font-weight:bold">int</span>[] nums, <span style="color:#fff;font-weight:bold">int</span> left, <span style="color:#fff;font-weight:bold">int</span> right) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 以 nums[left] 为基准数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> i = left, j = right;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> (i &lt; j) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])
</span></span><span style="display:flex;"><span>            j--;          <span style="color:#007f7f">// 从右向左找首个小于基准数的元素</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])
</span></span><span style="display:flex;"><span>            i++;          <span style="color:#007f7f">// 从左向右找首个大于基准数的元素</span>
</span></span><span style="display:flex;"><span>        swap(nums, i, j); <span style="color:#007f7f">// 交换这两个元素</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    swap(nums, i, left);  <span style="color:#007f7f">// 将基准数交换至两子数组的分界线</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> i;             <span style="color:#007f7f">// 返回基准数的索引</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="算法流程-2">算法流程<a hidden class="anchor" aria-hidden="true" href="#算法流程-2">#</a></h2>
<p>快速排序的整体流程如图 11-9 所示。</p>
<ol>
<li>首先，对原数组执行一次“哨兵划分”，得到未排序的左子数组和右子数组。</li>
<li>然后，对左子数组和右子数组分别递归执行“哨兵划分”。</li>
<li>持续递归，直至子数组长度为 1 时终止，从而完成整个数组的排序。</li>
</ol>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/quick_sort_overview.png"></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 快速排序 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> quickSort(<span style="color:#fff;font-weight:bold">int</span>[] nums, <span style="color:#fff;font-weight:bold">int</span> left, <span style="color:#fff;font-weight:bold">int</span> right) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 子数组长度为 1 时终止递归</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (left &gt;= right)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 哨兵划分</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> pivot = partition(nums, left, right);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 递归左子数组、右子数组</span>
</span></span><span style="display:flex;"><span>    quickSort(nums, left, pivot - 1);
</span></span><span style="display:flex;"><span>    quickSort(nums, pivot + 1, right);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="算法特性-3">算法特性<a hidden class="anchor" aria-hidden="true" href="#算法特性-3">#</a></h2>
<ul>
<li><strong>时间复杂度为 𝑂(𝑛log⁡𝑛)、自适应排序</strong>：在平均情况下，哨兵划分的递归层数为 log⁡𝑛 ，每层中的总循环数为 𝑛 ，总体使用 𝑂(𝑛log⁡𝑛) 时间。在最差情况下，每轮哨兵划分操作都将长度为 𝑛 的数组划分为长度为 0 和 𝑛−1 的两个子数组，此时递归层数达到 𝑛 ，每层中的循环数为 𝑛 ，总体使用 𝑂(𝑛2) 时间。</li>
<li><strong>空间复杂度为 𝑂(𝑛)、原地排序</strong>：在输入数组完全倒序的情况下，达到最差递归深度 𝑛 ，使用 𝑂(𝑛) 栈帧空间。排序操作是在原数组上进行的，未借助额外数组。</li>
<li><strong>非稳定排序</strong>：在哨兵划分的最后一步，基准数可能会被交换至相等元素的右侧。</li>
</ul>
<h2 id="快速排序为什么快">快速排序为什么快<a hidden class="anchor" aria-hidden="true" href="#快速排序为什么快">#</a></h2>
<p>从名称上就能看出，快速排序在效率方面应该具有一定的优势。尽管快速排序的平均时间复杂度与“归并排序”和“堆排序”相同，但通常快速排序的效率更高，主要有以下原因。</p>
<ul>
<li><strong>出现最差情况的概率很低</strong>：虽然快速排序的最差时间复杂度为 𝑂(𝑛2) ，没有归并排序稳定，但在绝大多数情况下，快速排序能在 𝑂(𝑛log⁡𝑛) 的时间复杂度下运行。</li>
<li><strong>缓存使用效率高</strong>：在执行哨兵划分操作时，系统可将整个子数组加载到缓存，因此访问元素的效率较高。而像“堆排序”这类算法需要跳跃式访问元素，从而缺乏这一特性。</li>
<li><strong>复杂度的常数系数小</strong>：在上述三种算法中，快速排序的比较、赋值、交换等操作的总数量最少。这与“插入排序”比“冒泡排序”更快的原因类似。</li>
</ul>
<h2 id="基准数优化">基准数优化<a hidden class="anchor" aria-hidden="true" href="#基准数优化">#</a></h2>
<p><strong>快速排序在某些输入下的时间效率可能降低</strong>。举一个极端例子，假设输入数组是完全倒序的，由于我们选择最左端元素作为基准数，那么在哨兵划分完成后，基准数被交换至数组最右端，导致左子数组长度为 𝑛−1、右子数组长度为 0 。如此递归下去，每轮哨兵划分后都有一个子数组的长度为 0 ，分治策略失效，快速排序退化为“冒泡排序”的近似形式。</p>
<p>为了尽量避免这种情况发生，<strong>我们可以优化哨兵划分中的基准数的选取策略</strong>。例如，我们可以随机选取一个元素作为基准数。然而，如果运气不佳，每次都选到不理想的基准数，效率仍然不尽如人意。</p>
<p>需要注意的是，编程语言通常生成的是“伪随机数”。如果我们针对伪随机数序列构建一个特定的测试样例，那么快速排序的效率仍然可能劣化。</p>
<p>为了进一步改进，我们可以在数组中选取三个候选元素（通常为数组的首、尾、中点元素），<strong>并将这三个候选元素的中位数作为基准数</strong>。这样一来，基准数“既不太小也不太大”的概率将大幅提升。当然，我们还可以选取更多候选元素，以进一步提高算法的稳健性。采用这种方法后，时间复杂度劣化至 𝑂(𝑛2) 的概率大大降低。</p>
<p>示例代码如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 选取三个候选元素的中位数 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> medianThree(<span style="color:#fff;font-weight:bold">int</span>[] nums, <span style="color:#fff;font-weight:bold">int</span> left, <span style="color:#fff;font-weight:bold">int</span> mid, <span style="color:#fff;font-weight:bold">int</span> right) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> l = nums[left], m = nums[mid], r = nums[right];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> ((l &lt;= m &amp;&amp; m &lt;= r) || (r &lt;= m &amp;&amp; m &lt;= l))
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> mid; <span style="color:#007f7f">// m 在 l 和 r 之间</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> ((m &lt;= l &amp;&amp; l &lt;= r) || (r &lt;= l &amp;&amp; l &lt;= m))
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> left; <span style="color:#007f7f">// l 在 m 和 r 之间</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> right;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* 哨兵划分（三数取中值） */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> partition(<span style="color:#fff;font-weight:bold">int</span>[] nums, <span style="color:#fff;font-weight:bold">int</span> left, <span style="color:#fff;font-weight:bold">int</span> right) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 选取三个候选元素的中位数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> med = medianThree(nums, left, (left + right) / 2, right);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 将中位数交换至数组最左端</span>
</span></span><span style="display:flex;"><span>    swap(nums, left, med);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 以 nums[left] 为基准数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> i = left, j = right;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> (i &lt; j) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">while</span> (i &lt; j &amp;&amp; nums[j] &gt;= nums[left])
</span></span><span style="display:flex;"><span>            j--;          <span style="color:#007f7f">// 从右向左找首个小于基准数的元素</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">while</span> (i &lt; j &amp;&amp; nums[i] &lt;= nums[left])
</span></span><span style="display:flex;"><span>            i++;          <span style="color:#007f7f">// 从左向右找首个大于基准数的元素</span>
</span></span><span style="display:flex;"><span>        swap(nums, i, j); <span style="color:#007f7f">// 交换这两个元素</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    swap(nums, i, left);  <span style="color:#007f7f">// 将基准数交换至两子数组的分界线</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> i;             <span style="color:#007f7f">// 返回基准数的索引</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="尾递归优化">尾递归优化<a hidden class="anchor" aria-hidden="true" href="#尾递归优化">#</a></h2>
<p><strong>在某些输入下，快速排序可能占用空间较多</strong>。以完全有序的输入数组为例，设递归中的子数组长度为 𝑚 ，每轮哨兵划分操作都将产生长度为 0 的左子数组和长度为 𝑚−1 的右子数组，这意味着每一层递归调用减少的问题规模非常小（只减少一个元素），递归树的高度会达到 𝑛−1 ，此时需要占用 𝑂(𝑛) 大小的栈帧空间。</p>
<p>为了防止栈帧空间的累积，我们可以在每轮哨兵排序完成后，比较两个子数组的长度，<strong>仅对较短的子数组进行递归</strong>。由于较短子数组的长度不会超过 𝑛/2 ，因此这种方法能确保递归深度不超过 log⁡𝑛 ，从而将最差空间复杂度优化至 𝑂(log⁡𝑛) 。代码如下所示：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 快速排序（尾递归优化） */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> quickSort(<span style="color:#fff;font-weight:bold">int</span>[] nums, <span style="color:#fff;font-weight:bold">int</span> left, <span style="color:#fff;font-weight:bold">int</span> right) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 子数组长度为 1 时终止</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> (left &lt; right) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 哨兵划分操作</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> pivot = partition(nums, left, right);
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 对两个子数组中较短的那个执行快速排序</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (pivot - left &lt; right - pivot) {
</span></span><span style="display:flex;"><span>            quickSort(nums, left, pivot - 1); <span style="color:#007f7f">// 递归排序左子数组</span>
</span></span><span style="display:flex;"><span>            left = pivot + 1; <span style="color:#007f7f">// 剩余未排序区间为 [pivot + 1, right]</span>
</span></span><span style="display:flex;"><span>        } <span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>            quickSort(nums, pivot + 1, right); <span style="color:#007f7f">// 递归排序右子数组</span>
</span></span><span style="display:flex;"><span>            right = pivot - 1; <span style="color:#007f7f">// 剩余未排序区间为 [left, pivot - 1]</span>
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="归并排序">归并排序<a hidden class="anchor" aria-hidden="true" href="#归并排序">#</a></h1>
<p>归并排序（merge sort）是一种基于分治策略的排序算法，包含图 11-10 所示的“划分”和“合并”阶段。</p>
<ol>
<li><strong>划分阶段</strong>：通过递归不断地将数组从中点处分开，将长数组的排序问题转换为短数组的排序问题。</li>
<li><strong>合并阶段</strong>：当子数组长度为 1 时终止划分，开始合并，持续地将左右两个较短的有序数组合并为一个较长的有序数组，直至结束。</li>
</ol>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/merge_sort_overview.png"></p>
<h2 id="算法流程-3">算法流程<a hidden class="anchor" aria-hidden="true" href="#算法流程-3">#</a></h2>
<p>如图 11-11 所示，“划分阶段”从顶至底递归地将数组从中点切分为两个子数组。</p>
<ol>
<li>计算数组中点 <code>mid</code> ，递归划分左子数组（区间 <code>[left, mid]</code> ）和右子数组（区间 <code>[mid + 1, right]</code> ）。</li>
<li>递归执行步骤 <code>1.</code> ，直至子数组区间长度为 1 时终止。</li>
</ol>
<p>“合并阶段”从底至顶地将左子数组和右子数组合并为一个有序数组。需要注意的是，从长度为 1 的子数组开始合并，合并阶段中的每个子数组都是有序的。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/merge_sort_step1.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/merge_sort_step2.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/merge_sort_step3.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/merge_sort_step4.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/merge_sort_step5.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/merge_sort_step6.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/merge_sort_step7.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/merge_sort_step8.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/merge_sort_step9.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/merge_sort_step10.png"></p>
<p>观察发现，归并排序与二叉树后序遍历的递归顺序是一致的。</p>
<ul>
<li><strong>后序遍历</strong>：先递归左子树，再递归右子树，最后处理根节点。</li>
<li><strong>归并排序</strong>：先递归左子数组，再递归右子数组，最后处理合并。</li>
</ul>
<p>归并排序的实现如以下代码所示。请注意，<code>nums</code> 的待合并区间为 <code>[left, right]</code> ，而 <code>tmp</code> 的对应区间为 <code>[0, right - left]</code> 。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">39
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 合并左子数组和右子数组 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> merge(<span style="color:#fff;font-weight:bold">int</span>[] nums, <span style="color:#fff;font-weight:bold">int</span> left, <span style="color:#fff;font-weight:bold">int</span> mid, <span style="color:#fff;font-weight:bold">int</span> right) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 左子数组区间为 [left, mid], 右子数组区间为 [mid+1, right]</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 创建一个临时数组 tmp ，用于存放合并后的结果</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span>[] tmp = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">int</span>[right - left + 1];
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 初始化左子数组和右子数组的起始索引</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> i = left, j = mid + 1, k = 0;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 当左右子数组都还有元素时，进行比较并将较小的元素复制到临时数组中</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> (i &lt;= mid &amp;&amp; j &lt;= right) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (nums[i] &lt;= nums[j])
</span></span><span style="display:flex;"><span>            tmp[k++] = nums[i++];
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>            tmp[k++] = nums[j++];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 将左子数组和右子数组的剩余元素复制到临时数组中</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> (i &lt;= mid) {
</span></span><span style="display:flex;"><span>        tmp[k++] = nums[i++];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> (j &lt;= right) {
</span></span><span style="display:flex;"><span>        tmp[k++] = nums[j++];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 将临时数组 tmp 中的元素复制回原数组 nums 的对应区间</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (k = 0; k &lt; tmp.<span style="color:#007f7f">length</span>; k++) {
</span></span><span style="display:flex;"><span>        nums[left + k] = tmp[k];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* 归并排序 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> mergeSort(<span style="color:#fff;font-weight:bold">int</span>[] nums, <span style="color:#fff;font-weight:bold">int</span> left, <span style="color:#fff;font-weight:bold">int</span> right) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 终止条件</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (left &gt;= right)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span>; <span style="color:#007f7f">// 当子数组长度为 1 时终止递归</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 划分阶段</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> mid = left + (right - left) / 2; <span style="color:#007f7f">// 计算中点</span>
</span></span><span style="display:flex;"><span>    mergeSort(nums, left, mid); <span style="color:#007f7f">// 递归左子数组</span>
</span></span><span style="display:flex;"><span>    mergeSort(nums, mid + 1, right); <span style="color:#007f7f">// 递归右子数组</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 合并阶段</span>
</span></span><span style="display:flex;"><span>    merge(nums, left, mid, right);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="算法特性-4">算法特性<a hidden class="anchor" aria-hidden="true" href="#算法特性-4">#</a></h2>
<ul>
<li><strong>时间复杂度为 𝑂(𝑛log⁡𝑛)、非自适应排序</strong>：划分产生高度为 log⁡𝑛 的递归树，每层合并的总操作数量为 𝑛 ，因此总体时间复杂度为 𝑂(𝑛log⁡𝑛) 。</li>
<li><strong>空间复杂度为 𝑂(𝑛)、非原地排序</strong>：递归深度为 log⁡𝑛 ，使用 𝑂(log⁡𝑛) 大小的栈帧空间。合并操作需要借助辅助数组实现，使用 𝑂(𝑛) 大小的额外空间。</li>
<li><strong>稳定排序</strong>：在合并过程中，相等元素的次序保持不变。</li>
</ul>
<h2 id="链表排序">链表排序<a hidden class="anchor" aria-hidden="true" href="#链表排序">#</a></h2>
<p>对于链表，归并排序相较于其他排序算法具有显著优势，<strong>可以将链表排序任务的空间复杂度优化至 𝑂(1)</strong> 。</p>
<ul>
<li><strong>划分阶段</strong>：可以使用“迭代”替代“递归”来实现链表划分工作，从而省去递归使用的栈帧空间。</li>
<li><strong>合并阶段</strong>：在链表中，节点增删操作仅需改变引用（指针）即可实现，因此合并阶段（将两个短有序链表合并为一个长有序链表）无须创建额外链表。</li>
</ul>
<p>具体实现细节比较复杂，有兴趣的读者可以查阅相关资料进行学习。</p>
<h1 id="堆排序">堆排序<a hidden class="anchor" aria-hidden="true" href="#堆排序">#</a></h1>
<p>堆排序（heap sort）是一种基于堆数据结构实现的高效排序算法。我们可以利用已经学过的“建堆操作”和“元素出堆操作”实现堆排序。</p>
<ol>
<li>输入数组并建立小顶堆，此时最小元素位于堆顶。</li>
<li>不断执行出堆操作，依次记录出堆元素，即可得到从小到大排序的序列。</li>
</ol>
<p>以上方法虽然可行，但需要借助一个额外数组来保存弹出的元素，比较浪费空间。在实际中，我们通常使用一种更加优雅的实现方式。</p>
<h2 id="算法流程httpswwwhello-algocomchapter_sortingheap_sort1171">算法流程<a href="https://www.hello-algo.com/chapter_sorting/heap_sort/#1171">¶</a><a hidden class="anchor" aria-hidden="true" href="#算法流程httpswwwhello-algocomchapter_sortingheap_sort1171">#</a></h2>
<p>设数组的长度为 𝑛 ，堆排序的流程如图 11-12 所示。</p>
<ol>
<li>输入数组并建立大顶堆。完成后，最大元素位于堆顶。</li>
<li>将堆顶元素（第一个元素）与堆底元素（最后一个元素）交换。完成交换后，堆的长度减 1 ，已排序元素数量加 1 。</li>
<li>从堆顶元素开始，从顶到底执行堆化操作（sift down）。完成堆化后，堆的性质得到修复。</li>
<li>循环执行第 <code>2.</code> 步和第 <code>3.</code> 步。循环 𝑛−1 轮后，即可完成数组排序。</li>
</ol>
<blockquote>
<p>Tip：实际上，元素出堆操作中也包含第 <code>2.</code> 步和第 <code>3.</code> 步，只是多了一个弹出元素的步骤。</p>
</blockquote>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/heap_sort_step1.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/heap_sort_step2.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/heap_sort_step3.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/heap_sort_step4.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/heap_sort_step5.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/heap_sort_step6.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/heap_sort_step7.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/heap_sort_step8.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/heap_sort_step9.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/heap_sort_step10.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/heap_sort_step11.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/heap_sort_step12.png"></p>
<p>在代码实现中，我们使用了与“堆”章节相同的从顶至底堆化 <code>sift_down()</code> 函数。值得注意的是，由于堆的长度会随着提取最大元素而减小，因此我们需要给 <code>sift_down()</code> 函数添加一个长度参数 𝑛 ，用于指定堆的当前有效长度。代码如下所示：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">39
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 堆的长度为 n ，从节点 i 开始，从顶至底堆化 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> siftDown(<span style="color:#fff;font-weight:bold">int</span>[] nums, <span style="color:#fff;font-weight:bold">int</span> n, <span style="color:#fff;font-weight:bold">int</span> i) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> (<span style="color:#fff;font-weight:bold">true</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 判断节点 i, l, r 中值最大的节点，记为 ma</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> l = 2 * i + 1;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> r = 2 * i + 2;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> ma = i;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (l &lt; n &amp;&amp; nums[l] &gt; nums[ma])
</span></span><span style="display:flex;"><span>            ma = l;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (r &lt; n &amp;&amp; nums[r] &gt; nums[ma])
</span></span><span style="display:flex;"><span>            ma = r;
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 若节点 i 最大或索引 l, r 越界，则无须继续堆化，跳出</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (ma == i)
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 交换两节点</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> temp = nums[i];
</span></span><span style="display:flex;"><span>        nums[i] = nums[ma];
</span></span><span style="display:flex;"><span>        nums[ma] = temp;
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 循环向下堆化</span>
</span></span><span style="display:flex;"><span>        i = ma;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* 堆排序 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> heapSort(<span style="color:#fff;font-weight:bold">int</span>[] nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 建堆操作：堆化除叶节点以外的其他所有节点</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = nums.<span style="color:#007f7f">length</span> / 2 - 1; i &gt;= 0; i--) {
</span></span><span style="display:flex;"><span>        siftDown(nums, nums.<span style="color:#007f7f">length</span>, i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 从堆中提取最大元素，循环 n-1 轮</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = nums.<span style="color:#007f7f">length</span> - 1; i &gt; 0; i--) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 交换根节点与最右叶节点（交换首元素与尾元素）</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> tmp = nums[0];
</span></span><span style="display:flex;"><span>        nums[0] = nums[i];
</span></span><span style="display:flex;"><span>        nums[i] = tmp;
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 以根节点为起点，从顶至底进行堆化</span>
</span></span><span style="display:flex;"><span>        siftDown(nums, i, 0);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="算法特性-5">算法特性<a hidden class="anchor" aria-hidden="true" href="#算法特性-5">#</a></h2>
<ul>
<li><strong>时间复杂度为 𝑂(𝑛log⁡𝑛)、非自适应排序</strong>：建堆操作使用 𝑂(𝑛) 时间。从堆中提取最大元素的时间复杂度为 𝑂(log⁡𝑛) ，共循环 𝑛−1 轮。</li>
<li><strong>空间复杂度为 𝑂(1)、原地排序</strong>：几个指针变量使用 𝑂(1) 空间。元素交换和堆化操作都是在原数组上进行的。</li>
<li><strong>非稳定排序</strong>：在交换堆顶元素和堆底元素时，相等元素的相对位置可能发生变化。</li>
</ul>
<h1 id="桶排序">桶排序<a hidden class="anchor" aria-hidden="true" href="#桶排序">#</a></h1>
<p>前述几种排序算法都属于“基于比较的排序算法”，它们通过比较元素间的大小来实现排序。此类排序算法的时间复杂度无法超越 𝑂(𝑛log⁡𝑛) 。接下来，我们将探讨几种“非比较排序算法”，它们的时间复杂度可以达到线性阶。</p>
<p>桶排序（bucket sort）是分治策略的一个典型应用。它通过设置一些具有大小顺序的桶，每个桶对应一个数据范围，将数据平均分配到各个桶中；然后，在每个桶内部分别执行排序；最终按照桶的顺序将所有数据合并。</p>
<h2 id="算法流程-4">算法流程<a hidden class="anchor" aria-hidden="true" href="#算法流程-4">#</a></h2>
<p>考虑一个长度为 𝑛 的数组，其元素是范围 [0,1) 内的浮点数。桶排序的流程如图 11-13 所示。</p>
<ol>
<li>初始化 𝑘 个桶，将 𝑛 个元素分配到 𝑘 个桶中。</li>
<li>对每个桶分别执行排序（这里采用编程语言的内置排序函数）。</li>
<li>按照桶从小到大的顺序合并结果。</li>
</ol>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/bucket_sort_overview.png"></p>
<p>代码如下所示：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 桶排序 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> bucketSort(<span style="color:#fff;font-weight:bold">float</span>[] nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 初始化 k = n/2 个桶，预期向每个桶分配 2 个元素</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> k = nums.<span style="color:#007f7f">length</span> / 2;
</span></span><span style="display:flex;"><span>    List&lt;List&lt;Float&gt;&gt; buckets = <span style="color:#fff;font-weight:bold">new</span> ArrayList&lt;&gt;();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 0; i &lt; k; i++) {
</span></span><span style="display:flex;"><span>        buckets.<span style="color:#007f7f">add</span>(<span style="color:#fff;font-weight:bold">new</span> ArrayList&lt;&gt;());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 1. 将数组元素分配到各个桶中</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">float</span> num : nums) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 输入数据范围为 [0, 1)，使用 num * k 映射到索引范围 [0, k-1]</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> i = (<span style="color:#fff;font-weight:bold">int</span>) (num * k);
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 将 num 添加进桶 i</span>
</span></span><span style="display:flex;"><span>        buckets.<span style="color:#007f7f">get</span>(i).<span style="color:#007f7f">add</span>(num);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 2. 对各个桶执行排序</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (List&lt;Float&gt; bucket : buckets) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 使用内置排序函数，也可以替换成其他排序算法</span>
</span></span><span style="display:flex;"><span>        Collections.<span style="color:#007f7f">sort</span>(bucket);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 3. 遍历桶合并结果</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> i = 0;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (List&lt;Float&gt; bucket : buckets) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">float</span> num : bucket) {
</span></span><span style="display:flex;"><span>            nums[i++] = num;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="算法特性-6">算法特性<a hidden class="anchor" aria-hidden="true" href="#算法特性-6">#</a></h2>
<p>桶排序适用于处理体量很大的数据。例如，输入数据包含 100 万个元素，由于空间限制，系统内存无法一次性加载所有数据。此时，可以将数据分成 1000 个桶，然后分别对每个桶进行排序，最后将结果合并。</p>
<ul>
<li><strong>时间复杂度为 𝑂(𝑛+𝑘)</strong> ：假设元素在各个桶内平均分布，那么每个桶内的元素数量为 𝑛𝑘 。假设排序单个桶使用 𝑂(𝑛𝑘log⁡𝑛𝑘) 时间，则排序所有桶使用 𝑂(𝑛log⁡𝑛𝑘) 时间。<strong>当桶数量 𝑘 比较大时，时间复杂度则趋向于 𝑂(𝑛)</strong> 。合并结果时需要遍历所有桶和元素，花费 𝑂(𝑛+𝑘) 时间。</li>
<li><strong>自适应排序</strong>：在最差情况下，所有数据被分配到一个桶中，且排序该桶使用 𝑂(𝑛2) 时间。</li>
<li><strong>空间复杂度为 𝑂(𝑛+𝑘)、非原地排序</strong>：需要借助 𝑘 个桶和总共 𝑛 个元素的额外空间。</li>
<li>桶排序是否稳定取决于排序桶内元素的算法是否稳定。</li>
</ul>
<h2 id="如何实现平均分配">如何实现平均分配<a hidden class="anchor" aria-hidden="true" href="#如何实现平均分配">#</a></h2>
<p>桶排序的时间复杂度理论上可以达到 𝑂(𝑛) ，<strong>关键在于将元素均匀分配到各个桶中</strong>，因为实际数据往往不是均匀分布的。例如，我们想要将淘宝上的所有商品按价格范围平均分配到 10 个桶中，但商品价格分布不均，低于 100 元的非常多，高于 1000 元的非常少。若将价格区间平均划分为 10 个，各个桶中的商品数量差距会非常大。</p>
<p>为实现平均分配，我们可以先设定一条大致的分界线，将数据粗略地分到 3 个桶中。<strong>分配完毕后，再将商品较多的桶继续划分为 3 个桶，直至所有桶中的元素数量大致相等</strong>。</p>
<p>如图 11-14 所示，这种方法本质上是创建一棵递归树，目标是让叶节点的值尽可能平均。当然，不一定要每轮将数据划分为 3 个桶，具体划分方式可根据数据特点灵活选择。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/scatter_in_buckets_recursively.png"></p>
<p>如果我们提前知道商品价格的概率分布，<strong>则可以根据数据概率分布设置每个桶的价格分界线</strong>。值得注意的是，数据分布并不一定需要特意统计，也可以根据数据特点采用某种概率模型进行近似。</p>
<p>如图 11-15 所示，我们假设商品价格服从正态分布，这样就可以合理地设定价格区间，从而将商品平均分配到各个桶中。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/scatter_in_buckets_distribution.png"></p>
<h1 id="计数排序">计数排序<a hidden class="anchor" aria-hidden="true" href="#计数排序">#</a></h1>
<p>计数排序（counting sort）通过统计元素数量来实现排序，通常应用于整数数组。</p>
<h2 id="简单实现httpswwwhello-algocomchapter_sortingcounting_sort1191">简单实现<a href="https://www.hello-algo.com/chapter_sorting/counting_sort/#1191">¶</a><a hidden class="anchor" aria-hidden="true" href="#简单实现httpswwwhello-algocomchapter_sortingcounting_sort1191">#</a></h2>
<p>先来看一个简单的例子。给定一个长度为 𝑛 的数组 <code>nums</code> ，其中的元素都是“非负整数”，计数排序的整体流程如图 11-16 所示。</p>
<ol>
<li>遍历数组，找出其中的最大数字，记为 𝑚 ，然后创建一个长度为 𝑚+1 的辅助数组 <code>counter</code> 。</li>
<li><strong>借助 <code>counter</code> 统计 <code>nums</code> 中各数字的出现次数</strong>，其中 <code>counter[num]</code> 对应数字 <code>num</code> 的出现次数。统计方法很简单，只需遍历 <code>nums</code>（设当前数字为 <code>num</code>），每轮将 <code>counter[num]</code> 增加 1 即可。</li>
<li><strong>由于 <code>counter</code> 的各个索引天然有序，因此相当于所有数字已经排序好了</strong>。接下来，我们遍历 <code>counter</code> ，根据各数字出现次数从小到大的顺序填入 <code>nums</code> 即可。</li>
</ol>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/counting_sort_overview.png"></p>
<p>代码如下所示：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 计数排序 */</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 简单实现，无法用于排序对象</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> countingSortNaive(<span style="color:#fff;font-weight:bold">int</span>[] nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 1. 统计数组最大元素 m</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> m = 0;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> num : nums) {
</span></span><span style="display:flex;"><span>        m = Math.<span style="color:#007f7f">max</span>(m, num);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 2. 统计各数字的出现次数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// counter[num] 代表 num 的出现次数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span>[] counter = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">int</span>[m + 1];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> num : nums) {
</span></span><span style="display:flex;"><span>        counter[num]++;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 3. 遍历 counter ，将各元素填入原数组 nums</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> i = 0;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> num = 0; num &lt; m + 1; num++) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> j = 0; j &lt; counter[num]; j++, i++) {
</span></span><span style="display:flex;"><span>            nums[i] = num;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>计数排序与桶排序的联系</p>
<p>从桶排序的角度看，我们可以将计数排序中的计数数组 <code>counter</code> 的每个索引视为一个桶，将统计数量的过程看作将各个元素分配到对应的桶中。本质上，计数排序是桶排序在整型数据下的一个特例。</p>
</blockquote>
<h2 id="完整实现httpswwwhello-algocomchapter_sortingcounting_sort1192">完整实现<a href="https://www.hello-algo.com/chapter_sorting/counting_sort/#1192">¶</a><a hidden class="anchor" aria-hidden="true" href="#完整实现httpswwwhello-algocomchapter_sortingcounting_sort1192">#</a></h2>
<p>细心的读者可能发现了，<strong>如果输入数据是对象，上述步骤 <code>3.</code> 就失效了</strong>。假设输入数据是商品对象，我们想按照商品价格（类的成员变量）对商品进行排序，而上述算法只能给出价格的排序结果。</p>
<p>那么如何才能得到原数据的排序结果呢？我们首先计算 <code>counter</code> 的“前缀和”。顾名思义，索引 <code>i</code> 处的前缀和 <code>prefix[i]</code> 等于数组前 <code>i</code> 个元素之和：
</p>
$$
prefix[i] = \sum_{j=0}^i counter[j]
$$
<p>
<strong>前缀和具有明确的意义，<code>prefix[num] - 1</code> 代表元素 <code>num</code> 在结果数组 <code>res</code> 中最后一次出现的索引</strong>。这个信息非常关键，因为它告诉我们各个元素应该出现在结果数组的哪个位置。接下来，我们倒序遍历原数组 <code>nums</code> 的每个元素 <code>num</code> ，在每轮迭代中执行以下两步。</p>
<ol>
<li>将 <code>num</code> 填入数组 <code>res</code> 的索引 <code>prefix[num] - 1</code> 处。</li>
<li>令前缀和 <code>prefix[num]</code> 减小 1 ，从而得到下次放置 <code>num</code> 的索引。</li>
</ol>
<p>遍历完成后，数组 <code>res</code> 中就是排序好的结果，最后使用 <code>res</code> 覆盖原数组 <code>nums</code> 即可。图 11-17 展示了完整的计数排序流程。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/counting_sort_step1.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/counting_sort_step2.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/counting_sort_step3.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/counting_sort_step4.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/counting_sort_step5.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/counting_sort_step6.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/counting_sort_step7.png">
<img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/counting_sort_step8.png"></p>
<p>计数排序的实现代码如下所示：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 计数排序 */</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 完整实现，可排序对象，并且是稳定排序</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> countingSort(<span style="color:#fff;font-weight:bold">int</span>[] nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 1. 统计数组最大元素 m</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> m = 0;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> num : nums) {
</span></span><span style="display:flex;"><span>        m = Math.<span style="color:#007f7f">max</span>(m, num);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 2. 统计各数字的出现次数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// counter[num] 代表 num 的出现次数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span>[] counter = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">int</span>[m + 1];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> num : nums) {
</span></span><span style="display:flex;"><span>        counter[num]++;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 3. 求 counter 的前缀和，将“出现次数”转换为“尾索引”</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 即 counter[num]-1 是 num 在 res 中最后一次出现的索引</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 0; i &lt; m; i++) {
</span></span><span style="display:flex;"><span>        counter[i + 1] += counter[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 4. 倒序遍历 nums ，将各元素填入结果数组 res</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 初始化数组 res 用于记录结果</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> n = nums.<span style="color:#007f7f">length</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span>[] res = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">int</span>[n];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = n - 1; i &gt;= 0; i--) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> num = nums[i];
</span></span><span style="display:flex;"><span>        res[counter[num] - 1] = num; <span style="color:#007f7f">// 将 num 放置到对应索引处</span>
</span></span><span style="display:flex;"><span>        counter[num]--; <span style="color:#007f7f">// 令前缀和自减 1 ，得到下次放置 num 的索引</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 使用结果数组 res 覆盖原数组 nums</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 0; i &lt; n; i++) {
</span></span><span style="display:flex;"><span>        nums[i] = res[i];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="算法特性-7">算法特性<a hidden class="anchor" aria-hidden="true" href="#算法特性-7">#</a></h2>
<ul>
<li><strong>时间复杂度为 𝑂(𝑛+𝑚)、非自适应排序</strong> ：涉及遍历 <code>nums</code> 和遍历 <code>counter</code> ，都使用线性时间。一般情况下 𝑛≫𝑚 ，时间复杂度趋于 𝑂(𝑛) 。</li>
<li><strong>空间复杂度为 𝑂(𝑛+𝑚)、非原地排序</strong>：借助了长度分别为 𝑛 和 𝑚 的数组 <code>res</code> 和 <code>counter</code> 。</li>
<li><strong>稳定排序</strong>：由于向 <code>res</code> 中填充元素的顺序是“从右向左”的，因此倒序遍历 <code>nums</code> 可以避免改变相等元素之间的相对位置，从而实现稳定排序。实际上，正序遍历 <code>nums</code> 也可以得到正确的排序结果，但结果是非稳定的。</li>
</ul>
<h2 id="局限性">局限性<a hidden class="anchor" aria-hidden="true" href="#局限性">#</a></h2>
<p>看到这里，你也许会觉得计数排序非常巧妙，仅通过统计数量就可以实现高效的排序。然而，使用计数排序的前置条件相对较为严格。</p>
<p><strong>计数排序只适用于非负整数</strong>。若想将其用于其他类型的数据，需要确保这些数据可以转换为非负整数，并且在转换过程中不能改变各个元素之间的相对大小关系。例如，对于包含负数的整数数组，可以先给所有数字加上一个常数，将全部数字转化为正数，排序完成后再转换回去。</p>
<p><strong>计数排序适用于数据量大但数据范围较小的情况</strong>。比如，在上述示例中 𝑚 不能太大，否则会占用过多空间。而当 𝑛≪𝑚 时，计数排序使用 𝑂(𝑚) 时间，可能比 𝑂(𝑛log⁡𝑛) 的排序算法还要慢。</p>
<h1 id="基数排序">基数排序<a hidden class="anchor" aria-hidden="true" href="#基数排序">#</a></h1>
<p>上一节介绍了计数排序，它适用于数据量 𝑛 较大但数据范围 𝑚 较小的情况。假设我们需要对 $𝑛=10^6$ 个学号进行排序，而学号是一个 8 位数字，这意味着数据范围 $𝑚=10^8$ 非常大，使用计数排序需要分配大量内存空间，而基数排序可以避免这种情况。</p>
<p>基数排序（radix sort）的核心思想与计数排序一致，也通过统计个数来实现排序。在此基础上，基数排序利用数字各位之间的递进关系，依次对每一位进行排序，从而得到最终的排序结果。</p>
<h2 id="算法流程httpswwwhello-algocomchapter_sortingradix_sort11101">算法流程<a href="https://www.hello-algo.com/chapter_sorting/radix_sort/#11101">¶</a><a hidden class="anchor" aria-hidden="true" href="#算法流程httpswwwhello-algocomchapter_sortingradix_sort11101">#</a></h2>
<p>以学号数据为例，假设数字的最低位是第 1 位，最高位是第 8 位，基数排序的流程如图 11-18 所示。</p>
<ol>
<li>初始化位数 𝑘=1 。</li>
<li>对学号的第 𝑘 位执行“计数排序”。完成后，数据会根据第 𝑘 位从小到大排序。</li>
<li>将 𝑘 增加 1 ，然后返回步骤 <code>2.</code> 继续迭代，直到所有位都排序完成后结束。</li>
</ol>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/radix_sort_overview.png"></p>
<p>下面剖析代码实现。对于一个 𝑑 进制的数字 𝑥 ，要获取其第 𝑘 位 𝑥𝑘 ，可以使用以下计算公式：
</p>
$$
𝑥_𝑘=⌊{𝑥 \over 𝑑𝑘-1}⌋mod \ 𝑑
$$
<p>
其中 ⌊𝑎⌋ 表示对浮点数 𝑎 向下取整，而 mod𝑑 表示对 𝑑 取模（取余）。对于学号数据，𝑑=10 且 𝑘∈[1,8] 。</p>
<p>此外，我们需要小幅改动计数排序代码，使之可以根据数字的第 𝑘 位进行排序：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">46
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">47
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">48
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">49
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 获取元素 num 的第 k 位，其中 exp = 10^(k-1) */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> digit(<span style="color:#fff;font-weight:bold">int</span> num, <span style="color:#fff;font-weight:bold">int</span> exp) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 传入 exp 而非 k 可以避免在此重复执行昂贵的次方计算</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> (num / exp) % 10;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* 计数排序（根据 nums 第 k 位排序） */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> countingSortDigit(<span style="color:#fff;font-weight:bold">int</span>[] nums, <span style="color:#fff;font-weight:bold">int</span> exp) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 十进制的位范围为 0~9 ，因此需要长度为 10 的桶数组</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span>[] counter = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">int</span>[10];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> n = nums.<span style="color:#007f7f">length</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 统计 0~9 各数字的出现次数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 0; i &lt; n; i++) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> d = digit(nums[i], exp); <span style="color:#007f7f">// 获取 nums[i] 第 k 位，记为 d</span>
</span></span><span style="display:flex;"><span>        counter[d]++;                <span style="color:#007f7f">// 统计数字 d 的出现次数</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 求前缀和，将“出现个数”转换为“数组索引”</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 1; i &lt; 10; i++) {
</span></span><span style="display:flex;"><span>        counter[i] += counter[i - 1];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 倒序遍历，根据桶内统计结果，将各元素填入 res</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span>[] res = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">int</span>[n];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = n - 1; i &gt;= 0; i--) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> d = digit(nums[i], exp);
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> j = counter[d] - 1; <span style="color:#007f7f">// 获取 d 在数组中的索引 j</span>
</span></span><span style="display:flex;"><span>        res[j] = nums[i];       <span style="color:#007f7f">// 将当前元素填入索引 j</span>
</span></span><span style="display:flex;"><span>        counter[d]--;           <span style="color:#007f7f">// 将 d 的数量减 1</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 使用结果覆盖原数组 nums</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 0; i &lt; n; i++)
</span></span><span style="display:flex;"><span>        nums[i] = res[i];
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* 基数排序 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> radixSort(<span style="color:#fff;font-weight:bold">int</span>[] nums) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 获取数组的最大元素，用于判断最大位数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> m = Integer.<span style="color:#007f7f">MIN_VALUE</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> num : nums)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (num &gt; m)
</span></span><span style="display:flex;"><span>            m = num;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 按照从低位到高位的顺序遍历</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> exp = 1; exp &lt;= m; exp *= 10) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 对数组元素的第 k 位执行计数排序</span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// k = 1 -&gt; exp = 1</span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// k = 2 -&gt; exp = 10</span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 即 exp = 10^(k-1)</span>
</span></span><span style="display:flex;"><span>        countingSortDigit(nums, exp);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><blockquote>
<p>为什么从最低位开始排序？</p>
<p>在连续的排序轮次中，后一轮排序会覆盖前一轮排序的结果。举例来说，如果第一轮排序结果 𝑎&lt;𝑏 ，而第二轮排序结果 𝑎&gt;𝑏 ，那么第二轮的结果将取代第一轮的结果。由于数字的高位优先级高于低位，因此应该先排序低位再排序高位。</p>
</blockquote>
<h2 id="算法特性-8">算法特性<a hidden class="anchor" aria-hidden="true" href="#算法特性-8">#</a></h2>
<p>相较于计数排序，基数排序适用于数值范围较大的情况，<strong>但前提是数据必须可以表示为固定位数的格式，且位数不能过大</strong>。例如，浮点数不适合使用基数排序，因为其位数 𝑘 过大，可能导致时间复杂度 $𝑂(𝑛𝑘)≫𝑂(𝑛^2)$ 。</p>
<ul>
<li><strong>时间复杂度为 𝑂(𝑛𝑘)、非自适应排序</strong>：设数据量为 𝑛、数据为 𝑑 进制、最大位数为 𝑘 ，则对某一位执行计数排序使用 𝑂(𝑛+𝑑) 时间，排序所有 𝑘 位使用 𝑂((𝑛+𝑑)𝑘) 时间。通常情况下，𝑑 和 𝑘 都相对较小，时间复杂度趋向 𝑂(𝑛) 。</li>
<li><strong>空间复杂度为 𝑂(𝑛+𝑑)、非原地排序</strong>：与计数排序相同，基数排序需要借助长度为 𝑛 和 𝑑 的数组 <code>res</code> 和 <code>counter</code> 。</li>
<li><strong>稳定排序</strong>：当计数排序稳定时，基数排序也稳定；当计数排序不稳定时，基数排序无法保证得到正确的排序结果。</li>
</ul>
<h1 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h1>
<h2 id="重点回顾">重点回顾<a hidden class="anchor" aria-hidden="true" href="#重点回顾">#</a></h2>
<ul>
<li>冒泡排序通过交换相邻元素来实现排序。通过添加一个标志位来实现提前返回，我们可以将冒泡排序的最佳时间复杂度优化到 𝑂(𝑛) 。</li>
<li>插入排序每轮将未排序区间内的元素插入到已排序区间的正确位置，从而完成排序。虽然插入排序的时间复杂度为 𝑂(𝑛2) ，但由于单元操作相对较少，因此在小数据量的排序任务中非常受欢迎。</li>
<li>快速排序基于哨兵划分操作实现排序。在哨兵划分中，有可能每次都选取到最差的基准数，导致时间复杂度劣化至 𝑂(𝑛2) 。引入中位数基准数或随机基准数可以降低这种劣化的概率。尾递归方法可以有效地减少递归深度，将空间复杂度优化到 𝑂(log⁡𝑛) 。</li>
<li>归并排序包括划分和合并两个阶段，典型地体现了分治策略。在归并排序中，排序数组需要创建辅助数组，空间复杂度为 𝑂(𝑛) ；然而排序链表的空间复杂度可以优化至 𝑂(1) 。</li>
<li>桶排序包含三个步骤：数据分桶、桶内排序和合并结果。它同样体现了分治策略，适用于数据体量很大的情况。桶排序的关键在于对数据进行平均分配。</li>
<li>计数排序是桶排序的一个特例，它通过统计数据出现的次数来实现排序。计数排序适用于数据量大但数据范围有限的情况，并且要求数据能够转换为正整数。</li>
<li>基数排序通过逐位排序来实现数据排序，要求数据能够表示为固定位数的数字。</li>
<li>总的来说，我们希望找到一种排序算法，具有高效率、稳定、原地以及正向自适应性等优点。然而，正如其他数据结构和算法一样，没有一种排序算法能够同时满足所有这些条件。在实际应用中，我们需要根据数据的特性来选择合适的排序算法。</li>
<li>图 11-19 对比了主流排序算法的效率、稳定性、就地性和自适应性等。</li>
</ul>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/10_%E6%8E%92%E5%BA%8F/sorting_algorithms_comparison.png"></p>
<h2 id="q--a">Q &amp; A<a hidden class="anchor" aria-hidden="true" href="#q--a">#</a></h2>
<p><strong>Q</strong>：排序算法稳定性在什么情况下是必需的？</p>
<p>在现实中，我们有可能基于对象的某个属性进行排序。例如，学生有姓名和身高两个属性，我们希望实现一个多级排序：先按照姓名进行排序，得到 <code>(A, 180) (B, 185) (C, 170) (D, 170)</code> ；再对身高进行排序。由于排序算法不稳定，因此可能得到 <code>(D, 170) (C, 170) (A, 180) (B, 185)</code> 。</p>
<p>可以发现，学生 D 和 C 的位置发生了交换，姓名的有序性被破坏了，而这是我们不希望看到的。</p>
<p><strong>Q</strong>：哨兵划分中“从右往左查找”与“从左往右查找”的顺序可以交换吗？</p>
<p>不行，当我们以最左端元素为基准数时，必须先“从右往左查找”再“从左往右查找”。这个结论有些反直觉，我们来剖析一下原因。</p>
<p>哨兵划分 <code>partition()</code> 的最后一步是交换 <code>nums[left]</code> 和 <code>nums[i]</code> 。完成交换后，基准数左边的元素都 <code>&lt;=</code> 基准数，<strong>这就要求最后一步交换前 <code>nums[left] &gt;= nums[i]</code> 必须成立</strong>。假设我们先“从左往右查找”，那么如果找不到比基准数更大的元素，<strong>则会在 <code>i == j</code> 时跳出循环，此时可能 <code>nums[j] == nums[i] &gt; nums[left]</code></strong>。也就是说，此时最后一步交换操作会把一个比基准数更大的元素交换至数组最左端，导致哨兵划分失败。</p>
<p>举个例子，给定数组 <code>[0, 0, 0, 0, 1]</code> ，如果先“从左向右查找”，哨兵划分后数组为 <code>[1, 0, 0, 0, 0]</code> ，这个结果是不正确的。</p>
<p>再深入思考一下，如果我们选择 <code>nums[right]</code> 为基准数，那么正好反过来，必须先“从左往右查找”。</p>
<p><strong>Q</strong>：关于尾递归优化，为什么选短的数组能保证递归深度不超过 log⁡𝑛 ？</p>
<p>递归深度就是当前未返回的递归方法的数量。每轮哨兵划分我们将原数组划分为两个子数组。在尾递归优化后，向下递归的子数组长度最大为原数组长度的一半。假设最差情况，一直为一半长度，那么最终的递归深度就是 log⁡𝑛 。</p>
<p>回顾原始的快速排序，我们有可能会连续地递归长度较大的数组，最差情况下为 𝑛、𝑛−1、…、2、1 ，递归深度为 𝑛 。尾递归优化可以避免这种情况出现。</p>
<p><strong>Q</strong>：当数组中所有元素都相等时，快速排序的时间复杂度是 $𝑂(𝑛^2)$ 吗？该如何处理这种退化情况？</p>
<p>是的。对于这种情况，可以考虑通过哨兵划分将数组划分为三个部分：小于、等于、大于基准数。仅向下递归小于和大于的两部分。在该方法下，输入元素全部相等的数组，仅一轮哨兵划分即可完成排序。</p>
<p><strong>Q</strong>：桶排序的最差时间复杂度为什么是 $𝑂(𝑛^2)$ ？</p>
<p>最差情况下，所有元素被分至同一个桶中。如果我们采用一个 $𝑂(𝑛^2)$ 算法来排序这些元素，则时间复杂度为 $𝑂(𝑛^2)$ 。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://wjy6.netlify.app/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://wjy6.netlify.app/">Wjy&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>