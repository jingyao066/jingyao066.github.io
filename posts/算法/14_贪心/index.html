<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>14_贪心 | Wjy&#39;s Blog</title>
<meta name="keywords" content="算法">
<meta name="description" content="贪心算法 贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选">
<meta name="author" content="Wjy">
<link rel="canonical" href="https://wjy6.netlify.app/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://wjy6.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://wjy6.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://wjy6.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://wjy6.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://wjy6.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://wjy6.netlify.app/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="https://wjy6.netlify.app/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/">
  <meta property="og:site_name" content="Wjy&#39;s Blog">
  <meta property="og:title" content="14_贪心">
  <meta property="og:description" content="贪心算法 贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-06-06T11:32:06+00:00">
    <meta property="article:modified_time" content="2024-06-06T11:32:06+00:00">
    <meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="14_贪心">
<meta name="twitter:description" content="贪心算法 贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://wjy6.netlify.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "14_贪心",
      "item": "https://wjy6.netlify.app/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "14_贪心",
  "name": "14_贪心",
  "description": "贪心算法 贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选",
  "keywords": [
    "算法"
  ],
  "articleBody": "贪心算法 贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。贪心算法简洁且高效，在许多实际问题中有着广泛的应用。\n贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构性质，但工作原理不同。\n动态规划会根据之前阶段的所有决策来考虑当前决策，并使用过去子问题的解来构建当前子问题的解。 贪心算法不会考虑过去的决策，而是一路向前地进行贪心选择，不断缩小问题范围，直至问题被解决。 我们先通过例题“零钱兑换”了解贪心算法的工作原理。这道题已经在“完全背包问题”章节中介绍过，相信你对它并不陌生。\n问题\n给定 $n$ 种硬币，第 $i$ 种硬币的面值为 $coins[i - 1]$ ，目标金额为 $amt$ ，每种硬币可以重复选取，问能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，则返回 $-1$ 。\n本题采取的贪心策略如图 15-1 所示。给定目标金额，我们贪心地选择不大于且最接近它的硬币，不断循环该步骤，直至凑出目标金额为止。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /* 零钱兑换：贪心 */ int coinChangeGreedy(int[] coins, int amt) { // 假设 coins 列表有序 int i = coins.length - 1; int count = 0; // 循环进行贪心选择，直到无剩余金额 while (amt \u003e 0) { // 找到小于且最接近剩余金额的硬币 while (i \u003e 0 \u0026\u0026 coins[i] \u003e amt) { i--; } // 选择 coins[i] amt -= coins[i]; count++; } // 若未找到可行方案，则返回 -1 return amt == 0 ? count : -1; } 你可能会不由地发出感叹：So clean ！贪心算法仅用约十行代码就解决了零钱兑换问题。\n贪心算法的优点与局限性 贪心算法不仅操作直接、实现简单，而且通常效率也很高。在以上代码中，记硬币最小面值为 $\\min(coins)$ ，则贪心选择最多循环 $amt / \\min(coins)$ 次，时间复杂度为 $O(amt / \\min(coins))$ 。这比动态规划解法的时间复杂度 $O(n \\times amt)$ 小了一个数量级。\n然而，对于某些硬币面值组合，贪心算法并不能找到最优解。图 15-2 给出了两个示例。\n正例 $coins = [1, 5, 10, 20, 50, 100]$：在该硬币组合下，给定任意 $amt$ ，贪心算法都可以找到最优解。 反例 $coins = [1, 20, 50]$：假设 $amt = 60$ ，贪心算法只能找到 $50 + 1 \\times 10$ 的兑换组合，共计 $11$ 枚硬币，但动态规划可以找到最优解 $20 + 20 + 20$ ，仅需 $3$ 枚硬币。 反例 $coins = [1, 49, 50]$：假设 $amt = 98$ ，贪心算法只能找到 $50 + 1 \\times 48$ 的兑换组合，共计 $49$ 枚硬币，但动态规划可以找到最优解 $49 + 49$ ，仅需 $2$ 枚硬币。 也就是说，对于零钱兑换问题，贪心算法无法保证找到全局最优解，并且有可能找到非常差的解。它更适合用动态规划解决。\n一般情况下，贪心算法的适用情况分以下两种。\n可以保证找到最优解：贪心算法在这种情况下往往是最优选择，因为它往往比回溯、动态规划更高效。 可以找到近似最优解：贪心算法在这种情况下也是可用的。对于很多复杂问题来说，寻找全局最优解非常困难，能以较高效率找到次优解也是非常不错的。 贪心算法特性 那么问题来了，什么样的问题适合用贪心算法求解呢？或者说，贪心算法在什么情况下可以保证找到最优解？\n相较于动态规划，贪心算法的使用条件更加苛刻，其主要关注问题的两个性质。\n贪心选择性质：只有当局部最优选择始终可以导致全局最优解时，贪心算法才能保证得到最优解。 最优子结构：原问题的最优解包含子问题的最优解。 最优子结构已经在“动态规划”章节中介绍过，这里不再赘述。值得注意的是，一些问题的最优子结构并不明显，但仍然可使用贪心算法解决。\n我们主要探究贪心选择性质的判断方法。虽然它的描述看上去比较简单，但实际上对于许多问题，证明贪心选择性质并非易事。\n例如零钱兑换问题，我们虽然能够容易地举出反例，对贪心选择性质进行证伪，但证实的难度较大。如果问：满足什么条件的硬币组合可以使用贪心算法求解？我们往往只能凭借直觉或举例子来给出一个模棱两可的答案，而难以给出严谨的数学证明。\nQuote\n有一篇论文给出了一个 $O(n^3)$ 时间复杂度的算法，用于判断一个硬币组合能否使用贪心算法找出任意金额的最优解。\nPearson, D. A polynomial-time algorithm for the change-making problem[J]. Operations Research Letters, 2005, 33(3): 231-234.\n贪心算法解题步骤 贪心问题的解决流程大体可分为以下三步。\n问题分析：梳理与理解问题特性，包括状态定义、优化目标和约束条件等。这一步在回溯和动态规划中都有涉及。 确定贪心策略：确定如何在每一步中做出贪心选择。这个策略能够在每一步减小问题的规模，并最终解决整个问题。 正确性证明：通常需要证明问题具有贪心选择性质和最优子结构。这个步骤可能需要用到数学证明，例如归纳法或反证法等。 确定贪心策略是求解问题的核心步骤，但实施起来可能并不容易，主要有以下原因。\n不同问题的贪心策略的差异较大。对于许多问题来说，贪心策略比较浅显，我们通过一些大概的思考与尝试就能得出。而对于一些复杂问题，贪心策略可能非常隐蔽，这种情况就非常考验个人的解题经验与算法能力了。 某些贪心策略具有较强的迷惑性。当我们满怀信心设计好贪心策略，写出解题代码并提交运行，很可能发现部分测试样例无法通过。这是因为设计的贪心策略只是“部分正确”的，上文介绍的零钱兑换就是一个典型案例。 为了保证正确性，我们应该对贪心策略进行严谨的数学证明，通常需要用到反证法或数学归纳法。\n然而，正确性证明也很可能不是一件易事。如若没有头绪，我们通常会选择面向测试用例进行代码调试，一步步修改与验证贪心策略。\n贪心算法典型例题 贪心算法常常应用在满足贪心选择性质和最优子结构的优化问题中，以下列举了一些典型的贪心算法问题。\n硬币找零问题：在某些硬币组合下，贪心算法总是可以得到最优解。 区间调度问题：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解。 分数背包问题：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 / 重量）的物品，那么贪心算法在一些情况下可以得到最优解。 股票买卖问题：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润。 霍夫曼编码：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最低的两个节点合并，最后得到的霍夫曼树的带权路径长度（编码长度）最小。 Dijkstra 算法：它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法。 分数背包问题 问题\n给定 $n$ 个物品，第 $i$ 个物品的重量为 $wgt[i-1]$、价值为 $val[i-1]$ ，和一个容量为 $cap$ 的背包。每个物品只能选择一次，但可以选择物品的一部分，价值根据选择的重量比例计算，问在限定背包容量下背包中物品的最大价值。示例如图 15-3 所示。\n分数背包问题和 0-1 背包问题整体上非常相似，状态包含当前物品 $i$ 和容量 $c$ ，目标是求限定背包容量下的最大价值。\n不同点在于，本题允许只选择物品的一部分。如图 15-4 所示，我们可以对物品任意地进行切分，并按照重量比例来计算相应价值。\n对于物品 $i$ ，它在单位重量下的价值为 $val[i-1] / wgt[i-1]$ ，简称单位价值。 假设放入一部分物品 $i$ ，重量为 $w$ ，则背包增加的价值为 $w \\times val[i-1] / wgt[i-1]$ 。 贪心策略确定 最大化背包内物品总价值，本质上是最大化单位重量下的物品价值。由此便可推理出图 15-5 所示的贪心策略。\n将物品按照单位价值从高到低进行排序。 遍历所有物品，每轮贪心地选择单位价值最高的物品。 若剩余背包容量不足，则使用当前物品的一部分填满背包。 代码实现 我们建立了一个物品类 Item ，以便将物品按照单位价值进行排序。循环进行贪心选择，当背包已满时跳出并返回解：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* 物品 */ class Item { int w; // 物品重量 int v; // 物品价值 public Item(int w, int v) { this.w = w; this.v = v; } } /* 分数背包：贪心 */ double fractionalKnapsack(int[] wgt, int[] val, int cap) { // 创建物品列表，包含两个属性：重量、价值 Item[] items = new Item[wgt.length]; for (int i = 0; i \u003c wgt.length; i++) { items[i] = new Item(wgt[i], val[i]); } // 按照单位价值 item.v / item.w 从高到低进行排序 Arrays.sort(items, Comparator.comparingDouble(item -\u003e -((double) item.v / item.w))); // 循环贪心选择 double res = 0; for (Item item : items) { if (item.w \u003c= cap) { // 若剩余容量充足，则将当前物品整个装进背包 res += item.v; cap -= item.w; } else { // 若剩余容量不足，则将当前物品的一部分装进背包 res += (double) item.v / item.w * cap; // 已无剩余容量，因此跳出循环 break; } } return res; } 除排序之外，在最差情况下，需要遍历整个物品列表，因此时间复杂度为 $O(n)$ ，其中 $n$ 为物品数量。\n由于初始化了一个 Item 对象列表，因此空间复杂度为 $O(n)$ 。\n正确性证明 采用反证法。假设物品 $x$ 是单位价值最高的物品，使用某算法求得最大价值为 res ，但该解中不包含物品 $x$ 。\n现在从背包中拿出单位重量的任意物品，并替换为单位重量的物品 $x$ 。由于物品 $x$ 的单位价值最高，因此替换后的总价值一定大于 res 。这与 res 是最优解矛盾，说明最优解中必须包含物品 $x$ 。\n对于该解中的其他物品，我们也可以构建出上述矛盾。总而言之，单位价值更大的物品总是更优选择，这说明贪心策略是有效的。\n如图 15-6 所示，如果将物品重量和物品单位价值分别看作一张二维图表的横轴和纵轴，则分数背包问题可转化为“求在有限横轴区间下围成的最大面积”。这个类比可以帮助我们从几何角度理解贪心策略的有效性。\n最大容量问题 问题\n输入一个数组 $ht$ ，其中的每个元素代表一个垂直隔板的高度。数组中的任意两个隔板，以及它们之间的空间可以组成一个容器。\n容器的容量等于高度和宽度的乘积（面积），其中高度由较短的隔板决定，宽度是两个隔板的数组索引之差。\n请在数组中选择两个隔板，使得组成的容器的容量最大，返回最大容量。示例如图 15-7 所示。\n容器由任意两个隔板围成，因此本题的状态为两个隔板的索引，记为 $[i, j]$ 。\n根据题意，容量等于高度乘以宽度，其中高度由短板决定，宽度是两隔板的数组索引之差。设容量为 $cap[i, j]$ ，则可得计算公式：\n$$ cap[i, j] = \\min(ht[i], ht[j]) \\times (j - i) $$ 设数组长度为 $n$ ，两个隔板的组合数量（状态总数）为 $C_n^2 = \\frac{n(n - 1)}{2}$ 个。最直接地，我们可以穷举所有状态，从而求得最大容量，时间复杂度为 $O(n^2)$ 。\n贪心策略确定 这道题还有更高效率的解法。如图 15-8 所示，现选取一个状态 $[i, j]$ ，其满足索引 $i \u003c j$ 且高度 $ht[i] \u003c ht[j]$ ，即 $i$ 为短板、$j$ 为长板。\n如图 15-9 所示，若此时将长板 $j$ 向短板 $i$ 靠近，则容量一定变小。\n这是因为在移动长板 $j$ 后，宽度 $j-i$ 肯定变小；而高度由短板决定，因此高度只可能不变（ $i$ 仍为短板）或变小（移动后的 $j$ 成为短板）。\n反向思考，我们只有向内收缩短板 $i$ ，才有可能使容量变大。因为虽然宽度一定变小，但高度可能会变大（移动后的短板 $i$ 可能会变长）。例如在图 15-10 中，移动短板后面积变大。\n由此便可推出本题的贪心策略：初始化两指针，使其分列容器两端，每轮向内收缩短板对应的指针，直至两指针相遇。\n图 15-11 展示了贪心策略的执行过程。\n初始状态下，指针 $i$ 和 $j$ 分列数组两端。 计算当前状态的容量 $cap[i, j]$ ，并更新最大容量。 比较板 $i$ 和 板 $j$ 的高度，并将短板向内移动一格。 循环执行第 2. 步和第 3. 步，直至 $i$ 和 $j$ 相遇时结束。 代码实现 代码循环最多 $n$ 轮，因此时间复杂度为 $O(n)$ 。\n变量 $i$、$j$、$res$ 使用常数大小的额外空间，因此空间复杂度为 $O(1)$ 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* 最大容量：贪心 */ int maxCapacity(int[] ht) { // 初始化 i, j，使其分列数组两端 int i = 0, j = ht.length - 1; // 初始最大容量为 0 int res = 0; // 循环贪心选择，直至两板相遇 while (i \u003c j) { // 更新最大容量 int cap = Math.min(ht[i], ht[j]) * (j - i); res = Math.max(res, cap); // 向内移动短板 if (ht[i] \u003c ht[j]) { i++; } else { j--; } } return res; } 正确性证明 之所以贪心比穷举更快，是因为每轮的贪心选择都会“跳过”一些状态。\n比如在状态 $cap[i, j]$ 下，$i$ 为短板、$j$ 为长板。若贪心地将短板 $i$ 向内移动一格，会导致图 15-12 所示的状态被“跳过”。这意味着之后无法验证这些状态的容量大小。\n$$ cap[i, i+1], cap[i, i+2], \\dots, cap[i, j-2], cap[i, j-1] $$ 观察发现，这些被跳过的状态实际上就是将长板 $j$ 向内移动的所有状态。前面我们已经证明内移长板一定会导致容量变小。也就是说，被跳过的状态都不可能是最优解，跳过它们不会导致错过最优解。\n以上分析说明，移动短板的操作是“安全”的，贪心策略是有效的。\n最大切分乘积问题 问题\n给定一个正整数 \\(n\\) ，将其切分为至少两个正整数的和，求切分后所有整数的乘积最大是多少，如图 15-13 所示。\n假设我们将 $n$ 切分为 $m$ 个整数因子，其中第 $i$ 个因子记为 $n_i$ ，即\n$$ n = \\sum_{i=1}^{m}n_i $$ 本题的目标是求得所有整数因子的最大乘积，即\n$$ \\max(\\prod_{i=1}^{m}n_i) $$ 我们需要思考的是：切分数量 $m$ 应该多大，每个 $n_i$ 应该是多少？\n贪心策略确定 根据经验，两个整数的乘积往往比它们的加和更大。假设从 $n$ 中分出一个因子 $2$ ，则它们的乘积为 $2(n-2)$ 。我们将该乘积与 $n$ 作比较：\n$$ \\begin{aligned} 2(n-2) \u0026 \\geq n \\newline 2n - n - 4 \u0026 \\geq 0 \\newline n \u0026 \\geq 4 \\end{aligned} $$ 如图 15-14 所示，当 $n \\geq 4$ 时，切分出一个 $2$ 后乘积会变大，这说明大于等于 $4$ 的整数都应该被切分。\n贪心策略一：如果切分方案中包含 $\\geq 4$ 的因子，那么它就应该被继续切分。最终的切分方案只应出现 $1$、$2$、$3$ 这三种因子。\n接下来思考哪个因子是最优的。在 $1$、$2$、$3$ 这三个因子中，显然 $1$ 是最差的，因为 $1 \\times (n-1) \u003c n$ 恒成立，即切分出 $1$ 反而会导致乘积减小。\n如图 15-15 所示，当 $n = 6$ 时，有 $3 \\times 3 \u003e 2 \\times 2 \\times 2$ 。这意味着切分出 $3$ 比切分出 $2$ 更优。\n贪心策略二：在切分方案中，最多只应存在两个 $2$ 。因为三个 $2$ 总是可以替换为两个 $3$ ，从而获得更大的乘积。\n综上所述，可推理出以下贪心策略。\n输入整数 $n$ ，从其不断地切分出因子 $3$ ，直至余数为 $0$、$1$、$2$ 。 当余数为 $0$ 时，代表 $n$ 是 $3$ 的倍数，因此不做任何处理。 当余数为 $2$ 时，不继续划分，保留。 当余数为 $1$ 时，由于 $2 \\times 2 \u003e 1 \\times 3$ ，因此应将最后一个 $3$ 替换为 $2$ 。 代码实现 如图 15-16 所示，我们无须通过循环来切分整数，而可以利用向下整除运算得到 $3$ 的个数 $a$ ，用取模运算得到余数 $b$ ，此时有：\n$$ n = 3 a + b $$ 请注意，对于 $n \\leq 3$ 的边界情况，必须拆分出一个 $1$ ，乘积为 $1 \\times (n - 1)$ 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /* 最大切分乘积：贪心 */ int maxProductCutting(int n) { // 当 n \u003c= 3 时，必须切分出一个 1 if (n \u003c= 3) { return 1 * (n - 1); } // 贪心地切分出 3 ，a 为 3 的个数，b 为余数 int a = n / 3; int b = n % 3; if (b == 1) { // 当余数为 1 时，将一对 1 * 3 转化为 2 * 2 return (int) Math.pow(3, a - 1) * 2 * 2; } if (b == 2) { // 当余数为 2 时，不做处理 return (int) Math.pow(3, a) * 2; } // 当余数为 0 时，不做处理 return (int) Math.pow(3, a); } 时间复杂度取决于编程语言的幂运算的实现方法。以 Python 为例，常用的幂计算函数有三种。\n运算符 ** 和函数 pow() 的时间复杂度均为 $O(\\log⁡ a)$ 。 函数 math.pow() 内部调用 C 语言库的 pow() 函数，其执行浮点取幂，时间复杂度为 $O(1)$ 。 变量 $a$ 和 $b$ 使用常数大小的额外空间，因此空间复杂度为 $O(1)$ 。\n正确性证明 使用反证法，只分析 $n \\geq 3$ 的情况。\n所有因子 $\\leq 3$ ：假设最优切分方案中存在 $\\geq 4$ 的因子 $x$ ，那么一定可以将其继续划分为 $2(x-2)$ ，从而获得更大的乘积。这与假设矛盾。 切分方案不包含 $1$ ：假设最优切分方案中存在一个因子 $1$ ，那么它一定可以合并入另外一个因子中，以获得更大的乘积。这与假设矛盾。 切分方案最多包含两个 $2$ ：假设最优切分方案中包含三个 $2$ ，那么一定可以替换为两个 $3$ ，乘积更大。这与假设矛盾。 小结 贪心算法通常用于解决最优化问题，其原理是在每个决策阶段都做出局部最优的决策，以期获得全局最优解。 贪心算法会迭代地做出一个又一个的贪心选择，每轮都将问题转化成一个规模更小的子问题，直到问题被解决。 贪心算法不仅实现简单，还具有很高的解题效率。相比于动态规划，贪心算法的时间复杂度通常更低。 在零钱兑换问题中，对于某些硬币组合，贪心算法可以保证找到最优解；对于另外一些硬币组合则不然，贪心算法可能找到很差的解。 适合用贪心算法求解的问题具有两大性质：贪心选择性质和最优子结构。贪心选择性质代表贪心策略的有效性。 对于某些复杂问题，贪心选择性质的证明并不简单。相对来说，证伪更加容易，例如零钱兑换问题。 求解贪心问题主要分为三步：问题分析、确定贪心策略、正确性证明。其中，确定贪心策略是核心步骤，正确性证明往往是难点。 分数背包问题在 0-1 背包的基础上，允许选择物品的一部分，因此可使用贪心算法求解。贪心策略的正确性可以使用反证法来证明。 最大容量问题可使用穷举法求解，时间复杂度为 $O(n^2)$ 。通过设计贪心策略，每轮向内移动短板，可将时间复杂度优化至 $O(n)$ 。 在最大切分乘积问题中，我们先后推理出两个贪心策略：$\\geq 4$ 的整数都应该继续切分，最优切分因子为 $3$ 。代码中包含幂运算，时间复杂度取决于幂运算实现方法，通常为 $O(1)$ 或 $O(\\log n)$ 。 ",
  "wordCount" : "6456",
  "inLanguage": "en",
  "datePublished": "2024-06-06T11:32:06Z",
  "dateModified": "2024-06-06T11:32:06Z",
  "author":{
    "@type": "Person",
    "name": "Wjy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://wjy6.netlify.app/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Wjy's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://wjy6.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://wjy6.netlify.app/" accesskey="h" title="Wjy&#39;s Blog (Alt + H)">Wjy&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://wjy6.netlify.app/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://wjy6.netlify.app/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://wjy6.netlify.app/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://wjy6.netlify.app/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://wjy6.netlify.app/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://wjy6.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://wjy6.netlify.app/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      14_贪心
    </h1>
    <div class="post-meta"><span title='2024-06-06 11:32:06 +0000 UTC'>2024-06-06</span>&nbsp;·&nbsp;Wjy

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95" aria-label="贪心算法">贪心算法</a><ul>
                        
                <li>
                    <a href="#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e7%9a%84%e4%bc%98%e7%82%b9%e4%b8%8e%e5%b1%80%e9%99%90%e6%80%a7" aria-label="贪心算法的优点与局限性">贪心算法的优点与局限性</a></li>
                <li>
                    <a href="#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e7%89%b9%e6%80%a7" aria-label="贪心算法特性">贪心算法特性</a></li>
                <li>
                    <a href="#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e8%a7%a3%e9%a2%98%e6%ad%a5%e9%aa%a4" aria-label="贪心算法解题步骤">贪心算法解题步骤</a></li>
                <li>
                    <a href="#%e8%b4%aa%e5%bf%83%e7%ae%97%e6%b3%95%e5%85%b8%e5%9e%8b%e4%be%8b%e9%a2%98" aria-label="贪心算法典型例题">贪心算法典型例题</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%86%e6%95%b0%e8%83%8c%e5%8c%85%e9%97%ae%e9%a2%98" aria-label="分数背包问题">分数背包问题</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e8%b4%aa%e5%bf%83%e7%ad%96%e7%95%a5%e7%a1%ae%e5%ae%9a" aria-label="贪心策略确定">贪心策略确定</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e6%ad%a3%e7%a1%ae%e6%80%a7%e8%af%81%e6%98%8e" aria-label="正确性证明">正确性证明</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#%e6%9c%80%e5%a4%a7%e5%ae%b9%e9%87%8f%e9%97%ae%e9%a2%98" aria-label="最大容量问题">最大容量问题</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e8%b4%aa%e5%bf%83%e7%ad%96%e7%95%a5%e7%a1%ae%e5%ae%9a-1" aria-label="贪心策略确定">贪心策略确定</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-1" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e6%ad%a3%e7%a1%ae%e6%80%a7%e8%af%81%e6%98%8e-1" aria-label="正确性证明">正确性证明</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#%e6%9c%80%e5%a4%a7%e5%88%87%e5%88%86%e4%b9%98%e7%a7%af%e9%97%ae%e9%a2%98" aria-label="最大切分乘积问题">最大切分乘积问题</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e8%b4%aa%e5%bf%83%e7%ad%96%e7%95%a5%e7%a1%ae%e5%ae%9a-2" aria-label="贪心策略确定">贪心策略确定</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0-2" aria-label="代码实现">代码实现</a></li>
                <li>
                    <a href="#%e6%ad%a3%e7%a1%ae%e6%80%a7%e8%af%81%e6%98%8e-2" aria-label="正确性证明">正确性证明</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#%e5%b0%8f%e7%bb%93" aria-label="小结">小结</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="贪心算法">贪心算法<a hidden class="anchor" aria-hidden="true" href="#贪心算法">#</a></h1>
<p>贪心算法（greedy algorithm）是一种常见的解决优化问题的算法，其基本思想是在问题的每个决策阶段，都选择当前看起来最优的选择，即贪心地做出局部最优的决策，以期获得全局最优解。贪心算法简洁且高效，在许多实际问题中有着广泛的应用。</p>
<p>贪心算法和动态规划都常用于解决优化问题。它们之间存在一些相似之处，比如都依赖最优子结构性质，但工作原理不同。</p>
<ul>
<li>动态规划会根据之前阶段的所有决策来考虑当前决策，并使用过去子问题的解来构建当前子问题的解。</li>
<li>贪心算法不会考虑过去的决策，而是一路向前地进行贪心选择，不断缩小问题范围，直至问题被解决。</li>
</ul>
<p>我们先通过例题“零钱兑换”了解贪心算法的工作原理。这道题已经在“完全背包问题”章节中介绍过，相信你对它并不陌生。</p>
<blockquote>
<p>问题</p>
<p>给定 $n$ 种硬币，第 $i$ 种硬币的面值为 $coins[i - 1]$ ，目标金额为 $amt$ ，每种硬币可以重复选取，问能够凑出目标金额的最少硬币数量。如果无法凑出目标金额，则返回 $-1$ 。</p>
</blockquote>
<p>本题采取的贪心策略如图 15-1 所示。给定目标金额，<strong>我们贪心地选择不大于且最接近它的硬币</strong>，不断循环该步骤，直至凑出目标金额为止。</p>
<p><img alt="图 15-1  零钱兑换的贪心策略" loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/coin_change_greedy_strategy.png"></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 零钱兑换：贪心 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> coinChangeGreedy(<span style="color:#fff;font-weight:bold">int</span>[] coins, <span style="color:#fff;font-weight:bold">int</span> amt) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 假设 coins 列表有序</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> i = coins.<span style="color:#007f7f">length</span> - 1;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> count = 0;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 循环进行贪心选择，直到无剩余金额</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> (amt &gt; 0) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 找到小于且最接近剩余金额的硬币</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">while</span> (i &gt; 0 &amp;&amp; coins[i] &gt; amt) {
</span></span><span style="display:flex;"><span>            i--;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 选择 coins[i]</span>
</span></span><span style="display:flex;"><span>        amt -= coins[i];
</span></span><span style="display:flex;"><span>        count++;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 若未找到可行方案，则返回 -1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> amt == 0 ? count : -1;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>你可能会不由地发出感叹：So clean ！贪心算法仅用约十行代码就解决了零钱兑换问题。</p>
<h2 id="贪心算法的优点与局限性">贪心算法的优点与局限性<a hidden class="anchor" aria-hidden="true" href="#贪心算法的优点与局限性">#</a></h2>
<p><strong>贪心算法不仅操作直接、实现简单，而且通常效率也很高</strong>。在以上代码中，记硬币最小面值为 $\min(coins)$ ，则贪心选择最多循环 $amt / \min(coins)$ 次，时间复杂度为 $O(amt / \min(coins))$ 。这比动态规划解法的时间复杂度 $O(n \times amt)$ 小了一个数量级。</p>
<p>然而，<strong>对于某些硬币面值组合，贪心算法并不能找到最优解</strong>。图 15-2 给出了两个示例。</p>
<ul>
<li><strong>正例 $coins = [1, 5, 10, 20, 50, 100]$</strong>：在该硬币组合下，给定任意 $amt$ ，贪心算法都可以找到最优解。</li>
<li><strong>反例 $coins = [1, 20, 50]$</strong>：假设 $amt = 60$ ，贪心算法只能找到 $50 + 1 \times 10$ 的兑换组合，共计 $11$ 枚硬币，但动态规划可以找到最优解 $20 + 20 + 20$ ，仅需 $3$ 枚硬币。</li>
<li><strong>反例 $coins = [1, 49, 50]$</strong>：假设 $amt = 98$ ，贪心算法只能找到 $50 + 1 \times 48$ 的兑换组合，共计 $49$ 枚硬币，但动态规划可以找到最优解 $49 + 49$ ，仅需 $2$ 枚硬币。</li>
</ul>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/coin_change_greedy_vs_dp.png"></p>
<p>也就是说，对于零钱兑换问题，贪心算法无法保证找到全局最优解，并且有可能找到非常差的解。它更适合用动态规划解决。</p>
<p>一般情况下，贪心算法的适用情况分以下两种。</p>
<ol>
<li><strong>可以保证找到最优解</strong>：贪心算法在这种情况下往往是最优选择，因为它往往比回溯、动态规划更高效。</li>
<li><strong>可以找到近似最优解</strong>：贪心算法在这种情况下也是可用的。对于很多复杂问题来说，寻找全局最优解非常困难，能以较高效率找到次优解也是非常不错的。</li>
</ol>
<h2 id="贪心算法特性">贪心算法特性<a hidden class="anchor" aria-hidden="true" href="#贪心算法特性">#</a></h2>
<p>那么问题来了，什么样的问题适合用贪心算法求解呢？或者说，贪心算法在什么情况下可以保证找到最优解？</p>
<p>相较于动态规划，贪心算法的使用条件更加苛刻，其主要关注问题的两个性质。</p>
<ul>
<li><strong>贪心选择性质</strong>：只有当局部最优选择始终可以导致全局最优解时，贪心算法才能保证得到最优解。</li>
<li><strong>最优子结构</strong>：原问题的最优解包含子问题的最优解。</li>
</ul>
<p>最优子结构已经在“动态规划”章节中介绍过，这里不再赘述。值得注意的是，一些问题的最优子结构并不明显，但仍然可使用贪心算法解决。</p>
<p>我们主要探究贪心选择性质的判断方法。虽然它的描述看上去比较简单，<strong>但实际上对于许多问题，证明贪心选择性质并非易事</strong>。</p>
<p>例如零钱兑换问题，我们虽然能够容易地举出反例，对贪心选择性质进行证伪，但证实的难度较大。如果问：<strong>满足什么条件的硬币组合可以使用贪心算法求解</strong>？我们往往只能凭借直觉或举例子来给出一个模棱两可的答案，而难以给出严谨的数学证明。</p>
<blockquote>
<p>Quote</p>
<p>有一篇论文给出了一个 $O(n^3)$ 时间复杂度的算法，用于判断一个硬币组合能否使用贪心算法找出任意金额的最优解。</p>
<p>Pearson, D. A polynomial-time algorithm for the change-making problem[J]. Operations Research Letters, 2005, 33(3): 231-234.</p>
</blockquote>
<h2 id="贪心算法解题步骤">贪心算法解题步骤<a hidden class="anchor" aria-hidden="true" href="#贪心算法解题步骤">#</a></h2>
<p>贪心问题的解决流程大体可分为以下三步。</p>
<ol>
<li><strong>问题分析</strong>：梳理与理解问题特性，包括状态定义、优化目标和约束条件等。这一步在回溯和动态规划中都有涉及。</li>
<li><strong>确定贪心策略</strong>：确定如何在每一步中做出贪心选择。这个策略能够在每一步减小问题的规模，并最终解决整个问题。</li>
<li><strong>正确性证明</strong>：通常需要证明问题具有贪心选择性质和最优子结构。这个步骤可能需要用到数学证明，例如归纳法或反证法等。</li>
</ol>
<p>确定贪心策略是求解问题的核心步骤，但实施起来可能并不容易，主要有以下原因。</p>
<ul>
<li><strong>不同问题的贪心策略的差异较大</strong>。对于许多问题来说，贪心策略比较浅显，我们通过一些大概的思考与尝试就能得出。而对于一些复杂问题，贪心策略可能非常隐蔽，这种情况就非常考验个人的解题经验与算法能力了。</li>
<li><strong>某些贪心策略具有较强的迷惑性</strong>。当我们满怀信心设计好贪心策略，写出解题代码并提交运行，很可能发现部分测试样例无法通过。这是因为设计的贪心策略只是“部分正确”的，上文介绍的零钱兑换就是一个典型案例。</li>
</ul>
<p>为了保证正确性，我们应该对贪心策略进行严谨的数学证明，<strong>通常需要用到反证法或数学归纳法</strong>。</p>
<p>然而，正确性证明也很可能不是一件易事。如若没有头绪，我们通常会选择面向测试用例进行代码调试，一步步修改与验证贪心策略。</p>
<h2 id="贪心算法典型例题">贪心算法典型例题<a hidden class="anchor" aria-hidden="true" href="#贪心算法典型例题">#</a></h2>
<p>贪心算法常常应用在满足贪心选择性质和最优子结构的优化问题中，以下列举了一些典型的贪心算法问题。</p>
<ul>
<li><strong>硬币找零问题</strong>：在某些硬币组合下，贪心算法总是可以得到最优解。</li>
<li><strong>区间调度问题</strong>：假设你有一些任务，每个任务在一段时间内进行，你的目标是完成尽可能多的任务。如果每次都选择结束时间最早的任务，那么贪心算法就可以得到最优解。</li>
<li><strong>分数背包问题</strong>：给定一组物品和一个载重量，你的目标是选择一组物品，使得总重量不超过载重量，且总价值最大。如果每次都选择性价比最高（价值 / 重量）的物品，那么贪心算法在一些情况下可以得到最优解。</li>
<li><strong>股票买卖问题</strong>：给定一组股票的历史价格，你可以进行多次买卖，但如果你已经持有股票，那么在卖出之前不能再买，目标是获取最大利润。</li>
<li><strong>霍夫曼编码</strong>：霍夫曼编码是一种用于无损数据压缩的贪心算法。通过构建霍夫曼树，每次选择出现频率最低的两个节点合并，最后得到的霍夫曼树的带权路径长度（编码长度）最小。</li>
<li><strong>Dijkstra 算法</strong>：它是一种解决给定源顶点到其余各顶点的最短路径问题的贪心算法。</li>
</ul>
<h1 id="分数背包问题">分数背包问题<a hidden class="anchor" aria-hidden="true" href="#分数背包问题">#</a></h1>
<blockquote>
<p>问题</p>
<p>给定 $n$ 个物品，第 $i$ 个物品的重量为 $wgt[i-1]$、价值为 $val[i-1]$ ，和一个容量为 $cap$ 的背包。每个物品只能选择一次，<strong>但可以选择物品的一部分，价值根据选择的重量比例计算</strong>，问在限定背包容量下背包中物品的最大价值。示例如图 15-3 所示。</p>
</blockquote>
<p><img alt="图 15-3  分数背包问题的示例数据" loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/fractional_knapsack_example.png"></p>
<p>分数背包问题和 0-1 背包问题整体上非常相似，状态包含当前物品 $i$ 和容量 $c$ ，目标是求限定背包容量下的最大价值。</p>
<p>不同点在于，本题允许只选择物品的一部分。如图 15-4 所示，<strong>我们可以对物品任意地进行切分，并按照重量比例来计算相应价值</strong>。</p>
<ol>
<li>对于物品 $i$ ，它在单位重量下的价值为 $val[i-1] / wgt[i-1]$ ，简称单位价值。</li>
<li>假设放入一部分物品 $i$ ，重量为 $w$ ，则背包增加的价值为 $w \times val[i-1] / wgt[i-1]$ 。</li>
</ol>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/fractional_knapsack_unit_value.png"></p>
<h3 id="贪心策略确定">贪心策略确定<a hidden class="anchor" aria-hidden="true" href="#贪心策略确定">#</a></h3>
<p>最大化背包内物品总价值，<strong>本质上是最大化单位重量下的物品价值</strong>。由此便可推理出图 15-5 所示的贪心策略。</p>
<ol>
<li>将物品按照单位价值从高到低进行排序。</li>
<li>遍历所有物品，<strong>每轮贪心地选择单位价值最高的物品</strong>。</li>
<li>若剩余背包容量不足，则使用当前物品的一部分填满背包。</li>
</ol>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/fractional_knapsack_greedy_strategy.png"></p>
<h3 id="代码实现">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现">#</a></h3>
<p>我们建立了一个物品类 <code>Item</code> ，以便将物品按照单位价值进行排序。循环进行贪心选择，当背包已满时跳出并返回解：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 物品 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> Item {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> w; <span style="color:#007f7f">// 物品重量</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> v; <span style="color:#007f7f">// 物品价值</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> Item(<span style="color:#fff;font-weight:bold">int</span> w, <span style="color:#fff;font-weight:bold">int</span> v) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">w</span> = w;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">v</span> = v;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* 分数背包：贪心 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">double</span> fractionalKnapsack(<span style="color:#fff;font-weight:bold">int</span>[] wgt, <span style="color:#fff;font-weight:bold">int</span>[] val, <span style="color:#fff;font-weight:bold">int</span> cap) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 创建物品列表，包含两个属性：重量、价值</span>
</span></span><span style="display:flex;"><span>    Item[] items = <span style="color:#fff;font-weight:bold">new</span> Item[wgt.<span style="color:#007f7f">length</span>];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 0; i &lt; wgt.<span style="color:#007f7f">length</span>; i++) {
</span></span><span style="display:flex;"><span>        items[i] = <span style="color:#fff;font-weight:bold">new</span> Item(wgt[i], val[i]);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 按照单位价值 item.v / item.w 从高到低进行排序</span>
</span></span><span style="display:flex;"><span>    Arrays.<span style="color:#007f7f">sort</span>(items, Comparator.<span style="color:#007f7f">comparingDouble</span>(item -&gt; -((<span style="color:#fff;font-weight:bold">double</span>) item.<span style="color:#007f7f">v</span> / item.<span style="color:#007f7f">w</span>)));
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 循环贪心选择</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">double</span> res = 0;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (Item item : items) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (item.<span style="color:#007f7f">w</span> &lt;= cap) {
</span></span><span style="display:flex;"><span>            <span style="color:#007f7f">// 若剩余容量充足，则将当前物品整个装进背包</span>
</span></span><span style="display:flex;"><span>            res += item.<span style="color:#007f7f">v</span>;
</span></span><span style="display:flex;"><span>            cap -= item.<span style="color:#007f7f">w</span>;
</span></span><span style="display:flex;"><span>        } <span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#007f7f">// 若剩余容量不足，则将当前物品的一部分装进背包</span>
</span></span><span style="display:flex;"><span>            res += (<span style="color:#fff;font-weight:bold">double</span>) item.<span style="color:#007f7f">v</span> / item.<span style="color:#007f7f">w</span> * cap;
</span></span><span style="display:flex;"><span>            <span style="color:#007f7f">// 已无剩余容量，因此跳出循环</span>
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>除排序之外，在最差情况下，需要遍历整个物品列表，<strong>因此时间复杂度为 $O(n)$</strong> ，其中 $n$ 为物品数量。</p>
<p>由于初始化了一个 <code>Item</code> 对象列表，<strong>因此空间复杂度为 $O(n)$</strong> 。</p>
<h3 id="正确性证明">正确性证明<a hidden class="anchor" aria-hidden="true" href="#正确性证明">#</a></h3>
<p>采用反证法。假设物品 $x$ 是单位价值最高的物品，使用某算法求得最大价值为 <code>res</code> ，但该解中不包含物品 $x$ 。</p>
<p>现在从背包中拿出单位重量的任意物品，并替换为单位重量的物品 $x$ 。由于物品 $x$ 的单位价值最高，因此替换后的总价值一定大于 <code>res</code> 。<strong>这与 <code>res</code> 是最优解矛盾，说明最优解中必须包含物品 $x$</strong> 。</p>
<p>对于该解中的其他物品，我们也可以构建出上述矛盾。总而言之，<strong>单位价值更大的物品总是更优选择</strong>，这说明贪心策略是有效的。</p>
<p>如图 15-6 所示，如果将物品重量和物品单位价值分别看作一张二维图表的横轴和纵轴，则分数背包问题可转化为“求在有限横轴区间下围成的最大面积”。这个类比可以帮助我们从几何角度理解贪心策略的有效性。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/fractional_knapsack_area_chart.png"></p>
<h1 id="最大容量问题">最大容量问题<a hidden class="anchor" aria-hidden="true" href="#最大容量问题">#</a></h1>
<blockquote>
<p>问题</p>
<p>输入一个数组 $ht$ ，其中的每个元素代表一个垂直隔板的高度。数组中的任意两个隔板，以及它们之间的空间可以组成一个容器。</p>
<p>容器的容量等于高度和宽度的乘积（面积），其中高度由较短的隔板决定，宽度是两个隔板的数组索引之差。</p>
<p>请在数组中选择两个隔板，使得组成的容器的容量最大，返回最大容量。示例如图 15-7 所示。</p>
</blockquote>
<p><img alt="图 15-7  最大容量问题的示例数据" loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/max_capacity_example.png"></p>
<p>容器由任意两个隔板围成，<strong>因此本题的状态为两个隔板的索引，记为 $[i, j]$</strong> 。</p>
<p>根据题意，容量等于高度乘以宽度，其中高度由短板决定，宽度是两隔板的数组索引之差。设容量为 $cap[i, j]$ ，则可得计算公式：</p>
$$ cap[i, j] = \min(ht[i], ht[j]) \times (j - i) $$
<p>设数组长度为 $n$ ，两个隔板的组合数量（状态总数）为 $C_n^2 = \frac{n(n - 1)}{2}$ 个。最直接地，<strong>我们可以穷举所有状态</strong>，从而求得最大容量，时间复杂度为 $O(n^2)$ 。</p>
<h3 id="贪心策略确定-1">贪心策略确定<a hidden class="anchor" aria-hidden="true" href="#贪心策略确定-1">#</a></h3>
<p>这道题还有更高效率的解法。如图 15-8 所示，现选取一个状态 $[i, j]$ ，其满足索引 $i &lt; j$ 且高度 $ht[i] &lt; ht[j]$ ，即 $i$ 为短板、$j$ 为长板。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/max_capacity_initial_state.png"></p>
<p>如图 15-9 所示，<strong>若此时将长板 $j$ 向短板 $i$ 靠近，则容量一定变小</strong>。</p>
<p>这是因为在移动长板 $j$ 后，宽度 $j-i$ 肯定变小；而高度由短板决定，因此高度只可能不变（ $i$ 仍为短板）或变小（移动后的 $j$ 成为短板）。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/max_capacity_moving_long_board.png"></p>
<p>反向思考，<strong>我们只有向内收缩短板 $i$ ，才有可能使容量变大</strong>。因为虽然宽度一定变小，<strong>但高度可能会变大</strong>（移动后的短板 $i$ 可能会变长）。例如在图 15-10 中，移动短板后面积变大。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/max_capacity_moving_short_board.png"></p>
<p>由此便可推出本题的贪心策略：初始化两指针，使其分列容器两端，每轮向内收缩短板对应的指针，直至两指针相遇。</p>
<p>图 15-11 展示了贪心策略的执行过程。</p>
<ol>
<li>初始状态下，指针 $i$ 和 $j$ 分列数组两端。</li>
<li>计算当前状态的容量 $cap[i, j]$ ，并更新最大容量。</li>
<li>比较板 $i$ 和 板 $j$ 的高度，并将短板向内移动一格。</li>
<li>循环执行第 <code>2.</code> 步和第 <code>3.</code> 步，直至 $i$ 和 $j$ 相遇时结束。</li>
</ol>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/max_capacity_greedy_step1.png"><br>
<img loading="lazy" src="max_capacity_greedy_step2.png"><br>
<img loading="lazy" src="max_capacity_greedy_step3.png"><br>
<img loading="lazy" src="max_capacity_greedy_step4.png"><br>
<img loading="lazy" src="max_capacity_greedy_step5.png"><br>
<img loading="lazy" src="max_capacity_greedy_step6.png"><br>
<img loading="lazy" src="max_capacity_greedy_step7.png"><br>
<img loading="lazy" src="max_capacity_greedy_step8.png"><br>
<img loading="lazy" src="max_capacity_greedy_step9.png"></p>
<h3 id="代码实现-1">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-1">#</a></h3>
<p>代码循环最多 $n$ 轮，<strong>因此时间复杂度为 $O(n)$</strong> 。</p>
<p>变量 $i$、$j$、$res$ 使用常数大小的额外空间，<strong>因此空间复杂度为 $O(1)$</strong> 。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 最大容量：贪心 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> maxCapacity(<span style="color:#fff;font-weight:bold">int</span>[] ht) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 初始化 i, j，使其分列数组两端</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> i = 0, j = ht.<span style="color:#007f7f">length</span> - 1;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 初始最大容量为 0</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> res = 0;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 循环贪心选择，直至两板相遇</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> (i &lt; j) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 更新最大容量</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">int</span> cap = Math.<span style="color:#007f7f">min</span>(ht[i], ht[j]) * (j - i);
</span></span><span style="display:flex;"><span>        res = Math.<span style="color:#007f7f">max</span>(res, cap);
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 向内移动短板</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (ht[i] &lt; ht[j]) {
</span></span><span style="display:flex;"><span>            i++;
</span></span><span style="display:flex;"><span>        } <span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>            j--;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> res;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="正确性证明-1">正确性证明<a hidden class="anchor" aria-hidden="true" href="#正确性证明-1">#</a></h3>
<p>之所以贪心比穷举更快，是因为每轮的贪心选择都会“跳过”一些状态。</p>
<p>比如在状态 $cap[i, j]$ 下，$i$ 为短板、$j$ 为长板。若贪心地将短板 $i$ 向内移动一格，会导致图 15-12 所示的状态被“跳过”。<strong>这意味着之后无法验证这些状态的容量大小</strong>。</p>
$$ cap[i, i+1], cap[i, i+2], \dots, cap[i, j-2], cap[i, j-1] $$
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/max_capacity_skipped_states.png"></p>
<p>观察发现，<strong>这些被跳过的状态实际上就是将长板 $j$ 向内移动的所有状态</strong>。前面我们已经证明内移长板一定会导致容量变小。也就是说，被跳过的状态都不可能是最优解，<strong>跳过它们不会导致错过最优解</strong>。</p>
<p>以上分析说明，移动短板的操作是“安全”的，贪心策略是有效的。</p>
<h1 id="最大切分乘积问题">最大切分乘积问题<a hidden class="anchor" aria-hidden="true" href="#最大切分乘积问题">#</a></h1>
<blockquote>
<p>问题</p>
<p>给定一个正整数 \(n\) ，将其切分为至少两个正整数的和，求切分后所有整数的乘积最大是多少，如图 15-13 所示。</p>
</blockquote>
<p><img alt="图 15-13  最大切分乘积的问题定义" loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/max_product_cutting_definition.png"></p>
<p>假设我们将 $n$ 切分为 $m$ 个整数因子，其中第 $i$ 个因子记为 $n_i$ ，即</p>
$$ n = \sum_{i=1}^{m}n_i $$
<p>本题的目标是求得所有整数因子的最大乘积，即</p>
$$ \max(\prod_{i=1}^{m}n_i) $$
<p>我们需要思考的是：切分数量 $m$ 应该多大，每个 $n_i$ 应该是多少？</p>
<h3 id="贪心策略确定-2">贪心策略确定<a hidden class="anchor" aria-hidden="true" href="#贪心策略确定-2">#</a></h3>
<p>根据经验，两个整数的乘积往往比它们的加和更大。假设从 $n$ 中分出一个因子 $2$ ，则它们的乘积为 $2(n-2)$ 。我们将该乘积与 $n$ 作比较：</p>
$$ \begin{aligned} 2(n-2) & \geq n \newline 2n - n - 4 & \geq 0 \newline n & \geq 4 \end{aligned} $$
<p>如图 15-14 所示，当 $n \geq 4$ 时，切分出一个 $2$ 后乘积会变大，<strong>这说明大于等于 $4$ 的整数都应该被切分</strong>。</p>
<p><strong>贪心策略一</strong>：如果切分方案中包含 $\geq 4$ 的因子，那么它就应该被继续切分。最终的切分方案只应出现 $1$、$2$、$3$ 这三种因子。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/max_product_cutting_greedy_infer1.png"></p>
<p>接下来思考哪个因子是最优的。在 $1$、$2$、$3$ 这三个因子中，显然 $1$ 是最差的，因为 $1 \times (n-1) &lt; n$ 恒成立，即切分出 $1$ 反而会导致乘积减小。</p>
<p>如图 15-15 所示，当 $n = 6$ 时，有 $3 \times 3 &gt; 2 \times 2 \times 2$ 。<strong>这意味着切分出 $3$ 比切分出 $2$ 更优</strong>。</p>
<p><strong>贪心策略二</strong>：在切分方案中，最多只应存在两个 $2$ 。因为三个 $2$ 总是可以替换为两个 $3$ ，从而获得更大的乘积。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/max_product_cutting_greedy_infer2.png"></p>
<p>综上所述，可推理出以下贪心策略。</p>
<ol>
<li>输入整数 $n$ ，从其不断地切分出因子 $3$ ，直至余数为 $0$、$1$、$2$ 。</li>
<li>当余数为 $0$ 时，代表 $n$ 是 $3$ 的倍数，因此不做任何处理。</li>
<li>当余数为 $2$ 时，不继续划分，保留。</li>
<li>当余数为 $1$ 时，由于 $2 \times 2 &gt; 1 \times 3$ ，因此应将最后一个 $3$ 替换为 $2$ 。</li>
</ol>
<h3 id="代码实现-2">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现-2">#</a></h3>
<p>如图 15-16 所示，我们无须通过循环来切分整数，而可以利用向下整除运算得到 $3$ 的个数 $a$ ，用取模运算得到余数 $b$ ，此时有：</p>
$$ n = 3 a + b $$
<p>请注意，对于 $n \leq 3$ 的边界情况，必须拆分出一个 $1$ ，乘积为 $1 \times (n - 1)$ 。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 最大切分乘积：贪心 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> maxProductCutting(<span style="color:#fff;font-weight:bold">int</span> n) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 当 n &lt;= 3 时，必须切分出一个 1</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (n &lt;= 3) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> 1 * (n - 1);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 贪心地切分出 3 ，a 为 3 的个数，b 为余数</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> a = n / 3;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> b = n % 3;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (b == 1) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 当余数为 1 时，将一对 1 * 3 转化为 2 * 2</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> (<span style="color:#fff;font-weight:bold">int</span>) Math.<span style="color:#007f7f">pow</span>(3, a - 1) * 2 * 2;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (b == 2) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 当余数为 2 时，不做处理</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> (<span style="color:#fff;font-weight:bold">int</span>) Math.<span style="color:#007f7f">pow</span>(3, a) * 2;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 当余数为 0 时，不做处理</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> (<span style="color:#fff;font-weight:bold">int</span>) Math.<span style="color:#007f7f">pow</span>(3, a);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/14_%E8%B4%AA%E5%BF%83/max_product_cutting_greedy_calculation.png"></p>
<p><strong>时间复杂度取决于编程语言的幂运算的实现方法</strong>。以 Python 为例，常用的幂计算函数有三种。</p>
<ul>
<li>运算符 <code>**</code> 和函数 <code>pow()</code> 的时间复杂度均为 $O(\log⁡ a)$ 。</li>
<li>函数 <code>math.pow()</code> 内部调用 C 语言库的 <code>pow()</code> 函数，其执行浮点取幂，时间复杂度为 $O(1)$ 。</li>
</ul>
<p>变量 $a$ 和 $b$ 使用常数大小的额外空间，<strong>因此空间复杂度为 $O(1)$</strong> 。</p>
<h3 id="正确性证明-2">正确性证明<a hidden class="anchor" aria-hidden="true" href="#正确性证明-2">#</a></h3>
<p>使用反证法，只分析 $n \geq 3$ 的情况。</p>
<ol>
<li><strong>所有因子 $\leq 3$</strong> ：假设最优切分方案中存在 $\geq 4$ 的因子 $x$ ，那么一定可以将其继续划分为 $2(x-2)$ ，从而获得更大的乘积。这与假设矛盾。</li>
<li><strong>切分方案不包含 $1$</strong> ：假设最优切分方案中存在一个因子 $1$ ，那么它一定可以合并入另外一个因子中，以获得更大的乘积。这与假设矛盾。</li>
<li><strong>切分方案最多包含两个 $2$</strong> ：假设最优切分方案中包含三个 $2$ ，那么一定可以替换为两个 $3$ ，乘积更大。这与假设矛盾。</li>
</ol>
<h1 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h1>
<ul>
<li>贪心算法通常用于解决最优化问题，其原理是在每个决策阶段都做出局部最优的决策，以期获得全局最优解。</li>
<li>贪心算法会迭代地做出一个又一个的贪心选择，每轮都将问题转化成一个规模更小的子问题，直到问题被解决。</li>
<li>贪心算法不仅实现简单，还具有很高的解题效率。相比于动态规划，贪心算法的时间复杂度通常更低。</li>
<li>在零钱兑换问题中，对于某些硬币组合，贪心算法可以保证找到最优解；对于另外一些硬币组合则不然，贪心算法可能找到很差的解。</li>
<li>适合用贪心算法求解的问题具有两大性质：贪心选择性质和最优子结构。贪心选择性质代表贪心策略的有效性。</li>
<li>对于某些复杂问题，贪心选择性质的证明并不简单。相对来说，证伪更加容易，例如零钱兑换问题。</li>
<li>求解贪心问题主要分为三步：问题分析、确定贪心策略、正确性证明。其中，确定贪心策略是核心步骤，正确性证明往往是难点。</li>
<li>分数背包问题在 0-1 背包的基础上，允许选择物品的一部分，因此可使用贪心算法求解。贪心策略的正确性可以使用反证法来证明。</li>
<li>最大容量问题可使用穷举法求解，时间复杂度为 $O(n^2)$ 。通过设计贪心策略，每轮向内移动短板，可将时间复杂度优化至 $O(n)$ 。</li>
<li>在最大切分乘积问题中，我们先后推理出两个贪心策略：$\geq 4$ 的整数都应该继续切分，最优切分因子为 $3$ 。代码中包含幂运算，时间复杂度取决于幂运算实现方法，通常为 $O(1)$ 或 $O(\log n)$ 。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://wjy6.netlify.app/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://wjy6.netlify.app/">Wjy&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
