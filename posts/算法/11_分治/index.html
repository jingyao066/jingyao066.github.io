<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>11_分治 | Wjy&#39;s Blog</title>
<meta name="keywords" content="算法">
<meta name="description" content="分治算法 分治（divide and conquer），全称分而治之，是一种非常重要且常见的算法策略。分治通常基于递归实现，包括“分”和“治”两个步骤">
<meta name="author" content="Wjy">
<link rel="canonical" href="https://funny-toffee-4aa7c3.netlify.app/posts/%E7%AE%97%E6%B3%95/11_%E5%88%86%E6%B2%BB/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://funny-toffee-4aa7c3.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://funny-toffee-4aa7c3.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://funny-toffee-4aa7c3.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://funny-toffee-4aa7c3.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://funny-toffee-4aa7c3.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="11_分治" />
<meta property="og:description" content="分治算法 分治（divide and conquer），全称分而治之，是一种非常重要且常见的算法策略。分治通常基于递归实现，包括“分”和“治”两个步骤" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://funny-toffee-4aa7c3.netlify.app/posts/%E7%AE%97%E6%B3%95/11_%E5%88%86%E6%B2%BB/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2024-06-05T11:42:32+00:00" />
<meta property="article:modified_time" content="2024-06-05T11:42:32+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="11_分治"/>
<meta name="twitter:description" content="分治算法 分治（divide and conquer），全称分而治之，是一种非常重要且常见的算法策略。分治通常基于递归实现，包括“分”和“治”两个步骤"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://funny-toffee-4aa7c3.netlify.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "11_分治",
      "item": "https://funny-toffee-4aa7c3.netlify.app/posts/%E7%AE%97%E6%B3%95/11_%E5%88%86%E6%B2%BB/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "11_分治",
  "name": "11_分治",
  "description": "分治算法 分治（divide and conquer），全称分而治之，是一种非常重要且常见的算法策略。分治通常基于递归实现，包括“分”和“治”两个步骤",
  "keywords": [
    "算法"
  ],
  "articleBody": "分治算法 分治（divide and conquer），全称分而治之，是一种非常重要且常见的算法策略。分治通常基于递归实现，包括“分”和“治”两个步骤。\n分（划分阶段）：递归地将原问题分解为两个或多个子问题，直至到达最小子问题时终止。 治（合并阶段）：从已知解的最小子问题开始，从底至顶地将子问题的解进行合并，从而构建出原问题的解。 如图 12-1 所示，“归并排序”是分治策略的典型应用之一。\n分：递归地将原数组（原问题）划分为两个子数组（子问题），直到子数组只剩一个元素（最小子问题）。 治：从底至顶地将有序的子数组（子问题的解）进行合并，从而得到有序的原数组（原问题的解）。 如何判断分治问题 一个问题是否适合使用分治解决，通常可以参考以下几个判断依据。\n问题可以分解：原问题可以分解成规模更小、类似的子问题，以及能够以相同方式递归地进行划分。 子问题是独立的：子问题之间没有重叠，互不依赖，可以独立解决。 子问题的解可以合并：原问题的解通过合并子问题的解得来。 显然，归并排序满足以上三个判断依据。\n问题可以分解：递归地将数组（原问题）划分为两个子数组（子问题）。 子问题是独立的：每个子数组都可以独立地进行排序（子问题可以独立进行求解）。 子问题的解可以合并：两个有序子数组（子问题的解）可以合并为一个有序数组（原问题的解）。 通过分治提升效率 分治不仅可以有效地解决算法问题，往往还可以提升算法效率。在排序算法中，快速排序、归并排序、堆排序相较于选择、冒泡、插入排序更快，就是因为它们应用了分治策略。\n那么，我们不禁发问：为什么分治可以提升算法效率，其底层逻辑是什么？换句话说，将大问题分解为多个子问题、解决子问题、将子问题的解合并为原问题的解，这几步的效率为什么比直接解决原问题的效率更高？这个问题可以从操作数量和并行计算两方面来讨论。\n操作数量优化 以“冒泡排序”为例，其处理一个长度为 𝑛 的数组需要 $𝑂(𝑛^2)$ 时间。假设我们按照图 12-2 所示的方式，将数组从中点处分为两个子数组，则划分需要 𝑂(𝑛) 时间，排序每个子数组需要 $𝑂((𝑛/2)^2)$ 时间，合并两个子数组需要 𝑂(𝑛) 时间，总体时间复杂度为： $$ O(n + (\\frac{n}{2})^2 \\times 2 + n) = O(\\frac{n^2}{2} + 2n) $$ 接下来，我们计算以下不等式，其左边和右边分别为划分前和划分后的操作总数：\n$$ \\begin{aligned} n^2 \u0026 \u003e \\frac{n^2}{2} + 2n \\newline n^2 - \\frac{n^2}{2} - 2n \u0026 \u003e 0 \\newline n(n - 4) \u0026 \u003e 0 \\end{aligned} $$\n这意味着当 $n \u003e 4$ 时，划分后的操作数量更少，排序效率应该更高。请注意，划分后的时间复杂度仍然是平方阶 $O(n^2)$ ，只是复杂度中的常数项变小了。\n进一步想，如果我们把子数组不断地再从中点处划分为两个子数组，直至子数组只剩一个元素时停止划分呢？这种思路实际上就是“归并排序”，时间复杂度为 $O(n \\log n)$ 。\n再思考，如果我们多设置几个划分点，将原数组平均划分为 $k$ 个子数组呢？这种情况与“桶排序”非常类似，它非常适合排序海量数据，理论上时间复杂度可以达到 $O(n + k)$ 。\n并行计算优化 我们知道，分治生成的子问题是相互独立的，因此通常可以并行解决。也就是说，分治不仅可以降低算法的时间复杂度，还有利于操作系统的并行优化。\n并行优化在多核或多处理器的环境中尤其有效，因为系统可以同时处理多个子问题，更加充分地利用计算资源，从而显著减少总体的运行时间。\n比如在图 12-3 所示的“桶排序”中，我们将海量的数据平均分配到各个桶中，则可将所有桶的排序任务分散到各个计算单元，完成后再合并结果。\n分治常见应用 一方面，分治可以用来解决许多经典算法问题。\n寻找最近点对：该算法首先将点集分成两部分，然后分别找出两部分中的最近点对，最后找出跨越两部分的最近点对。 大整数乘法：例如 Karatsuba 算法，它将大整数乘法分解为几个较小的整数的乘法和加法。 矩阵乘法：例如 Strassen 算法，它将大矩阵乘法分解为多个小矩阵的乘法和加法。 汉诺塔问题：汉诺塔问题可以通过递归解决，这是典型的分治策略应用。 求解逆序对：在一个序列中，如果前面的数字大于后面的数字，那么这两个数字构成一个逆序对。求解逆序对问题可以利用分治的思想，借助归并排序进行求解。 另一方面，分治在算法和数据结构的设计中应用得非常广泛。\n二分查找：二分查找是将有序数组从中点索引处分为两部分，然后根据目标值与中间元素值比较结果，决定排除哪一半区间，并在剩余区间执行相同的二分操作。 归并排序：本节开头已介绍，不再赘述。 快速排序：快速排序是选取一个基准值，然后把数组分为两个子数组，一个子数组的元素比基准值小，另一子数组的元素比基准值大，再对这两部分进行相同的划分操作，直至子数组只剩下一个元素。 桶排序：桶排序的基本思想是将数据分散到多个桶，然后对每个桶内的元素进行排序，最后将各个桶的元素依次取出，从而得到一个有序数组。 树：例如二叉搜索树、AVL 树、红黑树、B 树、B+ 树等，它们的查找、插入和删除等操作都可以视为分治策略的应用。 堆：堆是一种特殊的完全二叉树，其各种操作，如插入、删除和堆化，实际上都隐含了分治的思想。 哈希表：虽然哈希表并不直接应用分治，但某些哈希冲突解决方案间接应用了分治策略，例如，链式地址中的长链表会被转化为红黑树，以提升查询效率。 可以看出，分治是一种“润物细无声”的算法思想，隐含在各种算法与数据结构之中。\n分治搜索策略 我们已经学过，搜索算法分为两大类。\n暴力搜索：它通过遍历数据结构实现，时间复杂度为 $O(n)$ 。 自适应搜索：它利用特有的数据组织形式或先验信息，时间复杂度可达到 $O(\\log n)$ 甚至 $O(1)$ 。 实际上，时间复杂度为 $O(\\log n)$ 的搜索算法通常是基于分治策略实现的，例如二分查找和树。\n二分查找的每一步都将问题（在数组中搜索目标元素）分解为一个小问题（在数组的一半中搜索目标元素），这个过程一直持续到数组为空或找到目标元素为止。 树是分治思想的代表，在二叉搜索树、AVL 树、堆等数据结构中，各种操作的时间复杂度皆为 $O(\\log n)$ 。 二分查找的分治策略如下所示。\n问题可以分解：二分查找递归地将原问题（在数组中进行查找）分解为子问题（在数组的一半中进行查找），这是通过比较中间元素和目标元素来实现的。 子问题是独立的：在二分查找中，每轮只处理一个子问题，它不受其他子问题的影响。 子问题的解无须合并：二分查找旨在查找一个特定元素，因此不需要将子问题的解进行合并。当子问题得到解决时，原问题也会同时得到解决。 分治能够提升搜索效率，本质上是因为暴力搜索每轮只能排除一个选项，而分治搜索每轮可以排除一半选项。\n基于分治实现二分查找¶ 在之前的章节中，二分查找是基于递推（迭代）实现的。现在我们基于分治（递归）来实现它。\n问题：给定一个长度为 $n$ 的有序数组 nums ，其中所有元素都是唯一的，请查找元素 target 。\n从分治角度，我们将搜索区间 $[i, j]$ 对应的子问题记为 $f(i, j)$ 。\n以原问题 $f(0, n-1)$ 为起始点，通过以下步骤进行二分查找。\n计算搜索区间 $[i, j]$ 的中点 $m$ ，根据它排除一半搜索区间。 递归求解规模减小一半的子问题，可能为 $f(i, m-1)$ 或 $f(m+1, j)$ 。 循环第 1. 步和第 2. 步，直至找到 target 或区间为空时返回。 图 12-4 展示了在数组中二分查找元素 $6$ 的分治过程。\n在实现代码中，我们声明一个递归函数 dfs() 来求解问题 $f(i, j)$ ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 /* 二分查找：问题 f(i, j) */ int dfs(int[] nums, int target, int i, int j) { // 若区间为空，代表无目标元素，则返回 -1 if (i \u003e j) { return -1; } // 计算中点索引 m int m = (i + j) / 2; if (nums[m] \u003c target) { // 递归子问题 f(m+1, j) return dfs(nums, target, m + 1, j); } else if (nums[m] \u003e target) { // 递归子问题 f(i, m-1) return dfs(nums, target, i, m - 1); } else { // 找到目标元素，返回其索引 return m; } } /* 二分查找 */ int binarySearch(int[] nums, int target) { int n = nums.length; // 求解问题 f(0, n-1) return dfs(nums, target, 0, n - 1); } 构建二叉树问题 问题：给定一棵二叉树的前序遍历 preorder 和中序遍历 inorder ，请从中构建二叉树，返回二叉树的根节点。假设二叉树中没有值重复的节点（如图 12-5 所示）。\n判断是否为分治问题¶ 原问题定义为从 preorder 和 inorder 构建二叉树，是一个典型的分治问题。\n问题可以分解：从分治的角度切入，我们可以将原问题划分为两个子问题：构建左子树、构建右子树，加上一步操作：初始化根节点。而对于每棵子树（子问题），我们仍然可以复用以上划分方法，将其划分为更小的子树（子问题），直至达到最小子问题（空子树）时终止。 子问题是独立的：左子树和右子树是相互独立的，它们之间没有交集。在构建左子树时，我们只需关注中序遍历和前序遍历中与左子树对应的部分。右子树同理。 子问题的解可以合并：一旦得到了左子树和右子树（子问题的解），我们就可以将它们链接到根节点上，得到原问题的解。 如何划分子树¶ 根据以上分析，这道题可以使用分治来求解，但如何通过前序遍历 preorder 和中序遍历 inorder 来划分左子树和右子树呢？\n根据定义，preorder 和 inorder 都可以划分为三个部分。\n前序遍历：[ 根节点 | 左子树 | 右子树 ] ，例如图 12-5 的树对应 [ 3 | 9 | 2 1 7 ] 。 中序遍历：[ 左子树 | 根节点 ｜ 右子树 ] ，例如图 12-5 的树对应 [ 9 | 3 | 1 2 7 ] 。 以上图数据为例，我们可以通过图 12-6 所示的步骤得到划分结果。\n前序遍历的首元素 3 是根节点的值。 查找根节点 3 在 inorder 中的索引，利用该索引可将 inorder 划分为 [ 9 | 3 ｜ 1 2 7 ] 。 根据 inorder 的划分结果，易得左子树和右子树的节点数量分别为 1 和 3 ，从而可将 preorder 划分为 [ 3 | 9 | 2 1 7 ] 。 基于变量描述子树区间¶ 根据以上划分方法，我们已经得到根节点、左子树、右子树在 preorder 和 inorder 中的索引区间。而为了描述这些索引区间，我们需要借助几个指针变量。\n将当前树的根节点在 preorder 中的索引记为 $i$ 。 将当前树的根节点在 inorder 中的索引记为 $m$ 。 将当前树在 inorder 中的索引区间记为 $[l, r]$ 。 如表 12-1 所示，通过以上变量即可表示根节点在 preorder 中的索引，以及子树在 inorder 中的索引区间。\n表 12-1 根节点和子树在前序遍历和中序遍历中的索引\n根节点在 preorder 中的索引 子树在 inorder 中的索引区间 当前树 $i$ $[l, r]$ 左子树 $i + 1$ $[l, m-1]$ 右子树 $i + 1 + (m - l)$ $[m+1, r]$ 请注意，右子树根节点索引中的 $(m-l)$ 的含义是“左子树的节点数量”，建议结合图 12-7 理解。\n代码实现¶ 为了提升查询 $m$ 的效率，我们借助一个哈希表 hmap 来存储数组 inorder 中元素到索引的映射：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 /* 构建二叉树：分治 */ TreeNode dfs(int[] preorder, Map inorderMap, int i, int l, int r) { // 子树区间为空时终止 if (r - l \u003c 0) return null; // 初始化根节点 TreeNode root = new TreeNode(preorder[i]); // 查询 m ，从而划分左右子树 int m = inorderMap.get(preorder[i]); // 子问题：构建左子树 root.left = dfs(preorder, inorderMap, i + 1, l, m - 1); // 子问题：构建右子树 root.right = dfs(preorder, inorderMap, i + 1 + m - l, m + 1, r); // 返回根节点 return root; } /* 构建二叉树 */ TreeNode buildTree(int[] preorder, int[] inorder) { // 初始化哈希表，存储 inorder 元素到索引的映射 Map inorderMap = new HashMap\u003c\u003e(); for (int i = 0; i \u003c inorder.length; i++) { inorderMap.put(inorder[i], i); } TreeNode root = dfs(preorder, inorderMap, 0, 0, inorder.length - 1); return root; } 图 12-8 展示了构建二叉树的递归过程，各个节点是在向下“递”的过程中建立的，而各条边（引用）是在向上“归”的过程中建立的。\n每个递归函数内的前序遍历 preorder 和中序遍历 inorder 的划分结果如图 12-9 所示。\n设树的节点数量为 𝑛 ，初始化每一个节点（执行一个递归函数 dfs() ）使用 𝑂(1) 时间。因此总体时间复杂度为 𝑂(𝑛) 。\n哈希表存储 inorder 元素到索引的映射，空间复杂度为 𝑂(𝑛) 。在最差情况下，即二叉树退化为链表时，递归深度达到 𝑛 ，使用 𝑂(𝑛) 的栈帧空间。因此总体空间复杂度为 𝑂(𝑛) 。\n汉诺塔问题 在归并排序和构建二叉树中，我们都是将原问题分解为两个规模为原问题一半的子问题。然而对于汉诺塔问题，我们采用不同的分解策略。\n问题：\n给定三根柱子，记为 A、B 和 C 。起始状态下，柱子 A 上套着 𝑛 个圆盘，它们从上到下按照从小到大的顺序排列。我们的任务是要把这 𝑛 个圆盘移到柱子 C 上，并保持它们的原有顺序不变（如图 12-10 所示）。在移动圆盘的过程中，需要遵守以下规则。\n圆盘只能从一根柱子顶部拿出，从另一根柱子顶部放入。 每次只能移动一个圆盘。 小圆盘必须时刻位于大圆盘之上。 我们将规模为 𝑖 的汉诺塔问题记作 𝑓(𝑖) 。例如 𝑓(3) 代表将 3 个圆盘从 A 移动至 C 的汉诺塔问题。\n考虑基本情况 如图 12-11 所示，对于问题 𝑓(1) ，即当只有一个圆盘时，我们将它直接从 A 移动至 C 即可。\n如图 12-12 所示，对于问题 𝑓(2) ，即当有两个圆盘时，由于要时刻满足小圆盘在大圆盘之上，因此需要借助 B 来完成移动。\n先将上面的小圆盘从 A 移至 B 。 再将大圆盘从 A 移至 C 。 最后将小圆盘从 B 移至 C 。 解决问题 𝑓(2) 的过程可总结为：将两个圆盘借助 B 从 A 移至 C 。其中，C 称为目标柱、B 称为缓冲柱。\n子问题分解 对于问题 𝑓(3) ，即当有三个圆盘时，情况变得稍微复杂了一些。\n因为已知 𝑓(1) 和 𝑓(2) 的解，所以我们可从分治角度思考，将 A 顶部的两个圆盘看作一个整体，执行图 12-13 所示的步骤。这样三个圆盘就被顺利地从 A 移至 C 了。\n令 B 为目标柱、C 为缓冲柱，将两个圆盘从 A 移至 B 。 将 A 中剩余的一个圆盘从 A 直接移动至 C 。 令 C 为目标柱、A 为缓冲柱，将两个圆盘从 B 移至 C 。 从本质上看，我们将问题 𝑓(3) 划分为两个子问题 𝑓(2) 和一个子问题 𝑓(1) 。按顺序解决这三个子问题之后，原问题随之得到解决。这说明子问题是独立的，而且解可以合并。\n至此，我们可总结出图 12-14 所示的解决汉诺塔问题的分治策略：将原问题 𝑓(𝑛) 划分为两个子问题 𝑓(𝑛−1) 和一个子问题 𝑓(1) ，并按照以下顺序解决这三个子问题。\n将 𝑛−1 个圆盘借助 C 从 A 移至 B 。 将剩余 1 个圆盘从 A 直接移至 C 。 将 𝑛−1 个圆盘借助 A 从 B 移至 C 。 对于这两个子问题 𝑓(𝑛−1) ，可以通过相同的方式进行递归划分，直至达到最小子问题 𝑓(1) 。而 𝑓(1) 的解是已知的，只需一次移动操作即可。\n代码实现 在代码中，我们声明一个递归函数 dfs(i, src, buf, tar) ，它的作用是将柱 src 顶部的 𝑖 个圆盘借助缓冲柱 buf 移动至目标柱 tar ：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /* 移动一个圆盘 */ void move(List src, List tar) { // 从 src 顶部拿出一个圆盘 Integer pan = src.remove(src.size() - 1); // 将圆盘放入 tar 顶部 tar.add(pan); } /* 求解汉诺塔问题 f(i) */ void dfs(int i, List src, List buf, List tar) { // 若 src 只剩下一个圆盘，则直接将其移到 tar if (i == 1) { move(src, tar); return; } // 子问题 f(i-1) ：将 src 顶部 i-1 个圆盘借助 tar 移到 buf dfs(i - 1, src, tar, buf); // 子问题 f(1) ：将 src 剩余一个圆盘移到 tar move(src, tar); // 子问题 f(i-1) ：将 buf 顶部 i-1 个圆盘借助 src 移到 tar dfs(i - 1, buf, src, tar); } /* 求解汉诺塔问题 */ void solveHanota(List A, List B, List C) { int n = A.size(); // 将 A 顶部 n 个圆盘借助 B 移到 C dfs(n, A, B, C); } 如图 12-15 所示，汉诺塔问题形成一棵高度为 𝑛 的递归树，每个节点代表一个子问题，对应一个开启的 dfs() 函数，因此时间复杂度为 $𝑂(2^𝑛)$ ，空间复杂度为 𝑂(𝑛) 。\n汉诺塔问题源自一个古老的传说。在古印度的一个寺庙里，僧侣们有三根高大的钻石柱子，以及 64 个大小不一的金圆盘。僧侣们不断地移动圆盘，他们相信在最后一个圆盘被正确放置的那一刻，这个世界就会结束。\n然而，即使僧侣们每秒钟移动一次，总共需要大约 $2^{64}≈1.84×10^{19}$ 秒，合约 5850 亿年，远远超过了现在对宇宙年龄的估计。所以，倘若这个传说是真的，我们应该不需要担心世界末日的到来。\n小结 分治是一种常见的算法设计策略，包括分（划分）和治（合并）两个阶段，通常基于递归实现。 判断是否是分治算法问题的依据包括：问题能否分解、子问题是否独立、子问题能否合并。 归并排序是分治策略的典型应用，其递归地将数组划分为等长的两个子数组，直到只剩一个元素时开始逐层合并，从而完成排序。 引入分治策略往往可以提升算法效率。一方面，分治策略减少了操作数量；另一方面，分治后有利于系统的并行优化。 分治既可以解决许多算法问题，也广泛应用于数据结构与算法设计中，处处可见其身影。 相较于暴力搜索，自适应搜索效率更高。时间复杂度为 𝑂(log⁡𝑛) 的搜索算法通常是基于分治策略实现的。 二分查找是分治策略的另一个典型应用，它不包含将子问题的解进行合并的步骤。我们可以通过递归分治实现二分查找。 在构建二叉树的问题中，构建树（原问题）可以划分为构建左子树和右子树（子问题），这可以通过划分前序遍历和中序遍历的索引区间来实现。 在汉诺塔问题中，一个规模为 𝑛 的问题可以划分为两个规模为 𝑛−1 的子问题和一个规模为 1 的子问题。按顺序解决这三个子问题后，原问题随之得到解决。 ",
  "wordCount" : "6315",
  "inLanguage": "en",
  "datePublished": "2024-06-05T11:42:32Z",
  "dateModified": "2024-06-05T11:42:32Z",
  "author":{
    "@type": "Person",
    "name": "Wjy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://funny-toffee-4aa7c3.netlify.app/posts/%E7%AE%97%E6%B3%95/11_%E5%88%86%E6%B2%BB/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Wjy's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://funny-toffee-4aa7c3.netlify.app/favicon.ico"
    }
  }
}
</script>

  <script id="MathJax-script" async src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-chtml.min.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath:  [['\\(', '\\)'], ['$', '$']],  
    }
  };
</script>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://funny-toffee-4aa7c3.netlify.app/" accesskey="h" title="Wjy&#39;s Blog (Alt + H)">Wjy&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://funny-toffee-4aa7c3.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://funny-toffee-4aa7c3.netlify.app/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      11_分治
    </h1>
    <div class="post-meta"><span title='2024-06-05 11:42:32 +0000 UTC'>2024-06-05</span>&nbsp;·&nbsp;Wjy

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e5%88%86%e6%b2%bb%e7%ae%97%e6%b3%95" aria-label="分治算法">分治算法</a><ul>
                        
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e5%88%86%e6%b2%bb%e9%97%ae%e9%a2%98" aria-label="如何判断分治问题">如何判断分治问题</a></li>
                <li>
                    <a href="#%e9%80%9a%e8%bf%87%e5%88%86%e6%b2%bb%e6%8f%90%e5%8d%87%e6%95%88%e7%8e%87" aria-label="通过分治提升效率">通过分治提升效率</a><ul>
                        
                <li>
                    <a href="#%e6%93%8d%e4%bd%9c%e6%95%b0%e9%87%8f%e4%bc%98%e5%8c%96" aria-label="操作数量优化">操作数量优化</a></li>
                <li>
                    <a href="#%e5%b9%b6%e8%a1%8c%e8%ae%a1%e7%ae%97%e4%bc%98%e5%8c%96" aria-label="并行计算优化">并行计算优化</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%86%e6%b2%bb%e5%b8%b8%e8%a7%81%e5%ba%94%e7%94%a8" aria-label="分治常见应用">分治常见应用</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%86%e6%b2%bb%e6%90%9c%e7%b4%a2%e7%ad%96%e7%95%a5" aria-label="分治搜索策略">分治搜索策略</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8e%e5%88%86%e6%b2%bb%e5%ae%9e%e7%8e%b0%e4%ba%8c%e5%88%86%e6%9f%a5%e6%89%behttpswwwhello-algocomchapter_divide_and_conquerbinary_search_recur1" aria-label="基于分治实现二分查找¶">基于分治实现二分查找¶</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#%e6%9e%84%e5%bb%ba%e4%ba%8c%e5%8f%89%e6%a0%91%e9%97%ae%e9%a2%98" aria-label="构建二叉树问题">构建二叉树问题</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e5%88%a4%e6%96%ad%e6%98%af%e5%90%a6%e4%b8%ba%e5%88%86%e6%b2%bb%e9%97%ae%e9%a2%98httpswwwhello-algocomchapter_divide_and_conquerbuild_binary_tree_problem1" aria-label="判断是否为分治问题¶">判断是否为分治问题¶</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%88%92%e5%88%86%e5%ad%90%e6%a0%91httpswwwhello-algocomchapter_divide_and_conquerbuild_binary_tree_problem2" aria-label="如何划分子树¶">如何划分子树¶</a></li>
                <li>
                    <a href="#%e5%9f%ba%e4%ba%8e%e5%8f%98%e9%87%8f%e6%8f%8f%e8%bf%b0%e5%ad%90%e6%a0%91%e5%8c%ba%e9%97%b4httpswwwhello-algocomchapter_divide_and_conquerbuild_binary_tree_problem3" aria-label="基于变量描述子树区间¶">基于变量描述子树区间¶</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0httpswwwhello-algocomchapter_divide_and_conquerbuild_binary_tree_problem4" aria-label="代码实现¶">代码实现¶</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#%e6%b1%89%e8%af%ba%e5%a1%94%e9%97%ae%e9%a2%98" aria-label="汉诺塔问题">汉诺塔问题</a><ul>
                        <ul>
                        
                <li>
                    <a href="#%e8%80%83%e8%99%91%e5%9f%ba%e6%9c%ac%e6%83%85%e5%86%b5" aria-label="考虑基本情况">考虑基本情况</a></li>
                <li>
                    <a href="#%e5%ad%90%e9%97%ae%e9%a2%98%e5%88%86%e8%a7%a3" aria-label="子问题分解">子问题分解</a></li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e5%ae%9e%e7%8e%b0" aria-label="代码实现">代码实现</a></li></ul>
                    </ul>
                </li>
                <li>
                    <a href="#%e5%b0%8f%e7%bb%93" aria-label="小结">小结</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="分治算法">分治算法<a hidden class="anchor" aria-hidden="true" href="#分治算法">#</a></h1>
<p>分治（divide and conquer），全称分而治之，是一种非常重要且常见的算法策略。分治通常基于递归实现，包括“分”和“治”两个步骤。</p>
<ol>
<li><strong>分（划分阶段）</strong>：递归地将原问题分解为两个或多个子问题，直至到达最小子问题时终止。</li>
<li><strong>治（合并阶段）</strong>：从已知解的最小子问题开始，从底至顶地将子问题的解进行合并，从而构建出原问题的解。</li>
</ol>
<p>如图 12-1 所示，“归并排序”是分治策略的典型应用之一。</p>
<ol>
<li><strong>分</strong>：递归地将原数组（原问题）划分为两个子数组（子问题），直到子数组只剩一个元素（最小子问题）。</li>
<li><strong>治</strong>：从底至顶地将有序的子数组（子问题的解）进行合并，从而得到有序的原数组（原问题的解）。</li>
</ol>
<p><img loading="lazy" src="divide_and_conquer_merge_sort.png" alt=""  />
</p>
<h2 id="如何判断分治问题">如何判断分治问题<a hidden class="anchor" aria-hidden="true" href="#如何判断分治问题">#</a></h2>
<p>一个问题是否适合使用分治解决，通常可以参考以下几个判断依据。</p>
<ol>
<li><strong>问题可以分解</strong>：原问题可以分解成规模更小、类似的子问题，以及能够以相同方式递归地进行划分。</li>
<li><strong>子问题是独立的</strong>：子问题之间没有重叠，互不依赖，可以独立解决。</li>
<li><strong>子问题的解可以合并</strong>：原问题的解通过合并子问题的解得来。</li>
</ol>
<p>显然，归并排序满足以上三个判断依据。</p>
<ol>
<li><strong>问题可以分解</strong>：递归地将数组（原问题）划分为两个子数组（子问题）。</li>
<li><strong>子问题是独立的</strong>：每个子数组都可以独立地进行排序（子问题可以独立进行求解）。</li>
<li><strong>子问题的解可以合并</strong>：两个有序子数组（子问题的解）可以合并为一个有序数组（原问题的解）。</li>
</ol>
<h2 id="通过分治提升效率">通过分治提升效率<a hidden class="anchor" aria-hidden="true" href="#通过分治提升效率">#</a></h2>
<p><strong>分治不仅可以有效地解决算法问题，往往还可以提升算法效率</strong>。在排序算法中，快速排序、归并排序、堆排序相较于选择、冒泡、插入排序更快，就是因为它们应用了分治策略。</p>
<p>那么，我们不禁发问：<strong>为什么分治可以提升算法效率，其底层逻辑是什么</strong>？换句话说，将大问题分解为多个子问题、解决子问题、将子问题的解合并为原问题的解，这几步的效率为什么比直接解决原问题的效率更高？这个问题可以从操作数量和并行计算两方面来讨论。</p>
<h3 id="操作数量优化">操作数量优化<a hidden class="anchor" aria-hidden="true" href="#操作数量优化">#</a></h3>
<p>以“冒泡排序”为例，其处理一个长度为 𝑛 的数组需要 $𝑂(𝑛^2)$ 时间。假设我们按照图 12-2 所示的方式，将数组从中点处分为两个子数组，则划分需要 𝑂(𝑛) 时间，排序每个子数组需要 $𝑂((𝑛/2)^2)$ 时间，合并两个子数组需要 𝑂(𝑛) 时间，总体时间复杂度为：
$$
O(n + (\frac{n}{2})^2 \times 2 + n) = O(\frac{n^2}{2} + 2n)
$$
<img loading="lazy" src="divide_and_conquer_bubble_sort.png" alt=""  />
</p>
<p>接下来，我们计算以下不等式，其左边和右边分别为划分前和划分后的操作总数：</p>
<p>$$ \begin{aligned} n^2 &amp; &gt; \frac{n^2}{2} + 2n \newline n^2 - \frac{n^2}{2} - 2n &amp; &gt; 0 \newline n(n - 4) &amp; &gt; 0 \end{aligned} $$</p>
<p><strong>这意味着当 $n &gt; 4$ 时，划分后的操作数量更少，排序效率应该更高</strong>。请注意，划分后的时间复杂度仍然是平方阶 $O(n^2)$ ，只是复杂度中的常数项变小了。</p>
<p>进一步想，<strong>如果我们把子数组不断地再从中点处划分为两个子数组</strong>，直至子数组只剩一个元素时停止划分呢？这种思路实际上就是“归并排序”，时间复杂度为 $O(n \log n)$ 。</p>
<p>再思考，<strong>如果我们多设置几个划分点</strong>，将原数组平均划分为 $k$ 个子数组呢？这种情况与“桶排序”非常类似，它非常适合排序海量数据，理论上时间复杂度可以达到 $O(n + k)$ 。</p>
<h3 id="并行计算优化">并行计算优化<a hidden class="anchor" aria-hidden="true" href="#并行计算优化">#</a></h3>
<p>我们知道，分治生成的子问题是相互独立的，<strong>因此通常可以并行解决</strong>。也就是说，分治不仅可以降低算法的时间复杂度，<strong>还有利于操作系统的并行优化</strong>。</p>
<p>并行优化在多核或多处理器的环境中尤其有效，因为系统可以同时处理多个子问题，更加充分地利用计算资源，从而显著减少总体的运行时间。</p>
<p>比如在图 12-3 所示的“桶排序”中，我们将海量的数据平均分配到各个桶中，则可将所有桶的排序任务分散到各个计算单元，完成后再合并结果。</p>
<p><img loading="lazy" src="divide_and_conquer_parallel_computing.png" alt=""  />
</p>
<h2 id="分治常见应用">分治常见应用<a hidden class="anchor" aria-hidden="true" href="#分治常见应用">#</a></h2>
<p>一方面，分治可以用来解决许多经典算法问题。</p>
<ul>
<li><strong>寻找最近点对</strong>：该算法首先将点集分成两部分，然后分别找出两部分中的最近点对，最后找出跨越两部分的最近点对。</li>
<li><strong>大整数乘法</strong>：例如 Karatsuba 算法，它将大整数乘法分解为几个较小的整数的乘法和加法。</li>
<li><strong>矩阵乘法</strong>：例如 Strassen 算法，它将大矩阵乘法分解为多个小矩阵的乘法和加法。</li>
<li><strong>汉诺塔问题</strong>：汉诺塔问题可以通过递归解决，这是典型的分治策略应用。</li>
<li><strong>求解逆序对</strong>：在一个序列中，如果前面的数字大于后面的数字，那么这两个数字构成一个逆序对。求解逆序对问题可以利用分治的思想，借助归并排序进行求解。</li>
</ul>
<p>另一方面，分治在算法和数据结构的设计中应用得非常广泛。</p>
<ul>
<li><strong>二分查找</strong>：二分查找是将有序数组从中点索引处分为两部分，然后根据目标值与中间元素值比较结果，决定排除哪一半区间，并在剩余区间执行相同的二分操作。</li>
<li><strong>归并排序</strong>：本节开头已介绍，不再赘述。</li>
<li><strong>快速排序</strong>：快速排序是选取一个基准值，然后把数组分为两个子数组，一个子数组的元素比基准值小，另一子数组的元素比基准值大，再对这两部分进行相同的划分操作，直至子数组只剩下一个元素。</li>
<li><strong>桶排序</strong>：桶排序的基本思想是将数据分散到多个桶，然后对每个桶内的元素进行排序，最后将各个桶的元素依次取出，从而得到一个有序数组。</li>
<li><strong>树</strong>：例如二叉搜索树、AVL 树、红黑树、B 树、B+ 树等，它们的查找、插入和删除等操作都可以视为分治策略的应用。</li>
<li><strong>堆</strong>：堆是一种特殊的完全二叉树，其各种操作，如插入、删除和堆化，实际上都隐含了分治的思想。</li>
<li><strong>哈希表</strong>：虽然哈希表并不直接应用分治，但某些哈希冲突解决方案间接应用了分治策略，例如，链式地址中的长链表会被转化为红黑树，以提升查询效率。</li>
</ul>
<p>可以看出，<strong>分治是一种“润物细无声”的算法思想</strong>，隐含在各种算法与数据结构之中。</p>
<h1 id="分治搜索策略">分治搜索策略<a hidden class="anchor" aria-hidden="true" href="#分治搜索策略">#</a></h1>
<p>我们已经学过，搜索算法分为两大类。</p>
<ul>
<li><strong>暴力搜索</strong>：它通过遍历数据结构实现，时间复杂度为 $O(n)$ 。</li>
<li><strong>自适应搜索</strong>：它利用特有的数据组织形式或先验信息，时间复杂度可达到 $O(\log n)$ 甚至 $O(1)$ 。</li>
</ul>
<p>实际上，<strong>时间复杂度为 $O(\log n)$ 的搜索算法通常是基于分治策略实现的</strong>，例如二分查找和树。</p>
<ul>
<li>二分查找的每一步都将问题（在数组中搜索目标元素）分解为一个小问题（在数组的一半中搜索目标元素），这个过程一直持续到数组为空或找到目标元素为止。</li>
<li>树是分治思想的代表，在二叉搜索树、AVL 树、堆等数据结构中，各种操作的时间复杂度皆为 $O(\log n)$ 。</li>
</ul>
<p>二分查找的分治策略如下所示。</p>
<ul>
<li><strong>问题可以分解</strong>：二分查找递归地将原问题（在数组中进行查找）分解为子问题（在数组的一半中进行查找），这是通过比较中间元素和目标元素来实现的。</li>
<li><strong>子问题是独立的</strong>：在二分查找中，每轮只处理一个子问题，它不受其他子问题的影响。</li>
<li><strong>子问题的解无须合并</strong>：二分查找旨在查找一个特定元素，因此不需要将子问题的解进行合并。当子问题得到解决时，原问题也会同时得到解决。</li>
</ul>
<p>分治能够提升搜索效率，本质上是因为暴力搜索每轮只能排除一个选项，<strong>而分治搜索每轮可以排除一半选项</strong>。</p>
<h3 id="基于分治实现二分查找httpswwwhello-algocomchapter_divide_and_conquerbinary_search_recur1">基于分治实现二分查找<a href="https://www.hello-algo.com/chapter_divide_and_conquer/binary_search_recur/#1">¶</a><a hidden class="anchor" aria-hidden="true" href="#基于分治实现二分查找httpswwwhello-algocomchapter_divide_and_conquerbinary_search_recur1">#</a></h3>
<p>在之前的章节中，二分查找是基于递推（迭代）实现的。现在我们基于分治（递归）来实现它。</p>
<blockquote>
<p>问题：给定一个长度为 $n$ 的有序数组 <code>nums</code> ，其中所有元素都是唯一的，请查找元素 <code>target</code> 。</p>
</blockquote>
<p>从分治角度，我们将搜索区间 $[i, j]$ 对应的子问题记为 $f(i, j)$ 。</p>
<p>以原问题 $f(0, n-1)$ 为起始点，通过以下步骤进行二分查找。</p>
<ol>
<li>计算搜索区间 $[i, j]$ 的中点 $m$ ，根据它排除一半搜索区间。</li>
<li>递归求解规模减小一半的子问题，可能为 $f(i, m-1)$ 或 $f(m+1, j)$ 。</li>
<li>循环第 <code>1.</code> 步和第 <code>2.</code> 步，直至找到 <code>target</code> 或区间为空时返回。</li>
</ol>
<p>图 12-4 展示了在数组中二分查找元素 $6$ 的分治过程。</p>
<p><img loading="lazy" src="binary_search_recur.png" alt=""  />
</p>
<p>在实现代码中，我们声明一个递归函数 <code>dfs()</code> 来求解问题 $f(i, j)$ ：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 二分查找：问题 f(i, j) */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> dfs(<span style="color:#fff;font-weight:bold">int</span>[] nums, <span style="color:#fff;font-weight:bold">int</span> target, <span style="color:#fff;font-weight:bold">int</span> i, <span style="color:#fff;font-weight:bold">int</span> j) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 若区间为空，代表无目标元素，则返回 -1
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (i &gt; j) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> -<span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 计算中点索引 m
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> m = (i + j) / <span style="color:#ff0;font-weight:bold">2</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (nums[m] &lt; target) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 递归子问题 f(m+1, j)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">return</span> dfs(nums, target, m + <span style="color:#ff0;font-weight:bold">1</span>, j);
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">else</span> <span style="color:#fff;font-weight:bold">if</span> (nums[m] &gt; target) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 递归子问题 f(i, m-1)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">return</span> dfs(nums, target, i, m - <span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 找到目标元素，返回其索引
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">return</span> m;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* 二分查找 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> binarySearch(<span style="color:#fff;font-weight:bold">int</span>[] nums, <span style="color:#fff;font-weight:bold">int</span> target) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> n = nums.<span style="color:#007f7f">length</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 求解问题 f(0, n-1)
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> dfs(nums, target, <span style="color:#ff0;font-weight:bold">0</span>, n - <span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="构建二叉树问题">构建二叉树问题<a hidden class="anchor" aria-hidden="true" href="#构建二叉树问题">#</a></h1>
<blockquote>
<p>问题：给定一棵二叉树的前序遍历 <code>preorder</code> 和中序遍历 <code>inorder</code> ，请从中构建二叉树，返回二叉树的根节点。假设二叉树中没有值重复的节点（如图 12-5 所示）。</p>
</blockquote>
<p><img loading="lazy" src="build_tree_example.png" alt=""  />
</p>
<h3 id="判断是否为分治问题httpswwwhello-algocomchapter_divide_and_conquerbuild_binary_tree_problem1">判断是否为分治问题<a href="https://www.hello-algo.com/chapter_divide_and_conquer/build_binary_tree_problem/#1">¶</a><a hidden class="anchor" aria-hidden="true" href="#判断是否为分治问题httpswwwhello-algocomchapter_divide_and_conquerbuild_binary_tree_problem1">#</a></h3>
<p>原问题定义为从 <code>preorder</code> 和 <code>inorder</code> 构建二叉树，是一个典型的分治问题。</p>
<ul>
<li><strong>问题可以分解</strong>：从分治的角度切入，我们可以将原问题划分为两个子问题：构建左子树、构建右子树，加上一步操作：初始化根节点。而对于每棵子树（子问题），我们仍然可以复用以上划分方法，将其划分为更小的子树（子问题），直至达到最小子问题（空子树）时终止。</li>
<li><strong>子问题是独立的</strong>：左子树和右子树是相互独立的，它们之间没有交集。在构建左子树时，我们只需关注中序遍历和前序遍历中与左子树对应的部分。右子树同理。</li>
<li><strong>子问题的解可以合并</strong>：一旦得到了左子树和右子树（子问题的解），我们就可以将它们链接到根节点上，得到原问题的解。</li>
</ul>
<h3 id="如何划分子树httpswwwhello-algocomchapter_divide_and_conquerbuild_binary_tree_problem2">如何划分子树<a href="https://www.hello-algo.com/chapter_divide_and_conquer/build_binary_tree_problem/#2">¶</a><a hidden class="anchor" aria-hidden="true" href="#如何划分子树httpswwwhello-algocomchapter_divide_and_conquerbuild_binary_tree_problem2">#</a></h3>
<p>根据以上分析，这道题可以使用分治来求解，<strong>但如何通过前序遍历 <code>preorder</code> 和中序遍历 <code>inorder</code> 来划分左子树和右子树呢</strong>？</p>
<p>根据定义，<code>preorder</code> 和 <code>inorder</code> 都可以划分为三个部分。</p>
<ul>
<li>前序遍历：<code>[ 根节点 | 左子树 | 右子树 ]</code> ，例如图 12-5 的树对应 <code>[ 3 | 9 | 2 1 7 ]</code> 。</li>
<li>中序遍历：<code>[ 左子树 | 根节点 ｜ 右子树 ]</code> ，例如图 12-5 的树对应 <code>[ 9 | 3 | 1 2 7 ]</code> 。</li>
</ul>
<p>以上图数据为例，我们可以通过图 12-6 所示的步骤得到划分结果。</p>
<ol>
<li>前序遍历的首元素 3 是根节点的值。</li>
<li>查找根节点 3 在 <code>inorder</code> 中的索引，利用该索引可将 <code>inorder</code> 划分为 <code>[ 9 | 3 ｜ 1 2 7 ]</code> 。</li>
<li>根据 <code>inorder</code> 的划分结果，易得左子树和右子树的节点数量分别为 1 和 3 ，从而可将 <code>preorder</code> 划分为 <code>[ 3 | 9 | 2 1 7 ]</code> 。</li>
</ol>
<p><img loading="lazy" src="build_tree_preorder_inorder_division.png" alt=""  />
</p>
<h3 id="基于变量描述子树区间httpswwwhello-algocomchapter_divide_and_conquerbuild_binary_tree_problem3">基于变量描述子树区间<a href="https://www.hello-algo.com/chapter_divide_and_conquer/build_binary_tree_problem/#3">¶</a><a hidden class="anchor" aria-hidden="true" href="#基于变量描述子树区间httpswwwhello-algocomchapter_divide_and_conquerbuild_binary_tree_problem3">#</a></h3>
<p>根据以上划分方法，<strong>我们已经得到根节点、左子树、右子树在 <code>preorder</code> 和 <code>inorder</code> 中的索引区间</strong>。而为了描述这些索引区间，我们需要借助几个指针变量。</p>
<ul>
<li>将当前树的根节点在 <code>preorder</code> 中的索引记为 $i$ 。</li>
<li>将当前树的根节点在 <code>inorder</code> 中的索引记为 $m$ 。</li>
<li>将当前树在 <code>inorder</code> 中的索引区间记为 $[l, r]$ 。</li>
</ul>
<p>如表 12-1 所示，通过以上变量即可表示根节点在 <code>preorder</code> 中的索引，以及子树在 <code>inorder</code> 中的索引区间。</p>
<p>表 12-1  根节点和子树在前序遍历和中序遍历中的索引</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">根节点在 <code>preorder</code> 中的索引</th>
<th style="text-align:left">子树在 <code>inorder</code> 中的索引区间</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">当前树</td>
<td style="text-align:left">$i$</td>
<td style="text-align:left">$[l, r]$</td>
</tr>
<tr>
<td style="text-align:left">左子树</td>
<td style="text-align:left">$i + 1$</td>
<td style="text-align:left">$[l, m-1]$</td>
</tr>
<tr>
<td style="text-align:left">右子树</td>
<td style="text-align:left">$i + 1 + (m - l)$</td>
<td style="text-align:left">$[m+1, r]$</td>
</tr>
</tbody>
</table>
<p>请注意，右子树根节点索引中的 $(m-l)$ 的含义是“左子树的节点数量”，建议结合图 12-7 理解。</p>
<p><img loading="lazy" src="build_tree_division_pointers.png" alt=""  />
</p>
<h3 id="代码实现httpswwwhello-algocomchapter_divide_and_conquerbuild_binary_tree_problem4">代码实现<a href="https://www.hello-algo.com/chapter_divide_and_conquer/build_binary_tree_problem/#4">¶</a><a hidden class="anchor" aria-hidden="true" href="#代码实现httpswwwhello-algocomchapter_divide_and_conquerbuild_binary_tree_problem4">#</a></h3>
<p>为了提升查询 $m$ 的效率，我们借助一个哈希表 <code>hmap</code> 来存储数组 <code>inorder</code> 中元素到索引的映射：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 构建二叉树：分治 */</span>
</span></span><span style="display:flex;"><span>TreeNode dfs(<span style="color:#fff;font-weight:bold">int</span>[] preorder, Map&lt;Integer, Integer&gt; inorderMap, <span style="color:#fff;font-weight:bold">int</span> i, <span style="color:#fff;font-weight:bold">int</span> l, <span style="color:#fff;font-weight:bold">int</span> r) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 子树区间为空时终止
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (r - l &lt; <span style="color:#ff0;font-weight:bold">0</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 初始化根节点
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    TreeNode root = <span style="color:#fff;font-weight:bold">new</span> TreeNode(preorder[i]);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 查询 m ，从而划分左右子树
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">int</span> m = inorderMap.<span style="color:#007f7f">get</span>(preorder[i]);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 子问题：构建左子树
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    root.<span style="color:#007f7f">left</span> = dfs(preorder, inorderMap, i + <span style="color:#ff0;font-weight:bold">1</span>, l, m - <span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 子问题：构建右子树
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    root.<span style="color:#007f7f">right</span> = dfs(preorder, inorderMap, i + <span style="color:#ff0;font-weight:bold">1</span> + m - l, m + <span style="color:#ff0;font-weight:bold">1</span>, r);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 返回根节点
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* 构建二叉树 */</span>
</span></span><span style="display:flex;"><span>TreeNode buildTree(<span style="color:#fff;font-weight:bold">int</span>[] preorder, <span style="color:#fff;font-weight:bold">int</span>[] inorder) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 初始化哈希表，存储 inorder 元素到索引的映射
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    Map&lt;Integer, Integer&gt; inorderMap = <span style="color:#fff;font-weight:bold">new</span> HashMap&lt;&gt;();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = <span style="color:#ff0;font-weight:bold">0</span>; i &lt; inorder.<span style="color:#007f7f">length</span>; i++) {
</span></span><span style="display:flex;"><span>        inorderMap.<span style="color:#007f7f">put</span>(inorder[i], i);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    TreeNode root = dfs(preorder, inorderMap, <span style="color:#ff0;font-weight:bold">0</span>, <span style="color:#ff0;font-weight:bold">0</span>, inorder.<span style="color:#007f7f">length</span> - <span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> root;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>图 12-8 展示了构建二叉树的递归过程，各个节点是在向下“递”的过程中建立的，而各条边（引用）是在向上“归”的过程中建立的。</p>
<p><img loading="lazy" src="built_tree_step1.png" alt=""  />

<img loading="lazy" src="built_tree_step2.png" alt=""  />

<img loading="lazy" src="built_tree_step3.png" alt=""  />

<img loading="lazy" src="built_tree_step4.png" alt=""  />

<img loading="lazy" src="built_tree_step5.png" alt=""  />

<img loading="lazy" src="built_tree_step6.png" alt=""  />

<img loading="lazy" src="built_tree_step7.png" alt=""  />

<img loading="lazy" src="built_tree_step8.png" alt=""  />

<img loading="lazy" src="built_tree_step9.png" alt=""  />
</p>
<p>每个递归函数内的前序遍历 preorder 和中序遍历 inorder 的划分结果如图 12-9 所示。</p>
<p><img loading="lazy" src="built_tree_overall.png" alt=""  />
</p>
<p>设树的节点数量为 𝑛 ，初始化每一个节点（执行一个递归函数 <code>dfs()</code> ）使用 𝑂(1) 时间。<strong>因此总体时间复杂度为 𝑂(𝑛)</strong> 。</p>
<p>哈希表存储 <code>inorder</code> 元素到索引的映射，空间复杂度为 𝑂(𝑛) 。在最差情况下，即二叉树退化为链表时，递归深度达到 𝑛 ，使用 𝑂(𝑛) 的栈帧空间。<strong>因此总体空间复杂度为 𝑂(𝑛)</strong> 。</p>
<h1 id="汉诺塔问题">汉诺塔问题<a hidden class="anchor" aria-hidden="true" href="#汉诺塔问题">#</a></h1>
<p>在归并排序和构建二叉树中，我们都是将原问题分解为两个规模为原问题一半的子问题。然而对于汉诺塔问题，我们采用不同的分解策略。</p>
<blockquote>
<p>问题：</p>
<p>给定三根柱子，记为 <code>A</code>、<code>B</code> 和 <code>C</code> 。起始状态下，柱子 <code>A</code> 上套着 𝑛 个圆盘，它们从上到下按照从小到大的顺序排列。我们的任务是要把这 𝑛 个圆盘移到柱子 <code>C</code> 上，并保持它们的原有顺序不变（如图 12-10 所示）。在移动圆盘的过程中，需要遵守以下规则。</p>
<ol>
<li>圆盘只能从一根柱子顶部拿出，从另一根柱子顶部放入。</li>
<li>每次只能移动一个圆盘。</li>
<li>小圆盘必须时刻位于大圆盘之上。</li>
</ol>
</blockquote>
<p><img loading="lazy" src="hanota_example.png" alt=""  />
</p>
<p><strong>我们将规模为 𝑖 的汉诺塔问题记作 𝑓(𝑖)</strong> 。例如 𝑓(3) 代表将 3 个圆盘从 <code>A</code> 移动至 <code>C</code> 的汉诺塔问题。</p>
<h3 id="考虑基本情况">考虑基本情况<a hidden class="anchor" aria-hidden="true" href="#考虑基本情况">#</a></h3>
<p>如图 12-11 所示，对于问题 𝑓(1) ，即当只有一个圆盘时，我们将它直接从 <code>A</code> 移动至 <code>C</code> 即可。</p>
<p><img loading="lazy" src="hanota_f1_step1.png" alt=""  />
</p>
<p><img loading="lazy" src="hanota_f1_step2.png" alt=""  />
</p>
<p>如图 12-12 所示，对于问题 𝑓(2) ，即当有两个圆盘时，<strong>由于要时刻满足小圆盘在大圆盘之上，因此需要借助 <code>B</code> 来完成移动</strong>。</p>
<ol>
<li>先将上面的小圆盘从 <code>A</code> 移至 <code>B</code> 。</li>
<li>再将大圆盘从 <code>A</code> 移至 <code>C</code> 。</li>
<li>最后将小圆盘从 <code>B</code> 移至 <code>C</code> 。</li>
</ol>
<p><img loading="lazy" src="hanota_f2_step1.png" alt=""  />

<img loading="lazy" src="hanota_f2_step2.png" alt=""  />

<img loading="lazy" src="hanota_f2_step3.png" alt=""  />

<img loading="lazy" src="hanota_f2_step4.png" alt=""  />
</p>
<p>解决问题 𝑓(2) 的过程可总结为：<strong>将两个圆盘借助 <code>B</code> 从 <code>A</code> 移至 <code>C</code></strong> 。其中，<code>C</code> 称为目标柱、<code>B</code> 称为缓冲柱。</p>
<h3 id="子问题分解">子问题分解<a hidden class="anchor" aria-hidden="true" href="#子问题分解">#</a></h3>
<p>对于问题 𝑓(3) ，即当有三个圆盘时，情况变得稍微复杂了一些。</p>
<p>因为已知 𝑓(1) 和 𝑓(2) 的解，所以我们可从分治角度思考，<strong>将 <code>A</code> 顶部的两个圆盘看作一个整体</strong>，执行图 12-13 所示的步骤。这样三个圆盘就被顺利地从 <code>A</code> 移至 <code>C</code> 了。</p>
<ol>
<li>令 <code>B</code> 为目标柱、<code>C</code> 为缓冲柱，将两个圆盘从 <code>A</code> 移至 <code>B</code> 。</li>
<li>将 <code>A</code> 中剩余的一个圆盘从 <code>A</code> 直接移动至 <code>C</code> 。</li>
<li>令 <code>C</code> 为目标柱、<code>A</code> 为缓冲柱，将两个圆盘从 <code>B</code> 移至 <code>C</code> 。</li>
</ol>
<p><img loading="lazy" src="hanota_f3_step1.png" alt=""  />

<img loading="lazy" src="hanota_f3_step2.png" alt=""  />

<img loading="lazy" src="hanota_f3_step3.png" alt=""  />

<img loading="lazy" src="hanota_f3_step4.png" alt=""  />
</p>
<p>从本质上看，<strong>我们将问题 𝑓(3) 划分为两个子问题 𝑓(2) 和一个子问题 𝑓(1)</strong> 。按顺序解决这三个子问题之后，原问题随之得到解决。这说明子问题是独立的，而且解可以合并。</p>
<p>至此，我们可总结出图 12-14 所示的解决汉诺塔问题的分治策略：将原问题 𝑓(𝑛) 划分为两个子问题 𝑓(𝑛−1) 和一个子问题 𝑓(1) ，并按照以下顺序解决这三个子问题。</p>
<ol>
<li>将 𝑛−1 个圆盘借助 <code>C</code> 从 <code>A</code> 移至 <code>B</code> 。</li>
<li>将剩余 1 个圆盘从 <code>A</code> 直接移至 <code>C</code> 。</li>
<li>将 𝑛−1 个圆盘借助 <code>A</code> 从 <code>B</code> 移至 <code>C</code> 。</li>
</ol>
<p>对于这两个子问题 𝑓(𝑛−1) ，<strong>可以通过相同的方式进行递归划分</strong>，直至达到最小子问题 𝑓(1) 。而 𝑓(1) 的解是已知的，只需一次移动操作即可。</p>
<p><img loading="lazy" src="hanota_divide_and_conquer.png" alt=""  />
</p>
<h3 id="代码实现">代码实现<a hidden class="anchor" aria-hidden="true" href="#代码实现">#</a></h3>
<p>在代码中，我们声明一个递归函数 <code>dfs(i, src, buf, tar)</code> ，它的作用是将柱 <code>src</code> 顶部的 𝑖 个圆盘借助缓冲柱 <code>buf</code> 移动至目标柱 <code>tar</code> ：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/* 移动一个圆盘 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> move(List&lt;Integer&gt; src, List&lt;Integer&gt; tar) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 从 src 顶部拿出一个圆盘
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    Integer pan = src.<span style="color:#007f7f">remove</span>(src.<span style="color:#007f7f">size</span>() - <span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 将圆盘放入 tar 顶部
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    tar.<span style="color:#007f7f">add</span>(pan);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* 求解汉诺塔问题 f(i) */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> dfs(<span style="color:#fff;font-weight:bold">int</span> i, List&lt;Integer&gt; src, List&lt;Integer&gt; buf, List&lt;Integer&gt; tar) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 若 src 只剩下一个圆盘，则直接将其移到 tar
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    <span style="color:#fff;font-weight:bold">if</span> (i == <span style="color:#ff0;font-weight:bold">1</span>) {
</span></span><span style="display:flex;"><span>        move(src, tar);
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 子问题 f(i-1) ：将 src 顶部 i-1 个圆盘借助 tar 移到 buf
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    dfs(i - <span style="color:#ff0;font-weight:bold">1</span>, src, tar, buf);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 子问题 f(1) ：将 src 剩余一个圆盘移到 tar
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    move(src, tar);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 子问题 f(i-1) ：将 buf 顶部 i-1 个圆盘借助 src 移到 tar
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    dfs(i - <span style="color:#ff0;font-weight:bold">1</span>, buf, src, tar);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* 求解汉诺塔问题 */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> solveHanota(List&lt;Integer&gt; A, List&lt;Integer&gt; B, List&lt;Integer&gt; C) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> n = A.<span style="color:#007f7f">size</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 将 A 顶部 n 个圆盘借助 B 移到 C
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    dfs(n, A, B, C);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如图 12-15 所示，汉诺塔问题形成一棵高度为 𝑛 的递归树，每个节点代表一个子问题，对应一个开启的 <code>dfs()</code> 函数，<strong>因此时间复杂度为 $𝑂(2^𝑛)$ ，空间复杂度为 𝑂(𝑛)</strong> 。</p>
<p><img loading="lazy" src="hanota_recursive_tree.png" alt="图 12-15  汉诺塔问题的递归树"  />
</p>
<blockquote>
<p>汉诺塔问题源自一个古老的传说。在古印度的一个寺庙里，僧侣们有三根高大的钻石柱子，以及 64 个大小不一的金圆盘。僧侣们不断地移动圆盘，他们相信在最后一个圆盘被正确放置的那一刻，这个世界就会结束。</p>
<p>然而，即使僧侣们每秒钟移动一次，总共需要大约 $2^{64}≈1.84×10^{19}$ 秒，合约 5850 亿年，远远超过了现在对宇宙年龄的估计。所以，倘若这个传说是真的，我们应该不需要担心世界末日的到来。</p>
</blockquote>
<h1 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h1>
<ul>
<li>分治是一种常见的算法设计策略，包括分（划分）和治（合并）两个阶段，通常基于递归实现。</li>
<li>判断是否是分治算法问题的依据包括：问题能否分解、子问题是否独立、子问题能否合并。</li>
<li>归并排序是分治策略的典型应用，其递归地将数组划分为等长的两个子数组，直到只剩一个元素时开始逐层合并，从而完成排序。</li>
<li>引入分治策略往往可以提升算法效率。一方面，分治策略减少了操作数量；另一方面，分治后有利于系统的并行优化。</li>
<li>分治既可以解决许多算法问题，也广泛应用于数据结构与算法设计中，处处可见其身影。</li>
<li>相较于暴力搜索，自适应搜索效率更高。时间复杂度为 𝑂(log⁡𝑛) 的搜索算法通常是基于分治策略实现的。</li>
<li>二分查找是分治策略的另一个典型应用，它不包含将子问题的解进行合并的步骤。我们可以通过递归分治实现二分查找。</li>
<li>在构建二叉树的问题中，构建树（原问题）可以划分为构建左子树和右子树（子问题），这可以通过划分前序遍历和中序遍历的索引区间来实现。</li>
<li>在汉诺塔问题中，一个规模为 𝑛 的问题可以划分为两个规模为 𝑛−1 的子问题和一个规模为 1 的子问题。按顺序解决这三个子问题后，原问题随之得到解决。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://funny-toffee-4aa7c3.netlify.app/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://funny-toffee-4aa7c3.netlify.app/">Wjy&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>