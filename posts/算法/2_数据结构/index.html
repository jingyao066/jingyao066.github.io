<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>2_数据结构 | Wjy&#39;s Blog</title>
<meta name="keywords" content="算法">
<meta name="description" content="常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类。 数据结构分类 逻辑结构：线性">
<meta name="author" content="Wjy">
<link rel="canonical" href="https://009965.xyz/posts/%E7%AE%97%E6%B3%95/2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://009965.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://009965.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://009965.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://009965.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://009965.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://009965.xyz/posts/%E7%AE%97%E6%B3%95/2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="https://009965.xyz/posts/%E7%AE%97%E6%B3%95/2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
  <meta property="og:site_name" content="Wjy&#39;s Blog">
  <meta property="og:title" content="2_数据结构">
  <meta property="og:description" content="常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类。 数据结构分类 逻辑结构：线性">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-05-31T08:27:12+00:00">
    <meta property="article:modified_time" content="2024-05-31T08:27:12+00:00">
    <meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2_数据结构">
<meta name="twitter:description" content="常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类。 数据结构分类 逻辑结构：线性">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://009965.xyz/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "2_数据结构",
      "item": "https://009965.xyz/posts/%E7%AE%97%E6%B3%95/2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "2_数据结构",
  "name": "2_数据结构",
  "description": "常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类。 数据结构分类 逻辑结构：线性",
  "keywords": [
    "算法"
  ],
  "articleBody": "常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类。\n数据结构分类 逻辑结构：线性与非线性 逻辑结构揭示了数据元素之间的逻辑关系。在数组和链表中，数据按照一定顺序排列，体现了数据之间的线性关系；而在树中，数据从顶部向下按层次排列，表现出“祖先”与“后代”之间的派生关系；图则由节点和边构成，反映了复杂的网络关系。\n如图 3-1 所示，逻辑结构可分为“线性”和“非线性”两大类。线性结构比较直观，指数据在逻辑关系上呈线性排列；非线性结构则相反，呈非线性排列。\n线性数据结构：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系。 非线性数据结构：树、堆、图、哈希表。 非线性数据结构可以进一步划分为树形结构和网状结构。\n树形结构：树、堆、哈希表，元素之间是一对多的关系。 网状结构：图，元素之间是多对多的关系。 物理结构：连续与分散 当算法程序运行时，正在处理的数据主要存储在内存中。图 3-2 展示了一个计算机内存条，其中每个黑色方块都包含一块内存空间。我们可以将内存想象成一个巨大的 Excel 表格，其中每个单元格都可以存储一定大小的数据。\n系统通过内存地址来访问目标位置的数据。如图 3-2 所示，计算机根据特定规则为表格中的每个单元格分配编号，确保每个内存空间都有唯一的内存地址。有了这些地址，程序便可以访问内存中的数据。\n值得说明的是，将内存比作 Excel 表格是一个简化的类比，实际内存的工作机制比较复杂，涉及地址空间、内存管理、缓存机制、虚拟内存和物理内存等概念。\n内存是所有程序的共享资源，当某块内存被某个程序占用时，则无法被其他程序同时使用了。因此在数据结构与算法的设计中，内存资源是一个重要的考虑因素。比如，算法所占用的内存峰值不应超过系统剩余空闲内存；如果缺少连续大块的内存空间，那么所选用的数据结构必须能够存储在分散的内存空间内。\n如图 3-3 所示，物理结构反映了数据在计算机内存中的存储方式，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。\n值得说明的是，所有数据结构都是基于数组、链表或二者的组合实现的。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。\n基于数组可实现：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 ≥3 的数组）等。 基于链表可实现：栈、队列、哈希表、树、堆、图等。 链表在初始化后，仍可以在程序运行过程中对其长度进行调整，因此也称“动态数据结构”。数组在初始化后长度不可变，因此也称“静态数据结构”。值得注意的是，数组可通过重新分配内存实现长度变化，从而具备一定的“动态性”。\n基本数据类型 当谈及计算机中的数据时，我们会想到文本、图片、视频、语音、3D 模型等各种形式。尽管这些数据的组织形式各异，但它们都由各种基本数据类型构成。\n基本数据类型是 CPU 可以直接进行运算的类型，在算法中直接被使用，主要包括以下几种。\n整数类型 byte、short、int、long 。 浮点数类型 float、double ，用于表示小数。 字符类型 char ，用于表示各种语言的字母、标点符号甚至表情符号等。 布尔类型 bool ，用于表示“是”与“否”判断。 基本数据类型以二进制的形式存储在计算机中。一个二进制位即为 1 比特。在绝大多数现代操作系统中，1 字节（byte）由 8 比特（bit）组成。\n基本数据类型的取值范围取决于其占用的空间大小。下面以 Java 为例。\n整数类型 byte 占用 1 字节 = 8 比特 ，可以表示 28 个数字。 整数类型 int 占用 4 字节 = 32 比特 ，可以表示 232 个数字。 表 3-1 列举了 Java 中各种基本数据类型的占用空间、取值范围和默认值。此表格无须死记硬背，大致理解即可，需要时可以通过查表来回忆。\n表 3-1 基本数据类型的占用空间和取值范围\n类型 符号 占用空间 最小值 最大值 默认值 整数 byte 1 字节 $−2^7$ (−128) $2^7$−1 (127) 0 short 2 字节 $−2^{15}$ $2^{15}$−1 0 int 4 字节 $−2^{31}$ $2^{31}$−1 0 long 8 字节 $−2^{63}$ $−2^{63}$−1 0 浮点数 float 4 字节 $1.175×10^{−38}$ $3.403×10^{38}$ 0.0f double 8 字节 $2.225×10^{−308}$ $1.798×10^{308}$ 0.0 字符 char 2 字节 0 $2^{16}−1$ 0 布尔 bool 1 字节 false true false 请注意，表 3-1 针对的是 Java 的基本数据类型的情况。每种编程语言都有各自的数据类型定义，它们的占用空间、取值范围和默认值可能会有所不同。\n在 Python 中，整数类型 int 可以是任意大小，只受限于可用内存；浮点数 float 是双精度 64 位；没有 char 类型，单个字符实际上是长度为 1 的字符串 str 。 C 和 C++ 未明确规定基本数据类型的大小，而因实现和平台各异。表 3-1 遵循 LP64 数据模型，其用于包括 Linux 和 macOS 在内的 Unix 64 位操作系统。 字符 char 的大小在 C 和 C++ 中为 1 字节，在大多数编程语言中取决于特定的字符编码方法，详见“字符编码”章节。 即使表示布尔量仅需 1 位（0 或 1），它在内存中通常也存储为 1 字节。这是因为现代计算机 CPU 通常将 1 字节作为最小寻址内存单元。 那么，基本数据类型与数据结构之间有什么联系呢？我们知道，数据结构是在计算机中组织与存储数据的方式。这句话的主语是“结构”而非“数据”。\n如果想表示“一排数字”，我们自然会想到使用数组。这是因为数组的线性结构可以表示数字的相邻关系和顺序关系，但至于存储的内容是整数 int、小数 float 还是字符 char ，则与“数据结构”无关。\n换句话说，基本数据类型提供了数据的“内容类型”，而数据结构提供了数据的“组织方式”。例如以下代码，我们用相同的数据结构（数组）来存储与表示不同的基本数据类型，包括 int、float、char、bool 等。\n1 2 3 4 5 // 使用多种基本数据类型来初始化数组 int[] numbers = new int[5]; float[] decimals = new float[5]; char[] characters = new char[5]; boolean[] bools = new boolean[5]; 数字编码 原码、反码和补码 在上一节的表格中我们发现，所有整数类型能够表示的负数都比正数多一个，例如 byte 的取值范围是 [−128,127] 。这个现象比较反直觉，它的内在原因涉及原码、反码、补码的相关知识。\n首先需要指出，数字是以“补码”的形式存储在计算机中的。在分析这样做的原因之前，首先给出三者的定义。\n原码：我们将数字的二进制表示的最高位视为符号位，其中 0 表示正数，1 表示负数，其余位表示数字的值。 反码：正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反。 补码：正数的补码与其原码相同，负数的补码是在其反码的基础上加 1 。 图 3-4 展示了原码、反码和补码之间的转换方法。\n原码（sign‑magnitude）虽然最直观，但存在一些局限性。一方面，负数的原码不能直接用于运算。例如在原 码下计算1+(−2)，得到的结果是−3，这显然是不对的。\n1 2 3 4 1 +(−2) →0000 0001+1000 0010 =1000 0011 →−3 为了解决此问题，计算机引入了反码（1’scomplement）。如果我们先将原码转换为反码，并在反码下计算 1 +(−2)，最后将结果从反码转换回原码，则可得到正确结果−1。\n1 2 3 4 5 6 1 +(−2) →0000 0001 (原码)+1000 0010 (原码) =0000 0001 (反码)+1111 1101 (反码) =1111 1110 (反码) =1000 0001 (原码) →−1 另一方面，数字零的原码有+0和−0两种表示方式。这意味着数字零对应两个不同的二进制编码，这可能 会带来歧义。比如在条件判断中，如果没有区分正零和负零，则可能会导致判断结果出错。而如果我们想处 理正零和负零歧义，则需要引入额外的判断操作，这可能会降低计算机的运算效率。\n1 2 +0 →0000 0000 −0 →1000 0000 与原码一样，反码也存在正负零歧义问题，因此计算机进一步引入了补码（2’scomplement）。我们先来观 察一下负零的原码、反码、补码的转换过程：\n1 2 3 −0 →1000 0000 (原码) =1111 1111 (反码) =10000 0000 (补码) 在负零的反码基础上加1会产生进位，但 byte 类型的长度只有8位，因此溢出到第9位的1会被舍弃。也 就是说，负零的补码为00000000，与正零的补码相同。这意味着在补码表示中只存在一个零，正负零歧义 从而得到解决。\n还剩最后一个疑惑： byte 类型的取值范围是[−128,127]，多出来的一个负数−128是如何得到的呢？我 们注意到，区间[−127,+127]内的所有整数都有对应的原码、反码和补码，并且原码和补码之间可以互相 转换。\n然而，补码1000 0000是一个例外，它并没有对应的原码。根据转换方法，我们得到该补码的原码为 0000 0000。这显然是矛盾的，因为该原码表示数字0，它的补码应该是自身。计算机规定这个特殊的补码 1000 0000 代表−128。实际上，(−1)+(−127)在补码下的计算结果就是−128。\n1 2 3 4 5 6 (−127) +(−1) →1111 1111 (原码)+1000 0001 (原码) =1000 0000 (反码)+1111 1110 (反码) =1000 0001 (补码)+1111 1111 (补码) =1000 0000 (补码) →−128 你可能已经发现了，上述所有计算都是加法运算。这暗示着一个重要事实：计算机内部的硬件电路主要是基 于加法运算设计的。这是因为加法运算相对于其他运算（比如乘法、除法和减法）来说，硬件实现起来更简单，更容易进行并行化处理，运算速度更快。\n请注意，这并不意味着计算机只能做加法。通过将加法与一些基本逻辑运算结合，计算机能够实现各种其他 的数学运算。例如，计算减法𝑎−𝑏可以转换为计算加法𝑎+(−𝑏)；计算乘法和除法可以转换为计算多次 加法或减法。 现在我们可以总结出计算机使用补码的原因：基于补码表示，计算机可以用同样的电路和操作来处理正数和 负数的加法，不需要设计特殊的硬件电路来处理减法，并且无须特别处理正负零的歧义问题。这大大简化了 硬件设计，提高了运算效率。\n补码的设计非常精妙，因篇幅关系我们就先介绍到这里，建议有兴趣的读者进一步深入了解。\n浮点数编码 细心的你可能会发现： int 和 常反直觉，因为按理说 float 长度相同，都是4字节，但为什么 float 的取值范围远大于 float 需要表示小数，取值范围应该变小才对。\n实际上，这是因为浮点数 float 采用了不同的表示方式。记一个32比特长度的二进制数为： $$ 𝑏_{31}𝑏_{30}𝑏_{29} …𝑏_2𝑏_1𝑏_0 $$ 根据 IEEE 754 标准，32-bit 长度的 float 由以下三个部分构成。\n符号位 S ：占 1 位 ，对应 $𝑏_{31} $。 指数位 E ：占 8 位 ，对应 $𝑏_{30}𝑏_{29}…𝑏_{23} $。 分数位 N ：占 23 位 ，对应 $𝑏_{22}𝑏_{21}…𝑏_0$ 。 观察图 3-5 ，给定一个示例数据 S=0 ， E=124 ，N=2−2+2−3=0.375 ，则有： $$ val = (−1)^0 ×2^{124−127} ×(1+0.375) = 0.171875 $$ 现在我们可以回答最初的问题：float 的表示方式包含指数位，导致其取值范围远大于 int 。根据以上计算，float 可表示的最大正数为 $2^{254−127}×(2−2^{−23})≈3.4×10^{38}$ ，切换符号位便可得到最小负数。\n尽管浮点数 float 扩展了取值范围，但其副作用是牺牲了精度。整数类型 int 将全部 32 比特用于表示数字，数字是均匀分布的；而由于指数位的存在，浮点数 float 的数值越大，相邻两个数字之间的差值就会趋向越大。\n如表 3-2 所示，指数位 E=0 和 E=255 具有特殊含义，用于表示零、无穷大、NaN 等。\n表 3-2 指数位含义\n指数位 E 分数位 N=0 分数位 N≠0 计算公式 0 ±0 次正规数 $(−1)^S×2^{−126}×(0.N)$ 1,2,…,254 正规数 正规数 $(−1)^S×2^{(E−127)}×(1.N)$ 255 ±∞ NaN 值得说明的是，次正规数显著提升了浮点数的精度。最小正正规数为 $2^{−126}$ ，最小正次正规数为 $2^{−126}×2^{−23}$。\n双精度 double 也采用类似于 float 的表示方法，在此不做赘述。\n字符编码 在计算机中，所有数据都是以二进制数的形式存储的，字符 char 也不例外。为了表示字符，我们需要建立一套“字符集”，规定每个字符和二进制数之间的一一对应关系。有了字符集之后，计算机就可以通过查表完成二进制数到字符的转换。\nASCII 字符集 ASCII 码是最早出现的字符集，其全称为 American Standard Code for Information Interchange（美国标准信息交换代码）。它使用 7 位二进制数（一个字节的低 7 位）表示一个字符，最多能够表示 128 个不同的字符。如图 3-6 所示，ASCII 码包括英文字母的大小写、数字 0 ~ 9、一些标点符号，以及一些控制字符（如换行符和制表符）。\n然而，ASCII 码仅能够表示英文。随着计算机的全球化，诞生了一种能够表示更多语言的 EASCII 字符集。它在 ASCII 的 7 位基础上扩展到 8 位，能够表示 256 个不同的字符。\n在世界范围内，陆续出现了一批适用于不同地区的 EASCII 字符集。这些字符集的前 128 个字符统一为 ASCII 码，后 128 个字符定义不同，以适应不同语言的需求。\nGBK 字符集 后来人们发现，EASCII 码仍然无法满足许多语言的字符数量要求。比如汉字有近十万个，光日常使用的就有几千个。中国国家标准总局于 1980 年发布了 GB2312 字符集，其收录了 6763 个汉字，基本满足了汉字的计算机处理需要。\n然而，GB2312 无法处理部分罕见字和繁体字。GBK 字符集是在 GB2312 的基础上扩展得到的，它共收录了 21886 个汉字。在 GBK 的编码方案中，ASCII 字符使用一个字节表示，汉字使用两个字节表示。\nUnicode 字符集 随着计算机技术的蓬勃发展，字符集与编码标准百花齐放，而这带来了许多问题。一方面，这些字符集一般只定义了特定语言的字符，无法在多语言环境下正常工作。另一方面，同一种语言存在多种字符集标准，如果两台计算机使用的是不同的编码标准，则在信息传递时就会出现乱码。\n那个时代的研究人员就在想：如果推出一个足够完整的字符集，将世界范围内的所有语言和符号都收录其中，不就可以解决跨语言环境和乱码问题了吗？在这种想法的驱动下，一个大而全的字符集 Unicode 应运而生。\nUnicode 的中文名称为“统一码”，理论上能容纳 100 多万个字符。它致力于将全球范围内的字符纳入统一的字符集之中，提供一种通用的字符集来处理和显示各种语言文字，减少因为编码标准不同而产生的乱码问题。\n自 1991 年发布以来，Unicode 不断扩充新的语言与字符。截至 2022 年 9 月，Unicode 已经包含 149186 个字符，包括各种语言的字符、符号甚至表情符号等。在庞大的 Unicode 字符集中，常用的字符占用 2 字节，有些生僻的字符占用 3 字节甚至 4 字节。\nUnicode 是一种通用字符集，本质上是给每个字符分配一个编号（称为“码点”），但它并没有规定在计算机中如何存储这些字符码点。我们不禁会问：当多种长度的 Unicode 码点同时出现在一个文本中时，系统如何解析字符？例如给定一个长度为 2 字节的编码，系统如何确认它是一个 2 字节的字符还是两个 1 字节的字符？\n对于以上问题，一种直接的解决方案是将所有字符存储为等长的编码。如图 3-7 所示，“Hello”中的每个字符占用 1 字节，“算法”中的每个字符占用 2 字节。我们可以通过高位填 0 将“Hello 算法”中的所有字符都编码为 2 字节长度。这样系统就可以每隔 2 字节解析一个字符，恢复这个短语的内容了。\n然而 ASCII 码已经向我们证明，编码英文只需 1 字节。若采用上述方案，英文文本占用空间的大小将会是 ASCII 编码下的两倍，非常浪费内存空间。因此，我们需要一种更加高效的 Unicode 编码方法。\nUTF-8 编码 目前，UTF-8 已成为国际上使用最广泛的 Unicode 编码方法。它是一种可变长度的编码，使用 1 到 4 字节来表示一个字符，根据字符的复杂性而变。ASCII 字符只需 1 字节，拉丁字母和希腊字母需要 2 字节，常用的中文字符需要 3 字节，其他的一些生僻字符需要 4 字节。\nUTF-8 的编码规则并不复杂，分为以下两种情况。\n对于长度为 1 字节的字符，将最高位设置为 0 ，其余 7 位设置为 Unicode 码点。值得注意的是，ASCII 字符在 Unicode 字符集中占据了前 128 个码点。也就是说，UTF-8 编码可以向下兼容 ASCII 码。这意味着我们可以使用 UTF-8 来解析年代久远的 ASCII 码文本。 对于长度为 𝑛 字节的字符（其中 𝑛\u003e1），将首个字节的高 𝑛 位都设置为 1 ，第 𝑛+1 位设置为 0 ；从第二个字节开始，将每个字节的高 2 位都设置为 10 ；其余所有位用于填充字符的 Unicode 码点。 图 3-8 展示了“Hello算法”对应的 UTF-8 编码。观察发现，由于最高 𝑛 位都设置为 1 ，因此系统可以通过读取最高位 1 的个数来解析出字符的长度为 𝑛 。\n但为什么要将其余所有字节的高 2 位都设置为 10 呢？实际上，这个 10 能够起到校验符的作用。假设系统从一个错误的字节开始解析文本，字节头部的 10 能够帮助系统快速判断出异常。\n之所以将 10 当作校验符，是因为在 UTF-8 编码规则下，不可能有字符的最高两位是 10 。这个结论可以用反证法来证明：假设一个字符的最高两位是 10 ，说明该字符的长度为 1 ，对应 ASCII 码。而 ASCII 码的最高位应该是 0 ，与假设矛盾。\n除了 UTF-8 之外，常见的编码方式还包括以下两种。\nUTF-16 编码：使用 2 或 4 字节来表示一个字符。所有的 ASCII 字符和常用的非英文字符，都用 2 字节表示；少数字符需要用到 4 字节表示。对于 2 字节的字符，UTF-16 编码与 Unicode 码点相等。 UTF-32 编码：每个字符都使用 4 字节。这意味着 UTF-32 比 UTF-8 和 UTF-16 更占用空间，特别是对于 ASCII 字符占比较高的文本。 从存储空间占用的角度看，使用 UTF-8 表示英文字符非常高效，因为它仅需 1 字节；使用 UTF-16 编码某些非英文字符（例如中文）会更加高效，因为它仅需 2 字节，而 UTF-8 可能需要 3 字节。\n从兼容性的角度看，UTF-8 的通用性最佳，许多工具和库优先支持 UTF-8 。\n编程语言的字符编码 对于以往的大多数编程语言，程序运行中的字符串都采用 UTF-16 或 UTF-32 这类等长编码。在等长编码下，我们可以将字符串看作数组来处理，这种做法具有以下优点。\n随机访问：UTF-16 编码的字符串可以很容易地进行随机访问。UTF-8 是一种变长编码，要想找到第 𝑖 个字符，我们需要从字符串的开始处遍历到第 𝑖 个字符，这需要 𝑂(𝑛) 的时间。 字符计数：与随机访问类似，计算 UTF-16 编码的字符串的长度也是 𝑂(1) 的操作。但是，计算 UTF-8 编码的字符串的长度需要遍历整个字符串。 字符串操作：在 UTF-16 编码的字符串上，很多字符串操作（如分割、连接、插入、删除等）更容易进行。在 UTF-8 编码的字符串上，进行这些操作通常需要额外的计算，以确保不会产生无效的 UTF-8 编码。 实际上，编程语言的字符编码方案设计是一个很有趣的话题，涉及许多因素。\nJava 的 String 类型使用 UTF-16 编码，每个字符占用 2 字节。这是因为 Java 语言设计之初，人们认为 16 位足以表示所有可能的字符。然而，这是一个不正确的判断。后来 Unicode 规范扩展到了超过 16 位，所以 Java 中的字符现在可能由一对 16 位的值（称为“代理对”）表示。 JavaScript 和 TypeScript 的字符串使用 UTF-16 编码的原因与 Java 类似。当 1995 年 Netscape 公司首次推出 JavaScript 语言时，Unicode 还处于发展早期，那时候使用 16 位的编码就足以表示所有的 Unicode 字符了。 C# 使用 UTF-16 编码，主要是因为 .NET 平台是由 Microsoft 设计的，而 Microsoft 的很多技术（包括 Windows 操作系统）都广泛使用 UTF-16 编码。 由于以上编程语言对字符数量的低估，它们不得不采取“代理对”的方式来表示超过 16 位长度的 Unicode 字符。这是一个不得已为之的无奈之举。一方面，包含代理对的字符串中，一个字符可能占用 2 字节或 4 字节，从而丧失了等长编码的优势。另一方面，处理代理对需要额外增加代码，这提高了编程的复杂性和调试难度。\n出于以上原因，部分编程语言提出了一些不同的编码方案。\nPython 中的 str 使用 Unicode 编码，并采用一种灵活的字符串表示，存储的字符长度取决于字符串中最大的 Unicode 码点。若字符串中全部是 ASCII 字符，则每个字符占用 1 字节；如果有字符超出了 ASCII 范围，但全部在基本多语言平面（BMP）内，则每个字符占用 2 字节；如果有超出 BMP 的字符，则每个字符占用 4 字节。 Go 语言的 string 类型在内部使用 UTF-8 编码。Go 语言还提供了 rune 类型，它用于表示单个 Unicode 码点。 Rust 语言的 str 和 String 类型在内部使用 UTF-8 编码。Rust 也提供了 char 类型，用于表示单个 Unicode 码点。 需要注意的是，以上讨论的都是字符串在编程语言中的存储方式，这和字符串如何在文件中存储或在网络中传输是不同的问题。在文件存储或网络传输中，我们通常会将字符串编码为 UTF-8 格式，以达到最优的兼容性和空间效率。\n小结 重点回顾 数据结构可以从逻辑结构和物理结构两个角度进行分类。逻辑结构描述了数据元素之间的逻辑关系，而物理结构描述了数据在计算机内存中的存储方式。 常见的逻辑结构包括线性、树状和网状等。通常我们根据逻辑结构将数据结构分为线性（数组、链表、栈、队列）和非线性（树、图、堆）两种。哈希表的实现可能同时包含线性数据结构和非线性数据结构。 当程序运行时，数据被存储在计算机内存中。每个内存空间都拥有对应的内存地址，程序通过这些内存地址访问数据。 物理结构主要分为连续空间存储（数组）和分散空间存储（链表）。所有数据结构都是由数组、链表或两者的组合实现的。 计算机中的基本数据类型包括整数 byte、short、int、long ，浮点数 float、double ，字符 char 和布尔 bool 。它们的取值范围取决于占用空间大小和表示方式。 原码、反码和补码是在计算机中编码数字的三种方法，它们之间可以相互转换。整数的原码的最高位是符号位，其余位是数字的值。 整数在计算机中是以补码的形式存储的。在补码表示下，计算机可以对正数和负数的加法一视同仁，不需要为减法操作单独设计特殊的硬件电路，并且不存在正负零歧义的问题。 浮点数的编码由 1 位符号位、8 位指数位和 23 位分数位构成。由于存在指数位，因此浮点数的取值范围远大于整数，代价是牺牲了精度。 ASCII 码是最早出现的英文字符集，长度为 1 字节，共收录 127 个字符。GBK 字符集是常用的中文字符集，共收录两万多个汉字。Unicode 致力于提供一个完整的字符集标准，收录世界上各种语言的字符，从而解决由于字符编码方法不一致而导致的乱码问题。 UTF-8 是最受欢迎的 Unicode 编码方法，通用性非常好。它是一种变长的编码方法，具有很好的扩展性，有效提升了存储空间的使用效率。UTF-16 和 UTF-32 是等长的编码方法。在编码中文时，UTF-16 占用的空间比 UTF-8 更小。Java 和 C# 等编程语言默认使用 UTF-16 编码。 Q \u0026 A Q：为什么哈希表同时包含线性数据结构和非线性数据结构？\n哈希表底层是数组，而为了解决哈希冲突，我们可能会使用“链式地址”（后续“哈希冲突”章节会讲）：数组中每个桶指向一个链表，当链表长度超过一定阈值时，又可能被转化为树（通常为红黑树）。\n从存储的角度来看，哈希表的底层是数组，其中每一个桶槽位可能包含一个值，也可能包含一个链表或一棵树。因此，哈希表可能同时包含线性数据结构（数组、链表）和非线性数据结构（树）。\nQ：char 类型的长度是 1 字节吗？\nchar 类型的长度由编程语言采用的编码方法决定。例如，Java、JavaScript、TypeScript、C# 都采用 UTF-16 编码（保存 Unicode 码点），因此 char 类型的长度为 2 字节。\nQ：基于数组实现的数据结构也称“静态数据结构” 是否有歧义？栈也可以进行出栈和入栈等操作，这些操作都是“动态”的。\n栈确实可以实现动态的数据操作，但数据结构仍然是“静态”（长度不可变）的。尽管基于数组的数据结构可以动态地添加或删除元素，但它们的容量是固定的。如果数据量超出了预分配的大小，就需要创建一个新的更大的数组，并将旧数组的内容复制到新数组中。\nQ：在构建栈（队列）的时候，未指定它的大小，为什么它们是“静态数据结构”呢？\n在高级编程语言中，我们无须人工指定栈（队列）的初始容量，这个工作由类内部自动完成。例如，Java 的 ArrayList 的初始容量通常为 10。另外，扩容操作也是自动实现的。详见后续的“列表”章节。\nQ：原码转补码的方法是“先取反后加 1”，那么补码转原码应该是逆运算“先减 1 后取反”，而补码转原码也一样可以通过“先取反后加 1”得到，这是为什么呢？\nA：这是因为原码和补码的相互转换实际上是计算“补数”的过程。我们先给出补数的定义：假设 𝑎+𝑏=𝑐 ，那么我们称 𝑎 是 𝑏 到 𝑐 的补数，反之也称 𝑏 是 𝑎 到 𝑐 的补数。\n给定一个 𝑛=4 位长度的二进制数 0010 ，如果将这个数字看作原码（不考虑符号位），那么它的补码需通过“先取反后加 1”得到：\n1 0010 → 1101 → 1110 我们会发现，原码和补码的和是0010+1110=10000，也就是说，补码1110是原码0010到10000的 “补数”。这意味着上述“先取反后加1”实际上是计算到10000的补数的过程。\n那么，补码1110到10000的“补数”是多少呢？我们依然可以用“先取反后加1”得到它：\n1 1110 → 0001 → 0010 换句话说，原码和补码互为对方到10000的“补数”，因此“原码转补码”和“补码转原码”可以用相同的 操作（先取反后加1）实现。\n当然，我们也可以用逆运算来求补码1110的原码，即“先减1后取反”：\n1 1110 → 1101 → 0010 总结来看，“先取反后加1”和“先减1后取反”这两种运算都是在计算到10000的补数，它们是等价的。 本质上看，“取反”操作实际上是求到1111的补数（因为恒有 原码 + 反码 = 1111）；而在反码基础上再加1 得到的补码，就是到10000的补数。\n上述𝑛=4为例，其可推广至任意位数的二进制数。\n",
  "wordCount" : "9913",
  "inLanguage": "en",
  "datePublished": "2024-05-31T08:27:12Z",
  "dateModified": "2024-05-31T08:27:12Z",
  "author":{
    "@type": "Person",
    "name": "Wjy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://009965.xyz/posts/%E7%AE%97%E6%B3%95/2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Wjy's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://009965.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://009965.xyz/" accesskey="h" title="Wjy&#39;s Blog (Alt + H)">Wjy&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://009965.xyz/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://009965.xyz/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://009965.xyz/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://009965.xyz/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://009965.xyz/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://009965.xyz/">Home</a>&nbsp;»&nbsp;<a href="https://009965.xyz/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      2_数据结构
    </h1>
    <div class="post-meta"><span title='2024-05-31 08:27:12 +0000 UTC'>2024-05-31</span>&nbsp;·&nbsp;Wjy

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%88%86%e7%b1%bb" aria-label="数据结构分类">数据结构分类</a><ul>
                        
                <li>
                    <a href="#%e9%80%bb%e8%be%91%e7%bb%93%e6%9e%84%e7%ba%bf%e6%80%a7%e4%b8%8e%e9%9d%9e%e7%ba%bf%e6%80%a7" aria-label="逻辑结构：线性与非线性">逻辑结构：线性与非线性</a></li>
                <li>
                    <a href="#%e7%89%a9%e7%90%86%e7%bb%93%e6%9e%84%e8%bf%9e%e7%bb%ad%e4%b8%8e%e5%88%86%e6%95%a3" aria-label="物理结构：连续与分散">物理结构：连续与分散</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" aria-label="基本数据类型">基本数据类型</a></li>
                <li>
                    <a href="#%e6%95%b0%e5%ad%97%e7%bc%96%e7%a0%81" aria-label="数字编码">数字编码</a><ul>
                        
                <li>
                    <a href="#%e5%8e%9f%e7%a0%81%e5%8f%8d%e7%a0%81%e5%92%8c%e8%a1%a5%e7%a0%81" aria-label="原码、反码和补码">原码、反码和补码</a></li>
                <li>
                    <a href="#%e6%b5%ae%e7%82%b9%e6%95%b0%e7%bc%96%e7%a0%81" aria-label="浮点数编码">浮点数编码</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e7%bc%96%e7%a0%81" aria-label="字符编码">字符编码</a><ul>
                        
                <li>
                    <a href="#ascii-%e5%ad%97%e7%ac%a6%e9%9b%86" aria-label="ASCII 字符集">ASCII 字符集</a></li>
                <li>
                    <a href="#gbk-%e5%ad%97%e7%ac%a6%e9%9b%86" aria-label="GBK 字符集">GBK 字符集</a></li>
                <li>
                    <a href="#unicode-%e5%ad%97%e7%ac%a6%e9%9b%86" aria-label="Unicode 字符集">Unicode 字符集</a><ul>
                        
                <li>
                    <a href="#utf-8-%e7%bc%96%e7%a0%81" aria-label="UTF-8 编码">UTF-8 编码</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80%e7%9a%84%e5%ad%97%e7%ac%a6%e7%bc%96%e7%a0%81" aria-label="编程语言的字符编码">编程语言的字符编码</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b0%8f%e7%bb%93" aria-label="小结">小结</a><ul>
                        
                <li>
                    <a href="#%e9%87%8d%e7%82%b9%e5%9b%9e%e9%a1%be" aria-label="重点回顾">重点回顾</a></li>
                <li>
                    <a href="#q--a" aria-label="Q &amp; A">Q &amp; A</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p>常见的数据结构包括数组、链表、栈、队列、哈希表、树、堆、图，它们可以从“逻辑结构”和“物理结构”两个维度进行分类。</p>
<h1 id="数据结构分类">数据结构分类<a hidden class="anchor" aria-hidden="true" href="#数据结构分类">#</a></h1>
<h2 id="逻辑结构线性与非线性">逻辑结构：线性与非线性<a hidden class="anchor" aria-hidden="true" href="#逻辑结构线性与非线性">#</a></h2>
<p><strong>逻辑结构揭示了数据元素之间的逻辑关系</strong>。在数组和链表中，数据按照一定顺序排列，体现了数据之间的线性关系；而在树中，数据从顶部向下按层次排列，表现出“祖先”与“后代”之间的派生关系；图则由节点和边构成，反映了复杂的网络关系。</p>
<p>如图 3-1 所示，逻辑结构可分为“线性”和“非线性”两大类。线性结构比较直观，指数据在逻辑关系上呈线性排列；非线性结构则相反，呈非线性排列。</p>
<ul>
<li><strong>线性数据结构</strong>：数组、链表、栈、队列、哈希表，元素之间是一对一的顺序关系。</li>
<li><strong>非线性数据结构</strong>：树、堆、图、哈希表。</li>
</ul>
<p>非线性数据结构可以进一步划分为树形结构和网状结构。</p>
<ul>
<li><strong>树形结构</strong>：树、堆、哈希表，元素之间是一对多的关系。</li>
<li><strong>网状结构</strong>：图，元素之间是多对多的关系。</li>
</ul>
<p><img loading="lazy" src="classification_logic_structure.png"></p>
<h2 id="物理结构连续与分散">物理结构：连续与分散<a hidden class="anchor" aria-hidden="true" href="#物理结构连续与分散">#</a></h2>
<p><strong>当算法程序运行时，正在处理的数据主要存储在内存中</strong>。图 3-2 展示了一个计算机内存条，其中每个黑色方块都包含一块内存空间。我们可以将内存想象成一个巨大的 Excel 表格，其中每个单元格都可以存储一定大小的数据。</p>
<p><strong>系统通过内存地址来访问目标位置的数据</strong>。如图 3-2 所示，计算机根据特定规则为表格中的每个单元格分配编号，确保每个内存空间都有唯一的内存地址。有了这些地址，程序便可以访问内存中的数据。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/computer_memory_location.png"></p>
<blockquote>
<p>值得说明的是，将内存比作 Excel 表格是一个简化的类比，实际内存的工作机制比较复杂，涉及地址空间、内存管理、缓存机制、虚拟内存和物理内存等概念。</p>
</blockquote>
<p>内存是所有程序的共享资源，当某块内存被某个程序占用时，则无法被其他程序同时使用了。<strong>因此在数据结构与算法的设计中，内存资源是一个重要的考虑因素</strong>。比如，算法所占用的内存峰值不应超过系统剩余空闲内存；如果缺少连续大块的内存空间，那么所选用的数据结构必须能够存储在分散的内存空间内。</p>
<p>如图 3-3 所示，<strong>物理结构反映了数据在计算机内存中的存储方式</strong>，可分为连续空间存储（数组）和分散空间存储（链表）。物理结构从底层决定了数据的访问、更新、增删等操作方法，两种物理结构在时间效率和空间效率方面呈现出互补的特点。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/classification_phisical_structure.png"></p>
<p>值得说明的是，<strong>所有数据结构都是基于数组、链表或二者的组合实现的</strong>。例如，栈和队列既可以使用数组实现，也可以使用链表实现；而哈希表的实现可能同时包含数组和链表。</p>
<ul>
<li><strong>基于数组可实现</strong>：栈、队列、哈希表、树、堆、图、矩阵、张量（维度 ≥3 的数组）等。</li>
<li><strong>基于链表可实现</strong>：栈、队列、哈希表、树、堆、图等。</li>
</ul>
<p>链表在初始化后，仍可以在程序运行过程中对其长度进行调整，因此也称“动态数据结构”。数组在初始化后长度不可变，因此也称“静态数据结构”。值得注意的是，数组可通过重新分配内存实现长度变化，从而具备一定的“动态性”。</p>
<h1 id="基本数据类型">基本数据类型<a hidden class="anchor" aria-hidden="true" href="#基本数据类型">#</a></h1>
<p>当谈及计算机中的数据时，我们会想到文本、图片、视频、语音、3D 模型等各种形式。尽管这些数据的组织形式各异，但它们都由各种基本数据类型构成。</p>
<p><strong>基本数据类型是 CPU 可以直接进行运算的类型</strong>，在算法中直接被使用，主要包括以下几种。</p>
<ul>
<li>整数类型 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code> 。</li>
<li>浮点数类型 <code>float</code>、<code>double</code> ，用于表示小数。</li>
<li>字符类型 <code>char</code> ，用于表示各种语言的字母、标点符号甚至表情符号等。</li>
<li>布尔类型 <code>bool</code> ，用于表示“是”与“否”判断。</li>
</ul>
<p><strong>基本数据类型以二进制的形式存储在计算机中</strong>。一个二进制位即为 1 比特。在绝大多数现代操作系统中，1 字节（byte）由 8 比特（bit）组成。</p>
<p>基本数据类型的取值范围取决于其占用的空间大小。下面以 Java 为例。</p>
<ul>
<li>整数类型 <code>byte</code> 占用 1 字节 = 8 比特 ，可以表示 28 个数字。</li>
<li>整数类型 <code>int</code> 占用 4 字节 = 32 比特 ，可以表示 232 个数字。</li>
</ul>
<p>表 3-1 列举了 Java 中各种基本数据类型的占用空间、取值范围和默认值。此表格无须死记硬背，大致理解即可，需要时可以通过查表来回忆。</p>
<p>表 3-1  基本数据类型的占用空间和取值范围</p>
<table>
<thead>
<tr>
<th style="text-align:left">类型</th>
<th style="text-align:left">符号</th>
<th style="text-align:left">占用空间</th>
<th style="text-align:left">最小值</th>
<th style="text-align:left">最大值</th>
<th style="text-align:left">默认值</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">整数</td>
<td style="text-align:left"><code>byte</code></td>
<td style="text-align:left">1 字节</td>
<td style="text-align:left">$−2^7$ (−128)</td>
<td style="text-align:left">$2^7$−1 (127)</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>short</code></td>
<td style="text-align:left">2 字节</td>
<td style="text-align:left">$−2^{15}$</td>
<td style="text-align:left">$2^{15}$−1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>int</code></td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">$−2^{31}$</td>
<td style="text-align:left">$2^{31}$−1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>long</code></td>
<td style="text-align:left">8 字节</td>
<td style="text-align:left">$−2^{63}$</td>
<td style="text-align:left">$−2^{63}$−1</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">浮点数</td>
<td style="text-align:left"><code>float</code></td>
<td style="text-align:left">4 字节</td>
<td style="text-align:left">$1.175×10^{−38}$</td>
<td style="text-align:left">$3.403×10^{38}$</td>
<td style="text-align:left">0.0f</td>
</tr>
<tr>
<td style="text-align:left"></td>
<td style="text-align:left"><code>double</code></td>
<td style="text-align:left">8 字节</td>
<td style="text-align:left">$2.225×10^{−308}$</td>
<td style="text-align:left">$1.798×10^{308}$</td>
<td style="text-align:left">0.0</td>
</tr>
<tr>
<td style="text-align:left">字符</td>
<td style="text-align:left"><code>char</code></td>
<td style="text-align:left">2 字节</td>
<td style="text-align:left">0</td>
<td style="text-align:left">$2^{16}−1$</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">布尔</td>
<td style="text-align:left"><code>bool</code></td>
<td style="text-align:left">1 字节</td>
<td style="text-align:left">false</td>
<td style="text-align:left">true</td>
<td style="text-align:left">false</td>
</tr>
</tbody>
</table>
<p>请注意，表 3-1 针对的是 Java 的基本数据类型的情况。每种编程语言都有各自的数据类型定义，它们的占用空间、取值范围和默认值可能会有所不同。</p>
<ul>
<li>在 Python 中，整数类型 <code>int</code> 可以是任意大小，只受限于可用内存；浮点数 <code>float</code> 是双精度 64 位；没有 <code>char</code> 类型，单个字符实际上是长度为 1 的字符串 <code>str</code> 。</li>
<li>C 和 C++ 未明确规定基本数据类型的大小，而因实现和平台各异。表 3-1 遵循 LP64 <a href="https://en.cppreference.com/w/cpp/language/types#Properties">数据模型</a>，其用于包括 Linux 和 macOS 在内的 Unix 64 位操作系统。</li>
<li>字符 <code>char</code> 的大小在 C 和 C++ 中为 1 字节，在大多数编程语言中取决于特定的字符编码方法，详见“字符编码”章节。</li>
<li>即使表示布尔量仅需 1 位（0 或 1），它在内存中通常也存储为 1 字节。这是因为现代计算机 CPU 通常将 1 字节作为最小寻址内存单元。</li>
</ul>
<p>那么，基本数据类型与数据结构之间有什么联系呢？我们知道，数据结构是在计算机中组织与存储数据的方式。这句话的主语是“结构”而非“数据”。</p>
<p>如果想表示“一排数字”，我们自然会想到使用数组。这是因为数组的线性结构可以表示数字的相邻关系和顺序关系，但至于存储的内容是整数 <code>int</code>、小数 <code>float</code> 还是字符 <code>char</code> ，则与“数据结构”无关。</p>
<p>换句话说，<strong>基本数据类型提供了数据的“内容类型”，而数据结构提供了数据的“组织方式”</strong>。例如以下代码，我们用相同的数据结构（数组）来存储与表示不同的基本数据类型，包括 <code>int</code>、<code>float</code>、<code>char</code>、<code>bool</code> 等。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">// 使用多种基本数据类型来初始化数组</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span>[] numbers = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">int</span>[5];
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">float</span>[] decimals = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">float</span>[5];
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">char</span>[] characters = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">char</span>[5];
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">boolean</span>[] bools = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">boolean</span>[5];
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="数字编码">数字编码<a hidden class="anchor" aria-hidden="true" href="#数字编码">#</a></h1>
<h2 id="原码反码和补码">原码、反码和补码<a hidden class="anchor" aria-hidden="true" href="#原码反码和补码">#</a></h2>
<p>在上一节的表格中我们发现，所有整数类型能够表示的负数都比正数多一个，例如 <code>byte</code> 的取值范围是 [−128,127] 。这个现象比较反直觉，它的内在原因涉及原码、反码、补码的相关知识。</p>
<p>首先需要指出，<strong>数字是以“补码”的形式存储在计算机中的</strong>。在分析这样做的原因之前，首先给出三者的定义。</p>
<ul>
<li><strong>原码</strong>：我们将数字的二进制表示的最高位视为符号位，其中 0 表示正数，1 表示负数，其余位表示数字的值。</li>
<li><strong>反码</strong>：正数的反码与其原码相同，负数的反码是对其原码除符号位外的所有位取反。</li>
<li><strong>补码</strong>：正数的补码与其原码相同，负数的补码是在其反码的基础上加 1 。</li>
</ul>
<p>图 3-4 展示了原码、反码和补码之间的转换方法。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1s_2s_complement.png"></p>
<p>原码（sign‑magnitude）虽然最直观，但存在一些局限性。一方面，负数的原码不能直接用于运算。例如在原 码下计算1+(−2)，得到的结果是−3，这显然是不对的。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1 +(−2)
</span></span><span style="display:flex;"><span> →0000 0001+1000 0010
</span></span><span style="display:flex;"><span> =1000 0011
</span></span><span style="display:flex;"><span> →−3
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了解决此问题，计算机引入了反码（1’scomplement）。如果我们先将原码转换为反码，并在反码下计算 1 +(−2)，最后将结果从反码转换回原码，则可得到正确结果−1。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1 +(−2)
</span></span><span style="display:flex;"><span> →0000 0001 (原码)+1000 0010 (原码)
</span></span><span style="display:flex;"><span> =0000 0001 (反码)+1111 1101 (反码)
</span></span><span style="display:flex;"><span> =1111 1110 (反码)
</span></span><span style="display:flex;"><span> =1000 0001 (原码)
</span></span><span style="display:flex;"><span> →−1
</span></span></code></pre></td></tr></table>
</div>
</div><p>另一方面，数字零的原码有+0和−0两种表示方式。这意味着数字零对应两个不同的二进制编码，这可能 会带来歧义。比如在条件判断中，如果没有区分正零和负零，则可能会导致判断结果出错。而如果我们想处 理正零和负零歧义，则需要引入额外的判断操作，这可能会降低计算机的运算效率。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>+0 →0000 0000
</span></span><span style="display:flex;"><span>−0 →1000 0000
</span></span></code></pre></td></tr></table>
</div>
</div><p>与原码一样，反码也存在正负零歧义问题，因此计算机进一步引入了补码（2’scomplement）。我们先来观 察一下负零的原码、反码、补码的转换过程：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>−0 →1000 0000 (原码)
</span></span><span style="display:flex;"><span> =1111 1111 (反码)
</span></span><span style="display:flex;"><span> =10000 0000 (补码)
</span></span></code></pre></td></tr></table>
</div>
</div><p>在负零的反码基础上加1会产生进位，但 byte 类型的长度只有8位，因此溢出到第9位的1会被舍弃。也 就是说，负零的补码为00000000，与正零的补码相同。这意味着在补码表示中只存在一个零，正负零歧义 从而得到解决。</p>
<p>还剩最后一个疑惑： byte 类型的取值范围是[−128,127]，多出来的一个负数−128是如何得到的呢？我 们注意到，区间[−127,+127]内的所有整数都有对应的原码、反码和补码，并且原码和补码之间可以互相 转换。</p>
<p>然而，补码1000 0000是一个例外，它并没有对应的原码。根据转换方法，我们得到该补码的原码为 0000 0000。这显然是矛盾的，因为该原码表示数字0，它的补码应该是自身。计算机规定这个特殊的补码 1000 0000 代表−128。实际上，(−1)+(−127)在补码下的计算结果就是−128。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>(−127) +(−1)
</span></span><span style="display:flex;"><span> →1111 1111 (原码)+1000 0001 (原码)
</span></span><span style="display:flex;"><span> =1000 0000 (反码)+1111 1110 (反码)
</span></span><span style="display:flex;"><span> =1000 0001 (补码)+1111 1111 (补码)
</span></span><span style="display:flex;"><span> =1000 0000 (补码)
</span></span><span style="display:flex;"><span> →−128
</span></span></code></pre></td></tr></table>
</div>
</div><p>你可能已经发现了，上述所有计算都是加法运算。这暗示着一个重要事实：计算机内部的硬件电路主要是基 于加法运算设计的。这是因为加法运算相对于其他运算（比如乘法、除法和减法）来说，硬件实现起来更简单，更容易进行并行化处理，运算速度更快。</p>
<p>请注意，这并不意味着计算机只能做加法。通过将加法与一些基本逻辑运算结合，计算机能够实现各种其他 的数学运算。例如，计算减法𝑎−𝑏可以转换为计算加法𝑎+(−𝑏)；计算乘法和除法可以转换为计算多次 加法或减法。 现在我们可以总结出计算机使用补码的原因：基于补码表示，计算机可以用同样的电路和操作来处理正数和 负数的加法，不需要设计特殊的硬件电路来处理减法，并且无须特别处理正负零的歧义问题。这大大简化了 硬件设计，提高了运算效率。</p>
<p>补码的设计非常精妙，因篇幅关系我们就先介绍到这里，建议有兴趣的读者进一步深入了解。</p>
<h2 id="浮点数编码">浮点数编码<a hidden class="anchor" aria-hidden="true" href="#浮点数编码">#</a></h2>
<p>细心的你可能会发现： int 和 常反直觉，因为按理说 float 长度相同，都是4字节，但为什么 float 的取值范围远大于 float 需要表示小数，取值范围应该变小才对。</p>
<p>实际上，这是因为浮点数 float 采用了不同的表示方式。记一个32比特长度的二进制数为：
</p>
$$
𝑏_{31}𝑏_{30}𝑏_{29} …𝑏_2𝑏_1𝑏_0
$$
<p>
根据 IEEE 754 标准，32-bit 长度的 <code>float</code> 由以下三个部分构成。</p>
<ul>
<li>符号位 S ：占 1 位 ，对应 $𝑏_{31} $。</li>
<li>指数位 E ：占 8 位 ，对应 $𝑏_{30}𝑏_{29}…𝑏_{23} $。</li>
<li>分数位 N ：占 23 位 ，对应 $𝑏_{22}𝑏_{21}…𝑏_0$ 。</li>
</ul>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/Snipaste_2024-05-30_14-23-03.png"></p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ieee_754_float.png"></p>
<p>观察图 3-5 ，给定一个示例数据 S=0 ， E=124 ，N=2−2+2−3=0.375 ，则有：
</p>
$$
val = (−1)^0 ×2^{124−127} ×(1+0.375) = 0.171875
$$
<p>
现在我们可以回答最初的问题：<strong><code>float</code> 的表示方式包含指数位，导致其取值范围远大于 <code>int</code></strong> 。根据以上计算，<code>float</code> 可表示的最大正数为 $2^{254−127}×(2−2^{−23})≈3.4×10^{38}$ ，切换符号位便可得到最小负数。</p>
<p><strong>尽管浮点数 <code>float</code> 扩展了取值范围，但其副作用是牺牲了精度</strong>。整数类型 <code>int</code> 将全部 32 比特用于表示数字，数字是均匀分布的；而由于指数位的存在，浮点数 <code>float</code> 的数值越大，相邻两个数字之间的差值就会趋向越大。</p>
<p>如表 3-2 所示，指数位 E=0 和 E=255 具有特殊含义，<strong>用于表示零、无穷大、NaN 等</strong>。</p>
<p>表 3-2  指数位含义</p>
<table>
<thead>
<tr>
<th style="text-align:left">指数位 E</th>
<th style="text-align:left">分数位 N=0</th>
<th style="text-align:left">分数位 N≠0</th>
<th style="text-align:left">计算公式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">±0</td>
<td style="text-align:left">次正规数</td>
<td style="text-align:left">$(−1)^S×2^{−126}×(0.N)$</td>
</tr>
<tr>
<td style="text-align:left">1,2,…,254</td>
<td style="text-align:left">正规数</td>
<td style="text-align:left">正规数</td>
<td style="text-align:left">$(−1)^S×2^{(E−127)}×(1.N)$</td>
</tr>
<tr>
<td style="text-align:left">255</td>
<td style="text-align:left">±∞</td>
<td style="text-align:left">NaN</td>
<td style="text-align:left"></td>
</tr>
</tbody>
</table>
<p>值得说明的是，次正规数显著提升了浮点数的精度。最小正正规数为 $2^{−126}$ ，最小正次正规数为 $2^{−126}×2^{−23}$。</p>
<p>双精度 <code>double</code> 也采用类似于 <code>float</code> 的表示方法，在此不做赘述。</p>
<h1 id="字符编码">字符编码<a hidden class="anchor" aria-hidden="true" href="#字符编码">#</a></h1>
<p>在计算机中，所有数据都是以二进制数的形式存储的，字符 <code>char</code> 也不例外。为了表示字符，我们需要建立一套“字符集”，规定每个字符和二进制数之间的一一对应关系。有了字符集之后，计算机就可以通过查表完成二进制数到字符的转换。</p>
<h2 id="ascii-字符集">ASCII 字符集<a hidden class="anchor" aria-hidden="true" href="#ascii-字符集">#</a></h2>
<p>ASCII 码是最早出现的字符集，其全称为 American Standard Code for Information Interchange（美国标准信息交换代码）。它使用 7 位二进制数（一个字节的低 7 位）表示一个字符，最多能够表示 128 个不同的字符。如图 3-6 所示，ASCII 码包括英文字母的大小写、数字 0 ~ 9、一些标点符号，以及一些控制字符（如换行符和制表符）。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/ascii_table.png"></p>
<p>然而，<strong>ASCII 码仅能够表示英文</strong>。随着计算机的全球化，诞生了一种能够表示更多语言的 EASCII 字符集。它在 ASCII 的 7 位基础上扩展到 8 位，能够表示 256 个不同的字符。</p>
<p>在世界范围内，陆续出现了一批适用于不同地区的 EASCII 字符集。这些字符集的前 128 个字符统一为 ASCII 码，后 128 个字符定义不同，以适应不同语言的需求。</p>
<h2 id="gbk-字符集">GBK 字符集<a hidden class="anchor" aria-hidden="true" href="#gbk-字符集">#</a></h2>
<p>后来人们发现，<strong>EASCII 码仍然无法满足许多语言的字符数量要求</strong>。比如汉字有近十万个，光日常使用的就有几千个。中国国家标准总局于 1980 年发布了 GB2312 字符集，其收录了 6763 个汉字，基本满足了汉字的计算机处理需要。</p>
<p>然而，GB2312 无法处理部分罕见字和繁体字。GBK 字符集是在 GB2312 的基础上扩展得到的，它共收录了 21886 个汉字。在 GBK 的编码方案中，ASCII 字符使用一个字节表示，汉字使用两个字节表示。</p>
<h2 id="unicode-字符集">Unicode 字符集<a hidden class="anchor" aria-hidden="true" href="#unicode-字符集">#</a></h2>
<p>随着计算机技术的蓬勃发展，字符集与编码标准百花齐放，而这带来了许多问题。一方面，这些字符集一般只定义了特定语言的字符，无法在多语言环境下正常工作。另一方面，同一种语言存在多种字符集标准，如果两台计算机使用的是不同的编码标准，则在信息传递时就会出现乱码。</p>
<p>那个时代的研究人员就在想：<strong>如果推出一个足够完整的字符集，将世界范围内的所有语言和符号都收录其中，不就可以解决跨语言环境和乱码问题了吗</strong>？在这种想法的驱动下，一个大而全的字符集 Unicode 应运而生。</p>
<p>Unicode 的中文名称为“统一码”，理论上能容纳 100 多万个字符。它致力于将全球范围内的字符纳入统一的字符集之中，提供一种通用的字符集来处理和显示各种语言文字，减少因为编码标准不同而产生的乱码问题。</p>
<p>自 1991 年发布以来，Unicode 不断扩充新的语言与字符。截至 2022 年 9 月，Unicode 已经包含 149186 个字符，包括各种语言的字符、符号甚至表情符号等。在庞大的 Unicode 字符集中，常用的字符占用 2 字节，有些生僻的字符占用 3 字节甚至 4 字节。</p>
<p>Unicode 是一种通用字符集，本质上是给每个字符分配一个编号（称为“码点”），<strong>但它并没有规定在计算机中如何存储这些字符码点</strong>。我们不禁会问：当多种长度的 Unicode 码点同时出现在一个文本中时，系统如何解析字符？例如给定一个长度为 2 字节的编码，系统如何确认它是一个 2 字节的字符还是两个 1 字节的字符？</p>
<p>对于以上问题，<strong>一种直接的解决方案是将所有字符存储为等长的编码</strong>。如图 3-7 所示，“Hello”中的每个字符占用 1 字节，“算法”中的每个字符占用 2 字节。我们可以通过高位填 0 将“Hello 算法”中的所有字符都编码为 2 字节长度。这样系统就可以每隔 2 字节解析一个字符，恢复这个短语的内容了。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/unicode_hello_algo.png"></p>
<p>然而 ASCII 码已经向我们证明，编码英文只需 1 字节。若采用上述方案，英文文本占用空间的大小将会是 ASCII 编码下的两倍，非常浪费内存空间。因此，我们需要一种更加高效的 Unicode 编码方法。</p>
<h3 id="utf-8-编码">UTF-8 编码<a hidden class="anchor" aria-hidden="true" href="#utf-8-编码">#</a></h3>
<p>目前，UTF-8 已成为国际上使用最广泛的 Unicode 编码方法。<strong>它是一种可变长度的编码</strong>，使用 1 到 4 字节来表示一个字符，根据字符的复杂性而变。ASCII 字符只需 1 字节，拉丁字母和希腊字母需要 2 字节，常用的中文字符需要 3 字节，其他的一些生僻字符需要 4 字节。</p>
<p>UTF-8 的编码规则并不复杂，分为以下两种情况。</p>
<ul>
<li>对于长度为 1 字节的字符，将最高位设置为 0 ，其余 7 位设置为 Unicode 码点。值得注意的是，ASCII 字符在 Unicode 字符集中占据了前 128 个码点。也就是说，<strong>UTF-8 编码可以向下兼容 ASCII 码</strong>。这意味着我们可以使用 UTF-8 来解析年代久远的 ASCII 码文本。</li>
<li>对于长度为 𝑛 字节的字符（其中 𝑛&gt;1），将首个字节的高 𝑛 位都设置为 1 ，第 𝑛+1 位设置为 0 ；从第二个字节开始，将每个字节的高 2 位都设置为 10 ；其余所有位用于填充字符的 Unicode 码点。</li>
</ul>
<p>图 3-8 展示了“Hello算法”对应的 UTF-8 编码。观察发现，由于最高 𝑛 位都设置为 1 ，因此系统可以通过读取最高位 1 的个数来解析出字符的长度为 𝑛 。</p>
<p>但为什么要将其余所有字节的高 2 位都设置为 10 呢？实际上，这个 10 能够起到校验符的作用。假设系统从一个错误的字节开始解析文本，字节头部的 10 能够帮助系统快速判断出异常。</p>
<p>之所以将 10 当作校验符，是因为在 UTF-8 编码规则下，不可能有字符的最高两位是 10 。这个结论可以用反证法来证明：假设一个字符的最高两位是 10 ，说明该字符的长度为 1 ，对应 ASCII 码。而 ASCII 码的最高位应该是 0 ，与假设矛盾。</p>
<p><img loading="lazy" src="/posts/%E7%AE%97%E6%B3%95/2_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/utf-8_hello_algo.png"></p>
<p>除了 UTF-8 之外，常见的编码方式还包括以下两种。</p>
<ul>
<li><strong>UTF-16 编码</strong>：使用 2 或 4 字节来表示一个字符。所有的 ASCII 字符和常用的非英文字符，都用 2 字节表示；少数字符需要用到 4 字节表示。对于 2 字节的字符，UTF-16 编码与 Unicode 码点相等。</li>
<li><strong>UTF-32 编码</strong>：每个字符都使用 4 字节。这意味着 UTF-32 比 UTF-8 和 UTF-16 更占用空间，特别是对于 ASCII 字符占比较高的文本。</li>
</ul>
<p>从存储空间占用的角度看，使用 UTF-8 表示英文字符非常高效，因为它仅需 1 字节；使用 UTF-16 编码某些非英文字符（例如中文）会更加高效，因为它仅需 2 字节，而 UTF-8 可能需要 3 字节。</p>
<p>从兼容性的角度看，UTF-8 的通用性最佳，许多工具和库优先支持 UTF-8 。</p>
<h2 id="编程语言的字符编码">编程语言的字符编码<a hidden class="anchor" aria-hidden="true" href="#编程语言的字符编码">#</a></h2>
<p>对于以往的大多数编程语言，程序运行中的字符串都采用 UTF-16 或 UTF-32 这类等长编码。在等长编码下，我们可以将字符串看作数组来处理，这种做法具有以下优点。</p>
<ul>
<li><strong>随机访问</strong>：UTF-16 编码的字符串可以很容易地进行随机访问。UTF-8 是一种变长编码，要想找到第 𝑖 个字符，我们需要从字符串的开始处遍历到第 𝑖 个字符，这需要 𝑂(𝑛) 的时间。</li>
<li><strong>字符计数</strong>：与随机访问类似，计算 UTF-16 编码的字符串的长度也是 𝑂(1) 的操作。但是，计算 UTF-8 编码的字符串的长度需要遍历整个字符串。</li>
<li><strong>字符串操作</strong>：在 UTF-16 编码的字符串上，很多字符串操作（如分割、连接、插入、删除等）更容易进行。在 UTF-8 编码的字符串上，进行这些操作通常需要额外的计算，以确保不会产生无效的 UTF-8 编码。</li>
</ul>
<p>实际上，编程语言的字符编码方案设计是一个很有趣的话题，涉及许多因素。</p>
<ul>
<li>Java 的 <code>String</code> 类型使用 UTF-16 编码，每个字符占用 2 字节。这是因为 Java 语言设计之初，人们认为 16 位足以表示所有可能的字符。然而，这是一个不正确的判断。后来 Unicode 规范扩展到了超过 16 位，所以 Java 中的字符现在可能由一对 16 位的值（称为“代理对”）表示。</li>
<li>JavaScript 和 TypeScript 的字符串使用 UTF-16 编码的原因与 Java 类似。当 1995 年 Netscape 公司首次推出 JavaScript 语言时，Unicode 还处于发展早期，那时候使用 16 位的编码就足以表示所有的 Unicode 字符了。</li>
<li>C# 使用 UTF-16 编码，主要是因为 .NET 平台是由 Microsoft 设计的，而 Microsoft 的很多技术（包括 Windows 操作系统）都广泛使用 UTF-16 编码。</li>
</ul>
<p>由于以上编程语言对字符数量的低估，它们不得不采取“代理对”的方式来表示超过 16 位长度的 Unicode 字符。这是一个不得已为之的无奈之举。一方面，包含代理对的字符串中，一个字符可能占用 2 字节或 4 字节，从而丧失了等长编码的优势。另一方面，处理代理对需要额外增加代码，这提高了编程的复杂性和调试难度。</p>
<p>出于以上原因，部分编程语言提出了一些不同的编码方案。</p>
<ul>
<li>Python 中的 <code>str</code> 使用 Unicode 编码，并采用一种灵活的字符串表示，存储的字符长度取决于字符串中最大的 Unicode 码点。若字符串中全部是 ASCII 字符，则每个字符占用 1 字节；如果有字符超出了 ASCII 范围，但全部在基本多语言平面（BMP）内，则每个字符占用 2 字节；如果有超出 BMP 的字符，则每个字符占用 4 字节。</li>
<li>Go 语言的 <code>string</code> 类型在内部使用 UTF-8 编码。Go 语言还提供了 <code>rune</code> 类型，它用于表示单个 Unicode 码点。</li>
<li>Rust 语言的 <code>str</code> 和 <code>String</code> 类型在内部使用 UTF-8 编码。Rust 也提供了 <code>char</code> 类型，用于表示单个 Unicode 码点。</li>
</ul>
<p>需要注意的是，以上讨论的都是字符串在编程语言中的存储方式，<strong>这和字符串如何在文件中存储或在网络中传输是不同的问题</strong>。在文件存储或网络传输中，我们通常会将字符串编码为 UTF-8 格式，以达到最优的兼容性和空间效率。</p>
<h1 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h1>
<h2 id="重点回顾">重点回顾<a hidden class="anchor" aria-hidden="true" href="#重点回顾">#</a></h2>
<ul>
<li>数据结构可以从逻辑结构和物理结构两个角度进行分类。逻辑结构描述了数据元素之间的逻辑关系，而物理结构描述了数据在计算机内存中的存储方式。</li>
<li>常见的逻辑结构包括线性、树状和网状等。通常我们根据逻辑结构将数据结构分为线性（数组、链表、栈、队列）和非线性（树、图、堆）两种。哈希表的实现可能同时包含线性数据结构和非线性数据结构。</li>
<li>当程序运行时，数据被存储在计算机内存中。每个内存空间都拥有对应的内存地址，程序通过这些内存地址访问数据。</li>
<li>物理结构主要分为连续空间存储（数组）和分散空间存储（链表）。所有数据结构都是由数组、链表或两者的组合实现的。</li>
<li>计算机中的基本数据类型包括整数 <code>byte</code>、<code>short</code>、<code>int</code>、<code>long</code> ，浮点数 <code>float</code>、<code>double</code> ，字符 <code>char</code> 和布尔 <code>bool</code> 。它们的取值范围取决于占用空间大小和表示方式。</li>
<li>原码、反码和补码是在计算机中编码数字的三种方法，它们之间可以相互转换。整数的原码的最高位是符号位，其余位是数字的值。</li>
<li>整数在计算机中是以补码的形式存储的。在补码表示下，计算机可以对正数和负数的加法一视同仁，不需要为减法操作单独设计特殊的硬件电路，并且不存在正负零歧义的问题。</li>
<li>浮点数的编码由 1 位符号位、8 位指数位和 23 位分数位构成。由于存在指数位，因此浮点数的取值范围远大于整数，代价是牺牲了精度。</li>
<li>ASCII 码是最早出现的英文字符集，长度为 1 字节，共收录 127 个字符。GBK 字符集是常用的中文字符集，共收录两万多个汉字。Unicode 致力于提供一个完整的字符集标准，收录世界上各种语言的字符，从而解决由于字符编码方法不一致而导致的乱码问题。</li>
<li>UTF-8 是最受欢迎的 Unicode 编码方法，通用性非常好。它是一种变长的编码方法，具有很好的扩展性，有效提升了存储空间的使用效率。UTF-16 和 UTF-32 是等长的编码方法。在编码中文时，UTF-16 占用的空间比 UTF-8 更小。Java 和 C# 等编程语言默认使用 UTF-16 编码。</li>
</ul>
<h2 id="q--a">Q &amp; A<a hidden class="anchor" aria-hidden="true" href="#q--a">#</a></h2>
<p><strong>Q</strong>：为什么哈希表同时包含线性数据结构和非线性数据结构？</p>
<p>哈希表底层是数组，而为了解决哈希冲突，我们可能会使用“链式地址”（后续“哈希冲突”章节会讲）：数组中每个桶指向一个链表，当链表长度超过一定阈值时，又可能被转化为树（通常为红黑树）。</p>
<p>从存储的角度来看，哈希表的底层是数组，其中每一个桶槽位可能包含一个值，也可能包含一个链表或一棵树。因此，哈希表可能同时包含线性数据结构（数组、链表）和非线性数据结构（树）。</p>
<p><strong>Q</strong>：<code>char</code> 类型的长度是 1 字节吗？</p>
<p><code>char</code> 类型的长度由编程语言采用的编码方法决定。例如，Java、JavaScript、TypeScript、C# 都采用 UTF-16 编码（保存 Unicode 码点），因此 <code>char</code> 类型的长度为 2 字节。</p>
<p><strong>Q</strong>：基于数组实现的数据结构也称“静态数据结构” 是否有歧义？栈也可以进行出栈和入栈等操作，这些操作都是“动态”的。</p>
<p>栈确实可以实现动态的数据操作，但数据结构仍然是“静态”（长度不可变）的。尽管基于数组的数据结构可以动态地添加或删除元素，但它们的容量是固定的。如果数据量超出了预分配的大小，就需要创建一个新的更大的数组，并将旧数组的内容复制到新数组中。</p>
<p><strong>Q</strong>：在构建栈（队列）的时候，未指定它的大小，为什么它们是“静态数据结构”呢？</p>
<p>在高级编程语言中，我们无须人工指定栈（队列）的初始容量，这个工作由类内部自动完成。例如，Java 的 <code>ArrayList</code> 的初始容量通常为 10。另外，扩容操作也是自动实现的。详见后续的“列表”章节。</p>
<p><strong>Q</strong>：原码转补码的方法是“先取反后加 1”，那么补码转原码应该是逆运算“先减 1 后取反”，而补码转原码也一样可以通过“先取反后加 1”得到，这是为什么呢？</p>
<p><strong>A</strong>：这是因为原码和补码的相互转换实际上是计算“补数”的过程。我们先给出补数的定义：假设 𝑎+𝑏=𝑐 ，那么我们称 𝑎 是 𝑏 到 𝑐 的补数，反之也称 𝑏 是 𝑎 到 𝑐 的补数。</p>
<p>给定一个 𝑛=4 位长度的二进制数 0010 ，如果将这个数字看作原码（不考虑符号位），那么它的补码需通过“先取反后加 1”得到：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>0010 → 1101 → 1110
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们会发现，原码和补码的和是0010+1110=10000，也就是说，补码1110是原码0010到10000的 “补数”。这意味着上述“先取反后加1”实际上是计算到10000的补数的过程。</p>
<p>那么，补码1110到10000的“补数”是多少呢？我们依然可以用“先取反后加1”得到它：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1110 → 0001 → 0010
</span></span></code></pre></td></tr></table>
</div>
</div><p>换句话说，原码和补码互为对方到10000的“补数”，因此“原码转补码”和“补码转原码”可以用相同的 操作（先取反后加1）实现。</p>
<p>当然，我们也可以用逆运算来求补码1110的原码，即“先减1后取反”：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>1110 → 1101 → 0010
</span></span></code></pre></td></tr></table>
</div>
</div><p>总结来看，“先取反后加1”和“先减1后取反”这两种运算都是在计算到10000的补数，它们是等价的。 本质上看，“取反”操作实际上是求到1111的补数（因为恒有 原码 + 反码 = 1111）；而在反码基础上再加1 得到的补码，就是到10000的补数。</p>
<p>上述𝑛=4为例，其可推广至任意位数的二进制数。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://009965.xyz/tags/%E7%AE%97%E6%B3%95/">算法</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://009965.xyz/">Wjy&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
