<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>jvm | Wjy&#39;s Blog</title>
<meta name="keywords" content="java">
<meta name="description" content="jvm全面思维导图
java内存模型
什么是虚拟机
windows只能安装exe安装包，mac只能安装dmg安装包，这是因为操作系统底层的实现是不一样的。系统软件无法通用是一个常见的问题。
但使用过 Java 的同学都知道，Java 代码可以在Linux 系统运行，也可以在 Windows 系统运行，但我们并没有生成多份不同的代码。所以 Java 语言是如何做到的呢？
Java 语言并不直接将代码编译成与系统有关的机器码，而是编译成一种特定的语言规范，这种语言规范我们称之为字节码。无论 Java 程序要在 Windows 系统，还是 Mac 系统，抑或是 Linux 系统，它首先都得编译成字节码文件，之后才能运行。
但即使编译成字节码文件了，各个系统还是无法明白字节码文件的内容，这时候就需要 Java 虚拟机的帮助了。Java 虚拟机会解析字节码文件的内容，并将其翻译为各操作系统能理解的机器码。
java源码-&gt;字节码（byte code）-&gt;java Virture Machine -&gt;windows\linux code">
<meta name="author" content="Wjy">
<link rel="canonical" href="https://funny-toffee-4aa7c3.netlify.app/posts/java/jvm/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://funny-toffee-4aa7c3.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://funny-toffee-4aa7c3.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://funny-toffee-4aa7c3.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://funny-toffee-4aa7c3.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://funny-toffee-4aa7c3.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://funny-toffee-4aa7c3.netlify.app/posts/java/jvm/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="https://funny-toffee-4aa7c3.netlify.app/posts/java/jvm/">
  <meta property="og:site_name" content="Wjy&#39;s Blog">
  <meta property="og:title" content="jvm">
  <meta property="og:description" content="jvm全面思维导图 java内存模型
什么是虚拟机 windows只能安装exe安装包，mac只能安装dmg安装包，这是因为操作系统底层的实现是不一样的。系统软件无法通用是一个常见的问题。
但使用过 Java 的同学都知道，Java 代码可以在Linux 系统运行，也可以在 Windows 系统运行，但我们并没有生成多份不同的代码。所以 Java 语言是如何做到的呢？ Java 语言并不直接将代码编译成与系统有关的机器码，而是编译成一种特定的语言规范，这种语言规范我们称之为字节码。无论 Java 程序要在 Windows 系统，还是 Mac 系统，抑或是 Linux 系统，它首先都得编译成字节码文件，之后才能运行。 但即使编译成字节码文件了，各个系统还是无法明白字节码文件的内容，这时候就需要 Java 虚拟机的帮助了。Java 虚拟机会解析字节码文件的内容，并将其翻译为各操作系统能理解的机器码。 java源码-&gt;字节码（byte code）-&gt;java Virture Machine -&gt;windows\linux code">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-09-01T18:16:18+00:00">
    <meta property="article:modified_time" content="2022-09-01T18:16:18+00:00">
    <meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="jvm">
<meta name="twitter:description" content="jvm全面思维导图
java内存模型
什么是虚拟机
windows只能安装exe安装包，mac只能安装dmg安装包，这是因为操作系统底层的实现是不一样的。系统软件无法通用是一个常见的问题。
但使用过 Java 的同学都知道，Java 代码可以在Linux 系统运行，也可以在 Windows 系统运行，但我们并没有生成多份不同的代码。所以 Java 语言是如何做到的呢？
Java 语言并不直接将代码编译成与系统有关的机器码，而是编译成一种特定的语言规范，这种语言规范我们称之为字节码。无论 Java 程序要在 Windows 系统，还是 Mac 系统，抑或是 Linux 系统，它首先都得编译成字节码文件，之后才能运行。
但即使编译成字节码文件了，各个系统还是无法明白字节码文件的内容，这时候就需要 Java 虚拟机的帮助了。Java 虚拟机会解析字节码文件的内容，并将其翻译为各操作系统能理解的机器码。
java源码-&gt;字节码（byte code）-&gt;java Virture Machine -&gt;windows\linux code">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://funny-toffee-4aa7c3.netlify.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "jvm",
      "item": "https://funny-toffee-4aa7c3.netlify.app/posts/java/jvm/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "jvm",
  "name": "jvm",
  "description": "jvm全面思维导图 java内存模型\n什么是虚拟机 windows只能安装exe安装包，mac只能安装dmg安装包，这是因为操作系统底层的实现是不一样的。系统软件无法通用是一个常见的问题。\n但使用过 Java 的同学都知道，Java 代码可以在Linux 系统运行，也可以在 Windows 系统运行，但我们并没有生成多份不同的代码。所以 Java 语言是如何做到的呢？ Java 语言并不直接将代码编译成与系统有关的机器码，而是编译成一种特定的语言规范，这种语言规范我们称之为字节码。无论 Java 程序要在 Windows 系统，还是 Mac 系统，抑或是 Linux 系统，它首先都得编译成字节码文件，之后才能运行。 但即使编译成字节码文件了，各个系统还是无法明白字节码文件的内容，这时候就需要 Java 虚拟机的帮助了。Java 虚拟机会解析字节码文件的内容，并将其翻译为各操作系统能理解的机器码。 java源码-\u0026gt;字节码（byte code）-\u0026gt;java Virture Machine -\u0026gt;windows\\linux code\n",
  "keywords": [
    "java"
  ],
  "articleBody": "jvm全面思维导图 java内存模型\n什么是虚拟机 windows只能安装exe安装包，mac只能安装dmg安装包，这是因为操作系统底层的实现是不一样的。系统软件无法通用是一个常见的问题。\n但使用过 Java 的同学都知道，Java 代码可以在Linux 系统运行，也可以在 Windows 系统运行，但我们并没有生成多份不同的代码。所以 Java 语言是如何做到的呢？ Java 语言并不直接将代码编译成与系统有关的机器码，而是编译成一种特定的语言规范，这种语言规范我们称之为字节码。无论 Java 程序要在 Windows 系统，还是 Mac 系统，抑或是 Linux 系统，它首先都得编译成字节码文件，之后才能运行。 但即使编译成字节码文件了，各个系统还是无法明白字节码文件的内容，这时候就需要 Java 虚拟机的帮助了。Java 虚拟机会解析字节码文件的内容，并将其翻译为各操作系统能理解的机器码。 java源码-\u003e字节码（byte code）-\u003ejava Virture Machine -\u003ewindows\\linux code\n简单地说，对于同样一份 Java 源码文件，我们编译成字节码之后，无论是 Linux 系统还是 Windows 系统都不认识。这时候 Java 虚拟机就是一个翻译官，在 Linux 系统上翻译成 Linux 机器码给 Linux 系统听，在 Windows 系统上翻译成 Windows 机器码给 Windows 系统听。这样一来，Java 就实现了「Write Once，Run Anywhere」的伟大愿景了。\n在 Java 虚拟机还没出现之前，为了支持软件在不同系统上运行，我们必须在多个平台写多份代码，分别对应特定的系统。但 Java 虚拟机出现之后，你只需要按照特定规范编译书写，编译器编译成字节码文件后，虚拟机会帮你将字节码生成对应的 Windows Code 和 Mac Code。本质上最终还是会生成 Windows Code 和 Mac Code 两份机器代码，但对于开发人员来说，却只需要写一次代码了。Java 虚拟机帮开发人员承担了重复的工作，让开发效率更高了。\n其实 Java 虚拟机就是一个字节码翻译器，它将字节码文件翻译成各个系统对应的机器码，确保字节码文件能在各个系统正确运行。JVM 是可运行Java代码的假想计算机，JVM 是运行在操作系统之上的，它与硬件没有直接的交互。\n我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码。\nJava 源文件-\u003e编译器-\u003e字节码文件-\u003eJVM-\u003e机器码\n每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够跨平台的原因，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。\n从源代码到机器码，发生了什么？ 无论什么语言写的代码，其到最后都是通过机器码运行的，无一例外。那么对于 Java 语言来说，其从源代码到机器码，这中间到底发生了什么呢？\n我们知道实际输入到 Java 虚拟机的是字节码文件，而不是 Java 源文件。 那么对于 Java 语言而言，是怎么将 Java 代码转化成字节码文件的呢？我们知道在 JDK 的安装目录里有一个 javac 工具，就是它将 Java 代码翻译成字节码，这个工具我们叫做编译器。\n编译器可以分为：前端编译器、JIT编译器、AOT编译器\n前端编译器：源代码到字节码 相对于后面要讲的其他编译器，其因为处于编译的前期，因此又被成为前端编译器。 通过 javac 编译器，我们可以很方便地将 java 源文件翻译成字节码文件。就拿我们最熟悉的 Hello World 作为例子：\n1 2 3 4 5 public class Demo{ public static void main(String args[]){ System.out.println(\"Hello World!\"); } } 我们使用 javac 命令编译上面这个类，便会生成一个 Demo.class 文件：\n1 2 3 \u003e javac Demo.java \u003e ls Demo.java Demo.class 我们使用纯文本编辑器打开 Demo.class 文件，我们会发现是一连串的 16 进制数据流。 我们运行 javac 命令的过程，其实就是 javac 编译器解析 Java 源代码，并生成字节码文件的过程。说白了，其实就是使用 javac 编译器把 Java 语言规范转化为字节码语言规范。javac 编译器的处理过程可以分为下面四个阶段：\n第一个阶段：词法、语法分析。在这个阶段，javac 编译器会对源代码的字符进行一次扫描，最终生成一个抽象的语法树。简单地说，在这个阶段 javac 编译器会搞懂我们的代码到底想要干嘛。就像我们分析一个句子一样，我们会对句子划分主谓宾，弄清楚这个句子要表达的意思一样。\n第二个阶段：填充符号表。我们知道类之间是会互相引用的，但在编译阶段，我们无法确定其具体的地址，所以我们会使用一个符号来替代。在这个阶段做的就是类似的事情，即对抽象的类或接口进行符号填充。等到类加载阶段，javac 编译器会将符号替换成具体的内存地址。\n第三个阶段：注解处理。我们知道 Java 是支持注解的，因此在这个阶段会对注解进行分析，根据注解的作用将其还原成具体的指令集。\n第四个阶段：分析与字节码生成。到了这个阶段，javac 编译器便会根据上面几个阶段分析出来的结果，进行字节码的生成，最终输出为 class 文件。\n我们一般称 javac 编译器为前端编译器，因为其发生在整个编译的前期。常见的前端编译器有 Sun 的 javac，Eclipse JDT 的增量式编译器（ECJ）。\nJIT 编译器：从字节码到机器码 当源代码转化为字节码之后，其实要运行程序，有两种选择。一种是使用 Java 解释器解释执行字节码，另一种则是使用JIT 编译器将字节码转化为本地机器代码。 这两种方式的区别在于，前者启动速度快但运行速度慢，而后者启动速度慢但运行速度快。 因为解释器是解释执行，JIT编译器是编译执行，完成第一次编译后，其会将字节码对应的机器码保存下来，可以直接使用。机器码的运行效率肯定是高于 Java 解释器的。所以在实际情况中，为了运行速度以及效率，我们通常采用两者相结合的方式进行 Java 代码的编译执行。 HotSpot 虚拟机内置了两个即时编译器，分别称为 Client Compiler 和Server Compiler。这两种不同的编译器衍生出两种不同的编译模式，我们分别称之为：C1 编译模式，C2 编译模式。\n那么 C1 编译模式和 C2 编译模式有什么区别呢？\nC1 编译模式会将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。而 C2 编译模式，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。\n简单地说 C1 编译模式做的优化相对比较保守，其编译速度相比 C2 较快。而 C2 编译模式会做一些激进的优化，并且会根据性能监控做针对性优化，所以其编译质量相对较好，但是耗时更长。\n实际上对于 HotSpot 虚拟机来说，其一共有三种运行模式可选，分别是：\n混合模式（Mixed Mode） 。解释执行和编译执行混合使用，具体过程如下： 1、源代码经javac编译成字节码，class文件 2、程序字节码经过JIT环境变量进行判断，是否属于“热点代码”（多次调用的方法，或循环等） 3、如是，走JIT编译为具体硬件处理器（如sparc、intel）机器码 4、如否，则直接由解释器解释执行 5、操作系统及类库调用 6、硬件\n解释模式（Interpreted Mode）。即所有代码都解释执行，使用 -Xint 参数可以打开这个模式。\n编译模式（Compiled Mode）。 此模式优先采用编译，但是无法编译时也会解释执行，使用 -Xcomp 打开这种模式。\n在命令行中输入 java -version 可以看到，我机器上的虚拟机使用 Mixed Mode 运行模式。\n写到这里，我们了解了从 Java 源代码到字节码，再从字节码到机器码的全过程。本来到这里就应该结束了，但在我们 Java 中还有一个 AOT 编译器，它能直接将源代码转化为机器码。\nAOT 编译器：源代码到机器码 AOT 编译器的基本思想是：在程序执行前生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码。\n但是 Java 语言本身的动态特性带来了额外的复杂性，影响了 Java 程序静态编译代码的质量。例如 Java 语言中的动态类加载，因为 AOT 是在程序运行前编译的，所以无法获知这一信息，所以会导致一些问题的产生。类似的问题还有很多，这里就不一一举例了。\n总的来说，AOT 编译器从编译质量上来看，肯定比不上 JIT 编译器。其存在的目的在于避免 JIT 编译器的运行时性能消耗或内存消耗，或者避免解释程序的早期性能开销。\n在运行速度上来说，AOT 编译器编译出来的代码比 JIT 编译出来的慢，但是比解释执行的快。而编译时间上，AOT 也是一个始终的速度。所以说，AOT 编译器的存在是 JVM 牺牲质量换取性能的一种策略。就如 JVM 其运行模式中选择 Mixed 混合模式一样，使用 C1 编译模式只进行简单的优化，而 C2 编译模式则进行较为激进的优化。充分利用两种模式的优点，从而达到最优的运行效率。\n字节码文件结构 很多，暂时略\n线程 这里所说的线程，指的是程序执行过程中的一个线程实体，JVM 允许一个应用并发执行多个线程。Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。 当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。 Java 线程结束，原生线程随之被回收。 操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。 当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。 当线程结束时，会释放原生线程和 Java 线程的所有资源。\nHotspot JVM 后台运行的系统线程主要有下面几个：\n虚拟机线程（VM thread）： 这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-theworld 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。 周期性任务线程：这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。 GC 线程：这些线程支持 JVM 中不同的垃圾回收活动。 编译器线程：这些线程在运行时将字节码动态编译成本地平台相关的机器码。 信号分发线程：这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。 jvm内存区域 JVM 内存区域分为\n线程私有区域：程序计数器、虚拟机栈、本地方法区 线程私有数据区域的生命周期与线程相同，依赖用户线程的启动而创建，结束而销毁。 注：在 Hotspot VM 内，每个线程都与操作系统的本地线程直接映射，因此这部分内存区域的存/否跟随本地线程的生/死对应。 线程共享区域：堆区、方法区 线程共享区域，随虚拟机的启动而创建，关闭而销毁。 直接内存 直接内存并不是 JVM 运行时数据区的一部分，但也会被频繁的使用。在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展)，这样就避免了在 Java堆和 Native 堆中来回复制数据，因此在一些场景中可以显著提高性能。 程序计数器（线程私有） 程序计数器是一个记录着当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器。 JAVA代码编译后的字节码在未经过JIT（实时编译器）编译前，其执行方式是通过“字节码解释器”进行解释执行。简单的工作原理为解释器读取装载入内存的字节码，按照顺序读取字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转等流程。 从上面的描述中，可能会产生程序计数器是否是多余的疑问。因为沿着指令的顺序执行下去，即使是分支跳转这样的流程，跳转到指定的指令处按顺序继续执行是完全能够保证程序的执行顺序的。假设程序永远只有一个线程，这个疑问没有任何问题，也就是说并不需要程序计数器。但实际上程序是通过多个线程协同合作执行的。 首先我们要搞清楚JVM的多线程实现方式。JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都有属于自己的独立计数器。\n程序计数器的特点：\n线程隔离性，每个线程工作时都有属于自己的独立计数器。 执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址 执行native本地方法时，程序计数器的值为空（Undefined）。因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。 程序计数器占用内存很小，在进行JVM内存计算时，可以忽略不计。 程序计数器，是唯一一个在java虚拟机规范中没有规定任何 OutOfMemoryError 的区域。 问题：程序计数器是保存当前线程执行的字节码位置的，当调用本地方法的时候，字节码位置为Undefined，那么jvm是如何保证如果在执行本地方法的时候，被cpu暂停，再次恢复的时候能够找到执行的位置？ 本地方法执行完后，会出栈，栈帧中保存有方法的返回地址，可以通过这个找到下一条指令的位置。\n虚拟机栈（线程私有） 虚拟机栈是用于描述java方法执行的内存模型。 每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“局部变量表、操作数栈、动态链接、方法出口”几个部分。我们常说的“堆内存、栈内存”中的“栈内存”指的便是虚拟机栈，确切地说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。\n局部变量表存放了编译期可知的各种基本类型数据（boolean、byte、char、short、int、float、long、double）、对象引用、returnAddress类型（指向了一条字节码指令的地址）。\n方法调用时，创建栈帧，并压入虚拟机栈；方法执行完毕，栈帧出栈并被销毁，如下图所示： 虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈。\n虚拟机栈的StackOverflowError： 若单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。 JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用。\n虚拟机栈的OutOfMemoryError： 不同于StackOverflowError，OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。 JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常。\n本地方法栈（线程私有） 本地方法栈的功能和特点类似于虚拟机栈，均具有线程隔离的特点以及都能抛出StackOverflowError和OutOfMemoryError异常。 不同的是，本地方法栈服务的对象是JVM执行的native方法，而虚拟机栈服务的是JVM执行的java方法。如何去服务native方法？native方法使用什么语言实现？怎么组织像栈帧这种为了服务方法的数据结构？虚拟机规范并未给出强制规定，因此不同的虚拟机实可以进行自由实现，我们常用的HotSpot虚拟机选择合并了虚拟机栈和本地方法栈。\n堆Heap（线程共享） 堆是用于存放对象的内存区域。因此，它是垃圾收集器（GC）管理的主要目标。其具有以下特点：\n堆是所有线程共享的内存区域，因此每个线程都可以拿到堆上的同一个对象。 堆的生命周期是随着虚拟机的启动而创建。 堆占用的内存并不要求物理连续，只需要逻辑连续即可。 堆在逻辑上划分为“新生代”和“老年代”。由于JAVA中的对象大部分是朝生夕灭，还有一小部分能够长期的驻留在内存中，为了对这两种对象进行最有效的回收，将堆划分为新生代和老年代，并且执行不同的回收策略。不同的垃圾收集器对这2个逻辑区域的回收机制不尽相同。 堆一般实现成可扩展内存大小，使用“-Xms”与“-Xmx”控制堆的最小与最大内存，扩展动作交由虚拟机执行。但由于该行为比较消耗性能，因此一般将堆的最大最小内存设为相等。 Java 堆从 GC 的角度还可以细分为：\n新生代 Eden 区 From Survivor 区 To Survivor 区 老年代 新生代 新生代用来存放新生的对象。一般占据堆的 1/3 空间。 由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。 新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。\nEden 区 Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。 当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。\nSurvivorFrom 上一次 GC 的幸存者，作为这一次 GC 的被扫描者。\nSurvivorTo 保留了一次 MinorGC 过程中的幸存者。\nMinorGC MinorGC 采用复制算法，MinorGC的过程是（复制-\u003e清空-\u003e互换）\n首先，把 Eden 和 SurvivorFrom 区域中存活的对象复制到 SurvivorTo 区域（如果有对象的年龄以及达到了老年的标准，则复制到老年代区），同时把这些对象的年龄+1（如果 SurvivorTo 不够位置了就放到老年区） 然后，清空 Eden 和 SurvivorFrom 中的对象 最后，SurvivorTo 和 SurvivorFrom 互换，原 SurvivorTo 成为下一次 GC 时的 SurvivorFrom 区。 老年代 主要存放应用程序中生命周期长的内存对象。 老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。\nMajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。\n堆异常 当堆无法分配对象内存且无法再扩展时，会抛出OutOfMemoryError异常。 一般来说，堆无法分配对象时会进行一次GC，如果GC后仍然无法分配对象，才会报内存耗尽的错误。可以通过不断生成新的对象但不释放引用来模拟这种情形：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 /** * java堆溢出demo * JVM参数：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError */ public class HeapOOM { static class OOMObject { } public static void main(String[] args) { List list = new ArrayList\u003c\u003e(); //不断创建新对象，使得Heap溢出 while (true) { list.add(new OOMObject()); } } } 上述代码中对象不断的被创建而不进行引用释放，导致GC无法回收堆内存，最终OutOfMemoryError，错误信息：java.lang.OutOfMemoryError: Java heap space\n方法区（线程共享） 方法区，也称非堆（Non-Heap），又是一个被线程共享的内存区域。其中主要存储加载的类字节码、class/method/field等元数据对象、static-final常量、static变量、jit编译器编译后的代码等数据。另外，方法区包含了一个特殊的区域“运行时常量池”。\n加载的类字节码：要使用一个类，首先需要将其字节码加载到JVM的内存中。至于类的字节码来源，可以多种多样，如.class文件、网络传输、或cglib字节码框架直接生成。 class/method/field等元数据对象：字节码加载之后，JVM会根据其中的内容，为这个类生成Class/Method/Field等对象，它们用于描述一个类，通常在反射中用的比较多。不同于存储在堆中的java实例对象，这两种对象存储在方法区中。 static-final常量、static变量：对于这两种类型的类成员，JVM会在方法区为它们创建一份数据，因此同一个类的static修饰的类成员只有一份。 jit编译器的编译结果：以hotspot虚拟机为例，其在运行时会使用JIT即时编译器对热点代码进行优化，优化方式为将字节码编译成机器码。通常情况下，JVM使用“解释执行”的方式执行字节码，即JVM在读取到一个字节码指令时，会将其按照预先定好的规则执行栈操作，而栈操作会进一步映射为底层的机器操作；通过JIT编译后，执行的机器码会直接和底层机器打交道。 方法区的实现 虚拟机规范中并未明确规定方法区的实现，目前有2种比较主流的实现方式：\nHotSpot虚拟机1.7-：在JDK1.6及之前版本，HotSpot使用“永久代（permanent generation）”的概念作为实现，即将GC分代收集扩展至方法区。这种实现比较偷懒，可以不必为方法区编写专门的内存管理，但带来的后果是容易碰到内存溢出的问题（因为永久代有-XX:MaxPermSize的上限）。在JDK1.7+之后，HotSpot逐渐改变方法区的实现方式，如1.7版本移除了方法区中的字符串常量池。\nHotSpot虚拟机1.8+：1.8版本中移除了永久代并使用metaspace（元数据空间）作为替代实现。metaspace占用系统内存，也就是说，只要不碰触到系统内存上限，方法区会有足够的内存空间。 类的元数据放入 native memory，字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制，而由系统的实际可用空间来控制。 但这不意味着我们不对方法区进行限制，如果方法区无限膨胀，最终会导致系统崩溃。\n我们思考一个问题，为什么使用“永久代”并将GC分代收集扩展至方法区这种实现方式不好，会导致OOM？首先要明白方法区的内存回收目标是什么，方法区存储了类的元数据信息和各种常量，它的内存回收目标理应当是对这些类型的卸载和常量的回收。但由于这些数据被类的实例引用，卸载条件变得复杂且严格，回收不当会导致堆中的类实例失去元数据信息和常量信息。因此，回收方法区内存不是一件简单高效的事情，往往GC在做无用功。另外随着应用规模的变大，各种框架的引入，尤其是使用了字节码生成技术的框架，会导致方法区内存占用越来越大，最终OOM。\n参考《深入理解JAVA虚拟机第三版》中的一段话： 说到方法区，不得不提一下“永久代”这个概念，尤其是在JDK 8以前，许多Java程序员都习惯在 HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的 工作。但是对于其他虚拟机实现，譬如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要 没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法 （例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了 JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计 划了[1]，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta- space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。\n《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选 择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的 确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回 收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存 泄漏。\n运行时常量池 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字 段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生 成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 运行时常量池是方法区中一个比较特殊的部分，具备动态性，也就是说，除了类加载时将常量池写入其中，java程序运行期间也可以向其中写入常量：\n1 2 3 4 5 //使用StringBuilder在堆上创建字符串abc，再使用intern将其放入运行时常量池 String str = new StringBuilder(\"abc\").toString(); str.intern(); //直接使用字符串字面量xyz，其被放入运行时常量池 String str2 = \"xyz\"; 方法区异常 我们了解到方法区的2种实现方式最终都会有一个最大值上限，因此若方法区（含运行时常量池）占用内存到达其最大值，且无法再申请到内存时，便会抛出OutOfMemoryError。 在下面的例子中，我们将使用cglib字节码生成框架不断生成新的类，最终使方法区内存占用满，抛出OutOfMemoryError：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * java方法区溢出OutOfMemoryError（JVM参数适用于JDK1.6之前，借助CGLIB） * JVM参数：-XX:PermSize=10M -XX:MaxPermSize=10M */ public class JavaMethodAreaOOM { public static void main(String[] args) { while (true) { Enhancer enhancer = new Enhancer(); enhancer.setSuperclass(OOMObject.class); enhancer.setUseCache(false); enhancer.setCallback((MethodInterceptor) (o, method, objects, methodProxy) -\u003e methodProxy.invokeSuper(objects, args)); enhancer.create(); } } static class OOMObject { } } 其实，在日常开发中，不仅仅使CGlib字节码生成框架会产生大量的class信息，动态语言、JSP、基于OSGI的应用都会在方法区额外产生大量的类信息。\n直接内存 JVM的内存模型里并不包含直接内存，也就是说这块内存区域并不是JVM运行时数据区的一部分，但它却会被频繁的使用，原因是NIO这个包。 NIO（New input/output）是JDK1.4中新加入的类，引入了一种基于通道（channel）和缓冲区（buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过堆上的DirectByteBuffer对象对这块内存进行引用和操作。 直接内存的大小并不受到java堆大小的限制，甚至不受到JVM进程内存大小的限制。它只受限于本机总内存（RAM及SWAP区或者分页文件）大小以及处理器寻址空间的限制（最常见的就是32位/64位CPU的最大寻址空间限制不同）。\n直接内存的OufOfMemoryError 直接内存出现OutOfMemoryError的原因是对该区域进行内存分配时，其内存与其他内存加起来超过最大物理内存限制（包括物理的和操作系统级的限制），从而导致OutOfMemoryError。另外，若我们通过参数-XX:MaxDirectMemorySize指定了直接内存的最大值，其超过指定的最大值时，也会抛出内存溢出异常。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 /** * jvm直接内存溢出 * JVM参数：-Xmx20M -XX:MaxDirectMemorySize=10M */ public class DirectMemoryOOM { private static final int _1MB = 1024 * 1024; public static void main(String[] args) throws IllegalAccessException{ //通过反射获取Unsafe类并通过其分配直接内存 Field unsafeField = Unsafe.class.getDeclaredFields()[0]; unsafeField.setAccessible(true); Unsafe unsafe = (Unsafe) unsafeField.get(null); while (true) { unsafe.allocateMemory(_1MB); } } } 结果如下，可以看出，其抛出的内存溢出异常并没有指定是JVM哪一块数据区域：\n1 2 3 Exception in thread \"main\" java.lang.OutOfMemoryError at sun.misc.Unsafe.allocateMemory(Native Method) at com.manayi.study.jvm.chapter2._07_DirectMemoryOOM.main(_07_DirectMemoryOOM.java:22) 上面的例子有点特殊，因为我们使用到了Unsafe这个类（这个类为什么通过反射进行获取先不讨论），它的allocateMemory方法能够直接从堆外内存中申请内存（类比于c的malloc函数）。不同于DirectByteBuffer的内存分配方式（先计算是否有足够的可用内存再决定是手动抛异常还是向操作系统申请分配内存），Unsafe是直接向操作系统申请分配内存，若未申请到则抛异常。\n垃圾回收与算法 如何确定垃圾 引用计数法 在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，一个简单的办法是通过引用计数来判断一个对象是否可以回收。 给对象添加一个引用计数器，每当有一个地方引用它时计数器就+1，当引用失效时计数器就-1。只要计数器等于0的对象就是不可能再被使用的。 此算法在大部分情况下都是一个不错的选择，也有一些著名的应用案例。但是Java虚拟机中是没有使用的。 优点：实现简单、判断效率高。 缺点：很难解决对象之间循环引用的问题。\n1 2 3 4 5 Object a = new Object(); Object b = new Object(); a = b; b = a; a = b = null; //这样就导致gc无法回收他们，导致内存泄漏 可达性分析 通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。 主流的商用程序语言（Java、C#等）在主流的实现中，都是通过可达性分析来判定对象是否存活的。通过下图来清晰的感受gc root与对象展示的联系。所示灰色区域对象是存活的，Object5/6/7均是可回收的对象。 在Java语言中，可作为GC Roots 的对象包括下面几种\n虚拟机栈（栈帧中的本地变量表）中引用的对象 方法区中静态变量引用的对象 方法区中常量引用的对象 本地方法栈（即一般说的 Native 方法）中JNI引用的对象 优点：更加精确和严谨，可以分析出循环数据结构相互引用的情况； 缺点：实现比较复杂、需要分析大量数据，消耗大量时间、分析过程需要GC停顿（引用关系不能发生变化），即停顿所有Java执行线程（称为\"Stop The World\"，是垃圾回收重点关注的问题）。\n如何判断一个对象死亡 宣告一个对象死亡，至少要经历两次标记。\n第一次标记 如果对象进行可达性分析算法之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。 筛选条件：判断此对象是否有必要执行finalize()方法。 筛选结果：当对象没有覆盖finalize()方法、或者finalize()方法已经被JVM执行过，则判定为可回收对象。如果对象有必要执行finalize()方法，则被放入F-Queue队列中。稍后在JVM自动建立、低优先级的Finalizer线程（可能多个线程）中触发这个方法；\n第二次标记 GC对F-Queue队列中的对象进行二次标记。 如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。\nfinalize() 方法 finalize()是Object类的一个方法、一个对象的finalize()方法只会被系统自动调用一次，经过finalize()方法逃脱死亡的对象，第二次不会再调用； 特别说明：并不提倡在程序中调用finalize()来进行自救。建议忘掉Java程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（Java程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。\n回收方法区 有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载），方法区垃圾收集 的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。\n回收废弃常量 回收废弃常量与Java堆的回收类似。假如一个字符串“abc” 已经进入常量池中，但当前系统没有一个string对象是叫做abc的，也就是说，没有任何string对象的引用指向常量池中的abc常量，也没用其他地方引用这个字面量。如果这是发生内存回收，那么这个常量abc将会被清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。\n回收无用的类 需要同时满足下面3个条件的才能算是无用的类。\n该类所有的实例都已经被回收，也就是Java堆中无任何改类的实例。 加载该类的ClassLoader已经被回收。 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法虚拟机可以对同时满足这三个条件的类进行回收，但不是必须进行回收的。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。 分代收集理论 分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将堆区划分为老年代(Tenured/Old Generation)和新生代(Young Generation)。 老年代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。\n新生代与复制算法 目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space，To Space)，每次使用Eden 空间和中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。 老年代与标记整理算法 老年代因为对象存活率高，每次只回收少量对象，因而采用 Mark-Compact 算法。\n分区收集理论 分区算法则将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收。这样做的好处是可以控制一次回收多少个小区间，根据目标停顿时间，每次合理地回收若干个小区间(而不是整个堆)，从而减少一次 GC 所产生的停顿，G1收集器就是分区。\n标记清除算法(Mark-Sweep) “标记 - 清除”算法是最基础的垃圾收集算法，如同它的名字一样，算法的工作过程可以分为“记”和“清除”两个阶段：首先标记出所有需要回收的对象，然后统一回收所有被标记的对象。 标记待回收象：使用可达性分析算法筛选出所有没有可达链的对象。若对象覆盖了finalize方法且虚拟机还没有调用finalize方法，对象将被加入一个名为F-Queue的队列，后续将由虚拟机创建一个名为Finalizer的线程，逐个执行F-Queue队列每个对象的finalize方法。对象可以在finalize方法中和其他具有可达链的对象建立联系，从而避免本次的垃圾收集。需要注意的是，任何对象的finalize方法只会被执行一次。\n标记清除算法主要存在两个问题\n效率问题。标记和清除两个过程的效率都不高。 空间问题。可能产生大量的不连续的内存碎片，进而导致空间利用率下降，垃圾收集频率变高。 复制算法(copying) 为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图： 这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。\n标记整理算法(Mark-Compact) 标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图： 优点：不会像复制算法那样随着存活对象的升高而降低效率，不像标记-清除算法那样产生不连续的内存碎片。 缺点：效率问题，除了像标记-清除算法的标记过程外，还多了一步整理过程，效率更低。\n垃圾回收的类型（Minor GC\\Major GC\\FullGC） Minor GC 从新生代空间回收内存被称为 Minor GC，有时候也称之为 Young GC。 当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以 Eden 区越小，越频繁执行 Minor GC。\n当新生代中的 Eden 区分配满的时候，年轻代中的部分对象会晋升到老年代，所以 Minor GC 后老年代的占用量通常会有所升高。\n因为Minor GC 都会触发 Stop-The-World，停止应用程序的线程。 对于大部分应用程序，停顿导致的延迟都是可以忽略不计的，因为大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。 如果情况相反，即 Eden 区大部分新生对象不符合 GC 条件（即他们不被垃圾回收器收集），那么 Minor GC 执行时暂停的时间将会长很多（因为JVM要将他们复制到 Survivor 区或老年代）。\nMajor GC 从老年代空间回收内存被称为 Major GC，有时候也称之为 Old GC。 许多 Major GC 是由 Minor GC 触发的，所以很多情况下将这两种 GC 分离是不太可能的。 Minor GC 作用于新生代，Major GC 作用于老年代。 分配对象内存时发现内存不够，触发 Minor GC。Minor GC 会将对象移到老年代中，如果此时老年代空间不够，那么触发 Major GC。因此才会说，许多 Major GC 是由 Minor GC 引起的。\nFull GC Full GC 是清理整个堆空间和方法区。因此 Full GC 可以说是 Minor GC 和 Major GC 的结合。 当准备要触发一次 Minor GC 时，如果发现年轻代的剩余空间比以往晋升的空间小，则不会触发 Minor GC 而是转为触发 Full GC。因为JVM此时认为：之前这么大空间的时候已经发生对象晋升了，那现在剩余空间更小了，那么很大概率上也会发生对象晋升。既然如此，那么我就直接帮你把事情给做了吧，直接来一次 Full GC，整理一下老年代和年轻代的空间。另外，在给方法区分配空间时，如果没有足够空间，也会触发 Full GC。\nStop-The-World Stop-The-World，中文一般翻译为全世界暂停，是指在进行垃圾回收时因为标记或清理的需要，必须让所有执行任务的线程停止执行任务，从而让垃圾回收线程回收垃圾的时间间隔。\n在 Stop-The-World 这段时间里，所有非垃圾回收线程都无法工作，都暂停下来。只有等到垃圾回收线程工作完成才可以继续工作。可以看出，Stop-The-World 时间的长短将关系到应用程序的响应时间，因此在 GC 过程中，Stop-The-World 的时间是一个非常重要的指标。\n垃圾收集器（GC） 如果说收集算法是内存回收的方法论，那垃圾收集器就是内存回收的实践者。 上图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。\n新生代收集器：Serial、ParNew、Parallel Scavenge 老年代收集器：CMS、Serial Old、Parallel Old 整堆收集器： G1\n几个相关概念： 并行收集：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。\n并发收集：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。\n吞吐量：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )）。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%\nSerial 垃圾收集器（新生代、单线程、复制算法） Serial 垃圾收集器是HotSpot虚拟机运行在客户端模式下的默认新生代收集器。 特点：单线程、简单高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）。 应用场景：适用于Client模式下的虚拟机。 Serial / Serial Old收集器运行示意图 ParNew 垃圾收集器（新生代、Serial + 多线程） ParNew收集器其实就是Serial收集器的多线程版本。 除了使用多线程外其余行为均和Serial收集器一模一样（参数控制、收集算法、Stop The World、对象分配规则、回收策略等）。 特点：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用-XX:ParallelGCThreads参数来限制垃圾收集的线程数。 和Serial收集器一样存在Stop The World问题。 应用场景：ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，因为它是除了Serial收集器外，唯一一个能与CMS收集器配合工作的。 因为G1是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作。所以自JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。 ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器。\nParallel Scavenge收集器（新生代、复制算法、吞吐量优先） 新生代收集器 采用复制算法 并行的多线程收集器（与ParNew收集器类似）。 与吞吐量关系密切，故也称为吞吐量优先收集器。 吞吐量 = 运行用户代码时间 / 运行用户代码时间 + 运行垃圾收集时间\n如果虚拟机完成某个任务，用户代码加上垃圾收集总共耗费了100分钟，其中垃圾收集花掉1分 钟，那吞吐量就是99%。停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良 好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算 任务，主要适合在后台运算而不需要太多交互的分析任务。\nParallel Scavenge收集器提供了两个参数用于精确控制吞吐量\n控制最大垃圾收集停顿时间：-XX：MaxGCPauseMillis 允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的 时间不超过用户设定值\n直接设置吞吐量大小：-XX：GCTimeRatio 值应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的 比率，相当于吞吐量的倒数。譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5% （即1/(1+19)），默认值为99，即允许最大1%（即1/(1+99)）的垃圾收集时间。\n自适应调节策略 -XX：+UseAdaptiveSizePolicy 这是一 个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区 的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数 了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。 自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。\nSerial Old 收集器（老年代、单线程、标记整理算法 ） Serial Old是Serial收集器的老年代版本。 同样是单线程收集器，采用标记-整理算法。 主要也是使用在Client模式下的虚拟机中。也可在Server模式下使用。 Server模式下主要的两大用途：\n在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用。 作为CMS收集器的后备方案，在并发收集Concurent Mode Failure时使用。 Serial / Serial Old收集器工作过程图（Serial收集器图示相同） Parallel Old 收集器（老年代、多线程、标记整理算法） Parallel Old 收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，吞吐量优先。 在 JDK1.6才开始提供。在 JDK1.6 之前，新生代使用 Parallel Scavenge 收集器只能搭配老年代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。 其他表现良好的老年代收集器，如CMS无法与它配合工作。 直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，可以优先考虑新生代 Parallel Scavenge和老年代 Parallel Old 收集器的搭配策略。\n新生代 Parallel Scavenge 和老年代 Parallel Old 收集器搭配运行过程图： CMS 收集器（老年代、多线程、标记清除算法） CMS（Concurrent mark sweep） 收集器是一种老年代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他老年代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：\n初始标记 只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。\n并发标记 进行 GC Roots Tracing 的过程，找出存活对象，和用户线程一起工作，不需要暂停工作线程。\n重新标记 为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记 记录，仍然需要暂停所有的工作线程。\n并发清除 清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。\n由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。\nCMS 收集器工作过程： 缺点：\n对CPU资源非常敏感 面向并发设计的程序都会对CPU资源较敏感。CMS默认的回收线程数: （CPU数量+3）/4\n无法处理浮动垃圾 可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。并发清理阶段用户程序运行产生的垃圾过了标记阶段所以无法在本次收集中清理掉，称为浮动垃圾。CMS收集器默认在老年代使用了68%的空间后被激活。 若老年代增长的不是很快，可以适当调高参数-XX:CMSInitiatingOccupancyFraction 提高触发百分比，但调得太高会容易导致“Concurrent Mode Failure”失败。\n基于“标记-清除”算法会产生大量空间碎片。 提供开关参数-XX:+UseCMSCompactAtFullCollection 用于在“ 享受”完Full GC服务之后进行碎片整理过程，内存整理的过程是无法并发的。 但是停顿时间会变长。-XX:CMSFullGCsBeforeCompation设置在执行多少次不压缩的FullGC后，跟来一次带压缩的。\nG1收集器 Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收集器两个最突出的改进是：\n基于标记-整理算法，不产生内存碎片。 可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。 G1收集器可以在几乎不牺牲吞吐量的前提下完成低停顿的内存回收，这是由于它能够极力避免全区域的垃圾收集，之前的收集器进行收集的范围都是整个新生代或老年代，而G1将整个Java堆（包括新生代、老年代）划分为多个大小固定的独立区域（Region），并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域（这就是Garbage First名称的由来）。区域划分、有优先级的区域回收，保证了G1收集器在有限的时间内可以获得最高的收集效率。\nG1收集器的特点：\n并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间。部分收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让Java程序继续运行。\n分代收集：G1能够独自管理整个Java堆，并且采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。\n空间整合：G1运作期间不会产生空间碎片，收集后能提供规整的可用内存。\n可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。\nG1为什么能建立可预测的停顿时间模型？ 因为它有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。这样就保证了在有限的时间内可以获取尽可能高的收集效率。\nG1与其他收集器的区别： 其他收集器的工作范围是整个新生代或者老年代、G1收集器的工作范围是整个Java堆。在使用G1收集器时，它将整个Java堆划分为多个大小相等的独立区域（Region）。虽然也保留了新生代、老年代的概念，但新生代和老年代不再是相互隔离的，他们都是一部分Region（不需要连续）的集合。\nG1收集器存在的问题： Region不可能是孤立的，分配在Region中的对象可以与Java堆中的任意对象发生引用关系。在采用可达性分析算法来判断对象是否存活时，得扫描整个Java堆才能保证准确性。其他收集器也存在这种问题（G1更加突出而已）。会导致 Minor GC效率下降。\nG1收集器是如何解决上述问题的？\n采用Remembered Set来避免整堆扫描。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用对象是否处于多个Region中（即检查老年代中是否引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆进行扫描也不会有遗漏。\n如果不计算维护 Remembered Set 的操作，G1收集器大致可分为如下步骤：\n初始标记：仅标记GC Roots能直接到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象。（需要线程停顿，但耗时很短。）\n并发标记：从GC Roots开始对堆中对象进行可达性分析，找出存活对象。（耗时较长，但可与用户程序并发执行）\n最终标记：为了修正在并发标记期间因用户程序执行而导致标记产生变化的那一部分标记记录。且对象的变化记录在线程Remembered Set Logs里面，把Remembered Set Logs里面的数据合并到Remembered Set中。（需要线程停顿，但可并行执行。）\n筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。（可并发执行）\nG1收集器运行示意图： 垃圾收集参考\nJVM类加载机制 参考 类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。\n加载 加载的过程 通过一个类的全限定名来获取其定义的二进制字节流。 不仅可以从Class文件中获取，还可以从Jar包中获取、网络中获取。 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。 在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。 相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。\n加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。\n类加载时机 创建类的实例，也就是new一个对象 访问某个类或接口的静态变量，或者对该静态变量赋值 调用类的静态方法 反射（Class.forName(“com.lyj.load”)） 初始化一个类的子类（会首先初始化子类的父类） JVM启动时标明的启动类，即文件名和类名相同的那个类 除此之外，下面几种情形需要特别指出： 对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。\n类加载器 java代码通过javac编译成class文件，而类加载器的作用，就是把class文件装进虚拟机。 类加载器负责加载所有的类，其为所有被载入内存中的类生成一个 java.lang.Class 实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。 在Java中，一个类用其全限定类名（包括包名和类名）作为标识； 但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。 例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例 kl 加载后，Person类对应的Class对象在JVM中表示为(Person.pg.kl)。 被类加载器ClassLoader的实例 kl2 加载后，Person类对应的Class对象在JVM中表示为(Person.pg.kl2)。 也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。\n既然只是把class文件装进虚拟机，为什么要用多种加载器呢？因为Java虚拟机启动的时候，并不会一次性加载所有的class文件（内存会爆），而是根据需要去动态加载。\n站在Java虚拟机的角度来讲，只存在两种不同的类加载器：\n启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分，是无法被Java程序直接引用的。 所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。 站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：\n启动类加载器（Bootstrap ClassLoader）：它负责加载java核心类库，可以直接打印启动类加载器BootstrapClassLoader的加载路径看看： 1 2 3 4 URL[] urls = sun.misc.Launcher.getBootstrapClassPath().getURLs(); for (URL url : urls) { System.out.println(url); } 输出结果（%20是空格）：\n1 2 3 4 5 6 7 8 file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/lib/resources.jar file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/lib/rt.jar file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/lib/sunrsasign.jar file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/lib/jsse.jar file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/lib/jce.jar file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/lib/charsets.jar file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/lib/jfr.jar file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/classes 主要是$JAVA_HOME/jre/lib下的类，可以说所有的java.*开头的类均被Bootstrap ClassLoader加载。\n扩展类加载器（Extension ClassLoader） 该加载器由sun.misc.Launcher$ExtClassLoader实现，通过程序查看扩展类加载器加载了哪些类： 1 2 3 4 URL[] urls = ((URLClassLoader) ClassLoader.getSystemClassLoader().getParent()).getURLs(); for (URL url : urls) { System.out.println(url); } 输出结果：略 扩展类加载器加载的是$JAVA_HOME/jre/lib/ext目录下的扩展包。这些类库具体是什么不重要，只需要知道不同的类库可能是被不同的类加载器加载的。\n应用程序类加载器（Application ClassLoader）： 该类加载器由sun.misc.Launcher$AppClassLoader来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：\n在执行非置信代码之前，自动验证数字签名。 动态地创建符合用户特定需要的定制化构建类。 从特定的场所取得java class，例如数据库中和网络中。 事实上当使用Applet的时候，就用到了特定的ClassLoader，因为这时需要从网络上加载java class，并且要检查相关的安全信息，应用服务器也大都使用了自定义的ClassLoader技术。\n这几种类加载器的层次关系如下（由高到低）： 启动类加载器-\u003e扩展类加载器-\u003e应用程序类加载器-\u003e自定义加载器\n双亲委派模型 这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。\n然而这是一个很有误导性的术语，它应该叫做单亲委派模型（Parent-Delegation Model）。但是没有办法，大家都已经这样叫了。所谓双亲委派，这个亲就是指ClassLoader里的全局变量parent，也就是父加载器。\n双亲委派模型的工作流程是：\n当一个类加载器接收到类加载任务时，先查缓存里有没有，如果没有，将任务委托给它的父加载器去执行。 父加载器也做同样的事情，一层一层往上委托，直到最顶层的启动类加载器为止。 如果启动类加载器没有找到所需加载的类，便将此加载任务退回给下一级类加载器去执行，而下一级的类加载器也做同样的事情。 如果最底层类加载器仍然没有找到所需要的class文件，则抛出异常。 所以是一条线传上再传下，并没有什么“双亲”。整个过程的Java实现也没有什么神秘的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 public abstract class ClassLoader { // name: Class文件的绝对路径 // resolve: 找到后是否立即解析（什么是解析？） protected Class\u003c?\u003e loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (lock) { // 尝试从缓存获取，这也是为什么修改了Class后需重启JVM才能生效 Class\u003c?\u003e target = findLoadedClass(name); // native方法 if (target == null) { try { if (parent != null) { // 委托给父加载器， 只查找不解析 target = parent.loadClass(name, false); } else { // 父加载器为null，则委托给启动类加载器BootstrapClassloader target = findBootstrapClassOrNull(name); // native方法 } } catch (ClassNotFoundException e) {...} if (target == null) { // 父加载器没有找到，才调用自己的findClass()方法 target = findClass(name); } } if (resolve) { resolveClass(target); // native方法 } return target; } } // findClass是模板方法，需要重写 protected Class\u003c?\u003e findClass(String name) throws ClassNotFoundException { throw new ClassNotFoundException(name); } } 到现在就剩下findClass这个模板方法了，URLClassLoader继承了ClassLoader以后，重写了此方法，做了三件事：\n1 2 3 4 5 6 7 protected Class\u003c?\u003e findClass(final String name) throws ClassNotFoundException { // 1、安全检查 // 2、根据绝对路径把硬盘上class文件读入内存 byte[] raw = getBytes(name); // 3、将二进制数据转换成class对象 return defineClass(raw); } 如果我们自己去实现一个类加载器，基本上就是继承ClassLoader之后重写findClass方法，且在此方法的最后调用defineClass方法。\n为什么要双亲委派 确保类的全局唯一性。 例如，类java.lang.Object存放在 jre\\lib\\rt.jar中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器（BootstrapClassLoader）进行加载，其他类加载器没有机会再去加载，保证了Object类在程序中的各种类加载器中都是同一个类。\n参考\nOSGI（动态模型系统） OSGi(Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系统的一系列规范。\n动态改变构造 OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。\n模块化编程与热插拔 OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以实现模块级的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企业级程序开发来说是非常具有诱惑力的特性。OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。 OSGI参考\n验证 这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。\n准备 准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。对于该阶段有以下几点需要注意：\n这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。 这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。 假设一个类变量的定义为： public static int value = 3;\n那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器（）方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。\n另外，如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。 public static final int value = 3; 编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。回忆上一篇博文中对象被动引用的第2个例子，便是这种情况。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中。\n解析 解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断。 对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。 解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中\n1 2 3 4 CONSTANT_Class_info、 CONSTANT_Fieldref_info、 CONSTANT_Methodref_info、 CONSTANT_InterfaceMethodref_info 四种常量类型。\n类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。\n接口方法解析：与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。\n类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。\n字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下所示： 本类-\u003e接口-\u003e父接口-\u003e父类-\u003e祖父类\n从下面代码看出来字段解析的搜索顺序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 class Super{ public static int m = 11; static{ System.out.println(\"执行了super类静态语句块\"); } } class Father extends Super{ public static int m = 33; static{ System.out.println(\"执行了父类静态语句块\"); } } class Child extends Father{ static{ System.out.println(\"执行了子类静态语句块\"); } } public class StaticTest{ public static void main(String[] args){ System.out.println(Child.m); } } 执行结果如下： 执行了super类静态语句块 执行了父类静态语句块 33 如果注释掉Father类中对m定义的那一行，则输出结果如下： 执行了super类静态语句块 11 static变量发生在静态解析阶段，也即是初始化之前，此时已经将字段的符号引用转化为了内存引用，也便将它与对应的类关联在了一起，由于在子类中没有查找到与m相匹配的字段，那么m便不会与子类关联在一起，因此并不会触发子类的初始化。 最后需要注意：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译。如果对上面的代码做些修改，将Super改为接口，并将Child类继承Father类且实现Super接口，那么在编译时会报出如下错误：\n1 2 StaticTest.java:24: 对 m 的引用不明确，Father 中的 变量 m 和 Super 中的 变量 m 都匹配System.out.println(Child.m); 初始化 初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载 器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。 在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器 ()方法的过程。 （）方法的执行规则：\n（） 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。 - （） 方法与实例构造器（）方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的（）方法执行之前，父类的（）方法已经执行完毕。因此，在虚拟机中第一个被执行的（）方法的类肯定是java.lang.Object。 （）方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成（）方法。 接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成（）方法。但是接口鱼类不同的是：执行接口的（）方法不需要先执行父接口的（）方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的（）方法。 虚拟机会保证一个类的（）方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的（）方法，其他线程都需要阻塞等待，直到活动线程执行（）方法完毕。如果在一个类的（）方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。 下面给出一个简单的例子，以便更清晰地说明如上规则：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Father{ public static int a = 1; static{ a = 2; } } class Child extends Father{ public static int b = a; } public class ClinitTest{ public static void main(String[] args){ System.out.println(Child.b); } } 执行上面的代码，会打印出2，也就是说b的值被赋为了2。 我们来看得到该结果的步骤。首先在准备阶段为类变量分配内存并设置类变量初始值，这样A和B均被赋值为默认值0，而后再在调用（）方法时给他们赋予程序中指定的值。当我们调用Child.b时，触发Child的（）方法，根据规则2，在此之前，要先执行完其父类Father的（）方法，又根据规则1，在执行（）方法时，需要按static语句或static变量赋值操作等在代码中出现的顺序来执行相关的static语句，因此当触发执行Father的（）方法时，会先将a赋值为1，再执行static语句块中语句，将a赋值为2，而后再执行Child类的（）方法，这样便会将b的赋值为2。\n如果我们颠倒一下Father类中“public static int a = 1;”语句和“static语句块”的顺序，程序执行后，则会打印出1。很明显是根据规则1，执行Father的（）方法时，根据顺序先执行了static语句块中的内容，后执行了“public static int a = 1;”语句。 另外，在颠倒二者的顺序之后，如果在static语句块中对a进行访问（比如将a赋给某个变量），在编译时将会报错，因为根据规则1，它只能对a进行赋值，而不能访问。\n注意以下几种情况不会执行类初始化：\n通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。 定义对象数组，不会触发该类的初始化。 常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。 通过类名获取 Class 对象，不会触发类的初始化。 通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。 通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。 JVM参数 堆栈空间配置 总结 参数 含义 -Xms 初始堆大小 -Xmx 最大堆空间 -Xmn 设置新生代大小 -XX:SurvivorRatio 设置新生代eden空间和from/to空间的比例关系 -XX:PermSize 方法区初始大小 -XX:MaxPermSize 方法区最大大小 -XX:MetaspaceSize 元空间GC阈值（JDK1.8） -XX:MaxMetaspaceSize 最大元空间大小（JDK1.8） -Xss 栈大小 -XX:MaxDirectMemorySize 直接内存大小，默认为最大堆空间 堆配置 堆的初始空间大小：-Xms 堆的最大空间大小：-Xmx\n设置 JVM 的初始堆大小为 20M，最大堆空间为 30M java -Xms20m -Xmx30m GCDemo.jar\n新生代 在 JDK1.8 中，堆分为年轻代和老年代。 设置年轻代内存的大小：-Xmn jvm没有提供参数设置老年代的大小。但其实老年代的大小就等于堆大小减去年轻代大小。\n设置 JVM 堆初始大小为20M。其中年轻代的大小为 10M，那么剩下的就是老年代的大小，有 10M了 java -Xms20m -Xmn10M GCDemo 可以给上述命令加上-XX:+PrintGCDetails参数来查看内存区域的分配信息。\nEden区 在年轻代中，分为三个区域，分别是：eden 空间、from 空间、to 空间。如果要设置这部分的大小，那么就使用 -XX:SurvivorRatio 这个参数，该参数设置 eden / from 空间的比例关系，该参数的公式如下： -XX:SurvivorRatio = eden/from = eden/to 例如我们的年轻代有 10 M，而我们设置 -XX:SurvivorRatio 参数为 2。也就是说 eden / from = eden / to = 2。这里教一个快速计算的方法，我们假设 eden = 2，那么 from = 1，to = 1，那么 eden + from + to = 10M。这样就可以算出每一份大小是 10/4 = 2.5M。所以 Eden 区 = 2.5 * 2 = 5M，from 区是 2.5 M，to 区是 2.5 M。\n下面我们运行下命令来验证一下。 java -Xms20m -Xmn10M -XX:SurvivorRatio=2 -XX:+PrintGCDetails GCDemo 在上面的启动参数中，我们设置堆初始大小为 20M，年轻代大小为 10M，年轻代的 SurvivorRatio 比例为 2。那么最终分配的结果将会是：年轻代 10M，其中 Eden 区 5M、From 区 2.5M、To 区 2.5 M，老年代 10M。\n查看-XX:+PrintGCDetails的结果，可以得知： eden 空间是 5120 K，from 和 to 空间是 2560 K。 Details的结果还有一个细节，即 PSYoungGen 这里的 total 只有 7680K，难道年轻代只有 7.5M 的内存吗？为什么不是 10M 呢？其实是因为这里的 total 指的是可用内存。 from space 和 to space 两个区域同一时间只有一个区域是可以用的。 所以可用内存是 （eden）5120 +（from 或 to） 2560 = 7680。\n永久代（JDK1.7） 在 JDK 1.8 之前，所加载的类信息都放在永久代中。我们用 -XX:PermSize 设置永久代初始大小，用 -XX:MaxPermSize 设置永久代最大大小。 java -XX:PermSize10m -XX:MaxPermSize50m -XX:+PrintGCDetails GCDemo 在上面的启动参数中，我们设置永久代初始大小为 10M，最大大小为 50M。我们在 JDK1.7 的环境下运行上面的命令，会看到如下的 GC 日志，略。\n元空间（JDK1.8） 在 JDK 1.8 之前，所有加载的类信息都放在永久代中。但在 JDK1.8 之时，永久代被移除，取而代之的是元空间（Metaspace）。在元空间这块内存中，有两个参数很相似，它们是： -XX:MetaspaceSize：元空间发生 GC 的初始阈值 -XX:MaxMetaspaceSize：元空间的最大大小\njava -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=50m -XX:+PrintGCDetails GCDemo 上面的命令中，我们设置 MetaspaceSize 为 10M，MaxMetaspaceSize 为 50M。\n1 2 Metaspace used 2639K class space used 286K 从上面的执行结果可以看到，Metaspace 空间的大小为 2.6M 左右，并不是我们设置的 10M。那是因为 MetaspaceSize 设置的是元空间发生 GC 的初始阈值。当达到这个值时，元空间发生 GC 操作，这个值默认是 20.8M。而 MaxMetaspaceSize 则是设置元空间的最大大小，默认基本是机器的物理内存大小。虽然可以不设置，但还是建议设置一下，因为如果一直不断膨胀，那么 JVM 进程可能会被 OS kill 掉。\n栈空间 栈空间是每个线程各自有的一块区域，如果栈空间太小，也会导致 StackOverFlow 异常。而要设置栈空间大小，只需要使用 -Xss 参数就可以。 java -Xss2m GCDemo 上面的启动命令设置最大栈空间为 2M。\n直接内存 使用 -XX:MaxDirectMemorySize 设置最大直接内存。如果不设置，默认为最大堆空间，即 -Xmx。 java -XX:MaxDirectMemorySize=50m GCDemo 上面的启动命令设置直接内存最大值为 50M。 当直接内存使用达到设置值时，就会触发垃圾回收。如果不能有效释放足够空间，就会引发直接内存溢出导致系统的 OOM。\n查看JVM参数 打印显式参数 -XX:+PrintVMOptions 该参数表示程序运行时，打印虚拟机接受到的命令行显式参数。我们用下面的命令运行程序： java -XX:+UseSerialGC -XX:+PrintVMOptions com.wjy.ClassLoadDemo 输出结果： 1 2 3 VM option '+UseSerialGC' VM option '+PrintVMOptions' Hello, I'm wjy 可以看到我们设置了+UseSerialGC和+PrintVMOptions两个参数，最后运行时也将这两个参数打印出来了。\n打印显式隐式参数 -XX:+PrintCommandLineFlags 该参数打印传递给虚拟机的显式和隐式参数。我们用下面的命令运行程序： java -XX:+UseSerialGC -XX:+PrintCommandLineFlags com.wjy.ClassLoadDemo 输出：\n1 2 3 4 -XX:InitialHeapSize=134217728 -XX:MaxHeapSize=2147483648 -XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseSerialGC Hello, I'm wjy 可以看到程序不仅输出了我们显式设置的参数，还将虚拟机默认的参数打印了出来，包括初始堆大小（134217728），最大堆大小（2147483648）等。\n打印所有系统参数 -XX:+PrintFlagsFinal java -XX:+UseSerialGC -XX:+PrintFlagsFinal com.wjy.ClassLoadDemo \u003e jvm_flag_final.txt 之后打开 jvm_flag_final.txt 文件，可以看到有 800 多行，这是因为程序将虚拟机的所有参数都打印了出来。下面列几个我们常用的参数看看就可以：\n1 2 3 4 5 6 ... uintx InitialHeapSize := 134217728 {product} ... uintx MaxMetaspaceSize = 18446744073709547520 {product} ... uintx MetaspaceSize = 21807104 {pd product} 从上面我们列出的部分参数可以看到，上面三个参数分别是设置初始堆大小、元空间最大大小、初始元空间大小。\n追踪类信息 我们都知道 JVM 在启动的时候会去加载类信息，那么我们怎么得知他加载了哪些类，又卸载了哪些类呢？我们这一节就来介绍四个 JVM 参数，使用它们我们就可以清晰地知道 JVM 的类加载信息。 为了方便演示，我们使用下面的程序作为本次的演示程序。\n1 2 3 4 5 6 public class ClassLoadDemo { public static void main(String[] args) { String name = \"chenshuyi\"; System.out.println(\"Hello, I'm \" + name); } } 跟踪类的加载和卸载 -verbose:class java -verbose:class com.chenshuyi.ClassLoadDemo \u003e class_load_info.txt 之后我们打开 class_load_info.txt 文件。因为该文件太大，所以我们节选一部分： 1 2 3 4 5 6 7 ...省略... [Loaded java.util.ArrayList from /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/rt.jar] ...省略... [Loaded java.util.HashMap from /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/rt.jar] ...省略...\t[Loaded com.chenshuyi.ClassLoadDemo from file:/Users/yurongchan/Yosemite/Code/practice/target/classes/] ...省略... 从上面可以看到 JVM 分别加载了 ArrayList、HashMap 类，以及我们自己定义的 ClassLoadDemo 类。\n跟踪类的加载 -XX:+TraceClassLoading 该参数与可以显示类的加载信息，输出的结果和 -verbose:class 一样，但比起它少了类的卸载信息。\n跟踪类的卸载 -XX:+TraceClassUnloading 该参数与可以显示类的加载信息，输出的结果和 -verbose:class 一样，但比起它少了类的加载信息。但实际上我们通过上面这个简单的例子，没有发现类的卸载信息，或许是例子太简单了，所以没有这个。\n-XX:+PrintClassHistogram 该参数表示遇到 Ctrl-Break 后打印类实例的柱状信息，与 jmap -histo 功能相同。 了解了这些参数，能够让我们更好地了解哪些类已经被加载到 JVM 中，从而更好地排查问题。最后来个总结，加强记忆：\n参数 含义 -verbose:class 跟踪类的加载和卸载 -XX:+TraceClassLoading 跟踪类的加载 -XX:+TraceClassUnloading 跟踪类的卸载 -XX:+PrintClassHistogram 显示类信息柱状图 GC日志配置 对于 GC 日志，我们不仅要学会看懂，而且要学会如何设置对应的 GC 日志参数。 为了能够更直观地显示出每个参数的作用，我们将以下面的 Demo 为例子去设置 GC 日志参数。\n1 2 3 4 5 6 7 8 9 10 public class GCDemo { public static void main(String[] args) { // allocate 4M space byte[] b = new byte[4 * 1024 * 1024]; System.out.println(\"first allocate\"); // allocate 4M space b = new byte[4 * 1024 * 1024]; System.out.println(\"second allocate\"); } } 在上面的程序中，我们两次分配了 4M 的内存空间。为了认为制造 GC，我们启动时的 JVM 参数固定加上下面几个参数： -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8\n-XX：UseSerialGC 表示强制使用Serial+SerialOld收集器组合 -Xms20m 表示堆空间初始大小为 20 M。 -Xmx20m 表示堆空间最大大小为 20 M。 -Xmn10m 表示新生代大小为 10M。 -XX：urvivorRatio=8 表示Eden:Survivor=8:1 经过上面这个设置，此时我们的堆空间的内存比例情况如下：Eden区 8M，FromSurvivor 1M，ToSurvivor 1M，老年代 10M。\n打印GC日志 在 GC 日志参数中，最简单的一个参数就是打印 GC 日志：-XX:PrintGC。我们用下面的命令运行程序： java -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGC com.chenshuyi.GCDemo\n输出结果：\nfirst allocate second allocate [GC (Allocation Failure) 4767K-\u003e4374K(19456K), 0.0045179 secs]\n可以看到程序在第一次分配数组空间的时候发生了 GC，并且把 GC 前后以及堆空间大小都打印了出来。该日志显示 GC 前堆空间使用量为 4767K（4M左右）。GC 后堆空间为 4374K，当前可用堆大小为 19456K。\n但你会发现使用 PrintGC 参数打印出来的日志比较简单，无法查看更详细的信息。如果你要查看更详细的信息，那么就需要下面这个参数。\n打印详细GC日志 如果要查看更加详细的 GC 日志，那么就要使用 -XX:+PrintGCDetails 参数。下面我们使用该参数运行程序： java -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGC com.chenshuyi.GCDemo\n程序输出：\n1 2 3 4 5 6 7 8 9 10 11 12 first allocate second allocate [GC (Allocation Failure) [DefNew: 4603K-\u003e278K(9216K), 0.0036744 secs] 4603K-\u003e4374K(19456K), 0.0037100 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap def new generation total 9216K, used 4538K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) eden space 8192K, 52% used [0x00000007bec00000, 0x00000007bf0290e0, 0x00000007bf400000) from space 1024K, 27% used [0x00000007bf500000, 0x00000007bf545920, 0x00000007bf600000) to space 1024K, 0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000) tenured generation total 10240K, used 4096K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) the space 10240K, 40% used [0x00000007bf600000, 0x00000007bfa00010, 0x00000007bfa00200, 0x00000007c0000000) Metaspace used 2649K, capacity 4486K, committed 4864K, reserved 1056768K class space used 286K, capacity 386K, committed 512K, reserved 1048576K 从上面的日志可以看出，该参数能打印出更加详细的 GC 信息，包括：年轻代的信息、永久代的信息。 [GC (Allocation Failure) [DefNew: 4603K-\u003e278K(9216K), 0.0036744 secs] 4603K-\u003e4374K(19456K), 0.0037100 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]\n该参数还会在退出之前打印出整个堆的详细信息：\n1 2 3 4 5 6 7 8 9 Heap def new generation total 9216K, used 4538K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) eden space 8192K, 52% used [0x00000007bec00000, 0x00000007bf0290e0, 0x00000007bf400000) from space 1024K, 27% used [0x00000007bf500000, 0x00000007bf545920, 0x00000007bf600000) to space 1024K, 0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000) tenured generation total 10240K, used 4096K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) the space 10240K, 40% used [0x00000007bf600000, 0x00000007bfa00010, 0x00000007bfa00200, 0x00000007c0000000) Metaspace used 2649K, capacity 4486K, committed 4864K, reserved 1056768K class space used 286K, capacity 386K, committed 512K, reserved 1048576K GC前后打印堆信息 上面两个命令基本上可以应付 90% 的使用场景了，但有时候我们在 GC 前后还想获取更加详细的信息。那么我们可以使用 PrintHeapAtGC 参数，该参数会在 GC 前后打印堆信息。 java -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintHeapAtGC com.chenshuyi.GCDemo\n输出结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 first allocate second allocate {Heap before GC invocations=0 (full 0): def new generation total 9216K, used 4767K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) eden space 8192K, 58% used [0x00000007bec00000, 0x00000007bf0a7e98, 0x00000007bf400000) from space 1024K, 0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000) to space 1024K, 0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000) tenured generation total 10240K, used 0K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) the space 10240K, 0% used [0x00000007bf600000, 0x00000007bf600000, 0x00000007bf600200, 0x00000007c0000000) Metaspace used 2646K, capacity 4486K, committed 4864K, reserved 1056768K class space used 286K, capacity 386K, committed 512K, reserved 1048576K Heap after GC invocations=1 (full 0): def new generation total 9216K, used 278K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000) eden space 8192K, 0% used [0x00000007bec00000, 0x00000007bec00000, 0x00000007bf400000) from space 1024K, 27% used [0x00000007bf500000, 0x00000007bf545950, 0x00000007bf600000) to space 1024K, 0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000) tenured generation total 10240K, used 4096K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000) the space 10240K, 40% used [0x00000007bf600000, 0x00000007bfa00010, 0x00000007bfa00200, 0x00000007c0000000) Metaspace used 2646K, capacity 4486K, committed 4864K, reserved 1056768K class space used 286K, capacity 386K, committed 512K, reserved 1048576K } 仔细看一下，会发现在 GC 发生前后都打印了一次堆空间信息。 通过这个参数，我们可以详细了解每次 GC 时堆空间的详细信息。\n打印GC发生的时间 -XX:+PrintGCTimeStamps 这个参数非常简单，就是在每次 GC 日志的前面加上一个时间戳。这个时间戳表示 JVM 启动后到现在所逝去的时间。 使用下面的参数运行程序： java -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGC -XX:+PrintGCTimeStamps com.chenshuyi.GCDemo\n输出结果：\n1 2 3 first allocate second allocate 0.130: [GC (Allocation Failure) 4767K-\u003e4374K(19456K), 0.0051351 secs] 上面日志第 3 行中的「0.130」就是该 GC 发生的时间。\n打印应用程序的执行时间 -XX:+PrintGCApplicationConcurrentTime 使用下面的命令运行程序： java -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGC -XX:+PrintGCApplicationConcurrentTime com.chenshuyi.GCDemo\n运行结果：\n1 2 3 4 5 first allocate second allocate Application time: 0.0371892 seconds [GC (Allocation Failure) 4767K-\u003e4374K(19456K), 0.0040074 secs] Application time: 0.0010712 seconds 打印应用由于GC而产生的停顿时间 -XX:+PrintGCApplicationStoppedTime 使用下面的命令运行程序： java -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGC -XX:+PrintGCApplicationStoppedTime com.chenshuyi.GCDemo\n运行结果：\n1 2 3 4 first allocate second allocate [GC (Allocation Failure) 4767K-\u003e4374K(19456K), 0.0045644 secs] Total time for which application threads were stopped: 0.0047873 seconds, Stopping threads took: 0.0000329 seconds 可以看到最后一行打印出了因为 GC 而暂停的时间。\n保存GC日志 -Xloggc 这个参数可以将 GC 日志输出到文件中保存起来。 使用下面的参数运行程序： java -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGC -XX:+PrintReferenceGC -Xloggc:gc.log com.chenshuyi.GCDemo\n运行之后在本目录会生成一个 gc.log 文件，打开该文件：\n1 2 3 4 5 6 7 Java HotSpot(TM) 64-Bit Server VM (25.181-b13) for bsd-amd64 JRE (1.8.0_181-b13), built on Jul 7 2018 01:02:31 by \"java_re\" with gcc 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00) Memory: 4k page, physical 8388608k(45132k free) /proc/meminfo: CommandLine flags: -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:NewSize=10485760 -XX:+PrintGC -XX:+PrintGCTimeStamps -XX:+PrintReferenceGC -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseSerialGC 0.124: [GC (Allocation Failure) 4767K-\u003e4374K(19456K), 0.0047748 secs] 可以看到堆的相关信息，以及 GC 的信息。\n总结 除了上面这些参数，还有可以查看弱引用的参数：-XX:+PrintReferenceGC。它跟踪软引用、弱引用、虚引用和Finallize队列的信息，但是使用场景较为狭窄。基本上掌握上面的几个常用的 GC 日志参数就足够排查使用，最重要的是弄清楚每个参数的作用和用法。\n参数 含义 -XX:PrintGC 打印GC日志 -XX:+PrintGCDetails 打印详细的GC日志。还会在退出前打印堆的详细信息。 -XX:+PrintHeapAtGC 每次GC前后打印堆信息。 -XX:+PrintGCTimeStamps 打印GC发生的时间。 -XX:+PrintGCApplicationConcurrentTime 打印应用程序的执行时间 -XX:+PrintGCApplicationStoppedTime 打印应用由于GC而产生的停顿时间 -XX:+PrintReferenceGC 跟踪软引用、弱引用、虚引用和Finallize队列。 -XLoggc 将GC日志以文件形式输出。 JDK性能监控命令 查看虚拟机进程：jps 命令 jps 命令可以列出所有的 Java 进程。如果 jps 不加任何参数，可以列出 Java 程序的进程 ID 以及 Main 函数短名称，如下所示。\n1 2 3 $ jps 6540 Jps 64447 Main 除此之外，还可以指定下面的参数自定义输出信息：\n参数 含义 -q 指定jps只输出进程ID -m 输出传递给Java进程的参数 -l 输出主函数的完整路径 -v 显示传递给Java虚拟机的参数 虚拟机统计信息：jstat 命令 jstat 用于观察 Java 堆信息的详细情况，基本语法： jstat - [-t] [-h] [] []] 其中 option 可以由以下值构成。\n参数 含义 -class 监视类装载、卸载数量、总空间以及类装载所耗费的时间 -gc 监视Java堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息 -gccapacity 监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间 -gcutil 监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比 -gccause 与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因 -gcnew 监视新生代GC状况 -gcnewcapacity 监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间 -gcold 监视老年代GC状况 -gcoldcapacity 监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间 -gcpermcapacity 输出永久代使用到的最大、最小空间 -compiler 输出JIT编译器编译过的方法、耗时信息 -printcompilation 输出已经被JIT编译的方法 -t 参数表示输出时间戳、-h 参数表示在多少行后输出一个表头、vmid 则是虚拟机的进程ID、interval 和 count 表示输出间隔以及输出次数。 例如：我们用jstat命令来监视一个LVMID为2365的JVM进程。\n1 2 3 $ jstat -gcutil 2365 S0 S1 E O P YGC YGCT FGC FGCT GCT 0.00 0.00 12.05 0.00 14.17 0 0.000 0 0.000 0.000 其中每个选项的意义如下：\n参数 含义 S0、S1 表示Survivor0、Survivor1，还未使用。 E 表示Eden区使用了12.05%的空间。 O 表示老年代还未使用。 P 表示永久代使用了14.17%的空间 YUC、YGCT 表示从程序运行以来一共发生了0次Minor GC（YGC，Young GC），总共耗时0秒。 FGC、FGCT 表示从程序运行以来一共发生了0次Full GC（FGC，Full GC），总共耗时0秒。 查看虚拟机参数：jinfo 命令 jinfo 可以用来查看正在运行的 Java 应用程序的扩展参数，甚至支持在运行时，修改部分参数。它的基本语法是： jinfo 执行例子，查询 CMSInitiatingOccupancyFraction 参数值\n1 2 $ jinfo -flag CMSInitiatingOccupancyFraction 2618 -XX:CMSInitiatingOccupancyFraction=-1 导出堆到文件：jmap 命令 jmap 是一个多功能命令，可以生成 Java 程序的 Dump 文件，也可以查看堆内对象实例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。 jmap [option] vmid 执行样例，使用 jmap 生成一个正在运行的 Eclipse 的 dump 快照文件的例子。例子中的2618是通过jps名称查询到的LVMID。\n1 2 3 $ jmap -dump:format=b,file=Desktop/dump.bin 2618 Dumping heap to /Users/yurongchan/Desktop/dump.bin ... Heap dump file created 堆分析工具：jhat 命令 jhat 命令用于分析 Java 应用的对快照内存。Sun JDK 提供了 jhat 命令与 jmap 搭配使用，来分析 jmap 生成的堆转储快照。jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 文件的分析结果后，可以在浏览器中查看。下面我们用 jhat 来分析上面生成的 dump.bin 文件：\n1 2 3 4 5 6 7 8 9 10 $ jhat dump.bin Reading from dump.bin... Dump file created Sun May 15 23:04:19 CST 2016 Snapshot read, resolving... Resolving 13822 objects... Chasing references, expect 2 dots.. Eliminating duplicate references.. Snapshot resolved. Started HTTP server on port 7000 Server is ready. 之后在浏览器输入 http://localhost:7000 就可以看到分析结果，如下图所示： （略）\n不过一般情况下不用 jhat 命令来分析 dump 文件，主要有以下两个原因：一是一般不会再部署应用的服务器上分析 dump 文件，因为分析工作是一个耗时而且消耗硬件资源的过程。另一个原因是 jhat 的分析功能还比较简陋，比起后面介绍的 VisualVM 等工具还差得很多。\n查看线程堆栈：jstack 命令 jstack 命令用于导出 Java 应用程序的线程堆栈。jstack命令格式： jstack [option] vmid\n下面使用jstack查看一个线程堆栈的例子：\n1 2 3 4 5 6 7 8 9 10 11 nobody $ jstack -l 2618 2016-05-15 23:39:04 Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.79-b02 mixed mode): \"Attach Listener\" daemon prio=5 tid=0x00007f83228e6000 nid=0x280b waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None \"DestroyJavaVM\" prio=5 tid=0x00007f832387e800 nid=0x1303 waiting on condition [0x0000000000000000] java.lang.Thread.State: RUNNABLE Locked ownable synchronizers: - None 远程主机信息收集：jstatd 命令 jstad 命令用于收集远程主机信息。\n多功能命令行：jcmd 命令 jcmd 命令可以针对给定的 Java 虚拟机执行一条命令。\n性能统计工具：hprof 性能分析工具 VisualVM VisualVM是JDK自带的一个用于Java程序性能分析的工具，在JDK安装目录的bin文件夹下名称为jvisualvm.exe。 参考 参考\n安装插件失败，是因为插件中心的地址已经改为： https://visualvm.github.io/pluginscenters.html 进入这个网页，找到JDK对应的版本的url，然后编辑插件中心的url，然后安装插件即可。\n还可以单独安装visualVM工具，官网 https://visualvm.github.io/ 参考\njava的四种引用 引用与对象 每种编程语言都有自己操作内存中元素的方式，例如在 C 和 C++ 里是通过指针，而在 Java 中则是通过“引用”。在 Java 中一切都被视为了对象，但是我们操作的标识符实际上是对象的一个引用（reference）。 创建一个引用，引用可以独立存在，并不一定需要与一个对象关联 String s; 通过将这个叫“引用”的标识符指向某个对象，之后便可以通过这个引用来实现操作对象了。\n1 2 String str = new String(\"abc\"); System.out.println(str.toString()); 在 JDK1.2 之前，Java中的定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称为这块内存代表着一个引用。 Java 中的垃圾回收机制在判断是否回收某个对象的时候，都需要依据“引用”这个概念。 在不同垃圾回收算法中，对引用的判断方式有所不同：\n引用计数法：为每个对象添加一个引用计数器，每当有一个引用指向它时，计数器就加1，当引用失效时，计数器就减1，当计数器为0时，则认为该对象可以被回收（目前在Java中已经弃用这种方式了）。 可达性分析算法：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。 JDK1.2 之前，一个对象只有“已被引用”和\"未被引用\"两种状态，这将无法描述某些特殊情况下的对象，比如，当内存充足时需要保留，而内存紧张时才需要被抛弃的一类对象。 所以在 JDK.1.2 之后，Java 对引用的概念进行了扩充，将引用分为了：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用的强度依次减弱。\n强引用 Java中默认声明的就是强引用，比如：\n1 2 3 4 //只要obj还指向Object对象，Object对象就不会被回收 Object obj = new Object(); //手动置null obj = null; 只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了。\n软引用 软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。 在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。 下面以一个例子来进一步说明强引用和软引用的区别： 在运行下面的Java代码之前，需要先配置参数 -Xms2M -Xmx3M，将 JVM 的初始内存设为2M，最大可用内存为 3M。\n首先先来测试一下强引用，在限制了 JVM 内存的前提下，下面的代码运行正常\n1 2 3 4 5 6 7 8 9 10 public class TestOOM { public static void main(String[] args) { testStrongReference(); } private static void testStrongReference() { // 当 new byte为 1M 时，程序运行正常 byte[] buff = new byte[1024 * 1024 * 1]; } } 但是如果我们创建一个大小为 2M 的字节数组 byte[] buff = new byte[1024 * 1024 * 2]; 则内存不够使用，程序直接报错，强引用并不会被回收 Exception in thread \"main\" java.lang.OutOfMemoryError：Java Heap space\n接着来看一下软引用会有什么不一样，在下面的示例中连续创建了 10 个大小为 1M 的字节数组，并赋值给了软引用，然后循环遍历将这些对象打印出来。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 public class TestOOM { private static List list = new ArrayList\u003c\u003e(); public static void main(String[] args) { testSoftReference(); } private static void testSoftReference() { for (int i = 0; i \u003c 10; i++) { byte[] buff = new byte[1024 * 1024]; SoftReference\u003cbyte[]\u003e sr = new SoftReference\u003c\u003e(buff); list.add(sr); } System.gc(); //主动通知垃圾回收 for(int i=0; i \u003c list.size(); i++){ Object obj = ((SoftReference) list.get(i)).get(); System.out.println(obj); } } } 我们发现无论循环创建多少个软引用对象，打印结果总是只有最后一个对象被保留，其他的obj全都被置空回收了。这里就说明了在内存不足的情况下，软引用将会被自动回收。 值得注意的一点 , 即使有 byte[] buff 引用指向对象, 且 buff 是一个strong reference, 但是 SoftReference sr 指向的对象仍然被回收了，这是因为Java的编译器发现了在之后的代码中, buff 已经没有被使用了, 所以自动进行了优化。 如果我们将上面示例稍微修改一下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 private static void testSoftReference() { byte[] buff = null; for (int i = 0; i \u003c 10; i++) { buff = new byte[1024 * 1024]; SoftReference\u003cbyte[]\u003e sr = new SoftReference\u003c\u003e(buff); list.add(sr); } System.gc(); //主动通知垃圾回收 for(int i=0; i \u003c list.size(); i++){ Object obj = ((SoftReference) list.get(i)).get(); System.out.println(obj); } System.out.println(\"buff: \" + buff.toString()); } 则 buff 会因为强引用的存在，而无法被垃圾回收，从而抛出OOM的错误。 如果一个对象惟一剩下的引用是软引用，那么该对象是软可及的（softly reachable）。垃圾收集器并不像其收集弱可及的对象一样尽量地收集软可及的对象，相反，它只在真正 “需要” 内存时才收集软可及的对象。\n弱引用 弱引用的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。 我们以与软引用同样的方式来测试一下弱引用：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 private static void testWeakReference() { for (int i = 0; i \u003c 10; i++) { byte[] buff = new byte[1024 * 1024]; WeakReference\u003cbyte[]\u003e sr = new WeakReference\u003c\u003e(buff); list.add(sr); } System.gc(); //主动通知垃圾回收 for(int i=0; i \u003c list.size(); i++){ Object obj = ((WeakReference) list.get(i)).get(); System.out.println(obj); } } 可以发现所有被弱引用关联的对象都被垃圾回收了。\n虚引用 虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class PhantomReference extends Reference { /** * Returns this reference object's referent. Because the referent of a * phantom reference is always inaccessible, this method always returns * null. * * @return null */ public T get() { return null; } public PhantomReference(T referent, ReferenceQueue\u003c? super T\u003e q) { super(referent, q); } } 那么传入它的构造方法中的 ReferenceQueue 又是如何使用的呢？\n引用队列（ReferenceQueue） 引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。 与软引用、弱引用不同，虚引用必须和引用队列一起使用。 参考\nIO/NIO 阻塞IO模型 最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：data = socket.read();如果数据没有就绪，就会一直阻塞在 read 方法。\n非阻塞IO模型 当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下：\n1 2 3 4 5 6 7 while(true){ data = socket.read(); if(data!= error){ // 处理数据 break; } } 但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。\n多路复用IO模型 多路复用 IO 模型是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连接数比较多的情况。另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。\n信号驱动IO模型 在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。\n异步IO模型 异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，它会立刻返回，说明read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。\n也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。\n注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。\nIO NIO NIO 主要有三大核心部分：Channel(通道)，Buffer(缓冲区)，Selector。传统 IO 基于字节流和字符流进行操作，而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。\nNIO 和传统 IO 之间第一个最大的区别是，IO 是面向流的，NIO 是面向缓冲区的。\nNIO的缓冲区 Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。\nNIO的非阻塞 IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。\nChannel 首先说一下 Channel，国内大多翻译成“通道”。Channel 和 IO 中的 Stream(流)是差不多一个等级的。只不过 Stream 是单向的，譬如：InputStream，OutputStream，而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。NIO 中的 Channel 的主要实现有：\nFileChannel DatagramChannel SocketChannel ServerSocketChannel 这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。 下面演示的案例基本上就是围绕这 4 个类型的 Channel 进行陈述的。 Buffer Buffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。 上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有： ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、ShortBuffer\nSelector Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。\n深入理解java虚拟机(读书笔记) 参考\n虚拟机内存结构 线程私有：虚拟机栈，本地方法栈，程序计数器 线程共享：堆，方法区（包括运行时常量池）\n程序计数器 当前程序锁执行的字节码行号指示器，记录下一条需要执行的指令。\n虚拟机栈 生命周期与线程相同，每个方法在执行时都会创建一个栈帧。 方法执行的过程，就是栈帧入栈到出栈的过程。 栈帧用于存放局部变量表，操作数栈，动态链接，方法出口等信息。 局部变量表存放了编译期可知的基本数据类型和对象引用。\n本地方法栈 为虚拟机使用到的Native方法服务。 目前HotSpot虚拟机将本地方法栈和虚拟机栈合二为一。\n堆 存放对象实例，所有线程共享。\n方法区（永久代） 存放被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等。\n运行时常量池 方法区的一部分，用于存放编译期生成的各种字面量和符号引用。\n字面量，符号引用，直接引用 字面量：通俗解释就是一个变量的值，但是这个值不能超过范围。 int a = 1; 1是a的字面量 213738648则不能是int的字面量，因为超出了int的范围。 符号引用：以一组符号来描述引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。 直接引用：直接指向目标的指针（类变量，类方法）。 相对偏移量（实例变量，实例方法）。 一个能间接定位到目标的句柄。\n对象在内存中的布局 对象头（哈希码，GC分代年龄，数据指针，如果是数组还会有数组长度），实例数据，对齐填充\n判断对象是否死亡 引用计数算法 每个对象添加一个计数器，引用它加1，引用失效减1，为0则死亡，很难解决循环引用问题。\n可达性分析算法 从gc root节点开始向下搜索，不可达则已死。\n可作为gc root节点的情况：\n虚拟机栈本地变量表引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈native方法引用的对象 强/软/弱/虚 强引用，软引用，弱引用，虚引用\n强引用 new 关键字，强引用还在，则不会被回收 软引用 发生内存溢出钱，会把这些软引用对象列入回收范围，进行第二次回收时会将他们回收 弱引用 只能存活到下一次垃圾回收之前 虚引用 与对象的生存时间不发生关系，作用是在这个对象被回收的时候，收到一个系统通知 垃圾收集算法 标记—清除 Mark-Sweep 过程：标记可回收对象，进行清除 缺点：标记和清除效率低，清除后会产生内存碎片\n复制算法 过程：将内存划分为相等的两块，将存活的对象复制到另一块内存，把已经使用的内存清理掉 缺点：使用的内存变为了原来的一半 进化：将一块内存按8:1的比例分为一块Eden区（80%）和两块Survivor区（10%） 每次使用Eden和一块Survivor，回收时，将存活的对象一次性复制到另一块Survivor上，如果另一块Survivor空间不足，则使用分配担保机制存入老年代\n标记—整理 Mark—Compact 过程：所有存活的对象向一端移动，然后清除掉边界以外的内存\n分代收集算法 过程：将堆分为新生代和老年代，根据区域特点选用不同的收集算法，如果新生代朝生夕死，则采用复制算法，老年代采用标记清除，或标记整理\nHotSpot虚拟机算法实现 枚举根节点 回收时如果逐个检查引用（可达性分析）效率低下，通过OopMap数据结构来得知哪些地方存放着引用\n安全点 不会为所有指令都生成OopMap，只会在特定位置生成，这些位置成为安全点。方法调用，循环跳转，异常跳转等会产生安全点\n如何在GC发生时让所有线程都要附近的安全点停下 抢先式中断 中断全部线程，如果发现有线程不在安全点上，\t那么恢复线程，让它跑到安全点上（几乎不使用）\n主动式中断 设置一个标志，线程执行时去轮询这个标志，标志为true则线程挂起。标志和安全点是重合的\n安全区域 一段代码片段，在这个区域中的任意地方开始GC都是安全的。为了解决处于Sleep或Blocked线程达到安全点的问题。 过程：如果进入到了安全区域，那么标识自己已经进入，GC时不用管已经标识过的。如果离开，则检查是否完成了节点枚举或者整个GC，如果未完成，则必须等待离开信号。\n垃圾收集器 Serial 单线程新生代收集器，只会用一条线程完成收集工作 在Client模式下的虚拟机可以选择 新生代：复制算法 老年代：标记—整理\nParNew Serial的多线程版本，收集过程以及算法与Serival一致，可与CMS老年代收集器配合\nParallel Scavenge 新生代收集器，多线程，主要关注吞吐量，适合在后台运算不需要太多交互的任务，采用复制算法\nSerial Old Serial 的老年代版本，采用 标记—整理\nParallel Old Parallel Scavenge的老年代版本，采用多线程标记—整理\nCMS 老年代收集器，关注停顿时间，采用标记—清除 4个过程，初始标记，并发标记，重新标记，并发清除 收集过程与用户线程并发执行 缺点：并发收集占用CPU资源，降低吞吐率。浮动垃圾，程序不断运行会产生新的垃圾。 JDK1.5老年代占用达到68%会触发，JDK1.6老年代占用达到92%会触发，触发的阈值可以设置，设置不当会导致FuLL GC 降低性能。 会出现内存碎片，可设置参数，多少次不压缩的Full GC之后，进行一次压缩的，默认0，每次都会压缩。\nG1 垃圾收集器 特点：并行与并发，分代手机，空间整合，可预测的停顿 将Java堆分为多个大小相等的独立区域，跟踪每个区域里垃圾的价值，维护一个优先列表，优先回收价值最大的。 区域空间对象的引用使用Remembered Set记录，如果引用的对象处于不同的区域，通过Card Table把引用信息记录到被引用对象的Remembered Set中。 过程：初始标记，并发标记，最终标记，筛选回收\nGC日志 [DefNew:3324k -\u003e 1527k (3712k) ,0.025secs] 3324k152k(11904k) 0.03 secs DefNew表示GC发生的区域，区域名字与使用的收集器有关 中括号内部 3324k1527k(3712k) GC前该区域已使用—\u003eGC后已使用（该区域总容量） 中括号外表示堆信息 secs表示GC花费时间\n内存分配 优先在Eden分配 如果Eden空间不足，会发生一次MinorGC（新生代GC），GC时如果所剩空间不足以存放新对象，Survivor空间又无法存入原有存活对象，那么会将原有对象移入老年代，新对象分配在Eden区\nSerival和ParNew收集器可以通过设置来保证打对象直接进入老年代\n长期存活的对象进入老年代 MinorGC时如果有存活对象能被Survivor容纳，那么年龄为1，每熬过一次MinorGC年龄加1，默认15岁会晋升到老年代 -XX：MaxTenuringThreshold 设置晋升年龄\n10.4 如果Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代。\n10.5 空间分配担保，老年代的连续空间大于新生代的对象总大小，或者两次晋升的平均大小，就会进行MinorGC，否则将进行FULLGC。\nClass类文件的结构 8位字节为基础单位的二进制流文件 8位字节以上的数据项，按照高位在前的方式存储 主要组成部分：无符号数和表\n无符号数 u1,u2,u4,u8 代表1字节，2字节，4字节和8字节 可以描述数字，索引引用，数量值，按照UTF-8构成的字符串值。\n表 由多个无符号数或者其他表构成的复合数据类型，以_info结尾\nClass文件内容顺序 1-4字节，魔数，0xCAFEBABE 5-6字节，次版本号 7-8字节，主版本号 常量池 访问标志 类索引 父类索引 接口索引 字段表集合 方法表集合 属性表集合 常量池： Class文件中第一个表类型的数据，0x0016 =22 代表21项常量，索引为1-21，第0项表示“不引用任何一个常量池项目” 池中两大类常量：字面量和符号引用 字面量：文本字符串，声明为final的常量。 符号引用： 1.类和接口的全限定名 2.字段名称和描述符 3.方法名称和描述符 访问标志： 两个字节，类或者接口的访问信息，包括是类还是接口，是否是public,是否是abstract，是否是final（类） 类索引： 类的全限定名，u2 父类索引： 父类的全限定名，单根继承，所以只有一个，除了Object之外，其他父类索引都不为0，u2\n接口索引： u2类型集合，实现了哪些接口，顺序是implements关键字后从左至右 字段表集合： 类级变量（static）以及实例变量，不包括局部变量 方法表集合： 类中的方法 属性表集合： 描述某些专有信息，如方法的代码\n类的生命周期 加载，验证，准备，解析，初始化，使用，卸载，验证，准备，解析统称为连接\n五种初始化情况 1：使用new，读取或者设置一个类的静态字段，调用一个类的静态方法。被final修饰，编译器把结果放入常量池的静态字段除外。 2：对类进行反射调用的时候。 3：初始化一个类的时候，如果父类还没有初始化，先初始化父类。 4：初始化main方法的类。 5：java.lang.invoke.MethodHandle实例，解析结果为REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄\n加载 加载过程要完成3件事 1：获取此类的二进制字节流 2：将字节流转化为方法区的运行时数据结构 3：在内存中生成一个对应的Class对象，作为方法区各种数据的访问入口\n验证 确保字节流符合要求，并且不会危害虚拟机安全，4个阶段 文件格式验证，元数据验证，字节码验证，符号引用验证\n准备 为类变量（static）分配内存并设置初始值\n解析 将常量池内的符号引用替换为直接引用\n初始化 执行类构造器的方法的过程 clinit方法：由类中的所有类变量（static）的赋值动作和静态语句块合并产生。 静态语句块可为语句块之后的变量赋值，但不能访问。 虚拟机保证在子类的clinit方法执行之前，父类的clinit方法已经执行完毕，所以第一个被执行的clinit方法肯定是java.lang.Object。 父类的静态语句块优先于子类的变量赋值操作。 没有静态语句块也没有变量赋值操作，则不会生成clinit方法。 执行接口的clinit方法不需要执行父接口的clinit方法。 只有一个线程会执行到类的clinit方法。\n类加载器 即使两个类来源于同一个class文件，被同一个虚拟机加载，只要他们的类加载器不同，那这两个类必定不相等。\n三种系统提供的类加载器 启动类加载器：加载存放在JAVA_HOME\\lib目录中的，仅按照文件名识别，如rt.jar。 扩展类加载器：加载JAVA_HOME\\lib\\ext目录中的。 应用程序类加载器：加载用户类路径（classpath）上指定的类库，如果没有自定义的加载器，则这个为默认。\n双亲委派模型 图为双亲委派模型，除了顶层的启动类加载器外，其余的加载器都应当有自己的父类加载器，父子关系使用组合关系，复用父加载器的代码。 工作过程：如果要加载一个类，把这个请求委派给父类加载器，每一个都如此，所以最终都是由顶层启动类加载器加载，如果无法加载，则由自己去加载。 如Object类，所有加载器都要加载，会委派给顶层去加载，所以Object类在环境中都是同一个。\n运行时栈帧的结构 每一个方法从调用开始至执行完成都一应着一个栈帧在虚拟机栈中入栈到出站的过程。 栈帧包括：局部变量表，操作数栈，动态连接，方法返回地址和附加信息。 位于栈顶的栈帧才是有效的，与这个栈帧相关联的方法称为当前方法。\n局部变量表 用于存放方法参数，方法内部的局部变量。以Slot为单位，一个Slot可以存放32位以内的数据类型，long和double用两个Slot来存储。 变量表索引从0开始，如果执行的是非static方法，第0位索引表示方法所属对象的实例引用，即this关键字，从1开始按参数顺序占用Slot，在根据方法体内部定义的变量顺序分配其余的Slot。\n操作数栈 后入先出的栈 方法刚开始执行的时候，这个操作数栈是空的，执行过程中会发生出栈，入栈的操作。\n动态连接 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，一部分符号引用会在运行期间转换为直接引用，成为动态连接。\n方法的返回地址 两种方式退出方法 1.遇到方法返回的字节码指令，为正常出口 2.遇到了异常，并且在异常表中没有匹配的异常处理器（异常未被处理），称为异常出口，不会产生任何返回值。 方法正常退出时，调用者的PC计数器的值作为返回地址 异常退出时，通过异常处理器表来确定返回地址 退出方法执行的操作：恢复上层方法的局部变量表和操作数栈，把返回值（如果有）压入调用者的操作数栈，调整PC计数器的值，指向后一条指令（字节码）\n方法调用 唯一任务，确定要调用哪一个方法。 解析：在类加载的解析阶段，会将一部分符号引用转化为直接引用。条件为：编译器可知，运行期不可变。 例如：静态方法，私有方法，实例构造器，父类方法，final方法。\n分派 静态分派 Human man = new Man(); Human 称为变量的静态类型，Man为变量的实际类型。 静态分派的典型应用是方法重载，重载是根据参数的静态类型作为判定依据。\n动态分派 主要体现在重写上，根据变量的实际类型来确定。 静态分派属于多分派类型，动态分派属于单分派类型。\n虚方法表 在方法区中建立一个虚方法表，在连接阶段进行初始化，用于存放方法的实际入口。如果方法的在子类没有被重写，那么地址入口与父类一致，如果重写了，则指向子类实现的入口地址。\nJava内存模型（JMM） 定义程序中各个变量的访问规则，实例字段，静态字段，构成数组对象的元素。 不包括局部变量和方法参数，因为是线程私有。 所有变量存储在主内存，对应Java堆中的实例数据部分，每条线程有自己的工作内存，对应着虚拟机栈中的部分区域。 工作内存中保存了该线程使用到的变量（主内存的副本拷贝），对变量的所有操作都在工作内存中进行，工作内存中变量只对该线程可见，线程间变量值的传递通过主内存完成。\n内存间的交互 8种操作 lock：将主内存变量标识为一条线程占用，即上锁。 unlock：将主内存lock状态的变量释放，其他线程可锁定，即 解锁。 read：将主内存变量的值传送到工作内存中，为load准备。 load：将read获取到的值放入工作内存的变量副本。 use：将工作内存中的变量值传递给执行引擎。 assign：将执行引擎接收到的值赋值给工作内存的变量。 store：将工作内存的变量值传递到主内存，为write准备。 write：将store获取到的值放入主内存。\nvolatile变量 作用：保证此变量对所有线程的可见性。禁止指令的重排序优化。 效率：volatile变量读操作性能与普通变量差别不大，写操作会慢一些。 因为需要在本地代码中插入许多内存屏障来保证不会发生乱序执行，开销一般来讲比锁要低。 规则：每次使用变量前都必须从主内存中刷新值，保证能看见其线程对变量的修改。 每次修改变量后都必须同步回主内存中，保证其他线程可以看到自己的修改。 变量不会被指令重排序优化，保证代码的执行顺序与程序顺序相同。 非原子性协定： 允许虚拟机将没有被volatile修改的64位数据分为两次32位操作来进行。long和double 目前虚拟机几乎都将64位数据读写操作做为原子操作，所以long和double一般不需要用volatile修饰。\n三种特性 原子性 基本数据类型的读写具备原子性，同步块中的也具备原子性。\n可见性 一个线程修改了共享变量的值，其他线程立即得知。 普通变量和volatile变量都是如此，volatile变量是立即刷新主内存，普通变量则不会。\n有序性 如果在本线程内观察，所有操作都是有序的，一个线程中观察另一个线程，所有操作都是无序的。 前半句：线程内表现都是串行。 后半句：指令重排序，工作内存与主内存同步延迟的现象。\n先行发生原则 操作A先行发生与操作B，A发生在B操作之前，A产生的影响（赋值，方法调用等）可以被B观察到。 Java中天然的先行发生关系： 1程序次序规则：一个线程内，按照控制流程顺序，前面的操作，先行发生与后面的操作。 2 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作，时间先后。 3 volatile变量规则：对变量的写操作先行发生于后面的读操作，时间先后。 4 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。 5 线程终止规则：线程中所有操作都先行发生于此线程的终止检测。 6 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。 7 对象终结规则：一个对象的初始化完成先行发生于它的finalsize()方法开始。 8 传递性规则：操作A先行发生于操作B，B先C，可以得出，A先行发生于C的结论。 一个操作时间上的先发生，不代表这个操作会是先行发生。 时间先后与先行发生原则没有太大关系。\nJava线程调度 协同式和抢占式\n协同式 线程自己工作执行完成以后，主动通知系统切换到另外一个线程，不存在同步问题。 缺点：一个线程阻塞会导致整个系统崩溃。\n抢占式 每个线程由系统分配执行时间，切换不由线程本身决定，不会有一个线程导致系统崩溃的问题。\n线程的状态 新建，运行，无限期等待，限期等待，阻塞\n新建 创建后未启动的线程。\n运行 Running和Ready 可能在执行，也可能在等待CPU为他分配执行时间。\n无限期等待 不会被分配执行时间，需要等待显示的唤醒。\n限期等待 不会被分配执行时间，一定时间后由系统自动唤醒。\n阻塞 线程被阻塞，等待获取一个排他锁。``\n结束 已终止，结束执行。\n线程安全 不可变，绝对线程安全，相对线程安全，线程兼容，线程对立\n不可变 final 关键字。\n绝对线程安全 不管运行时环境如何，调用者都不需要任何额外的同步措施。\n相对线程安全 常说的线程安全，保证对这个对象单独的操作是线程安全的。 Vector，HashTable，Collections的synchronizedConllection()方法\n线程兼容 常说的线程不安全，对象本身并不是线程安全，调用时使用同步手段来保证线程安全。\n线程对立 无论是否采取了同步措施，都无法在多线程环境中使用。\n线程安全的实现方法 互斥同步（阻塞） 共享数据在同一时刻只能被一个线程使用，如synchronized关键字和并发包中的ReentrantLock。 会在同步块的前后分别形成monitorenter和monitorexit 需要一个引用类型的参数来指明要锁定和解锁的对象。 如果没有明确指定，去取对象的对象实例（实例方法）或者Class对象（类方法static）来作为锁对象。\n非阻塞同步 先进行操作，如果没有其他线程争用，则操作成功，如果有争用，则采取补偿措施（不断尝试，直到成功为止）。\n无同步方案 可重入代码 如果一个方法，只要输入了相同的参数，就能返回相同的结果，则满足可重入行的要求，为线程安全。\n线程本地存储 共享数据的代码能否在一个线程中执行，如果能则共享数据的可见范围限制在一个线程内。 如 生成者—消费者模式。 Web应用交互，一个请求对应一个线程。\n锁优化 自旋锁与自适应自旋 互斥同步性能最大影响是阻塞，挂起线程和恢复线程都需要转入内核态来完成。 自旋锁是让线程执行一个忙循环，而不是挂起。 JDK1.6默认开始，并增加了自适应的自旋锁。 根据每次自旋的效果，来判定获取该对象的锁是自旋还是挂起，如果自旋的话，循环的次数。 因为自旋锁属于占用执行时间，所以不适宜等待时间过长，因此根据对象以往获取锁的状态来判定，如果自旋时间过长还得不到锁，则放弃自旋，直接选择挂起线程。\n锁消除 一段代码中，堆上的所有数据都不会逃逸出去，被其他线程访问到，就可以把他们当做栈上的数据。无需同步加锁进行。\n锁粗化 如果虚拟机探测到有一串零碎的操作都对同一个对象加锁， 将会把锁范围扩展到操作序列外部。如：\n1 2 3 4 5 StringBuffer sb = new StringBuffer(); sb.append(s1); ... sb.append(s5); sb.toString(); 则会将锁扩展到第一个append之前至最后一个append之后。\n轻量级锁 减少传统重量级锁使用操作系统互斥量产生的性能消耗。\n偏向锁 无竞争的情况下无需同步线程。 线程第一次获取对象锁，CAS操作把线程ID记录到对象头中，CAS成功则这个线程每次进入到这个锁相关的同步块时，无需任何同步操作。 如果有另外一个线程尝试获取该锁时，偏向模式结束。\n编译优化技术 公共子表达式消除 如果一个表达式E已经经过计算，并且E中所有变量的值都没有发生变化，那么E为公共表达式。\n数组边界检查消除 编译期能判断变量的取值范围永远在[0,arr.length]之间，则无线检查。 例如，在一个循环中进行数组的访问。\n方法内联\n逃逸分析 定义一个对象后，被外部方法调用，或当做参数传递，称为方法逃逸。被其他线程访问，称为线程逃逸。 别的方法和线程无法访问到这个对象，则不会逃逸，可以优化。 栈上分配：不会逃逸的对象分配在栈上，方法结束，自动销毁。 同步消除：不会逃逸则同步措施可以消除。 标量替换： 数据无法继续分解则成为标量，如基本类型。 可以分解成为聚合量，如Java对象。 如果不会逃逸，创建一个Java对象时，不直接创建该对象，而是创建若干个标量代替\n",
  "wordCount" : "48827",
  "inLanguage": "en",
  "datePublished": "2022-09-01T18:16:18Z",
  "dateModified": "2022-09-01T18:16:18Z",
  "author":{
    "@type": "Person",
    "name": "Wjy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://funny-toffee-4aa7c3.netlify.app/posts/java/jvm/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Wjy's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://funny-toffee-4aa7c3.netlify.app/favicon.ico"
    }
  }
}
</script>

  <script id="MathJax-script" async src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-chtml.min.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath:  [['\\(', '\\)'], ['$', '$']],  
    }
  };
</script>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://funny-toffee-4aa7c3.netlify.app/" accesskey="h" title="Wjy&#39;s Blog (Alt + H)">Wjy&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://funny-toffee-4aa7c3.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://funny-toffee-4aa7c3.netlify.app/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      jvm
    </h1>
    <div class="post-meta"><span title='2022-09-01 18:16:18 +0000 UTC'>2022-09-01</span>&nbsp;·&nbsp;Wjy

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%99%9a%e6%8b%9f%e6%9c%ba" aria-label="什么是虚拟机">什么是虚拟机</a></li>
                <li>
                    <a href="#%e4%bb%8e%e6%ba%90%e4%bb%a3%e7%a0%81%e5%88%b0%e6%9c%ba%e5%99%a8%e7%a0%81%e5%8f%91%e7%94%9f%e4%ba%86%e4%bb%80%e4%b9%88" aria-label="从源代码到机器码，发生了什么？">从源代码到机器码，发生了什么？</a><ul>
                        
                <li>
                    <a href="#%e5%89%8d%e7%ab%af%e7%bc%96%e8%af%91%e5%99%a8%e6%ba%90%e4%bb%a3%e7%a0%81%e5%88%b0%e5%ad%97%e8%8a%82%e7%a0%81" aria-label="前端编译器：源代码到字节码">前端编译器：源代码到字节码</a></li>
                <li>
                    <a href="#jit-%e7%bc%96%e8%af%91%e5%99%a8%e4%bb%8e%e5%ad%97%e8%8a%82%e7%a0%81%e5%88%b0%e6%9c%ba%e5%99%a8%e7%a0%81" aria-label="JIT 编译器：从字节码到机器码">JIT 编译器：从字节码到机器码</a></li>
                <li>
                    <a href="#aot-%e7%bc%96%e8%af%91%e5%99%a8%e6%ba%90%e4%bb%a3%e7%a0%81%e5%88%b0%e6%9c%ba%e5%99%a8%e7%a0%81" aria-label="AOT 编译器：源代码到机器码">AOT 编译器：源代码到机器码</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%ad%97%e8%8a%82%e7%a0%81%e6%96%87%e4%bb%b6%e7%bb%93%e6%9e%84" aria-label="字节码文件结构">字节码文件结构</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b" aria-label="线程">线程</a></li>
                <li>
                    <a href="#jvm%e5%86%85%e5%ad%98%e5%8c%ba%e5%9f%9f" aria-label="jvm内存区域">jvm内存区域</a><ul>
                        
                <li>
                    <a href="#%e7%a8%8b%e5%ba%8f%e8%ae%a1%e6%95%b0%e5%99%a8%e7%ba%bf%e7%a8%8b%e7%a7%81%e6%9c%89" aria-label="程序计数器（线程私有）">程序计数器（线程私有）</a></li>
                <li>
                    <a href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e6%a0%88%e7%ba%bf%e7%a8%8b%e7%a7%81%e6%9c%89" aria-label="虚拟机栈（线程私有）">虚拟机栈（线程私有）</a></li>
                <li>
                    <a href="#%e6%9c%ac%e5%9c%b0%e6%96%b9%e6%b3%95%e6%a0%88%e7%ba%bf%e7%a8%8b%e7%a7%81%e6%9c%89" aria-label="本地方法栈（线程私有）">本地方法栈（线程私有）</a></li>
                <li>
                    <a href="#%e5%a0%86heap%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab" aria-label="堆Heap（线程共享）">堆Heap（线程共享）</a><ul>
                        
                <li>
                    <a href="#%e6%96%b0%e7%94%9f%e4%bb%a3" aria-label="新生代">新生代</a></li>
                <li>
                    <a href="#%e8%80%81%e5%b9%b4%e4%bb%a3" aria-label="老年代">老年代</a></li>
                <li>
                    <a href="#%e5%a0%86%e5%bc%82%e5%b8%b8" aria-label="堆异常">堆异常</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%96%b9%e6%b3%95%e5%8c%ba%e7%ba%bf%e7%a8%8b%e5%85%b1%e4%ba%ab" aria-label="方法区（线程共享）">方法区（线程共享）</a><ul>
                        
                <li>
                    <a href="#%e6%96%b9%e6%b3%95%e5%8c%ba%e7%9a%84%e5%ae%9e%e7%8e%b0" aria-label="方法区的实现">方法区的实现</a></li>
                <li>
                    <a href="#%e8%bf%90%e8%a1%8c%e6%97%b6%e5%b8%b8%e9%87%8f%e6%b1%a0" aria-label="运行时常量池">运行时常量池</a></li>
                <li>
                    <a href="#%e6%96%b9%e6%b3%95%e5%8c%ba%e5%bc%82%e5%b8%b8" aria-label="方法区异常">方法区异常</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98" aria-label="直接内存">直接内存</a><ul>
                        
                <li>
                    <a href="#%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98%e7%9a%84oufofmemoryerror" aria-label="直接内存的OufOfMemoryError">直接内存的OufOfMemoryError</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e4%b8%8e%e7%ae%97%e6%b3%95" aria-label="垃圾回收与算法">垃圾回收与算法</a><ul>
                        
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e7%a1%ae%e5%ae%9a%e5%9e%83%e5%9c%be" aria-label="如何确定垃圾">如何确定垃圾</a><ul>
                        
                <li>
                    <a href="#%e5%bc%95%e7%94%a8%e8%ae%a1%e6%95%b0%e6%b3%95" aria-label="引用计数法">引用计数法</a></li>
                <li>
                    <a href="#%e5%8f%af%e8%be%be%e6%80%a7%e5%88%86%e6%9e%90" aria-label="可达性分析">可达性分析</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e4%b8%80%e4%b8%aa%e5%af%b9%e8%b1%a1%e6%ad%bb%e4%ba%a1" aria-label="如何判断一个对象死亡">如何判断一个对象死亡</a></li>
                <li>
                    <a href="#%e5%9b%9e%e6%94%b6%e6%96%b9%e6%b3%95%e5%8c%ba" aria-label="回收方法区">回收方法区</a></li>
                <li>
                    <a href="#%e5%88%86%e4%bb%a3%e6%94%b6%e9%9b%86%e7%90%86%e8%ae%ba" aria-label="分代收集理论">分代收集理论</a></li>
                <li>
                    <a href="#%e5%88%86%e5%8c%ba%e6%94%b6%e9%9b%86%e7%90%86%e8%ae%ba" aria-label="分区收集理论">分区收集理论</a></li>
                <li>
                    <a href="#%e6%a0%87%e8%ae%b0%e6%b8%85%e9%99%a4%e7%ae%97%e6%b3%95mark-sweep" aria-label="标记清除算法(Mark-Sweep)">标记清除算法(Mark-Sweep)</a></li>
                <li>
                    <a href="#%e5%a4%8d%e5%88%b6%e7%ae%97%e6%b3%95copying" aria-label="复制算法(copying)">复制算法(copying)</a></li>
                <li>
                    <a href="#%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95mark-compact" aria-label="标记整理算法(Mark-Compact)">标记整理算法(Mark-Compact)</a></li>
                <li>
                    <a href="#%e5%9e%83%e5%9c%be%e5%9b%9e%e6%94%b6%e7%9a%84%e7%b1%bb%e5%9e%8bminor-gcmajor-gcfullgc" aria-label="垃圾回收的类型（Minor GC\Major GC\FullGC）">垃圾回收的类型（Minor GC\Major GC\FullGC）</a><ul>
                        
                <li>
                    <a href="#minor-gc" aria-label="Minor GC">Minor GC</a></li>
                <li>
                    <a href="#major-gc" aria-label="Major GC">Major GC</a></li>
                <li>
                    <a href="#full-gc" aria-label="Full GC">Full GC</a></li>
                <li>
                    <a href="#stop-the-world" aria-label="Stop-The-World">Stop-The-World</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8gc" aria-label="垃圾收集器（GC）">垃圾收集器（GC）</a><ul>
                        
                <li>
                    <a href="#serial-%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%e6%96%b0%e7%94%9f%e4%bb%a3%e5%8d%95%e7%ba%bf%e7%a8%8b%e5%a4%8d%e5%88%b6%e7%ae%97%e6%b3%95" aria-label="Serial 垃圾收集器（新生代、单线程、复制算法）">Serial 垃圾收集器（新生代、单线程、复制算法）</a></li>
                <li>
                    <a href="#parnew-%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%e6%96%b0%e7%94%9f%e4%bb%a3serial--%e5%a4%9a%e7%ba%bf%e7%a8%8b" aria-label="ParNew 垃圾收集器（新生代、Serial &#43; 多线程）">ParNew 垃圾收集器（新生代、Serial + 多线程）</a></li>
                <li>
                    <a href="#parallel-scavenge%e6%94%b6%e9%9b%86%e5%99%a8%e6%96%b0%e7%94%9f%e4%bb%a3%e5%a4%8d%e5%88%b6%e7%ae%97%e6%b3%95%e5%90%9e%e5%90%90%e9%87%8f%e4%bc%98%e5%85%88" aria-label="Parallel Scavenge收集器（新生代、复制算法、吞吐量优先）">Parallel Scavenge收集器（新生代、复制算法、吞吐量优先）</a><ul>
                        
                <li>
                    <a href="#%e8%87%aa%e9%80%82%e5%ba%94%e8%b0%83%e8%8a%82%e7%ad%96%e7%95%a5" aria-label="自适应调节策略">自适应调节策略</a></li></ul>
                </li>
                <li>
                    <a href="#serial-old-%e6%94%b6%e9%9b%86%e5%99%a8%e8%80%81%e5%b9%b4%e4%bb%a3%e5%8d%95%e7%ba%bf%e7%a8%8b%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95-" aria-label="Serial Old 收集器（老年代、单线程、标记整理算法 ）">Serial Old 收集器（老年代、单线程、标记整理算法 ）</a></li>
                <li>
                    <a href="#parallel-old-%e6%94%b6%e9%9b%86%e5%99%a8%e8%80%81%e5%b9%b4%e4%bb%a3%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%a0%87%e8%ae%b0%e6%95%b4%e7%90%86%e7%ae%97%e6%b3%95" aria-label="Parallel Old 收集器（老年代、多线程、标记整理算法）">Parallel Old 收集器（老年代、多线程、标记整理算法）</a></li>
                <li>
                    <a href="#cms-%e6%94%b6%e9%9b%86%e5%99%a8%e8%80%81%e5%b9%b4%e4%bb%a3%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%a0%87%e8%ae%b0%e6%b8%85%e9%99%a4%e7%ae%97%e6%b3%95" aria-label="CMS 收集器（老年代、多线程、标记清除算法）">CMS 收集器（老年代、多线程、标记清除算法）</a></li>
                <li>
                    <a href="#g1%e6%94%b6%e9%9b%86%e5%99%a8" aria-label="G1收集器">G1收集器</a></li></ul>
                </li>
                <li>
                    <a href="#jvm%e7%b1%bb%e5%8a%a0%e8%bd%bd%e6%9c%ba%e5%88%b6" aria-label="JVM类加载机制">JVM类加载机制</a><ul>
                        
                <li>
                    <a href="#%e5%8a%a0%e8%bd%bd" aria-label="加载">加载</a><ul>
                        
                <li>
                    <a href="#%e5%8a%a0%e8%bd%bd%e7%9a%84%e8%bf%87%e7%a8%8b" aria-label="加载的过程">加载的过程</a></li>
                <li>
                    <a href="#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e6%97%b6%e6%9c%ba" aria-label="类加载时机">类加载时机</a></li>
                <li>
                    <a href="#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8" aria-label="类加载器">类加载器</a><ul>
                        
                <li>
                    <a href="#%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be%e6%a8%a1%e5%9e%8b" aria-label="双亲委派模型">双亲委派模型</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%8f%8c%e4%ba%b2%e5%a7%94%e6%b4%be" aria-label="为什么要双亲委派">为什么要双亲委派</a></li></ul>
                </li>
                <li>
                    <a href="#osgi%e5%8a%a8%e6%80%81%e6%a8%a1%e5%9e%8b%e7%b3%bb%e7%bb%9f" aria-label="OSGI（动态模型系统）">OSGI（动态模型系统）</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%aa%8c%e8%af%81" aria-label="验证">验证</a></li>
                <li>
                    <a href="#%e5%87%86%e5%a4%87" aria-label="准备">准备</a></li>
                <li>
                    <a href="#%e8%a7%a3%e6%9e%90" aria-label="解析">解析</a></li>
                <li>
                    <a href="#%e5%88%9d%e5%a7%8b%e5%8c%96" aria-label="初始化">初始化</a></li></ul>
                </li>
                <li>
                    <a href="#jvm%e5%8f%82%e6%95%b0" aria-label="JVM参数">JVM参数</a><ul>
                        
                <li>
                    <a href="#%e5%a0%86%e6%a0%88%e7%a9%ba%e9%97%b4%e9%85%8d%e7%bd%ae" aria-label="堆栈空间配置">堆栈空间配置</a><ul>
                        
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li>
                <li>
                    <a href="#%e5%a0%86%e9%85%8d%e7%bd%ae" aria-label="堆配置">堆配置</a><ul>
                        
                <li>
                    <a href="#%e6%96%b0%e7%94%9f%e4%bb%a3-1" aria-label="新生代">新生代</a><ul>
                        
                <li>
                    <a href="#eden%e5%8c%ba" aria-label="Eden区">Eden区</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%b0%b8%e4%b9%85%e4%bb%a3jdk17" aria-label="永久代（JDK1.7）">永久代（JDK1.7）</a></li>
                <li>
                    <a href="#%e5%85%83%e7%a9%ba%e9%97%b4jdk18" aria-label="元空间（JDK1.8）">元空间（JDK1.8）</a></li>
                <li>
                    <a href="#%e6%a0%88%e7%a9%ba%e9%97%b4" aria-label="栈空间">栈空间</a></li>
                <li>
                    <a href="#%e7%9b%b4%e6%8e%a5%e5%86%85%e5%ad%98-1" aria-label="直接内存">直接内存</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8bjvm%e5%8f%82%e6%95%b0" aria-label="查看JVM参数">查看JVM参数</a></li>
                <li>
                    <a href="#%e8%bf%bd%e8%b8%aa%e7%b1%bb%e4%bf%a1%e6%81%af" aria-label="追踪类信息">追踪类信息</a></li>
                <li>
                    <a href="#gc%e6%97%a5%e5%bf%97%e9%85%8d%e7%bd%ae" aria-label="GC日志配置">GC日志配置</a><ul>
                        
                <li>
                    <a href="#%e6%89%93%e5%8d%b0gc%e6%97%a5%e5%bf%97" aria-label="打印GC日志">打印GC日志</a></li>
                <li>
                    <a href="#%e6%89%93%e5%8d%b0%e8%af%a6%e7%bb%86gc%e6%97%a5%e5%bf%97" aria-label="打印详细GC日志">打印详细GC日志</a></li>
                <li>
                    <a href="#gc%e5%89%8d%e5%90%8e%e6%89%93%e5%8d%b0%e5%a0%86%e4%bf%a1%e6%81%af" aria-label="GC前后打印堆信息">GC前后打印堆信息</a></li>
                <li>
                    <a href="#%e6%89%93%e5%8d%b0gc%e5%8f%91%e7%94%9f%e7%9a%84%e6%97%b6%e9%97%b4--xxprintgctimestamps" aria-label="打印GC发生的时间 -XX:&#43;PrintGCTimeStamps">打印GC发生的时间 -XX:+PrintGCTimeStamps</a></li>
                <li>
                    <a href="#%e6%89%93%e5%8d%b0%e5%ba%94%e7%94%a8%e7%a8%8b%e5%ba%8f%e7%9a%84%e6%89%a7%e8%a1%8c%e6%97%b6%e9%97%b4--xxprintgcapplicationconcurrenttime" aria-label="打印应用程序的执行时间 -XX:&#43;PrintGCApplicationConcurrentTime">打印应用程序的执行时间 -XX:+PrintGCApplicationConcurrentTime</a></li>
                <li>
                    <a href="#%e6%89%93%e5%8d%b0%e5%ba%94%e7%94%a8%e7%94%b1%e4%ba%8egc%e8%80%8c%e4%ba%a7%e7%94%9f%e7%9a%84%e5%81%9c%e9%a1%bf%e6%97%b6%e9%97%b4--xxprintgcapplicationstoppedtime" aria-label="打印应用由于GC而产生的停顿时间 -XX:&#43;PrintGCApplicationStoppedTime">打印应用由于GC而产生的停顿时间 -XX:+PrintGCApplicationStoppedTime</a></li>
                <li>
                    <a href="#%e4%bf%9d%e5%ad%98gc%e6%97%a5%e5%bf%97--xloggc" aria-label="保存GC日志 -Xloggc">保存GC日志 -Xloggc</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93-1" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#jdk%e6%80%a7%e8%83%bd%e7%9b%91%e6%8e%a7%e5%91%bd%e4%bb%a4" aria-label="JDK性能监控命令">JDK性能监控命令</a><ul>
                        
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e8%99%9a%e6%8b%9f%e6%9c%ba%e8%bf%9b%e7%a8%8bjps-%e5%91%bd%e4%bb%a4" aria-label="查看虚拟机进程：jps 命令">查看虚拟机进程：jps 命令</a></li>
                <li>
                    <a href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%bb%9f%e8%ae%a1%e4%bf%a1%e6%81%afjstat-%e5%91%bd%e4%bb%a4" aria-label="虚拟机统计信息：jstat 命令">虚拟机统计信息：jstat 命令</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%8f%82%e6%95%b0jinfo-%e5%91%bd%e4%bb%a4" aria-label="查看虚拟机参数：jinfo 命令">查看虚拟机参数：jinfo 命令</a></li>
                <li>
                    <a href="#%e5%af%bc%e5%87%ba%e5%a0%86%e5%88%b0%e6%96%87%e4%bb%b6jmap-%e5%91%bd%e4%bb%a4" aria-label="导出堆到文件：jmap 命令">导出堆到文件：jmap 命令</a></li>
                <li>
                    <a href="#%e5%a0%86%e5%88%86%e6%9e%90%e5%b7%a5%e5%85%b7jhat-%e5%91%bd%e4%bb%a4" aria-label="堆分析工具：jhat 命令">堆分析工具：jhat 命令</a></li>
                <li>
                    <a href="#%e6%9f%a5%e7%9c%8b%e7%ba%bf%e7%a8%8b%e5%a0%86%e6%a0%88jstack-%e5%91%bd%e4%bb%a4" aria-label="查看线程堆栈：jstack 命令">查看线程堆栈：jstack 命令</a></li>
                <li>
                    <a href="#%e8%bf%9c%e7%a8%8b%e4%b8%bb%e6%9c%ba%e4%bf%a1%e6%81%af%e6%94%b6%e9%9b%86jstatd-%e5%91%bd%e4%bb%a4" aria-label="远程主机信息收集：jstatd 命令">远程主机信息收集：jstatd 命令</a></li>
                <li>
                    <a href="#%e5%a4%9a%e5%8a%9f%e8%83%bd%e5%91%bd%e4%bb%a4%e8%a1%8cjcmd-%e5%91%bd%e4%bb%a4" aria-label="多功能命令行：jcmd 命令">多功能命令行：jcmd 命令</a></li>
                <li>
                    <a href="#%e6%80%a7%e8%83%bd%e7%bb%9f%e8%ae%a1%e5%b7%a5%e5%85%b7hprof" aria-label="性能统计工具：hprof">性能统计工具：hprof</a></li>
                <li>
                    <a href="#%e6%80%a7%e8%83%bd%e5%88%86%e6%9e%90%e5%b7%a5%e5%85%b7-visualvm" aria-label="性能分析工具 VisualVM">性能分析工具 VisualVM</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#java%e7%9a%84%e5%9b%9b%e7%a7%8d%e5%bc%95%e7%94%a8" aria-label="java的四种引用">java的四种引用</a><ul>
                        
                <li>
                    <a href="#%e5%bc%95%e7%94%a8%e4%b8%8e%e5%af%b9%e8%b1%a1" aria-label="引用与对象">引用与对象</a></li>
                <li>
                    <a href="#%e5%bc%ba%e5%bc%95%e7%94%a8" aria-label="强引用">强引用</a></li>
                <li>
                    <a href="#%e8%bd%af%e5%bc%95%e7%94%a8" aria-label="软引用">软引用</a></li>
                <li>
                    <a href="#%e5%bc%b1%e5%bc%95%e7%94%a8" aria-label="弱引用">弱引用</a></li>
                <li>
                    <a href="#%e8%99%9a%e5%bc%95%e7%94%a8" aria-label="虚引用">虚引用</a></li>
                <li>
                    <a href="#%e5%bc%95%e7%94%a8%e9%98%9f%e5%88%97referencequeue" aria-label="引用队列（ReferenceQueue）">引用队列（ReferenceQueue）</a></li></ul>
                </li>
                <li>
                    <a href="#ionio" aria-label="IO/NIO">IO/NIO</a><ul>
                        
                <li>
                    <a href="#%e9%98%bb%e5%a1%9eio%e6%a8%a1%e5%9e%8b" aria-label="阻塞IO模型">阻塞IO模型</a></li>
                <li>
                    <a href="#%e9%9d%9e%e9%98%bb%e5%a1%9eio%e6%a8%a1%e5%9e%8b" aria-label="非阻塞IO模型">非阻塞IO模型</a></li>
                <li>
                    <a href="#%e5%a4%9a%e8%b7%af%e5%a4%8d%e7%94%a8io%e6%a8%a1%e5%9e%8b" aria-label="多路复用IO模型">多路复用IO模型</a></li>
                <li>
                    <a href="#%e4%bf%a1%e5%8f%b7%e9%a9%b1%e5%8a%a8io%e6%a8%a1%e5%9e%8b" aria-label="信号驱动IO模型">信号驱动IO模型</a></li>
                <li>
                    <a href="#%e5%bc%82%e6%ad%a5io%e6%a8%a1%e5%9e%8b" aria-label="异步IO模型">异步IO模型</a></li>
                <li>
                    <a href="#io" aria-label="IO">IO</a></li>
                <li>
                    <a href="#nio" aria-label="NIO">NIO</a><ul>
                        
                <li>
                    <a href="#nio%e7%9a%84%e7%bc%93%e5%86%b2%e5%8c%ba" aria-label="NIO的缓冲区">NIO的缓冲区</a></li>
                <li>
                    <a href="#nio%e7%9a%84%e9%9d%9e%e9%98%bb%e5%a1%9e" aria-label="NIO的非阻塞">NIO的非阻塞</a></li>
                <li>
                    <a href="#channel" aria-label="Channel">Channel</a></li>
                <li>
                    <a href="#buffer" aria-label="Buffer">Buffer</a></li>
                <li>
                    <a href="#selector" aria-label="Selector">Selector</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e6%b7%b1%e5%85%a5%e7%90%86%e8%a7%a3java%e8%99%9a%e6%8b%9f%e6%9c%ba%e8%af%bb%e4%b9%a6%e7%ac%94%e8%ae%b0" aria-label="深入理解java虚拟机(读书笔记)">深入理解java虚拟机(读书笔记)</a><ul>
                        
                <li>
                    <a href="#%e8%99%9a%e6%8b%9f%e6%9c%ba%e5%86%85%e5%ad%98%e7%bb%93%e6%9e%84" aria-label="虚拟机内存结构">虚拟机内存结构</a></li>
                <li>
                    <a href="#%e5%af%b9%e8%b1%a1%e5%9c%a8%e5%86%85%e5%ad%98%e4%b8%ad%e7%9a%84%e5%b8%83%e5%b1%80" aria-label="对象在内存中的布局">对象在内存中的布局</a></li>
                <li>
                    <a href="#%e5%88%a4%e6%96%ad%e5%af%b9%e8%b1%a1%e6%98%af%e5%90%a6%e6%ad%bb%e4%ba%a1" aria-label="判断对象是否死亡">判断对象是否死亡</a></li>
                <li>
                    <a href="#%e5%bc%ba%e8%bd%af%e5%bc%b1%e8%99%9a" aria-label="强/软/弱/虚">强/软/弱/虚</a></li>
                <li>
                    <a href="#%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e7%ae%97%e6%b3%95" aria-label="垃圾收集算法">垃圾收集算法</a></li>
                <li>
                    <a href="#hotspot%e8%99%9a%e6%8b%9f%e6%9c%ba%e7%ae%97%e6%b3%95%e5%ae%9e%e7%8e%b0" aria-label="HotSpot虚拟机算法实现">HotSpot虚拟机算法实现</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%9c%a8gc%e5%8f%91%e7%94%9f%e6%97%b6%e8%ae%a9%e6%89%80%e6%9c%89%e7%ba%bf%e7%a8%8b%e9%83%bd%e8%a6%81%e9%99%84%e8%bf%91%e7%9a%84%e5%ae%89%e5%85%a8%e7%82%b9%e5%81%9c%e4%b8%8b" aria-label="如何在GC发生时让所有线程都要附近的安全点停下">如何在GC发生时让所有线程都要附近的安全点停下</a></li>
                <li>
                    <a href="#%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8" aria-label="垃圾收集器">垃圾收集器</a></li>
                <li>
                    <a href="#gc%e6%97%a5%e5%bf%97" aria-label="GC日志">GC日志</a></li>
                <li>
                    <a href="#%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d" aria-label="内存分配">内存分配</a></li>
                <li>
                    <a href="#class%e7%b1%bb%e6%96%87%e4%bb%b6%e7%9a%84%e7%bb%93%e6%9e%84" aria-label="Class类文件的结构">Class类文件的结构</a></li>
                <li>
                    <a href="#%e7%b1%bb%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" aria-label="类的生命周期">类的生命周期</a></li>
                <li>
                    <a href="#%e7%b1%bb%e5%8a%a0%e8%bd%bd%e5%99%a8-1" aria-label="类加载器">类加载器</a></li>
                <li>
                    <a href="#%e8%bf%90%e8%a1%8c%e6%97%b6%e6%a0%88%e5%b8%a7%e7%9a%84%e7%bb%93%e6%9e%84" aria-label="运行时栈帧的结构">运行时栈帧的结构</a></li>
                <li>
                    <a href="#%e6%96%b9%e6%b3%95%e8%b0%83%e7%94%a8" aria-label="方法调用">方法调用</a></li>
                <li>
                    <a href="#%e5%88%86%e6%b4%be" aria-label="分派">分派</a></li>
                <li>
                    <a href="#%e8%99%9a%e6%96%b9%e6%b3%95%e8%a1%a8" aria-label="虚方法表">虚方法表</a></li>
                <li>
                    <a href="#java%e5%86%85%e5%ad%98%e6%a8%a1%e5%9e%8bjmm" aria-label="Java内存模型（JMM）">Java内存模型（JMM）</a></li>
                <li>
                    <a href="#%e5%86%85%e5%ad%98%e9%97%b4%e7%9a%84%e4%ba%a4%e4%ba%92" aria-label="内存间的交互">内存间的交互</a></li>
                <li>
                    <a href="#volatile%e5%8f%98%e9%87%8f" aria-label="volatile变量">volatile变量</a></li>
                <li>
                    <a href="#%e4%b8%89%e7%a7%8d%e7%89%b9%e6%80%a7" aria-label="三种特性">三种特性</a></li>
                <li>
                    <a href="#%e5%85%88%e8%a1%8c%e5%8f%91%e7%94%9f%e5%8e%9f%e5%88%99" aria-label="先行发生原则">先行发生原则</a></li>
                <li>
                    <a href="#java%e7%ba%bf%e7%a8%8b%e8%b0%83%e5%ba%a6" aria-label="Java线程调度">Java线程调度</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81" aria-label="线程的状态">线程的状态</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8" aria-label="线程安全">线程安全</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e5%ae%9e%e7%8e%b0%e6%96%b9%e6%b3%95" aria-label="线程安全的实现方法">线程安全的实现方法</a><ul>
                        
                <li>
                    <a href="#%e6%97%a0%e5%90%8c%e6%ad%a5%e6%96%b9%e6%a1%88" aria-label="无同步方案">无同步方案</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%94%81%e4%bc%98%e5%8c%96" aria-label="锁优化">锁优化</a></li>
                <li>
                    <a href="#%e7%bc%96%e8%af%91%e4%bc%98%e5%8c%96%e6%8a%80%e6%9c%af" aria-label="编译优化技术">编译优化技术</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><a href="https://www.processon.com/view/link/5eea141cf346fb1ae56a44e7#map">jvm全面思维导图</a>
<a href="https://blog.csdn.net/suifeng3051/article/details/52611310">java内存模型</a></p>
<h1 id="什么是虚拟机">什么是虚拟机<a hidden class="anchor" aria-hidden="true" href="#什么是虚拟机">#</a></h1>
<p>windows只能安装exe安装包，mac只能安装dmg安装包，这是因为操作系统底层的实现是不一样的。系统软件无法通用是一个常见的问题。</p>
<p>但使用过 Java 的同学都知道，Java 代码可以在Linux 系统运行，也可以在 Windows 系统运行，但我们并没有生成多份不同的代码。所以 Java 语言是如何做到的呢？
Java 语言并不直接将代码编译成与系统有关的机器码，而是编译成一种特定的语言规范，这种语言规范我们称之为字节码。无论 Java 程序要在 Windows 系统，还是 Mac 系统，抑或是 Linux 系统，它首先都得编译成字节码文件，之后才能运行。
但即使编译成字节码文件了，各个系统还是无法明白字节码文件的内容，这时候就需要 Java 虚拟机的帮助了。Java 虚拟机会解析字节码文件的内容，并将其翻译为各操作系统能理解的机器码。
<code>java源码-&gt;字节码（byte code）-&gt;java Virture Machine -&gt;windows\linux code</code></p>
<p>简单地说，对于同样一份 Java 源码文件，我们编译成字节码之后，无论是 Linux 系统还是 Windows 系统都不认识。这时候 Java 虚拟机就是一个翻译官，在 Linux 系统上翻译成 Linux 机器码给 Linux 系统听，在 Windows 系统上翻译成 Windows 机器码给 Windows 系统听。这样一来，Java 就实现了「Write Once，Run Anywhere」的伟大愿景了。</p>
<p>在 Java 虚拟机还没出现之前，为了支持软件在不同系统上运行，我们必须在多个平台写多份代码，分别对应特定的系统。但 Java 虚拟机出现之后，你只需要按照特定规范编译书写，编译器编译成字节码文件后，虚拟机会帮你将字节码生成对应的 Windows Code 和 Mac Code。本质上最终还是会生成 Windows Code 和 Mac Code 两份机器代码，但对于开发人员来说，却只需要写一次代码了。Java 虚拟机帮开发人员承担了重复的工作，让开发效率更高了。</p>
<p>其实 Java 虚拟机就是一个字节码翻译器，它将字节码文件翻译成各个系统对应的机器码，确保字节码文件能在各个系统正确运行。JVM 是可运行Java代码的假想计算机，JVM 是运行在操作系统之上的，它与硬件没有直接的交互。</p>
<p><img loading="lazy" src="/posts/java/jvm/1.png"></p>
<p>我们都知道 Java 源文件，通过编译器，能够生产相应的.Class 文件，也就是字节码文件，而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码。</p>
<p>Java 源文件-&gt;编译器-&gt;字节码文件-&gt;JVM-&gt;机器码</p>
<p>每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够跨平台的原因，当一个程序从开始运行，这时虚拟机就开始实例化了，多个程序启动就会存在多个虚拟机实例。程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不能共享。</p>
<h1 id="从源代码到机器码发生了什么">从源代码到机器码，发生了什么？<a hidden class="anchor" aria-hidden="true" href="#从源代码到机器码发生了什么">#</a></h1>
<p>无论什么语言写的代码，其到最后都是通过机器码运行的，无一例外。那么对于 Java 语言来说，其从源代码到机器码，这中间到底发生了什么呢？</p>
<p>我们知道实际输入到 Java 虚拟机的是字节码文件，而不是 Java 源文件。
那么对于 Java 语言而言，是怎么将 Java 代码转化成字节码文件的呢？我们知道在 JDK 的安装目录里有一个 javac 工具，就是它将 Java 代码翻译成字节码，这个工具我们叫做编译器。</p>
<p>编译器可以分为：前端编译器、JIT编译器、AOT编译器</p>
<h2 id="前端编译器源代码到字节码">前端编译器：源代码到字节码<a hidden class="anchor" aria-hidden="true" href="#前端编译器源代码到字节码">#</a></h2>
<p>相对于后面要讲的其他编译器，其因为处于编译的前期，因此又被成为前端编译器。
通过 javac 编译器，我们可以很方便地将 java 源文件翻译成字节码文件。就拿我们最熟悉的 Hello World 作为例子：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> Demo{
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String args[]){
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;Hello World!&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们使用 javac 命令编译上面这个类，便会生成一个 Demo.class 文件：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>&gt; javac Demo.java
</span></span><span style="display:flex;"><span>&gt; ls 
</span></span><span style="display:flex;"><span>Demo.java Demo.class
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们使用纯文本编辑器打开 Demo.class 文件，我们会发现是一连串的 16 进制数据流。
我们运行 javac 命令的过程，其实就是 javac 编译器解析 Java 源代码，并生成字节码文件的过程。说白了，其实就是使用 javac 编译器把 Java 语言规范转化为字节码语言规范。javac 编译器的处理过程可以分为下面四个阶段：</p>
<p>第一个阶段：词法、语法分析。在这个阶段，javac 编译器会对源代码的字符进行一次扫描，最终生成一个抽象的语法树。简单地说，在这个阶段 javac 编译器会搞懂我们的代码到底想要干嘛。就像我们分析一个句子一样，我们会对句子划分主谓宾，弄清楚这个句子要表达的意思一样。</p>
<p>第二个阶段：填充符号表。我们知道类之间是会互相引用的，但在编译阶段，我们无法确定其具体的地址，所以我们会使用一个符号来替代。在这个阶段做的就是类似的事情，即对抽象的类或接口进行符号填充。等到类加载阶段，javac 编译器会将符号替换成具体的内存地址。</p>
<p>第三个阶段：注解处理。我们知道 Java 是支持注解的，因此在这个阶段会对注解进行分析，根据注解的作用将其还原成具体的指令集。</p>
<p>第四个阶段：分析与字节码生成。到了这个阶段，javac 编译器便会根据上面几个阶段分析出来的结果，进行字节码的生成，最终输出为 class 文件。</p>
<p>我们一般称 javac 编译器为前端编译器，因为其发生在整个编译的前期。常见的前端编译器有 Sun 的 javac，Eclipse JDT 的增量式编译器（ECJ）。</p>
<h2 id="jit-编译器从字节码到机器码">JIT 编译器：从字节码到机器码<a hidden class="anchor" aria-hidden="true" href="#jit-编译器从字节码到机器码">#</a></h2>
<p>当源代码转化为字节码之后，其实要运行程序，有两种选择。一种是使用 Java 解释器解释执行字节码，另一种则是使用JIT 编译器将字节码转化为本地机器代码。
这两种方式的区别在于，前者启动速度快但运行速度慢，而后者启动速度慢但运行速度快。
因为解释器是解释执行，JIT编译器是编译执行，完成第一次编译后，其会将字节码对应的机器码保存下来，可以直接使用。机器码的运行效率肯定是高于 Java 解释器的。所以在实际情况中，为了运行速度以及效率，我们通常采用两者相结合的方式进行 Java 代码的编译执行。
<img loading="lazy" src="/posts/java/jvm/2_1.png"></p>
<p>HotSpot 虚拟机内置了两个即时编译器，分别称为 Client Compiler 和Server Compiler。这两种不同的编译器衍生出两种不同的编译模式，我们分别称之为：C1 编译模式，C2 编译模式。</p>
<p>那么 C1 编译模式和 C2 编译模式有什么区别呢？</p>
<p>C1 编译模式会将字节码编译为本地代码，进行简单、可靠的优化，如有必要将加入性能监控的逻辑。而 C2 编译模式，也是将字节码编译为本地代码，但是会启用一些编译耗时较长的优化，甚至会根据性能监控信息进行一些不可靠的激进优化。</p>
<p>简单地说 C1 编译模式做的优化相对比较保守，其编译速度相比 C2 较快。而 C2 编译模式会做一些激进的优化，并且会根据性能监控做针对性优化，所以其编译质量相对较好，但是耗时更长。</p>
<p>实际上对于 HotSpot 虚拟机来说，其一共有三种运行模式可选，分别是：</p>
<ul>
<li>
<p>混合模式（Mixed Mode） 。解释执行和编译执行混合使用，具体过程如下：
<img loading="lazy" src="/posts/java/jvm/2_2.png">
1、源代码经javac编译成字节码，class文件
2、程序字节码经过JIT环境变量进行判断，是否属于“热点代码”（多次调用的方法，或循环等）
3、如是，走JIT编译为具体硬件处理器（如sparc、intel）机器码
4、如否，则直接由解释器解释执行
5、操作系统及类库调用
6、硬件</p>
</li>
<li>
<p>解释模式（Interpreted Mode）。即所有代码都解释执行，使用 -Xint 参数可以打开这个模式。</p>
</li>
<li>
<p>编译模式（Compiled Mode）。 此模式优先采用编译，但是无法编译时也会解释执行，使用 -Xcomp 打开这种模式。</p>
</li>
</ul>
<p>在命令行中输入 java -version 可以看到，我机器上的虚拟机使用 Mixed Mode 运行模式。</p>
<p>写到这里，我们了解了从 Java 源代码到字节码，再从字节码到机器码的全过程。本来到这里就应该结束了，但在我们 Java 中还有一个 AOT 编译器，它能直接将源代码转化为机器码。</p>
<h2 id="aot-编译器源代码到机器码">AOT 编译器：源代码到机器码<a hidden class="anchor" aria-hidden="true" href="#aot-编译器源代码到机器码">#</a></h2>
<p>AOT 编译器的基本思想是：在程序执行前生成 Java 方法的本地代码，以便在程序运行时直接使用本地代码。</p>
<p>但是 Java 语言本身的动态特性带来了额外的复杂性，影响了 Java 程序静态编译代码的质量。例如 Java 语言中的动态类加载，因为 AOT 是在程序运行前编译的，所以无法获知这一信息，所以会导致一些问题的产生。类似的问题还有很多，这里就不一一举例了。</p>
<p>总的来说，AOT 编译器从编译质量上来看，肯定比不上 JIT 编译器。其存在的目的在于避免 JIT 编译器的运行时性能消耗或内存消耗，或者避免解释程序的早期性能开销。</p>
<p>在运行速度上来说，AOT 编译器编译出来的代码比 JIT 编译出来的慢，但是比解释执行的快。而编译时间上，AOT 也是一个始终的速度。所以说，AOT 编译器的存在是 JVM 牺牲质量换取性能的一种策略。就如 JVM 其运行模式中选择 Mixed 混合模式一样，使用 C1 编译模式只进行简单的优化，而 C2 编译模式则进行较为激进的优化。充分利用两种模式的优点，从而达到最优的运行效率。</p>
<h1 id="字节码文件结构">字节码文件结构<a hidden class="anchor" aria-hidden="true" href="#字节码文件结构">#</a></h1>
<p>很多，暂时略</p>
<h1 id="线程">线程<a hidden class="anchor" aria-hidden="true" href="#线程">#</a></h1>
<p>这里所说的线程，指的是程序执行过程中的一个线程实体，JVM 允许一个应用并发执行多个线程。Hotspot JVM 中的 Java 线程与原生操作系统线程有直接的映射关系。
当线程本地存储、缓冲区分配、同步对象、栈、程序计数器等准备好以后，就会创建一个操作系统原生线程。
Java 线程结束，原生线程随之被回收。
操作系统负责调度所有线程，并把它们分配到任何可用的 CPU 上。
当原生线程初始化完毕，就会调用 Java 线程的 run() 方法。
当线程结束时，会释放原生线程和 Java 线程的所有资源。</p>
<p>Hotspot JVM 后台运行的系统线程主要有下面几个：</p>
<ul>
<li>虚拟机线程（VM thread）：
这个线程等待 JVM 到达安全点操作出现。这些操作必须要在独立的线程里执行，因为当堆修改无法进行时，线程都需要 JVM 位于安全点。这些操作的类型有：stop-theworld 垃圾回收、线程栈 dump、线程暂停、线程偏向锁（biased locking）解除。</li>
<li>周期性任务线程：这线程负责定时器事件（也就是中断），用来调度周期性操作的执行。</li>
<li>GC 线程：这些线程支持 JVM 中不同的垃圾回收活动。</li>
<li>编译器线程：这些线程在运行时将字节码动态编译成本地平台相关的机器码。</li>
<li>信号分发线程：这个线程接收发送到 JVM 的信号并调用适当的 JVM 方法处理。</li>
</ul>
<h1 id="jvm内存区域">jvm内存区域<a hidden class="anchor" aria-hidden="true" href="#jvm内存区域">#</a></h1>
<p><img loading="lazy" src="/posts/java/jvm/3.png"></p>
<p>JVM 内存区域分为</p>
<ul>
<li>线程私有区域：程序计数器、虚拟机栈、本地方法区
线程私有数据区域的生命周期与线程相同，依赖用户线程的启动而创建，结束而销毁。
注：在 Hotspot VM 内，每个线程都与操作系统的本地线程直接映射，因此这部分内存区域的存/否跟随本地线程的生/死对应。</li>
<li>线程共享区域：堆区、方法区
线程共享区域，随虚拟机的启动而创建，关闭而销毁。</li>
<li>直接内存
直接内存并不是 JVM 运行时数据区的一部分，但也会被频繁的使用。在 JDK 1.4 引入的 NIO 提供了基于 Channel 与 Buffer 的 IO 方式，它可以使用 Native 函数库直接分配堆外内存，然后使用DirectByteBuffer 对象作为这块内存的引用进行操作(详见: Java I/O 扩展)，这样就避免了在 Java堆和 Native 堆中来回复制数据，因此在一些场景中可以显著提高性能。
<img loading="lazy" src="/posts/java/jvm/4.png"></li>
</ul>
<h2 id="程序计数器线程私有">程序计数器（线程私有）<a hidden class="anchor" aria-hidden="true" href="#程序计数器线程私有">#</a></h2>
<p>程序计数器是一个记录着当前线程所执行的字节码的行号指示器，每条线程都要有一个独立的程序计数器。
JAVA代码编译后的字节码在未经过JIT（实时编译器）编译前，其执行方式是通过“字节码解释器”进行解释执行。简单的工作原理为解释器读取装载入内存的字节码，按照顺序读取字节码指令。读取一个指令后，将该指令“翻译”成固定的操作，并根据这些操作进行分支、循环、跳转等流程。
从上面的描述中，可能会产生程序计数器是否是多余的疑问。因为沿着指令的顺序执行下去，即使是分支跳转这样的流程，跳转到指定的指令处按顺序继续执行是完全能够保证程序的执行顺序的。假设程序永远只有一个线程，这个疑问没有任何问题，也就是说并不需要程序计数器。但实际上程序是通过多个线程协同合作执行的。
首先我们要搞清楚JVM的多线程实现方式。JVM的多线程是通过CPU时间片轮转（即线程轮流切换并分配处理器执行时间）算法来实现的。也就是说，某个线程在执行过程中可能会因为时间片耗尽而被挂起，而另一个线程获取到时间片开始执行。当被挂起的线程重新获取到时间片的时候，它要想从被挂起的地方继续执行，就必须知道它上次执行到哪个位置，在JVM中，通过程序计数器来记录某个线程的字节码执行位置。因此，程序计数器是具备线程隔离的特性，也就是说，每个线程工作时都有属于自己的独立计数器。</p>
<p>程序计数器的特点：</p>
<ul>
<li>线程隔离性，每个线程工作时都有属于自己的独立计数器。</li>
<li>执行java方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址</li>
<li>执行native本地方法时，程序计数器的值为空（Undefined）。因为native方法是java通过JNI直接调用本地C/C++库，可以近似的认为native方法相当于C/C++暴露给java的一个接口，java通过调用这个接口从而调用到C/C++方法。由于该方法是通过C/C++而不是java进行实现。那么自然无法产生相应的字节码，并且C/C++执行时的内存分配是由自己语言决定的，而不是由JVM决定的。</li>
<li>程序计数器占用内存很小，在进行JVM内存计算时，可以忽略不计。</li>
<li>程序计数器，是唯一一个在java虚拟机规范中没有规定任何 OutOfMemoryError 的区域。</li>
</ul>
<p>问题：程序计数器是保存当前线程执行的字节码位置的，当调用本地方法的时候，字节码位置为Undefined，那么jvm是如何保证如果在执行本地方法的时候，被cpu暂停，再次恢复的时候能够找到执行的位置？
本地方法执行完后，会出栈，栈帧中保存有方法的返回地址，可以通过这个找到下一条指令的位置。</p>
<h2 id="虚拟机栈线程私有">虚拟机栈（线程私有）<a hidden class="anchor" aria-hidden="true" href="#虚拟机栈线程私有">#</a></h2>
<p>虚拟机栈是用于描述java方法执行的内存模型。
每个java方法在执行时，会创建一个“栈帧（stack frame）”，栈帧的结构分为“局部变量表、操作数栈、动态链接、方法出口”几个部分。我们常说的“堆内存、栈内存”中的“栈内存”指的便是虚拟机栈，确切地说，指的是虚拟机栈的栈帧中的局部变量表，因为这里存放了一个方法的所有局部变量。</p>
<p>局部变量表存放了编译期可知的各种基本类型数据（boolean、byte、char、short、int、float、long、double）、对象引用、returnAddress类型（指向了一条字节码指令的地址）。</p>
<p>方法调用时，创建栈帧，并压入虚拟机栈；方法执行完毕，栈帧出栈并被销毁，如下图所示：
<img loading="lazy" src="/posts/java/jvm/5.png"></p>
<p>虚拟机栈是线程隔离的，即每个线程都有自己独立的虚拟机栈。</p>
<p>虚拟机栈的StackOverflowError：
若单个线程请求的栈深度大于虚拟机允许的深度，则会抛出StackOverflowError（栈溢出错误）。
JVM会为每个线程的虚拟机栈分配一定的内存大小（-Xss参数），因此虚拟机栈能够容纳的栈帧数量是有限的，若栈帧不断进栈而不出栈，最终会导致当前线程虚拟机栈的内存空间耗尽，典型如一个无结束条件的递归函数调用。</p>
<p>虚拟机栈的OutOfMemoryError：
不同于StackOverflowError，OutOfMemoryError指的是当整个虚拟机栈内存耗尽，并且无法再申请到新的内存时抛出的异常。
JVM未提供设置整个虚拟机栈占用内存的配置参数。虚拟机栈的最大内存大致上等于“JVM进程能占用的最大内存（依赖于具体操作系统） - 最大堆内存 - 最大方法区内存 - 程序计数器内存（可以忽略不计） - JVM进程本身消耗内存”。当虚拟机栈能够使用的最大内存被耗尽后，便会抛出OutOfMemoryError，可以通过不断开启新的线程来模拟这种异常。</p>
<h2 id="本地方法栈线程私有">本地方法栈（线程私有）<a hidden class="anchor" aria-hidden="true" href="#本地方法栈线程私有">#</a></h2>
<p>本地方法栈的功能和特点类似于虚拟机栈，均具有线程隔离的特点以及都能抛出StackOverflowError和OutOfMemoryError异常。
不同的是，本地方法栈服务的对象是JVM执行的native方法，而虚拟机栈服务的是JVM执行的java方法。如何去服务native方法？native方法使用什么语言实现？怎么组织像栈帧这种为了服务方法的数据结构？虚拟机规范并未给出强制规定，因此不同的虚拟机实可以进行自由实现，我们常用的HotSpot虚拟机选择合并了虚拟机栈和本地方法栈。</p>
<h2 id="堆heap线程共享">堆Heap（线程共享）<a hidden class="anchor" aria-hidden="true" href="#堆heap线程共享">#</a></h2>
<p>堆是用于存放对象的内存区域。因此，它是垃圾收集器（GC）管理的主要目标。其具有以下特点：</p>
<ul>
<li>堆是所有线程共享的内存区域，因此每个线程都可以拿到堆上的同一个对象。</li>
<li>堆的生命周期是随着虚拟机的启动而创建。</li>
<li>堆占用的内存并不要求物理连续，只需要逻辑连续即可。</li>
<li>堆在逻辑上划分为“新生代”和“老年代”。由于JAVA中的对象大部分是朝生夕灭，还有一小部分能够长期的驻留在内存中，为了对这两种对象进行最有效的回收，将堆划分为新生代和老年代，并且执行不同的回收策略。不同的垃圾收集器对这2个逻辑区域的回收机制不尽相同。</li>
<li>堆一般实现成可扩展内存大小，使用“-Xms”与“-Xmx”控制堆的最小与最大内存，扩展动作交由虚拟机执行。但由于该行为比较消耗性能，因此一般将堆的最大最小内存设为相等。</li>
</ul>
<p>Java 堆从 GC 的角度还可以细分为：</p>
<ul>
<li>新生代
<ul>
<li>Eden 区</li>
<li>From Survivor 区</li>
<li>To Survivor 区</li>
</ul>
</li>
<li>老年代
<img loading="lazy" src="/posts/java/jvm/6.png"></li>
</ul>
<h3 id="新生代">新生代<a hidden class="anchor" aria-hidden="true" href="#新生代">#</a></h3>
<p>新生代用来存放新生的对象。一般占据堆的 1/3 空间。
由于频繁创建对象，所以新生代会频繁触发MinorGC 进行垃圾回收。
新生代又分为 Eden 区、ServivorFrom、ServivorTo 三个区。</p>
<ul>
<li>
<p>Eden 区
Java 新对象的出生地（如果新创建的对象占用内存很大，则直接分配到老年代）。
当 Eden 区内存不够的时候就会触发 MinorGC，对新生代区进行一次垃圾回收。</p>
</li>
<li>
<p>SurvivorFrom
上一次 GC 的幸存者，作为这一次 GC 的被扫描者。</p>
</li>
<li>
<p>SurvivorTo
保留了一次 MinorGC 过程中的幸存者。</p>
</li>
<li>
<p>MinorGC
MinorGC 采用复制算法，MinorGC的过程是（复制-&gt;清空-&gt;互换）</p>
</li>
</ul>
<ol>
<li>首先，把 Eden 和 SurvivorFrom 区域中存活的对象复制到 SurvivorTo 区域（如果有对象的年龄以及达到了老年的标准，则复制到老年代区），同时把这些对象的年龄+1（如果 SurvivorTo 不够位置了就放到老年区）</li>
<li>然后，清空 Eden 和 SurvivorFrom 中的对象</li>
<li>最后，SurvivorTo 和 SurvivorFrom 互换，原 SurvivorTo 成为下一次 GC 时的 SurvivorFrom
区。</li>
</ol>
<h3 id="老年代">老年代<a hidden class="anchor" aria-hidden="true" href="#老年代">#</a></h3>
<p>主要存放应用程序中生命周期长的内存对象。
老年代的对象比较稳定，所以 MajorGC 不会频繁执行。在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋身入老年代，导致空间不够用时才触发。当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。</p>
<p>MajorGC 采用标记清除算法：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。MajorGC 的耗时比较长，因为要扫描再回收。MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。</p>
<h3 id="堆异常">堆异常<a hidden class="anchor" aria-hidden="true" href="#堆异常">#</a></h3>
<p>当堆无法分配对象内存且无法再扩展时，会抛出<code>OutOfMemoryError</code>异常。
一般来说，堆无法分配对象时会进行一次GC，如果GC后仍然无法分配对象，才会报内存耗尽的错误。可以通过不断生成新的对象但不释放引用来模拟这种情形：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * java堆溢出demo
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * JVM参数：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> HeapOOM {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">class</span> OOMObject {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) {
</span></span><span style="display:flex;"><span>        List&lt;OOMObject&gt; list = <span style="color:#fff;font-weight:bold">new</span> ArrayList&lt;&gt;();
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">//不断创建新对象，使得Heap溢出</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">while</span> (<span style="color:#fff;font-weight:bold">true</span>) {
</span></span><span style="display:flex;"><span>            list.<span style="color:#007f7f">add</span>(<span style="color:#fff;font-weight:bold">new</span> OOMObject());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上述代码中对象不断的被创建而不进行引用释放，导致GC无法回收堆内存，最终OutOfMemoryError，错误信息：<code>java.lang.OutOfMemoryError: Java heap space</code></p>
<h2 id="方法区线程共享">方法区（线程共享）<a hidden class="anchor" aria-hidden="true" href="#方法区线程共享">#</a></h2>
<p>方法区，也称非堆（Non-Heap），又是一个被线程共享的内存区域。其中主要存储加载的类字节码、class/method/field等元数据对象、static-final常量、static变量、jit编译器编译后的代码等数据。另外，方法区包含了一个特殊的区域“运行时常量池”。</p>
<ul>
<li>加载的类字节码：要使用一个类，首先需要将其字节码加载到JVM的内存中。至于类的字节码来源，可以多种多样，如.class文件、网络传输、或cglib字节码框架直接生成。</li>
<li>class/method/field等元数据对象：字节码加载之后，JVM会根据其中的内容，为这个类生成Class/Method/Field等对象，它们用于描述一个类，通常在反射中用的比较多。不同于存储在堆中的java实例对象，这两种对象存储在方法区中。</li>
<li>static-final常量、static变量：对于这两种类型的类成员，JVM会在方法区为它们创建一份数据，因此同一个类的static修饰的类成员只有一份。</li>
<li>jit编译器的编译结果：以hotspot虚拟机为例，其在运行时会使用JIT即时编译器对热点代码进行优化，优化方式为将字节码编译成机器码。通常情况下，JVM使用“解释执行”的方式执行字节码，即JVM在读取到一个字节码指令时，会将其按照预先定好的规则执行栈操作，而栈操作会进一步映射为底层的机器操作；通过JIT编译后，执行的机器码会直接和底层机器打交道。</li>
</ul>
<h3 id="方法区的实现">方法区的实现<a hidden class="anchor" aria-hidden="true" href="#方法区的实现">#</a></h3>
<p>虚拟机规范中并未明确规定方法区的实现，目前有2种比较主流的实现方式：</p>
<ul>
<li>
<p>HotSpot虚拟机1.7-：在JDK1.6及之前版本，HotSpot使用“永久代（permanent generation）”的概念作为实现，即将GC分代收集扩展至方法区。这种实现比较偷懒，可以不必为方法区编写专门的内存管理，但带来的后果是容易碰到内存溢出的问题（因为永久代有-XX:MaxPermSize的上限）。在JDK1.7+之后，HotSpot逐渐改变方法区的实现方式，如1.7版本移除了方法区中的字符串常量池。</p>
</li>
<li>
<p>HotSpot虚拟机1.8+：1.8版本中移除了永久代并使用metaspace（元数据空间）作为替代实现。metaspace占用系统内存，也就是说，只要不碰触到系统内存上限，方法区会有足够的内存空间。
类的元数据放入 native memory，字符串池和类的静态变量放入 java 堆中，这样可以加载多少类的元数据就不再由MaxPermSize 控制，而由系统的实际可用空间来控制。
但这不意味着我们不对方法区进行限制，如果方法区无限膨胀，最终会导致系统崩溃。</p>
</li>
</ul>
<p>我们思考一个问题，为什么使用“永久代”并将GC分代收集扩展至方法区这种实现方式不好，会导致OOM？首先要明白方法区的内存回收目标是什么，方法区存储了类的元数据信息和各种常量，它的内存回收目标理应当是对这些类型的卸载和常量的回收。但由于这些数据被类的实例引用，卸载条件变得复杂且严格，回收不当会导致堆中的类实例失去元数据信息和常量信息。因此，回收方法区内存不是一件简单高效的事情，往往GC在做无用功。另外随着应用规模的变大，各种框架的引入，尤其是使用了字节码生成技术的框架，会导致方法区内存占用越来越大，最终OOM。</p>
<p>参考《深入理解JAVA虚拟机第三版》中的一段话：
说到方法区，不得不提一下“永久代”这个概念，尤其是在JDK 8以前，许多Java程序员都习惯在 HotSpot虚拟机上开发、部署程序，很多人都更愿意把方法区称呼为“永久代”（Permanent Generation），或将两者混为一谈。本质上这两者并不是等价的，因为仅仅是当时的HotSpot虚拟机设计团队选择把收集器的分代设计扩展至方法区，或者说使用永久代来实现方法区而已，这样使得 HotSpot的垃圾收集器能够像管理Java堆一样管理这部分内存，省去专门为方法区编写内存管理代码的 工作。但是对于其他虚拟机实现，譬如BEA JRockit、IBM J9等来说，是不存在永久代的概念的。原则上如何实现方法区属于虚拟机实现细节，不受《Java虚拟机规范》管束，并不要求统一。但现在回头来看，当年使用永久代来实现方法区的决定并不是一个好主意，这种设计导致了Java应用更容易遇到内存溢出的问题（永久代有-XX：MaxPermSize的上限，即使不设置也有默认大小，而J9和JRockit只要 没有触碰到进程可用内存的上限，例如32位系统中的4GB限制，就不会出问题），而且有极少数方法 （例如String::intern()）会因永久代的原因而导致不同虚拟机下有不同的表现。当Oracle收购BEA获得了 JRockit的所有权后，准备把JRockit中的优秀功能，譬如Java Mission Control管理工具，移植到HotSpot 虚拟机时，但因为两者对方法区实现的差异而面临诸多困难。考虑到HotSpot未来的发展，在JDK 6的时候HotSpot开发团队就有放弃永久代，逐步改为采用本地内存（Native Memory）来实现方法区的计 划了[1]，到了JDK 7的HotSpot，已经把原本放在永久代的字符串常量池、静态变量等移出，而到了 JDK 8，终于完全废弃了永久代的概念，改用与JRockit、J9一样在本地内存中实现的元空间（Meta- space）来代替，把JDK 7中永久代还剩余的内容（主要是类型信息）全部移到元空间中。</p>
<p>《Java虚拟机规范》对方法区的约束是非常宽松的，除了和Java堆一样不需要连续的内存和可以选 择固定大小或者可扩展外，甚至还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域的 确是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这区域的内存回 收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收效果比较难令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收有时又确实是必要的。以前Sun公司的Bug列表中，曾出现过的若干个严重的Bug就是由于低版本的HotSpot虚拟机对此区域未完全回收而导致内存 泄漏。</p>
<h3 id="运行时常量池">运行时常量池<a hidden class="anchor" aria-hidden="true" href="#运行时常量池">#</a></h3>
<p>运行时常量池（Runtime Constant Pool）是方法区的一部分。Class文件中除了有类的版本、字 段、方法、接口等描述信息外，还有一项信息是常量池表（Constant Pool Table），用于存放编译期生 成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。
运行时常量池是方法区中一个比较特殊的部分，具备动态性，也就是说，除了类加载时将常量池写入其中，java程序运行期间也可以向其中写入常量：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">//使用StringBuilder在堆上创建字符串abc，再使用intern将其放入运行时常量池</span>
</span></span><span style="display:flex;"><span>String str = <span style="color:#fff;font-weight:bold">new</span> StringBuilder(<span style="color:#0ff;font-weight:bold">&#34;abc&#34;</span>).<span style="color:#007f7f">toString</span>();
</span></span><span style="display:flex;"><span>str.<span style="color:#007f7f">intern</span>();
</span></span><span style="display:flex;"><span><span style="color:#007f7f">//直接使用字符串字面量xyz，其被放入运行时常量池</span>
</span></span><span style="display:flex;"><span>String str2 = <span style="color:#0ff;font-weight:bold">&#34;xyz&#34;</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="方法区异常">方法区异常<a hidden class="anchor" aria-hidden="true" href="#方法区异常">#</a></h3>
<p>我们了解到方法区的2种实现方式最终都会有一个最大值上限，因此若方法区（含运行时常量池）占用内存到达其最大值，且无法再申请到内存时，便会抛出OutOfMemoryError。
在下面的例子中，我们将使用cglib字节码生成框架不断生成新的类，最终使方法区内存占用满，抛出OutOfMemoryError：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * java方法区溢出OutOfMemoryError（JVM参数适用于JDK1.6之前，借助CGLIB）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * JVM参数：-XX:PermSize=10M -XX:MaxPermSize=10M
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> JavaMethodAreaOOM {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">while</span> (<span style="color:#fff;font-weight:bold">true</span>) {
</span></span><span style="display:flex;"><span>            Enhancer enhancer = <span style="color:#fff;font-weight:bold">new</span> Enhancer();
</span></span><span style="display:flex;"><span>            enhancer.<span style="color:#007f7f">setSuperclass</span>(OOMObject.<span style="color:#007f7f">class</span>);
</span></span><span style="display:flex;"><span>            enhancer.<span style="color:#007f7f">setUseCache</span>(<span style="color:#fff;font-weight:bold">false</span>);
</span></span><span style="display:flex;"><span>            enhancer.<span style="color:#007f7f">setCallback</span>((MethodInterceptor) (o, method, objects, methodProxy) -&gt; methodProxy.<span style="color:#007f7f">invokeSuper</span>(objects, args));
</span></span><span style="display:flex;"><span>            enhancer.<span style="color:#007f7f">create</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">class</span> OOMObject {
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>其实，在日常开发中，不仅仅使CGlib字节码生成框架会产生大量的class信息，动态语言、JSP、基于OSGI的应用都会在方法区额外产生大量的类信息。</p>
<h2 id="直接内存">直接内存<a hidden class="anchor" aria-hidden="true" href="#直接内存">#</a></h2>
<p>JVM的内存模型里并不包含直接内存，也就是说这块内存区域并不是JVM运行时数据区的一部分，但它却会被频繁的使用，原因是NIO这个包。
NIO（New input/output）是JDK1.4中新加入的类，引入了一种基于通道（channel）和缓冲区（buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过堆上的DirectByteBuffer对象对这块内存进行引用和操作。
直接内存的大小并不受到java堆大小的限制，甚至不受到JVM进程内存大小的限制。它只受限于本机总内存（RAM及SWAP区或者分页文件）大小以及处理器寻址空间的限制（最常见的就是32位/64位CPU的最大寻址空间限制不同）。</p>
<h3 id="直接内存的oufofmemoryerror">直接内存的OufOfMemoryError<a hidden class="anchor" aria-hidden="true" href="#直接内存的oufofmemoryerror">#</a></h3>
<p>直接内存出现OutOfMemoryError的原因是对该区域进行内存分配时，其内存与其他内存加起来超过最大物理内存限制（包括物理的和操作系统级的限制），从而导致OutOfMemoryError。另外，若我们通过参数<code>-XX:MaxDirectMemorySize</code>指定了直接内存的最大值，其超过指定的最大值时，也会抛出内存溢出异常。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * jvm直接内存溢出
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * JVM参数：-Xmx20M -XX:MaxDirectMemorySize=10M
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> DirectMemoryOOM {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">int</span> _1MB = 1024 * 1024;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) <span style="color:#fff;font-weight:bold">throws</span> IllegalAccessException{
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">//通过反射获取Unsafe类并通过其分配直接内存</span>
</span></span><span style="display:flex;"><span>        Field unsafeField = Unsafe.<span style="color:#007f7f">class</span>.<span style="color:#007f7f">getDeclaredFields</span>()[0];
</span></span><span style="display:flex;"><span>        unsafeField.<span style="color:#007f7f">setAccessible</span>(<span style="color:#fff;font-weight:bold">true</span>);
</span></span><span style="display:flex;"><span>        Unsafe unsafe = (Unsafe) unsafeField.<span style="color:#007f7f">get</span>(<span style="color:#fff;font-weight:bold">null</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">while</span> (<span style="color:#fff;font-weight:bold">true</span>) {
</span></span><span style="display:flex;"><span>            unsafe.<span style="color:#007f7f">allocateMemory</span>(_1MB);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>结果如下，可以看出，其抛出的内存溢出异常并没有指定是JVM哪一块数据区域：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Exception in thread &#34;main&#34; java.lang.OutOfMemoryError
</span></span><span style="display:flex;"><span>    at sun.misc.Unsafe.allocateMemory(Native Method)
</span></span><span style="display:flex;"><span>    at com.manayi.study.jvm.chapter2._07_DirectMemoryOOM.main(_07_DirectMemoryOOM.java:22)
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的例子有点特殊，因为我们使用到了Unsafe这个类（这个类为什么通过反射进行获取先不讨论），它的allocateMemory方法能够直接从堆外内存中申请内存（类比于c的malloc函数）。不同于DirectByteBuffer的内存分配方式（先计算是否有足够的可用内存再决定是手动抛异常还是向操作系统申请分配内存），Unsafe是直接向操作系统申请分配内存，若未申请到则抛异常。</p>
<h1 id="垃圾回收与算法">垃圾回收与算法<a hidden class="anchor" aria-hidden="true" href="#垃圾回收与算法">#</a></h1>
<p><img loading="lazy" src="/posts/java/jvm/gc1.png">
<img loading="lazy" src="/posts/java/jvm/gc2.png"></p>
<h2 id="如何确定垃圾">如何确定垃圾<a hidden class="anchor" aria-hidden="true" href="#如何确定垃圾">#</a></h2>
<h3 id="引用计数法">引用计数法<a hidden class="anchor" aria-hidden="true" href="#引用计数法">#</a></h3>
<p>在 Java 中，引用和对象是有关联的。如果要操作对象则必须用引用进行。因此，一个简单的办法是通过引用计数来判断一个对象是否可以回收。
给对象添加一个引用计数器，每当有一个地方引用它时计数器就+1，当引用失效时计数器就-1。只要计数器等于0的对象就是不可能再被使用的。
此算法在大部分情况下都是一个不错的选择，也有一些著名的应用案例。但是Java虚拟机中是没有使用的。
优点：实现简单、判断效率高。
缺点：很难解决对象之间循环引用的问题。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Object a = <span style="color:#fff;font-weight:bold">new</span> Object();
</span></span><span style="display:flex;"><span>Object b = <span style="color:#fff;font-weight:bold">new</span> Object();
</span></span><span style="display:flex;"><span>a = b;
</span></span><span style="display:flex;"><span>b = a;
</span></span><span style="display:flex;"><span>a = b = <span style="color:#fff;font-weight:bold">null</span>; <span style="color:#007f7f">//这样就导致gc无法回收他们，导致内存泄漏</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="可达性分析">可达性分析<a hidden class="anchor" aria-hidden="true" href="#可达性分析">#</a></h3>
<p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。
主流的商用程序语言（Java、C#等）在主流的实现中，都是通过可达性分析来判定对象是否存活的。通过下图来清晰的感受gc root与对象展示的联系。所示灰色区域对象是存活的，Object5/6/7均是可回收的对象。
<img loading="lazy" src="/posts/java/jvm/GC_Roots.png"></p>
<p>在Java语言中，可作为GC Roots 的对象包括下面几种</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li>
<li>方法区中静态变量引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈（即一般说的 Native 方法）中JNI引用的对象</li>
</ul>
<p>优点：更加精确和严谨，可以分析出循环数据结构相互引用的情况；
缺点：实现比较复杂、需要分析大量数据，消耗大量时间、分析过程需要GC停顿（引用关系不能发生变化），即停顿所有Java执行线程（称为&quot;Stop The World&quot;，是垃圾回收重点关注的问题）。</p>
<h2 id="如何判断一个对象死亡">如何判断一个对象死亡<a hidden class="anchor" aria-hidden="true" href="#如何判断一个对象死亡">#</a></h2>
<p>宣告一个对象死亡，至少要经历两次标记。</p>
<ul>
<li>
<p>第一次标记
如果对象进行可达性分析算法之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。
筛选条件：判断此对象是否有必要执行finalize()方法。
筛选结果：当对象没有覆盖finalize()方法、或者finalize()方法已经被JVM执行过，则判定为可回收对象。如果对象有必要执行finalize()方法，则被放入F-Queue队列中。稍后在JVM自动建立、低优先级的Finalizer线程（可能多个线程）中触发这个方法；</p>
</li>
<li>
<p>第二次标记
GC对F-Queue队列中的对象进行二次标记。
如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。</p>
</li>
<li>
<p>finalize() 方法
finalize()是Object类的一个方法、一个对象的finalize()方法只会被系统自动调用一次，经过finalize()方法逃脱死亡的对象，第二次不会再调用；
特别说明：并不提倡在程序中调用finalize()来进行自救。建议忘掉Java程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（Java程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）。</p>
</li>
</ul>
<h2 id="回收方法区">回收方法区<a hidden class="anchor" aria-hidden="true" href="#回收方法区">#</a></h2>
<p>有些人认为方法区（如HotSpot虚拟机中的元空间或者永久代）是没有垃圾收集行为的，《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在（如JDK 11时期的ZGC收集器就不支持类卸载），方法区垃圾收集 的“性价比”通常也是比较低的：在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。</p>
<ul>
<li>
<p>回收废弃常量
回收废弃常量与Java堆的回收类似。假如一个字符串“abc” 已经进入常量池中，但当前系统没有一个string对象是叫做abc的，也就是说，没有任何string对象的引用指向常量池中的abc常量，也没用其他地方引用这个字面量。如果这是发生内存回收，那么这个常量abc将会被清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</p>
</li>
<li>
<p>回收无用的类
需要同时满足下面3个条件的才能算是无用的类。</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中无任何改类的实例。</li>
<li>加载该类的ClassLoader已经被回收。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法虚拟机可以对同时满足这三个条件的类进行回收，但不是必须进行回收的。是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制。</li>
</ul>
</li>
</ul>
<h2 id="分代收集理论">分代收集理论<a hidden class="anchor" aria-hidden="true" href="#分代收集理论">#</a></h2>
<p>分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将堆区划分为老年代(Tenured/Old Generation)和新生代(Young Generation)。
老年代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。</p>
<ul>
<li>
<p>新生代与复制算法
目前大部分 JVM 的 GC 对于新生代都采取 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1：1 来划分新生代。一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间(From Space，To Space)，每次使用Eden 空间和中的一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。
<img loading="lazy" src="/posts/java/jvm/10.png"></p>
</li>
<li>
<p>老年代与标记整理算法
老年代因为对象存活率高，每次只回收少量对象，因而采用 Mark-Compact 算法。</p>
</li>
</ul>
<h2 id="分区收集理论">分区收集理论<a hidden class="anchor" aria-hidden="true" href="#分区收集理论">#</a></h2>
<p>分区算法则将整个堆空间划分为连续的不同小区间，每个小区间独立使用，独立回收。这样做的好处是可以控制一次回收多少个小区间，根据目标停顿时间，每次合理地回收若干个小区间(而不是整个堆)，从而减少一次 GC 所产生的停顿，G1收集器就是分区。</p>
<h2 id="标记清除算法mark-sweep">标记清除算法(Mark-Sweep)<a hidden class="anchor" aria-hidden="true" href="#标记清除算法mark-sweep">#</a></h2>
<p>“标记 - 清除”算法是最基础的垃圾收集算法，如同它的名字一样，算法的工作过程可以分为“记”和“清除”两个阶段：首先标记出所有需要回收的对象，然后统一回收所有被标记的对象。
标记待回收象：使用可达性分析算法筛选出所有没有可达链的对象。若对象覆盖了finalize方法且虚拟机还没有调用finalize方法，对象将被加入一个名为F-Queue的队列，后续将由虚拟机创建一个名为Finalizer的线程，逐个执行F-Queue队列每个对象的finalize方法。对象可以在finalize方法中和其他具有可达链的对象建立联系，从而避免本次的垃圾收集。需要注意的是，任何对象的finalize方法只会被执行一次。</p>
<p>标记清除算法主要存在两个问题</p>
<ul>
<li>效率问题。标记和清除两个过程的效率都不高。</li>
<li>空间问题。可能产生大量的不连续的内存碎片，进而导致空间利用率下降，垃圾收集频率变高。
<img loading="lazy" src="/posts/java/jvm/7.png"></li>
</ul>
<h2 id="复制算法copying">复制算法(copying)<a hidden class="anchor" aria-hidden="true" href="#复制算法copying">#</a></h2>
<p>为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉，如图：
<img loading="lazy" src="/posts/java/jvm/8.png">
这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。且存活对象增多的话，Copying 算法的效率会大大降低。</p>
<h2 id="标记整理算法mark-compact">标记整理算法(Mark-Compact)<a hidden class="anchor" aria-hidden="true" href="#标记整理算法mark-compact">#</a></h2>
<p>标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。如图：
<img loading="lazy" src="/posts/java/jvm/9.png">
优点：不会像复制算法那样随着存活对象的升高而降低效率，不像标记-清除算法那样产生不连续的内存碎片。
缺点：效率问题，除了像标记-清除算法的标记过程外，还多了一步整理过程，效率更低。</p>
<h2 id="垃圾回收的类型minor-gcmajor-gcfullgc">垃圾回收的类型（Minor GC\Major GC\FullGC）<a hidden class="anchor" aria-hidden="true" href="#垃圾回收的类型minor-gcmajor-gcfullgc">#</a></h2>
<h3 id="minor-gc">Minor GC<a hidden class="anchor" aria-hidden="true" href="#minor-gc">#</a></h3>
<p>从新生代空间回收内存被称为 Minor GC，有时候也称之为 Young GC。
当 JVM 无法为一个新的对象分配空间时会触发 Minor GC，比如当 Eden 区满了。所以 Eden 区越小，越频繁执行 Minor GC。</p>
<p>当新生代中的 Eden 区分配满的时候，年轻代中的部分对象会晋升到老年代，所以 Minor GC 后老年代的占用量通常会有所升高。</p>
<p>因为Minor GC 都会触发 Stop-The-World，停止应用程序的线程。
对于大部分应用程序，停顿导致的延迟都是可以忽略不计的，因为大部分 Eden 区中的对象都能被认为是垃圾，永远也不会被复制到 Survivor 区或者老年代空间。
如果情况相反，即 Eden 区大部分新生对象不符合 GC 条件（即他们不被垃圾回收器收集），那么 Minor GC 执行时暂停的时间将会长很多（因为JVM要将他们复制到 Survivor 区或老年代）。</p>
<h3 id="major-gc">Major GC<a hidden class="anchor" aria-hidden="true" href="#major-gc">#</a></h3>
<p>从老年代空间回收内存被称为 Major GC，有时候也称之为 Old GC。
许多 Major GC 是由 Minor GC 触发的，所以很多情况下将这两种 GC 分离是不太可能的。
Minor GC 作用于新生代，Major GC 作用于老年代。
分配对象内存时发现内存不够，触发 Minor GC。Minor GC 会将对象移到老年代中，如果此时老年代空间不够，那么触发 Major GC。因此才会说，许多 Major GC 是由 Minor GC 引起的。</p>
<h3 id="full-gc">Full GC<a hidden class="anchor" aria-hidden="true" href="#full-gc">#</a></h3>
<p>Full GC 是清理整个堆空间和方法区。因此 Full GC 可以说是 Minor GC 和 Major GC 的结合。
当准备要触发一次 Minor GC 时，如果发现年轻代的剩余空间比以往晋升的空间小，则不会触发 Minor GC 而是转为触发 Full GC。因为JVM此时认为：之前这么大空间的时候已经发生对象晋升了，那现在剩余空间更小了，那么很大概率上也会发生对象晋升。既然如此，那么我就直接帮你把事情给做了吧，直接来一次 Full GC，整理一下老年代和年轻代的空间。另外，在给方法区分配空间时，如果没有足够空间，也会触发 Full GC。</p>
<h3 id="stop-the-world">Stop-The-World<a hidden class="anchor" aria-hidden="true" href="#stop-the-world">#</a></h3>
<p>Stop-The-World，中文一般翻译为全世界暂停，是指在进行垃圾回收时因为标记或清理的需要，必须让所有执行任务的线程停止执行任务，从而让垃圾回收线程回收垃圾的时间间隔。</p>
<p>在 Stop-The-World 这段时间里，所有非垃圾回收线程都无法工作，都暂停下来。只有等到垃圾回收线程工作完成才可以继续工作。可以看出，Stop-The-World 时间的长短将关系到应用程序的响应时间，因此在 GC 过程中，Stop-The-World 的时间是一个非常重要的指标。</p>
<h1 id="垃圾收集器gc">垃圾收集器（GC）<a hidden class="anchor" aria-hidden="true" href="#垃圾收集器gc">#</a></h1>
<p>如果说收集算法是内存回收的方法论，那垃圾收集器就是内存回收的实践者。
<img loading="lazy" src="/posts/java/jvm/11.png">
上图展示了七种作用于不同分代的收集器，如果两个收集器之间存在连线，就说明它们可以搭配使用，图中收集器所处的区域，则表示它是属于新生代收集器抑或是老年代收集器。</p>
<p>新生代收集器：Serial、ParNew、Parallel Scavenge
老年代收集器：CMS、Serial Old、Parallel Old
整堆收集器： G1</p>
<p>几个相关概念：
并行收集：指多条垃圾收集线程并行工作，但此时用户线程仍处于等待状态。</p>
<p>并发收集：指用户线程与垃圾收集线程同时工作（不一定是并行的可能会交替执行）。用户程序在继续运行，而垃圾收集程序运行在另一个CPU上。</p>
<p>吞吐量：即CPU用于运行用户代码的时间与CPU总消耗时间的比值（吞吐量 = 运行用户代码时间 / ( 运行用户代码时间 + 垃圾收集时间 )）。例如：虚拟机共运行100分钟，垃圾收集器花掉1分钟，那么吞吐量就是99%</p>
<h2 id="serial-垃圾收集器新生代单线程复制算法">Serial 垃圾收集器（新生代、单线程、复制算法）<a hidden class="anchor" aria-hidden="true" href="#serial-垃圾收集器新生代单线程复制算法">#</a></h2>
<p>Serial 垃圾收集器是HotSpot虚拟机运行在客户端模式下的默认新生代收集器。
特点：单线程、简单高效（与其他收集器的单线程相比），对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。收集器进行垃圾回收时，必须暂停其他所有的工作线程，直到它结束（Stop The World）。
应用场景：适用于Client模式下的虚拟机。
Serial / Serial Old收集器运行示意图
<img loading="lazy" src="/posts/java/jvm/12.png"></p>
<h2 id="parnew-垃圾收集器新生代serial--多线程">ParNew 垃圾收集器（新生代、Serial + 多线程）<a hidden class="anchor" aria-hidden="true" href="#parnew-垃圾收集器新生代serial--多线程">#</a></h2>
<p>ParNew收集器其实就是Serial收集器的多线程版本。
除了使用多线程外其余行为均和Serial收集器一模一样（参数控制、收集算法、Stop The World、对象分配规则、回收策略等）。
特点：多线程、ParNew收集器默认开启的收集线程数与CPU的数量相同，在CPU非常多的环境中，可以使用<code>-XX:ParallelGCThreads</code>参数来限制垃圾收集的线程数。
和Serial收集器一样存在Stop The World问题。
应用场景：ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，因为它是除了Serial收集器外，唯一一个能与CMS收集器配合工作的。
<img loading="lazy" src="/posts/java/jvm/13.png"></p>
<p>因为G1是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作。所以自JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。
ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器。</p>
<h2 id="parallel-scavenge收集器新生代复制算法吞吐量优先">Parallel Scavenge收集器（新生代、复制算法、吞吐量优先）<a hidden class="anchor" aria-hidden="true" href="#parallel-scavenge收集器新生代复制算法吞吐量优先">#</a></h2>
<ul>
<li>新生代收集器</li>
<li>采用复制算法</li>
<li>并行的多线程收集器（与ParNew收集器类似）。</li>
</ul>
<p>与吞吐量关系密切，故也称为吞吐量优先收集器。
<code>吞吐量 = 运行用户代码时间 / 运行用户代码时间 + 运行垃圾收集时间</code></p>
<p>如果虚拟机完成某个任务，用户代码加上垃圾收集总共耗费了100分钟，其中垃圾收集花掉1分 钟，那吞吐量就是99%。停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良 好的响应速度能提升用户体验；而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算 任务，主要适合在后台运算而不需要太多交互的分析任务。</p>
<p>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量</p>
<ul>
<li>
<p>控制最大垃圾收集停顿时间：<code>-XX：MaxGCPauseMillis</code>
允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的 时间不超过用户设定值</p>
</li>
<li>
<p>直接设置吞吐量大小：<code>-XX：GCTimeRatio</code>
值应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的 比率，相当于吞吐量的倒数。譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5% （即1/(1+19)），默认值为99，即允许最大1%（即1/(1+99)）的垃圾收集时间。</p>
</li>
</ul>
<h3 id="自适应调节策略">自适应调节策略<a hidden class="anchor" aria-hidden="true" href="#自适应调节策略">#</a></h3>
<p><code>-XX：+UseAdaptiveSizePolicy</code>
这是一 个开关参数，当这个参数被激活之后，就不需要人工指定新生代的大小（-Xmn）、Eden与Survivor区 的比例（-XX：SurvivorRatio）、晋升老年代对象大小（-XX：PretenureSizeThreshold）等细节参数 了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量。
自适应调节策略也是Parallel Scavenge收集器区别于ParNew收集器的一个重要特性。</p>
<h2 id="serial-old-收集器老年代单线程标记整理算法-">Serial Old 收集器（老年代、单线程、标记整理算法 ）<a hidden class="anchor" aria-hidden="true" href="#serial-old-收集器老年代单线程标记整理算法-">#</a></h2>
<p>Serial Old是Serial收集器的老年代版本。
同样是单线程收集器，采用标记-整理算法。
主要也是使用在Client模式下的虚拟机中。也可在Server模式下使用。
Server模式下主要的两大用途：</p>
<ul>
<li>在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用。</li>
<li>作为CMS收集器的后备方案，在并发收集Concurent Mode Failure时使用。</li>
</ul>
<p>Serial / Serial Old收集器工作过程图（Serial收集器图示相同）
<img loading="lazy" src="/posts/java/jvm/12.png"></p>
<h2 id="parallel-old-收集器老年代多线程标记整理算法">Parallel Old 收集器（老年代、多线程、标记整理算法）<a hidden class="anchor" aria-hidden="true" href="#parallel-old-收集器老年代多线程标记整理算法">#</a></h2>
<p>Parallel Old 收集器是Parallel Scavenge的老年代版本，使用多线程的标记-整理算法，吞吐量优先。
在 JDK1.6才开始提供。在 JDK1.6 之前，新生代使用 Parallel Scavenge 收集器只能搭配老年代的 Serial Old 收集器，只能保证新生代的吞吐量优先，无法保证整体的吞吐量。
其他表现良好的老年代收集器，如CMS无法与它配合工作。
直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的搭配组合，在注重吞吐量或者处理器资源较为稀缺的场合，可以优先考虑新生代 Parallel Scavenge和老年代 Parallel Old 收集器的搭配策略。</p>
<p>新生代 Parallel Scavenge 和老年代 Parallel Old 收集器搭配运行过程图：
<img loading="lazy" src="/posts/java/jvm/14.png"></p>
<h2 id="cms-收集器老年代多线程标记清除算法">CMS 收集器（老年代、多线程、标记清除算法）<a hidden class="anchor" aria-hidden="true" href="#cms-收集器老年代多线程标记清除算法">#</a></h2>
<p>CMS（Concurrent mark sweep） 收集器是一种老年代垃圾收集器，其最主要目标是获取最短垃圾回收停顿时间，和其他老年代使用标记-整理算法不同，它使用多线程的标记-清除算法。最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：</p>
<ul>
<li>
<p>初始标记
只是标记一下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。</p>
</li>
<li>
<p>并发标记
进行 GC Roots Tracing 的过程，找出存活对象，和用户线程一起工作，不需要暂停工作线程。</p>
</li>
<li>
<p>重新标记
为了修正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记
记录，仍然需要暂停所有的工作线程。</p>
</li>
<li>
<p>并发清除
清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。</p>
</li>
</ul>
<p>由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户现在一起并发工作，所以总体上来看CMS 收集器的内存回收和用户线程是一起并发地执行。</p>
<p>CMS 收集器工作过程：
<img loading="lazy" src="/posts/java/jvm/15.png"></p>
<p>缺点：</p>
<ul>
<li>
<p>对CPU资源非常敏感
面向并发设计的程序都会对CPU资源较敏感。CMS默认的回收线程数: （CPU数量+3）/4</p>
</li>
<li>
<p>无法处理浮动垃圾
可能出现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。并发清理阶段用户程序运行产生的垃圾过了标记阶段所以无法在本次收集中清理掉，称为浮动垃圾。CMS收集器默认在老年代使用了68%的空间后被激活。
若老年代增长的不是很快，可以适当调高参数<code>-XX:CMSInitiatingOccupancyFraction</code> 提高触发百分比，但调得太高会容易导致“Concurrent Mode Failure”失败。</p>
</li>
<li>
<p>基于“标记-清除”算法会产生大量空间碎片。
提供开关参数<code>-XX:+UseCMSCompactAtFullCollection </code>用于在“ 享受”完Full GC服务之后进行碎片整理过程，内存整理的过程是无法并发的。
但是停顿时间会变长。<code>-XX:CMSFullGCsBeforeCompation</code>设置在执行多少次不压缩的FullGC后，跟来一次带压缩的。</p>
</li>
</ul>
<h2 id="g1收集器">G1收集器<a hidden class="anchor" aria-hidden="true" href="#g1收集器">#</a></h2>
<p>Garbage first 垃圾收集器是目前垃圾收集器理论发展的最前沿成果，相比与 CMS 收集器，G1 收集器两个最突出的改进是：</p>
<ol>
<li>基于标记-整理算法，不产生内存碎片。</li>
<li>可以非常精确控制停顿时间，在不牺牲吞吐量前提下，实现低停顿垃圾回收。</li>
</ol>
<p>G1收集器可以在几乎不牺牲吞吐量的前提下完成低停顿的内存回收，这是由于它能够极力避免全区域的垃圾收集，之前的收集器进行收集的范围都是整个新生代或老年代，而G1将整个Java堆（包括新生代、老年代）划分为多个大小固定的独立区域（Region），并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，每次根据允许的收集时间，优先回收垃圾最多的区域（这就是Garbage First名称的由来）。区域划分、有优先级的区域回收，保证了G1收集器在有限的时间内可以获得最高的收集效率。</p>
<p>G1收集器的特点：</p>
<ul>
<li>
<p>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿时间。部分收集器原本需要停顿Java线程来执行GC动作，G1收集器仍然可以通过并发的方式让Java程序继续运行。</p>
</li>
<li>
<p>分代收集：G1能够独自管理整个Java堆，并且采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。</p>
</li>
<li>
<p>空间整合：G1运作期间不会产生空间碎片，收集后能提供规整的可用内存。</p>
</li>
<li>
<p>可预测的停顿：G1除了追求低停顿外，还能建立可预测的停顿时间模型。能让使用者明确指定在一个长度为M毫秒的时间段内，消耗在垃圾收集上的时间不得超过N毫秒。</p>
</li>
</ul>
<p>G1为什么能建立可预测的停顿时间模型？
因为它有计划的避免在整个Java堆中进行全区域的垃圾收集。G1跟踪各个Region里面的垃圾堆积的大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region。这样就保证了在有限的时间内可以获取尽可能高的收集效率。</p>
<p>G1与其他收集器的区别：
其他收集器的工作范围是整个新生代或者老年代、G1收集器的工作范围是整个Java堆。在使用G1收集器时，它将整个Java堆划分为多个大小相等的独立区域（Region）。虽然也保留了新生代、老年代的概念，但新生代和老年代不再是相互隔离的，他们都是一部分Region（不需要连续）的集合。</p>
<p>G1收集器存在的问题：
Region不可能是孤立的，分配在Region中的对象可以与Java堆中的任意对象发生引用关系。在采用可达性分析算法来判断对象是否存活时，得扫描整个Java堆才能保证准确性。其他收集器也存在这种问题（G1更加突出而已）。会导致 Minor GC效率下降。</p>
<p>G1收集器是如何解决上述问题的？</p>
<p>采用Remembered Set来避免整堆扫描。G1中每个Region都有一个与之对应的Remembered Set，虚拟机发现程序在对Reference类型进行写操作时，会产生一个Write Barrier暂时中断写操作，检查Reference引用对象是否处于多个Region中（即检查老年代中是否引用了新生代中的对象），如果是，便通过CardTable把相关引用信息记录到被引用对象所属的Region的Remembered Set中。当进行内存回收时，在GC根节点的枚举范围中加入Remembered Set即可保证不对全堆进行扫描也不会有遗漏。</p>
<p>如果不计算维护 Remembered Set 的操作，G1收集器大致可分为如下步骤：</p>
<ul>
<li>
<p>初始标记：仅标记GC Roots能直接到的对象，并且修改TAMS（Next Top at Mark Start）的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象。（需要线程停顿，但耗时很短。）</p>
</li>
<li>
<p>并发标记：从GC Roots开始对堆中对象进行可达性分析，找出存活对象。（耗时较长，但可与用户程序并发执行）</p>
</li>
<li>
<p>最终标记：为了修正在并发标记期间因用户程序执行而导致标记产生变化的那一部分标记记录。且对象的变化记录在线程Remembered Set  Logs里面，把Remembered Set  Logs里面的数据合并到Remembered Set中。（需要线程停顿，但可并行执行。）</p>
</li>
<li>
<p>筛选回收：对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划。（可并发执行）</p>
</li>
</ul>
<p>G1收集器运行示意图：
<img loading="lazy" src="/posts/java/jvm/15_1.png"></p>
<p><a href="https://blog.csdn.net/clover_lily/article/details/80160726">垃圾收集参考</a></p>
<h1 id="jvm类加载机制">JVM类加载机制<a hidden class="anchor" aria-hidden="true" href="#jvm类加载机制">#</a></h1>
<p><a href="https://www.cnblogs.com/riches/p/14563092.html">参考</a>
类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用和卸载七个阶段。</p>
<h2 id="加载">加载<a hidden class="anchor" aria-hidden="true" href="#加载">#</a></h2>
<h3 id="加载的过程">加载的过程<a hidden class="anchor" aria-hidden="true" href="#加载的过程">#</a></h3>
<ul>
<li>通过一个类的全限定名来获取其定义的二进制字节流。
不仅可以从Class文件中获取，还可以从Jar包中获取、网络中获取。</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在Java堆中生成一个代表这个类的java.lang.Class对象，作为对方法区中这些数据的访问入口。</li>
</ul>
<p>相对于类加载的其他阶段而言，加载阶段（准确地说，是加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，因为开发人员既可以使用系统提供的类加载器来完成加载，也可以自定义自己的类加载器来完成加载。</p>
<p>加载阶段完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在方法区之中，而且在Java堆中也创建一个java.lang.Class类的对象，这样便可以通过该对象访问方法区中的这些数据。</p>
<h3 id="类加载时机">类加载时机<a hidden class="anchor" aria-hidden="true" href="#类加载时机">#</a></h3>
<ul>
<li>创建类的实例，也就是new一个对象</li>
<li>访问某个类或接口的静态变量，或者对该静态变量赋值</li>
<li>调用类的静态方法</li>
<li>反射（Class.forName(&ldquo;com.lyj.load&rdquo;)）</li>
<li>初始化一个类的子类（会首先初始化子类的父类）</li>
<li>JVM启动时标明的启动类，即文件名和类名相同的那个类</li>
</ul>
<p>除此之外，下面几种情形需要特别指出：
对于一个final类型的静态变量，如果该变量的值在编译时就可以确定下来，那么这个变量相当于“宏变量”。Java编译器会在编译时直接把这个变量出现的地方替换成它的值，因此即使程序使用该静态变量，也不会导致该类的初始化。反之，如果final类型的静态Field的值不能在编译时确定下来，则必须等到运行时才可以确定该变量的值，如果通过该类来访问它的静态变量，则会导致该类被初始化。</p>
<h3 id="类加载器">类加载器<a hidden class="anchor" aria-hidden="true" href="#类加载器">#</a></h3>
<p>java代码通过javac编译成class文件，而类加载器的作用，就是把class文件装进虚拟机。
类加载器负责加载所有的类，其为所有被载入内存中的类生成一个 java.lang.Class 实例对象。一旦一个类被加载如JVM中，同一个类就不会被再次载入了。正如一个对象有一个唯一的标识一样，一个载入JVM的类也有一个唯一的标识。
在Java中，一个类用其全限定类名（包括包名和类名）作为标识；
但在JVM中，一个类用其全限定类名和其类加载器作为其唯一标识。
例如，如果在pg的包中有一个名为Person的类，被类加载器ClassLoader的实例 kl 加载后，Person类对应的Class对象在JVM中表示为(Person.pg.kl)。
被类加载器ClassLoader的实例 kl2 加载后，Person类对应的Class对象在JVM中表示为(Person.pg.kl2)。
也就是说，即使两个类来源于同一个Class文件，只要加载它们的类加载器不同，那这两个类就必定不相等。这里的“相等”包括了代表类的Class对象的equals（）、isAssignableFrom（）、isInstance（）等方法的返回结果，也包括了使用instanceof关键字对对象所属关系的判定结果。</p>
<p>既然只是把class文件装进虚拟机，为什么要用多种加载器呢？因为Java虚拟机启动的时候，并不会一次性加载所有的class文件（内存会爆），而是根据需要去动态加载。</p>
<p>站在Java虚拟机的角度来讲，只存在两种不同的类加载器：</p>
<ul>
<li>启动类加载器：它使用C++实现（这里仅限于Hotspot，也就是JDK1.5之后默认的虚拟机，有很多其他的虚拟机是用Java语言实现的），是虚拟机自身的一部分，是无法被Java程序直接引用的。</li>
<li>所有其他的类加载器：这些类加载器都由Java语言实现，独立于虚拟机之外，并且全部继承自抽象类java.lang.ClassLoader，这些类加载器需要由启动类加载器加载到内存中之后才能去加载其他的类。</li>
</ul>
<p>站在Java开发人员的角度来看，类加载器可以大致划分为以下三类：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader）：它负责加载java核心类库，可以直接打印启动类加载器BootstrapClassLoader的加载路径看看：</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>URL[] urls = sun.<span style="color:#007f7f">misc</span>.<span style="color:#007f7f">Launcher</span>.<span style="color:#007f7f">getBootstrapClassPath</span>().<span style="color:#007f7f">getURLs</span>();
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">for</span> (URL url : urls) {
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(url);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果（%20是空格）：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/lib/resources.jar
</span></span><span style="display:flex;"><span>file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/lib/rt.jar
</span></span><span style="display:flex;"><span>file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/lib/sunrsasign.jar
</span></span><span style="display:flex;"><span>file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/lib/jsse.jar
</span></span><span style="display:flex;"><span>file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/lib/jce.jar
</span></span><span style="display:flex;"><span>file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/lib/charsets.jar
</span></span><span style="display:flex;"><span>file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/lib/jfr.jar
</span></span><span style="display:flex;"><span>file:/C:/Program%20Files/Java/jdk1.8.0_211/jre/classes
</span></span></code></pre></td></tr></table>
</div>
</div><p>主要是<code>$JAVA_HOME/jre/lib</code>下的类，可以说所有的java.*开头的类均被Bootstrap ClassLoader加载。</p>
<ul>
<li>扩展类加载器（Extension ClassLoader）
该加载器由<code>sun.misc.Launcher$ExtClassLoader</code>实现，通过程序查看扩展类加载器加载了哪些类：</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>URL[] urls = ((URLClassLoader) ClassLoader.<span style="color:#007f7f">getSystemClassLoader</span>().<span style="color:#007f7f">getParent</span>()).<span style="color:#007f7f">getURLs</span>();
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">for</span> (URL url : urls) {
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(url);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>输出结果：略
扩展类加载器加载的是<code>$JAVA_HOME/jre/lib/ext</code>目录下的扩展包。这些类库具体是什么不重要，只需要知道不同的类库可能是被不同的类加载器加载的。</p>
<ul>
<li>应用程序类加载器（Application ClassLoader）：
该类加载器由<code>sun.misc.Launcher$AppClassLoader</code>来实现，它负责加载用户类路径（ClassPath）所指定的类，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p>应用程序都是由这三种类加载器互相配合进行加载的，如果有必要，我们还可以加入自定义的类加载器。因为JVM自带的ClassLoader只是懂得从本地文件系统加载标准的java class文件，因此如果编写了自己的ClassLoader，便可以做到如下几点：</p>
<ul>
<li>在执行非置信代码之前，自动验证数字签名。</li>
<li>动态地创建符合用户特定需要的定制化构建类。</li>
<li>从特定的场所取得java class，例如数据库中和网络中。</li>
</ul>
<p>事实上当使用Applet的时候，就用到了特定的ClassLoader，因为这时需要从网络上加载java class，并且要检查相关的安全信息，应用服务器也大都使用了自定义的ClassLoader技术。</p>
<p>这几种类加载器的层次关系如下（由高到低）：
启动类加载器-&gt;扩展类加载器-&gt;应用程序类加载器-&gt;自定义加载器</p>
<h4 id="双亲委派模型">双亲委派模型<a hidden class="anchor" aria-hidden="true" href="#双亲委派模型">#</a></h4>
<p>这种层次关系称为类加载器的双亲委派模型。我们把每一层上面的类加载器叫做当前层类加载器的父加载器，当然，它们之间的父子关系并不是通过继承关系来实现的，而是使用组合关系来复用父加载器中的代码。该模型在JDK1.2期间被引入并广泛应用于之后几乎所有的Java程序中，但它并不是一个强制性的约束模型，而是Java设计者们推荐给开发者的一种类的加载器实现方式。</p>
<p>然而这是一个很有误导性的术语，它应该叫做单亲委派模型（Parent-Delegation Model）。但是没有办法，大家都已经这样叫了。所谓双亲委派，这个亲就是指ClassLoader里的全局变量parent，也就是父加载器。</p>
<p>双亲委派模型的工作流程是：</p>
<ol>
<li>当一个类加载器接收到类加载任务时，先查缓存里有没有，如果没有，将任务委托给它的父加载器去执行。</li>
<li>父加载器也做同样的事情，一层一层往上委托，直到最顶层的启动类加载器为止。</li>
<li>如果启动类加载器没有找到所需加载的类，便将此加载任务退回给下一级类加载器去执行，而下一级的类加载器也做同样的事情。</li>
<li>如果最底层类加载器仍然没有找到所需要的class文件，则抛出异常。</li>
</ol>
<p>所以是一条线传上再传下，并没有什么“双亲”。整个过程的Java实现也没有什么神秘的：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">abstract</span> <span style="color:#fff;font-weight:bold">class</span> ClassLoader {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// name: Class文件的绝对路径</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// resolve: 找到后是否立即解析（什么是解析？）</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">protected</span> Class&lt;?&gt; loadClass(String name, <span style="color:#fff;font-weight:bold">boolean</span> resolve) <span style="color:#fff;font-weight:bold">throws</span> ClassNotFoundException {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">synchronized</span> (lock) {
</span></span><span style="display:flex;"><span>            <span style="color:#007f7f">// 尝试从缓存获取，这也是为什么修改了Class后需重启JVM才能生效</span>
</span></span><span style="display:flex;"><span>            Class&lt;?&gt; target = findLoadedClass(name); <span style="color:#007f7f">// native方法</span>
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">if</span> (target == <span style="color:#fff;font-weight:bold">null</span>) {
</span></span><span style="display:flex;"><span>                <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>                    <span style="color:#fff;font-weight:bold">if</span> (parent != <span style="color:#fff;font-weight:bold">null</span>) {
</span></span><span style="display:flex;"><span>                        <span style="color:#007f7f">// 委托给父加载器， 只查找不解析</span>
</span></span><span style="display:flex;"><span>                        target = parent.<span style="color:#007f7f">loadClass</span>(name, <span style="color:#fff;font-weight:bold">false</span>);
</span></span><span style="display:flex;"><span>                    } <span style="color:#fff;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>                        <span style="color:#007f7f">// 父加载器为null，则委托给启动类加载器BootstrapClassloader</span>
</span></span><span style="display:flex;"><span>                        target = findBootstrapClassOrNull(name); <span style="color:#007f7f">// native方法</span>
</span></span><span style="display:flex;"><span>                    }
</span></span><span style="display:flex;"><span>                } <span style="color:#fff;font-weight:bold">catch</span> (ClassNotFoundException e) {...}
</span></span><span style="display:flex;"><span>				
</span></span><span style="display:flex;"><span>                <span style="color:#fff;font-weight:bold">if</span> (target == <span style="color:#fff;font-weight:bold">null</span>) {
</span></span><span style="display:flex;"><span>                    <span style="color:#007f7f">// 父加载器没有找到，才调用自己的findClass()方法</span>
</span></span><span style="display:flex;"><span>                    target = findClass(name);
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">if</span> (resolve) {
</span></span><span style="display:flex;"><span>                resolveClass(target); <span style="color:#007f7f">// native方法</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span> target;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// findClass是模板方法，需要重写</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">protected</span> Class&lt;?&gt; findClass(String name) <span style="color:#fff;font-weight:bold">throws</span> ClassNotFoundException {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> ClassNotFoundException(name);
</span></span><span style="display:flex;"><span>    }    
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>到现在就剩下findClass这个模板方法了，URLClassLoader继承了ClassLoader以后，重写了此方法，做了三件事：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">protected</span> Class&lt;?&gt; findClass(<span style="color:#fff;font-weight:bold">final</span> String name) <span style="color:#fff;font-weight:bold">throws</span> ClassNotFoundException {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 1、安全检查</span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 2、根据绝对路径把硬盘上class文件读入内存</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">byte</span>[] raw = getBytes(name); 
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 3、将二进制数据转换成class对象</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> defineClass(raw);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们自己去实现一个类加载器，基本上就是继承ClassLoader之后重写findClass方法，且在此方法的最后调用defineClass方法。</p>
<h4 id="为什么要双亲委派">为什么要双亲委派<a hidden class="anchor" aria-hidden="true" href="#为什么要双亲委派">#</a></h4>
<p>确保类的全局唯一性。
例如，类<code>java.lang.Object</code>存放在 <code>jre\lib\rt.jar</code>中，因此无论是哪个类加载器要加载此类，最终都会委派给启动类加载器（BootstrapClassLoader）进行加载，其他类加载器没有机会再去加载，保证了Object类在程序中的各种类加载器中都是同一个类。</p>
<p><img loading="lazy" src="/posts/java/jvm/21.png">
<img loading="lazy" src="/posts/java/jvm/22.png"></p>
<p><a href="https://zhuanlan.zhihu.com/p/73359363">参考</a></p>
<h3 id="osgi动态模型系统">OSGI（动态模型系统）<a hidden class="anchor" aria-hidden="true" href="#osgi动态模型系统">#</a></h3>
<p>OSGi(Open Service Gateway Initiative)，是面向 Java 的动态模型系统，是 Java 动态化模块化系统的一系列规范。</p>
<ul>
<li>
<p>动态改变构造
OSGi 服务平台提供在多种网络设备上无需重启的动态改变构造的功能。为了最小化耦合度和促使这些耦合度可管理，OSGi 技术提供一种面向服务的架构，它能使这些组件动态地发现对方。</p>
</li>
<li>
<p>模块化编程与热插拔
OSGi 旨在为实现 Java 程序的模块化编程提供基础条件，基于 OSGi 的程序很可能可以实现模块级的热插拔功能，当程序升级更新时，可以只停用、重新安装然后启动程序的其中一部分，这对企业级程序开发来说是非常具有诱惑力的特性。OSGi 描绘了一个很美好的模块化开发目标，而且定义了实现这个目标的所需要服务与架构，同时也有成熟的框架进行实现支持。但并非所有的应用都适合采用 OSGi 作为基础架构，它在提供强大功能同时，也引入了额外的复杂度，因为它不遵守了类加载的双亲委托模型。
<a href="https://blog.csdn.net/acmman/article/details/50848595">OSGI参考</a></p>
</li>
</ul>
<h2 id="验证">验证<a hidden class="anchor" aria-hidden="true" href="#验证">#</a></h2>
<p>这一阶段的主要目的是为了确保 Class 文件的字节流中包含的信息是否符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。不同的虚拟机对类验证的实现可能会有所不同，但大致都会完成以下四个阶段的验证：文件格式的验证、元数据的验证、字节码验证和符号引用验证。</p>
<h2 id="准备">准备<a hidden class="anchor" aria-hidden="true" href="#准备">#</a></h2>
<p>准备阶段是正式为类变量分配内存并设置类变量的初始值阶段，即在方法区中分配这些变量所使用的内存空间。对于该阶段有以下几点需要注意：</p>
<ul>
<li>这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在Java堆中。</li>
<li>这里所设置的初始值通常情况下是数据类型默认的零值（如0、0L、null、false等），而不是被在Java代码中被显式地赋予的值。</li>
</ul>
<p>假设一个类变量的定义为：
<code>public static int value = 3;</code></p>
<p>那么变量value在准备阶段过后的初始值为0，而不是3，因为这时候尚未开始执行任何Java方法，而把value赋值为3的putstatic指令是在程序编译后，存放于类构造器<code>&lt;clinit&gt;（）</code>方法之中的，所以把value赋值为3的动作将在初始化阶段才会执行。</p>
<p>另外，如果类字段的字段属性表中存在ConstantValue属性，即同时被final和static修饰，那么在准备阶段变量value就会被初始化为ConstValue属性所指定的值。
<code>public static final int value = 3;</code>
编译时Javac将会为value生成ConstantValue属性，在准备阶段虚拟机就会根据ConstantValue的设置将value赋值为3。回忆上一篇博文中对象被动引用的第2个例子，便是这种情况。我们可以理解为static final常量在编译期就将其结果放入了调用它的类的常量池中。</p>
<h2 id="解析">解析<a hidden class="anchor" aria-hidden="true" href="#解析">#</a></h2>
<p>解析阶段是指虚拟机将常量池中的符号引用替换为直接引用的过程。前面说解析阶段可能开始于初始化之前，也可能在初始化之后开始，虚拟机会根据需要来判断。
对同一个符号引用进行多次解析请求是很常见的事情，虚拟机实现可能会对第一次解析的结果进行缓存（在运行时常量池中记录直接引用，并把常量标示为已解析状态），从而避免解析动作重复进行。
解析动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行，分别对应于常量池中</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>CONSTANT_Class_info、
</span></span><span style="display:flex;"><span>CONSTANT_Fieldref_info、
</span></span><span style="display:flex;"><span>CONSTANT_Methodref_info、
</span></span><span style="display:flex;"><span>CONSTANT_InterfaceMethodref_info
</span></span></code></pre></td></tr></table>
</div>
</div><p>四种常量类型。</p>
<ul>
<li>
<p>类方法解析：对类方法的解析与对字段解析的搜索步骤差不多，只是多了判断该方法所处的是类还是接口的步骤，而且对类方法的匹配搜索，是先搜索父类，再搜索接口。</p>
</li>
<li>
<p>接口方法解析：与类方法解析步骤类似，只是接口不会有父类，因此，只递归向上搜索父接口就行了。</p>
</li>
<li>
<p>类或接口的解析：判断所要转化成的直接引用是对数组类型，还是普通的对象类型的引用，从而进行不同的解析。</p>
</li>
<li>
<p>字段解析：对字段进行解析时，会先在本类中查找是否包含有简单名称和字段描述符都与目标相匹配的字段，如果有，则查找结束；如果没有，则会按照继承关系从上往下递归搜索该类所实现的各个接口和它们的父接口，还没有，则按照继承关系从上往下递归搜索其父类，直至查找结束，查找流程如下所示：
本类-&gt;接口-&gt;父接口-&gt;父类-&gt;祖父类</p>
</li>
</ul>
<p>从下面代码看出来字段解析的搜索顺序：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> Super{
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">int</span> m = 11;
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">static</span>{
</span></span><span style="display:flex;"><span>		System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;执行了super类静态语句块&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> Father <span style="color:#fff;font-weight:bold">extends</span> Super{
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">int</span> m = 33;
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">static</span>{
</span></span><span style="display:flex;"><span>		System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;执行了父类静态语句块&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> Child <span style="color:#fff;font-weight:bold">extends</span> Father{
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">static</span>{
</span></span><span style="display:flex;"><span>		System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;执行了子类静态语句块&#34;</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> StaticTest{
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args){
</span></span><span style="display:flex;"><span>		System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(Child.<span style="color:#007f7f">m</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>执行结果如下<span style="color:#f00">：</span>
</span></span><span style="display:flex;"><span>执行了super类静态语句块
</span></span><span style="display:flex;"><span>执行了父类静态语句块
</span></span><span style="display:flex;"><span>33
</span></span><span style="display:flex;"><span>如果注释掉Father类中对m定义的那一行<span style="color:#f00">，</span>则输出结果如下<span style="color:#f00">：</span>
</span></span><span style="display:flex;"><span>执行了super类静态语句块
</span></span><span style="display:flex;"><span>11
</span></span></code></pre></td></tr></table>
</div>
</div><p>static变量发生在静态解析阶段，也即是初始化之前，此时已经将字段的符号引用转化为了内存引用，也便将它与对应的类关联在了一起，由于在子类中没有查找到与m相匹配的字段，那么m便不会与子类关联在一起，因此并不会触发子类的初始化。
最后需要注意：理论上是按照上述顺序进行搜索解析，但在实际应用中，虚拟机的编译器实现可能要比上述规范要求的更严格一些。如果有一个同名字段同时出现在该类的接口和父类中，或同时在自己或父类的接口中出现，编译器可能会拒绝编译。如果对上面的代码做些修改，将Super改为接口，并将Child类继承Father类且实现Super接口，那么在编译时会报出如下错误：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>StaticTest.java:24: 对 m 的引用不明确，Father 中的 变量 m 和 Super 中的 变量 m
</span></span><span style="display:flex;"><span>都匹配System.out.println(Child.m);
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="初始化">初始化<a hidden class="anchor" aria-hidden="true" href="#初始化">#</a></h2>
<p>初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载
器以外，其它操作都由 JVM 主导。到了初始阶段，才开始真正执行类中定义的 Java 程序代码。
在准备阶段，类变量已经被赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序指定的主观计划去初始化类变量和其他资源，或者可以从另一个角度来表达：初始化阶段是执行类构造器 <code>&lt;clinit&gt;</code> ()方法的过程。
<code>&lt;clinit&gt;（）</code>方法的执行规则：</p>
<ul>
<li><code>&lt;clinit&gt;（）</code> 方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句中可以赋值，但是不能访问。
-<code> &lt;clinit&gt;（）</code> 方法与实例构造器<code>&lt;init&gt;（）</code>方法（类的构造函数）不同，它不需要显式地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;（）</code>方法执行之前，父类的<code>&lt;clinit&gt;（）</code>方法已经执行完毕。因此，在虚拟机中第一个被执行的<code>&lt;clinit&gt;（）</code>方法的类肯定是java.lang.Object。</li>
<li><code>&lt;clinit&gt;（）</code>方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成<code>&lt;clinit&gt;（）</code>方法。</li>
<li>接口中不能使用静态语句块，但仍然有类变量（final static）初始化的赋值操作，因此接口与类一样会生成<code>&lt;clinit&gt;（）</code>方法。但是接口鱼类不同的是：执行接口的<code>&lt;clinit&gt;（）</code>方法不需要先执行父接口的<code>&lt;clinit&gt;（）</code>方法，只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;（）</code>方法。</li>
<li>虚拟机会保证一个类的<code>&lt;clinit&gt;（）</code>方法在多线程环境中被正确地加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的<code>&lt;clinit&gt;（）</code>方法，其他线程都需要阻塞等待，直到活动线程执行<code>&lt;clinit&gt;（）</code>方法完毕。如果在一个类的<code>&lt;clinit&gt;（）</code>方法中有耗时很长的操作，那就可能造成多个线程阻塞，在实际应用中这种阻塞往往是很隐蔽的。</li>
</ul>
<p>下面给出一个简单的例子，以便更清晰地说明如上规则：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> Father{
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">int</span> a = 1;
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">static</span>{
</span></span><span style="display:flex;"><span>		a = 2;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">class</span> Child <span style="color:#fff;font-weight:bold">extends</span> Father{
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">int</span> b = a;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span> 
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> ClinitTest{
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args){
</span></span><span style="display:flex;"><span>		System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(Child.<span style="color:#007f7f">b</span>);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>执行上面的代码，会打印出2，也就是说b的值被赋为了2。
我们来看得到该结果的步骤。首先在准备阶段为类变量分配内存并设置类变量初始值，这样A和B均被赋值为默认值0，而后再在调用<code>&lt;clinit&gt;（）</code>方法时给他们赋予程序中指定的值。当我们调用Child.b时，触发Child的<code>&lt;clinit&gt;（）</code>方法，根据规则2，在此之前，要先执行完其父类Father的<code>&lt;clinit&gt;（）</code>方法，又根据规则1，在执行<code>&lt;clinit&gt;（）</code>方法时，需要按static语句或static变量赋值操作等在代码中出现的顺序来执行相关的static语句，因此当触发执行Father的<code>&lt;clinit&gt;（）</code>方法时，会先将a赋值为1，再执行static语句块中语句，将a赋值为2，而后再执行Child类的<code>&lt;clinit&gt;（）</code>方法，这样便会将b的赋值为2。</p>
<p>如果我们颠倒一下Father类中“public static int a = 1;”语句和“static语句块”的顺序，程序执行后，则会打印出1。很明显是根据规则1，执行Father的<code>&lt;clinit&gt;（）</code>方法时，根据顺序先执行了static语句块中的内容，后执行了“public static int a = 1;”语句。
另外，在颠倒二者的顺序之后，如果在static语句块中对a进行访问（比如将a赋给某个变量），在编译时将会报错，因为根据规则1，它只能对a进行赋值，而不能访问。</p>
<p>注意以下几种情况不会执行类初始化：</p>
<ul>
<li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。</li>
<li>定义对象数组，不会触发该类的初始化。</li>
<li>常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类。</li>
<li>通过类名获取 Class 对象，不会触发类的初始化。</li>
<li>通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。</li>
<li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。</li>
</ul>
<h1 id="jvm参数">JVM参数<a hidden class="anchor" aria-hidden="true" href="#jvm参数">#</a></h1>
<h2 id="堆栈空间配置">堆栈空间配置<a hidden class="anchor" aria-hidden="true" href="#堆栈空间配置">#</a></h2>
<h3 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h3>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-Xms</td>
<td>初始堆大小</td>
</tr>
<tr>
<td>-Xmx</td>
<td>最大堆空间</td>
</tr>
<tr>
<td>-Xmn</td>
<td>设置新生代大小</td>
</tr>
<tr>
<td>-XX:SurvivorRatio</td>
<td>设置新生代eden空间和from/to空间的比例关系</td>
</tr>
<tr>
<td>-XX:PermSize</td>
<td>方法区初始大小</td>
</tr>
<tr>
<td>-XX:MaxPermSize</td>
<td>方法区最大大小</td>
</tr>
<tr>
<td>-XX:MetaspaceSize</td>
<td>元空间GC阈值（JDK1.8）</td>
</tr>
<tr>
<td>-XX:MaxMetaspaceSize</td>
<td>最大元空间大小（JDK1.8）</td>
</tr>
<tr>
<td>-Xss</td>
<td>栈大小</td>
</tr>
<tr>
<td>-XX:MaxDirectMemorySize</td>
<td>直接内存大小，默认为最大堆空间</td>
</tr>
</tbody>
</table>
<h3 id="堆配置">堆配置<a hidden class="anchor" aria-hidden="true" href="#堆配置">#</a></h3>
<p>堆的初始空间大小：-Xms
堆的最大空间大小：-Xmx</p>
<p>设置 JVM 的初始堆大小为 20M，最大堆空间为 30M
<code>java -Xms20m -Xmx30m GCDemo.jar</code></p>
<h4 id="新生代-1">新生代<a hidden class="anchor" aria-hidden="true" href="#新生代-1">#</a></h4>
<p>在 JDK1.8 中，堆分为年轻代和老年代。
设置年轻代内存的大小：-Xmn
jvm没有提供参数设置老年代的大小。但其实老年代的大小就等于堆大小减去年轻代大小。</p>
<p>设置 JVM 堆初始大小为20M。其中年轻代的大小为 10M，那么剩下的就是老年代的大小，有 10M了
<code>java -Xms20m -Xmn10M GCDemo</code>
可以给上述命令加上<code>-XX:+PrintGCDetails</code>参数来查看内存区域的分配信息。</p>
<h5 id="eden区">Eden区<a hidden class="anchor" aria-hidden="true" href="#eden区">#</a></h5>
<p>在年轻代中，分为三个区域，分别是：eden 空间、from 空间、to 空间。如果要设置这部分的大小，那么就使用 -XX:SurvivorRatio 这个参数，该参数设置 eden / from 空间的比例关系，该参数的公式如下：
<code>-XX:SurvivorRatio = eden/from = eden/to</code>
例如我们的年轻代有 10 M，而我们设置 -XX:SurvivorRatio 参数为 2。也就是说 eden / from = eden / to = 2。这里教一个快速计算的方法，我们假设 eden = 2，那么 from = 1，to = 1，那么 eden + from + to = 10M。这样就可以算出每一份大小是 10/4 = 2.5M。所以 Eden 区 = 2.5 * 2 = 5M，from 区是 2.5 M，to 区是 2.5 M。</p>
<p>下面我们运行下命令来验证一下。
<code>java -Xms20m -Xmn10M -XX:SurvivorRatio=2 -XX:+PrintGCDetails GCDemo</code>
在上面的启动参数中，我们设置堆初始大小为 20M，年轻代大小为 10M，年轻代的 SurvivorRatio 比例为 2。那么最终分配的结果将会是：年轻代 10M，其中 Eden 区 5M、From 区 2.5M、To 区 2.5 M，老年代 10M。</p>
<p>查看<code>-XX:+PrintGCDetails</code>的结果，可以得知：
eden 空间是 5120 K，from 和 to 空间是 2560 K。
Details的结果还有一个细节，即 PSYoungGen 这里的 total 只有 7680K，难道年轻代只有 7.5M 的内存吗？为什么不是 10M 呢？其实是因为这里的 total 指的是可用内存。
from space 和 to space 两个区域同一时间只有一个区域是可以用的。
所以可用内存是 （eden）5120 +（from 或 to） 2560 = 7680。</p>
<h3 id="永久代jdk17">永久代（JDK1.7）<a hidden class="anchor" aria-hidden="true" href="#永久代jdk17">#</a></h3>
<p>在 JDK 1.8 之前，所加载的类信息都放在永久代中。我们用 -XX:PermSize 设置永久代初始大小，用 -XX:MaxPermSize 设置永久代最大大小。
<code>java -XX:PermSize10m -XX:MaxPermSize50m -XX:+PrintGCDetails GCDemo</code>
在上面的启动参数中，我们设置永久代初始大小为 10M，最大大小为 50M。我们在 JDK1.7 的环境下运行上面的命令，会看到如下的 GC 日志，略。</p>
<h3 id="元空间jdk18">元空间（JDK1.8）<a hidden class="anchor" aria-hidden="true" href="#元空间jdk18">#</a></h3>
<p>在 JDK 1.8 之前，所有加载的类信息都放在永久代中。但在 JDK1.8 之时，永久代被移除，取而代之的是元空间（Metaspace）。在元空间这块内存中，有两个参数很相似，它们是：
-XX:MetaspaceSize：元空间发生 GC 的初始阈值
-XX:MaxMetaspaceSize：元空间的最大大小</p>
<p><code>java -XX:MetaspaceSize=10m -XX:MaxMetaspaceSize=50m -XX:+PrintGCDetails GCDemo</code>
上面的命令中，我们设置 MetaspaceSize 为 10M，MaxMetaspaceSize 为 50M。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Metaspace used 2639K
</span></span><span style="display:flex;"><span>class space used 286K
</span></span></code></pre></td></tr></table>
</div>
</div><p>从上面的执行结果可以看到，Metaspace 空间的大小为 2.6M 左右，并不是我们设置的 10M。那是因为 MetaspaceSize 设置的是元空间发生 GC 的初始阈值。当达到这个值时，元空间发生 GC 操作，这个值默认是 20.8M。而 MaxMetaspaceSize 则是设置元空间的最大大小，默认基本是机器的物理内存大小。虽然可以不设置，但还是建议设置一下，因为如果一直不断膨胀，那么 JVM 进程可能会被 OS kill 掉。</p>
<h3 id="栈空间">栈空间<a hidden class="anchor" aria-hidden="true" href="#栈空间">#</a></h3>
<p>栈空间是每个线程各自有的一块区域，如果栈空间太小，也会导致 StackOverFlow 异常。而要设置栈空间大小，只需要使用 -Xss 参数就可以。
<code>java -Xss2m GCDemo</code>
上面的启动命令设置最大栈空间为 2M。</p>
<h3 id="直接内存-1">直接内存<a hidden class="anchor" aria-hidden="true" href="#直接内存-1">#</a></h3>
<p>使用 -XX:MaxDirectMemorySize 设置最大直接内存。如果不设置，默认为最大堆空间，即 -Xmx。
<code>java -XX:MaxDirectMemorySize=50m GCDemo</code>
上面的启动命令设置直接内存最大值为 50M。
当直接内存使用达到设置值时，就会触发垃圾回收。如果不能有效释放足够空间，就会引发直接内存溢出导致系统的 OOM。</p>
<h2 id="查看jvm参数">查看JVM参数<a hidden class="anchor" aria-hidden="true" href="#查看jvm参数">#</a></h2>
<ul>
<li>打印显式参数 -XX:+PrintVMOptions
该参数表示程序运行时，打印虚拟机接受到的命令行显式参数。我们用下面的命令运行程序：
<code>java  -XX:+UseSerialGC -XX:+PrintVMOptions com.wjy.ClassLoadDemo</code>
输出结果：</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>VM option &#39;+UseSerialGC&#39;
</span></span><span style="display:flex;"><span>VM option &#39;+PrintVMOptions&#39;
</span></span><span style="display:flex;"><span>Hello, I&#39;m wjy
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到我们设置了+UseSerialGC和+PrintVMOptions两个参数，最后运行时也将这两个参数打印出来了。</p>
<ul>
<li>打印显式隐式参数 -XX:+PrintCommandLineFlags
该参数打印传递给虚拟机的显式和隐式参数。我们用下面的命令运行程序：
<code>java  -XX:+UseSerialGC -XX:+PrintCommandLineFlags com.wjy.ClassLoadDemo</code></li>
</ul>
<p>输出：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>-XX:InitialHeapSize=134217728 -XX:MaxHeapSize=2147483648
</span></span><span style="display:flex;"><span>-XX:+PrintCommandLineFlags -XX:+UseCompressedClassPointers
</span></span><span style="display:flex;"><span>-XX:+UseCompressedOops -XX:+UseSerialGC
</span></span><span style="display:flex;"><span>Hello, I&#39;m wjy
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到程序不仅输出了我们显式设置的参数，还将虚拟机默认的参数打印了出来，包括初始堆大小（134217728），最大堆大小（2147483648）等。</p>
<ul>
<li>打印所有系统参数 -XX:+PrintFlagsFinal
<code>java  -XX:+UseSerialGC -XX:+PrintFlagsFinal com.wjy.ClassLoadDemo  &gt; jvm_flag_final.txt</code></li>
</ul>
<p>之后打开 jvm_flag_final.txt 文件，可以看到有 800 多行，这是因为程序将虚拟机的所有参数都打印了出来。下面列几个我们常用的参数看看就可以：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>uintx InitialHeapSize := 134217728 {product}
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>uintx MaxMetaspaceSize = 18446744073709547520 {product}
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>uintx MetaspaceSize = 21807104 {pd product}
</span></span></code></pre></td></tr></table>
</div>
</div><p>从上面我们列出的部分参数可以看到，上面三个参数分别是设置初始堆大小、元空间最大大小、初始元空间大小。</p>
<h2 id="追踪类信息">追踪类信息<a hidden class="anchor" aria-hidden="true" href="#追踪类信息">#</a></h2>
<p>我们都知道 JVM 在启动的时候会去加载类信息，那么我们怎么得知他加载了哪些类，又卸载了哪些类呢？我们这一节就来介绍四个 JVM 参数，使用它们我们就可以清晰地知道 JVM 的类加载信息。
为了方便演示，我们使用下面的程序作为本次的演示程序。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> ClassLoadDemo {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) {
</span></span><span style="display:flex;"><span>        String name = <span style="color:#0ff;font-weight:bold">&#34;chenshuyi&#34;</span>;
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;Hello, I&#39;m &#34;</span> + name);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>跟踪类的加载和卸载 -verbose:class
<code>java -verbose:class com.chenshuyi.ClassLoadDemo &gt; class_load_info.txt</code>
之后我们打开 class_load_info.txt 文件。因为该文件太大，所以我们节选一部分：</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>...省略...
</span></span><span style="display:flex;"><span>[Loaded java.util.ArrayList from /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/rt.jar]
</span></span><span style="display:flex;"><span>...省略...
</span></span><span style="display:flex;"><span>[Loaded java.util.HashMap from /Library/Java/JavaVirtualMachines/jdk1.8.0_181.jdk/Contents/Home/jre/lib/rt.jar]
</span></span><span style="display:flex;"><span>...省略...	
</span></span><span style="display:flex;"><span>[Loaded com.chenshuyi.ClassLoadDemo from file:/Users/yurongchan/Yosemite/Code/practice/target/classes/]
</span></span><span style="display:flex;"><span>...省略...
</span></span></code></pre></td></tr></table>
</div>
</div><p>从上面可以看到 JVM 分别加载了 ArrayList、HashMap 类，以及我们自己定义的 ClassLoadDemo 类。</p>
<ul>
<li>
<p>跟踪类的加载 -XX:+TraceClassLoading
该参数与可以显示类的加载信息，输出的结果和 -verbose:class 一样，但比起它少了类的卸载信息。</p>
</li>
<li>
<p>跟踪类的卸载 -XX:+TraceClassUnloading
该参数与可以显示类的加载信息，输出的结果和 -verbose:class 一样，但比起它少了类的加载信息。但实际上我们通过上面这个简单的例子，没有发现类的卸载信息，或许是例子太简单了，所以没有这个。</p>
</li>
<li>
<p>-XX:+PrintClassHistogram
该参数表示遇到 Ctrl-Break 后打印类实例的柱状信息，与 jmap -histo 功能相同。
了解了这些参数，能够让我们更好地了解哪些类已经被加载到 JVM 中，从而更好地排查问题。最后来个总结，加强记忆：</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-verbose:class</td>
<td>跟踪类的加载和卸载</td>
</tr>
<tr>
<td>-XX:+TraceClassLoading</td>
<td>跟踪类的加载</td>
</tr>
<tr>
<td>-XX:+TraceClassUnloading</td>
<td>跟踪类的卸载</td>
</tr>
<tr>
<td>-XX:+PrintClassHistogram</td>
<td>显示类信息柱状图</td>
</tr>
</tbody>
</table>
<h2 id="gc日志配置">GC日志配置<a hidden class="anchor" aria-hidden="true" href="#gc日志配置">#</a></h2>
<p>对于 GC 日志，我们不仅要学会看懂，而且要学会如何设置对应的 GC 日志参数。
为了能够更直观地显示出每个参数的作用，我们将以下面的 Demo 为例子去设置 GC 日志参数。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> GCDemo {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// allocate 4M space</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">byte</span>[] b = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">byte</span>[4 * 1024 * 1024];
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;first allocate&#34;</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// allocate 4M space</span>
</span></span><span style="display:flex;"><span>        b = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">byte</span>[4 * 1024 * 1024];
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;second allocate&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在上面的程序中，我们两次分配了 4M 的内存空间。为了认为制造 GC，我们启动时的 JVM 参数固定加上下面几个参数：
<code>-XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8</code></p>
<p>-XX：UseSerialGC 表示强制使用Serial+SerialOld收集器组合
-Xms20m 表示堆空间初始大小为 20 M。
-Xmx20m 表示堆空间最大大小为 20 M。
-Xmn10m 表示新生代大小为 10M。
-XX：urvivorRatio=8 表示Eden:Survivor=8:1
经过上面这个设置，此时我们的堆空间的内存比例情况如下：Eden区 8M，FromSurvivor 1M，ToSurvivor 1M，老年代 10M。</p>
<h3 id="打印gc日志">打印GC日志<a hidden class="anchor" aria-hidden="true" href="#打印gc日志">#</a></h3>
<p>在 GC 日志参数中，最简单的一个参数就是打印 GC 日志：-XX:PrintGC。我们用下面的命令运行程序：
<code>java -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGC com.chenshuyi.GCDemo</code></p>
<p>输出结果：</p>
<p>first allocate
second allocate
[GC (Allocation Failure)  4767K-&gt;4374K(19456K), 0.0045179 secs]</p>
<p>可以看到程序在第一次分配数组空间的时候发生了 GC，并且把 GC 前后以及堆空间大小都打印了出来。该日志显示 GC 前堆空间使用量为 4767K（4M左右）。GC 后堆空间为 4374K，当前可用堆大小为 19456K。</p>
<p>但你会发现使用 PrintGC 参数打印出来的日志比较简单，无法查看更详细的信息。如果你要查看更详细的信息，那么就需要下面这个参数。</p>
<h3 id="打印详细gc日志">打印详细GC日志<a hidden class="anchor" aria-hidden="true" href="#打印详细gc日志">#</a></h3>
<p>如果要查看更加详细的 GC 日志，那么就要使用 -XX:+PrintGCDetails 参数。下面我们使用该参数运行程序：
<code>java -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGC com.chenshuyi.GCDemo</code></p>
<p>程序输出：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>first allocate
</span></span><span style="display:flex;"><span>second allocate
</span></span><span style="display:flex;"><span>[GC (Allocation Failure) [DefNew: 4603K-&gt;278K(9216K), 0.<span style="color:#007f7f">0036744</span> secs] 4603K-&gt;4374K(19456K), 0.<span style="color:#007f7f">0037100</span> secs] [Times: user=0.<span style="color:#007f7f">00</span> sys=0.<span style="color:#007f7f">00</span>, real=0.<span style="color:#007f7f">00</span> secs]
</span></span><span style="display:flex;"><span>Heap
</span></span><span style="display:flex;"><span> def <span style="color:#fff;font-weight:bold">new</span> generation   total 9216K, used 4538K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
</span></span><span style="display:flex;"><span>  eden space 8192K,  52% used [0x00000007bec00000, 0x00000007bf0290e0, 0x00000007bf400000)
</span></span><span style="display:flex;"><span>  from space 1024K,  27% used [0x00000007bf500000, 0x00000007bf545920, 0x00000007bf600000)
</span></span><span style="display:flex;"><span>  to   space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)
</span></span><span style="display:flex;"><span> tenured generation   total 10240K, used 4096K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
</span></span><span style="display:flex;"><span>   the space 10240K,  40% used [0x00000007bf600000, 0x00000007bfa00010, 0x00000007bfa00200, 0x00000007c0000000)
</span></span><span style="display:flex;"><span> Metaspace       used 2649K, capacity 4486K, committed 4864K, reserved 1056768K
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">class</span> space    used 286K, capacity 386K, committed 512K, reserved 1048576K
</span></span></code></pre></td></tr></table>
</div>
</div><p>从上面的日志可以看出，该参数能打印出更加详细的 GC 信息，包括：年轻代的信息、永久代的信息。
<code>[GC (Allocation Failure) [DefNew: 4603K-&gt;278K(9216K), 0.0036744 secs] 4603K-&gt;4374K(19456K), 0.0037100 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]</code></p>
<p>该参数还会在退出之前打印出整个堆的详细信息：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Heap
</span></span><span style="display:flex;"><span> def new generation   total 9216K, used 4538K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
</span></span><span style="display:flex;"><span>  eden space 8192K,  52% used [0x00000007bec00000, 0x00000007bf0290e0, 0x00000007bf400000)
</span></span><span style="display:flex;"><span>  from space 1024K,  27% used [0x00000007bf500000, 0x00000007bf545920, 0x00000007bf600000)
</span></span><span style="display:flex;"><span>  to   space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)
</span></span><span style="display:flex;"><span> tenured generation   total 10240K, used 4096K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
</span></span><span style="display:flex;"><span>   the space 10240K,  40% used [0x00000007bf600000, 0x00000007bfa00010, 0x00000007bfa00200, 0x00000007c0000000)
</span></span><span style="display:flex;"><span> Metaspace       used 2649K, capacity 4486K, committed 4864K, reserved 1056768K
</span></span><span style="display:flex;"><span>  class space    used 286K, capacity 386K, committed 512K, reserved 1048576K
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="gc前后打印堆信息">GC前后打印堆信息<a hidden class="anchor" aria-hidden="true" href="#gc前后打印堆信息">#</a></h3>
<p>上面两个命令基本上可以应付 90% 的使用场景了，但有时候我们在 GC 前后还想获取更加详细的信息。那么我们可以使用 PrintHeapAtGC 参数，该参数会在 GC 前后打印堆信息。
<code>java -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintHeapAtGC com.chenshuyi.GCDemo</code></p>
<p>输出结果：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>first allocate
</span></span><span style="display:flex;"><span>second allocate
</span></span><span style="display:flex;"><span>{Heap before GC invocations=0 (full 0):
</span></span><span style="display:flex;"><span> def <span style="color:#fff;font-weight:bold">new</span> generation   total 9216K, used 4767K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
</span></span><span style="display:flex;"><span>  eden space 8192K,  58% used [0x00000007bec00000, 0x00000007bf0a7e98, 0x00000007bf400000)
</span></span><span style="display:flex;"><span>  from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)
</span></span><span style="display:flex;"><span>  to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)
</span></span><span style="display:flex;"><span> tenured generation   total 10240K, used 0K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
</span></span><span style="display:flex;"><span>   the space 10240K,   0% used [0x00000007bf600000, 0x00000007bf600000, 0x00000007bf600200, 0x00000007c0000000)
</span></span><span style="display:flex;"><span> Metaspace       used 2646K, capacity 4486K, committed 4864K, reserved 1056768K
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">class</span> space    used 286K, capacity 386K, committed 512K, reserved 1048576K
</span></span><span style="display:flex;"><span>Heap after GC invocations=1 (full 0):
</span></span><span style="display:flex;"><span> def <span style="color:#fff;font-weight:bold">new</span> generation   total 9216K, used 278K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)
</span></span><span style="display:flex;"><span>  eden space 8192K,   0% used [0x00000007bec00000, 0x00000007bec00000, 0x00000007bf400000)
</span></span><span style="display:flex;"><span>  from space 1024K,  27% used [0x00000007bf500000, 0x00000007bf545950, 0x00000007bf600000)
</span></span><span style="display:flex;"><span>  to   space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)
</span></span><span style="display:flex;"><span> tenured generation   total 10240K, used 4096K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)
</span></span><span style="display:flex;"><span>   the space 10240K,  40% used [0x00000007bf600000, 0x00000007bfa00010, 0x00000007bfa00200, 0x00000007c0000000)
</span></span><span style="display:flex;"><span> Metaspace       used 2646K, capacity 4486K, committed 4864K, reserved 1056768K
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">class</span> space    used 286K, capacity 386K, committed 512K, reserved 1048576K
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>仔细看一下，会发现在 GC 发生前后都打印了一次堆空间信息。
通过这个参数，我们可以详细了解每次 GC 时堆空间的详细信息。</p>
<h3 id="打印gc发生的时间--xxprintgctimestamps">打印GC发生的时间 -XX:+PrintGCTimeStamps<a hidden class="anchor" aria-hidden="true" href="#打印gc发生的时间--xxprintgctimestamps">#</a></h3>
<p>这个参数非常简单，就是在每次 GC 日志的前面加上一个时间戳。这个时间戳表示 JVM 启动后到现在所逝去的时间。
使用下面的参数运行程序：
<code>java -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGC -XX:+PrintGCTimeStamps com.chenshuyi.GCDemo</code></p>
<p>输出结果：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>first allocate
</span></span><span style="display:flex;"><span>second allocate
</span></span><span style="display:flex;"><span>0.130: [GC (Allocation Failure)  4767K-&gt;4374K(19456K), 0.0051351 secs]
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面日志第 3 行中的「0.130」就是该 GC 发生的时间。</p>
<h3 id="打印应用程序的执行时间--xxprintgcapplicationconcurrenttime">打印应用程序的执行时间 -XX:+PrintGCApplicationConcurrentTime<a hidden class="anchor" aria-hidden="true" href="#打印应用程序的执行时间--xxprintgcapplicationconcurrenttime">#</a></h3>
<p>使用下面的命令运行程序：
<code>java -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGC -XX:+PrintGCApplicationConcurrentTime com.chenshuyi.GCDemo</code></p>
<p>运行结果：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>first allocate
</span></span><span style="display:flex;"><span>second allocate
</span></span><span style="display:flex;"><span>Application time: 0.0371892 seconds
</span></span><span style="display:flex;"><span>[GC (Allocation Failure)  4767K-&gt;4374K(19456K), 0.0040074 secs]
</span></span><span style="display:flex;"><span>Application time: 0.0010712 seconds
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="打印应用由于gc而产生的停顿时间--xxprintgcapplicationstoppedtime">打印应用由于GC而产生的停顿时间 -XX:+PrintGCApplicationStoppedTime<a hidden class="anchor" aria-hidden="true" href="#打印应用由于gc而产生的停顿时间--xxprintgcapplicationstoppedtime">#</a></h3>
<p>使用下面的命令运行程序：
<code>java -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGC -XX:+PrintGCApplicationStoppedTime com.chenshuyi.GCDemo</code></p>
<p>运行结果：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>first allocate
</span></span><span style="display:flex;"><span>second allocate
</span></span><span style="display:flex;"><span>[GC (Allocation Failure)  4767K-&gt;4374K(19456K), 0.0045644 secs]
</span></span><span style="display:flex;"><span>Total time for which application threads were stopped: 0.0047873 seconds, Stopping threads took: 0.0000329 seconds
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到最后一行打印出了因为 GC 而暂停的时间。</p>
<h3 id="保存gc日志--xloggc">保存GC日志 -Xloggc<a hidden class="anchor" aria-hidden="true" href="#保存gc日志--xloggc">#</a></h3>
<p>这个参数可以将 GC 日志输出到文件中保存起来。
使用下面的参数运行程序：
<code>java -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio=8 -XX:+PrintGC -XX:+PrintReferenceGC -Xloggc:gc.log com.chenshuyi.GCDemo</code></p>
<p>运行之后在本目录会生成一个 gc.log 文件，打开该文件：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Java HotSpot(TM) 64-Bit Server VM (25.181-b13) for bsd-amd64 JRE (1.8.0_181-b13), built on Jul  7 2018 01:02:31 by &#34;java_re&#34; with gcc 4.2.1 (Based on Apple Inc. build 5658) (LLVM build 2336.11.00)
</span></span><span style="display:flex;"><span>Memory: 4k page, physical 8388608k(45132k free)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>/proc/meminfo:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>CommandLine flags: -XX:InitialHeapSize=20971520 -XX:MaxHeapSize=20971520 -XX:MaxNewSize=10485760 -XX:NewSize=10485760 -XX:+PrintGC -XX:+PrintGCTimeStamps -XX:+PrintReferenceGC -XX:SurvivorRatio=8 -XX:+UseCompressedClassPointers -XX:+UseCompressedOops -XX:+UseSerialGC 
</span></span><span style="display:flex;"><span>0.124: [GC (Allocation Failure)  4767K-&gt;4374K(19456K), 0.0047748 secs]
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到堆的相关信息，以及 GC 的信息。</p>
<h3 id="总结-1">总结<a hidden class="anchor" aria-hidden="true" href="#总结-1">#</a></h3>
<p>除了上面这些参数，还有可以查看弱引用的参数：-XX:+PrintReferenceGC。它跟踪软引用、弱引用、虚引用和Finallize队列的信息，但是使用场景较为狭窄。基本上掌握上面的几个常用的 GC 日志参数就足够排查使用，最重要的是弄清楚每个参数的作用和用法。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-XX:PrintGC</td>
<td>打印GC日志</td>
</tr>
<tr>
<td>-XX:+PrintGCDetails</td>
<td>打印详细的GC日志。还会在退出前打印堆的详细信息。</td>
</tr>
<tr>
<td>-XX:+PrintHeapAtGC</td>
<td>每次GC前后打印堆信息。</td>
</tr>
<tr>
<td>-XX:+PrintGCTimeStamps</td>
<td>打印GC发生的时间。</td>
</tr>
<tr>
<td>-XX:+PrintGCApplicationConcurrentTime</td>
<td>打印应用程序的执行时间</td>
</tr>
<tr>
<td>-XX:+PrintGCApplicationStoppedTime</td>
<td>打印应用由于GC而产生的停顿时间</td>
</tr>
<tr>
<td>-XX:+PrintReferenceGC</td>
<td>跟踪软引用、弱引用、虚引用和Finallize队列。</td>
</tr>
<tr>
<td>-XLoggc</td>
<td>将GC日志以文件形式输出。</td>
</tr>
</tbody>
</table>
<h2 id="jdk性能监控命令">JDK性能监控命令<a hidden class="anchor" aria-hidden="true" href="#jdk性能监控命令">#</a></h2>
<h3 id="查看虚拟机进程jps-命令">查看虚拟机进程：jps 命令<a hidden class="anchor" aria-hidden="true" href="#查看虚拟机进程jps-命令">#</a></h3>
<p>jps 命令可以列出所有的 Java 进程。如果 jps 不加任何参数，可以列出 Java 程序的进程 ID 以及 Main 函数短名称，如下所示。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>$ jps
</span></span><span style="display:flex;"><span>6540 Jps
</span></span><span style="display:flex;"><span>64447 Main
</span></span></code></pre></td></tr></table>
</div>
</div><p>除此之外，还可以指定下面的参数自定义输出信息：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-q</td>
<td>指定jps只输出进程ID</td>
</tr>
<tr>
<td>-m</td>
<td>输出传递给Java进程的参数</td>
</tr>
<tr>
<td>-l</td>
<td>输出主函数的完整路径</td>
</tr>
<tr>
<td>-v</td>
<td>显示传递给Java虚拟机的参数</td>
</tr>
</tbody>
</table>
<h3 id="虚拟机统计信息jstat-命令">虚拟机统计信息：jstat 命令<a hidden class="anchor" aria-hidden="true" href="#虚拟机统计信息jstat-命令">#</a></h3>
<p>jstat 用于观察 Java 堆信息的详细情况，基本语法：
<code>jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt;] [&lt;count&gt;]]</code>
其中 option 可以由以下值构成。</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>-class</td>
<td>监视类装载、卸载数量、总空间以及类装载所耗费的时间</td>
</tr>
<tr>
<td>-gc</td>
<td>监视Java堆状况，包括Eden区、两个Survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息</td>
</tr>
<tr>
<td>-gccapacity</td>
<td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcutil</td>
<td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td>
</tr>
<tr>
<td>-gccause</td>
<td>与-gcutil功能一样，但是会额外输出导致上一次GC产生的原因</td>
</tr>
<tr>
<td>-gcnew</td>
<td>监视新生代GC状况</td>
</tr>
<tr>
<td>-gcnewcapacity</td>
<td>监视内容与-gcnew基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcold</td>
<td>监视老年代GC状况</td>
</tr>
<tr>
<td>-gcoldcapacity</td>
<td>监视内容与-gcold基本相同，输出主要关注使用到的最大、最小空间</td>
</tr>
<tr>
<td>-gcpermcapacity</td>
<td>输出永久代使用到的最大、最小空间</td>
</tr>
<tr>
<td>-compiler</td>
<td>输出JIT编译器编译过的方法、耗时信息</td>
</tr>
<tr>
<td>-printcompilation</td>
<td>输出已经被JIT编译的方法</td>
</tr>
</tbody>
</table>
<p>-t 参数表示输出时间戳、-h 参数表示在多少行后输出一个表头、vmid 则是虚拟机的进程ID、interval 和 count 表示输出间隔以及输出次数。
例如：我们用jstat命令来监视一个LVMID为2365的JVM进程。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>$ jstat -gcutil 2365 
</span></span><span style="display:flex;"><span>  S0     S1     E      O      P     YGC     YGCT    FGC    FGCT     GCT   
</span></span><span style="display:flex;"><span>  0.00   0.00  12.05   0.00  14.17      0    0.000     0    0.000    0.000
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中每个选项的意义如下：</p>
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>S0、S1</td>
<td>表示Survivor0、Survivor1，还未使用。</td>
</tr>
<tr>
<td>E</td>
<td>表示Eden区使用了12.05%的空间。</td>
</tr>
<tr>
<td>O</td>
<td>表示老年代还未使用。</td>
</tr>
<tr>
<td>P</td>
<td>表示永久代使用了14.17%的空间</td>
</tr>
<tr>
<td>YUC、YGCT</td>
<td>表示从程序运行以来一共发生了0次Minor GC（YGC，Young GC），总共耗时0秒。</td>
</tr>
<tr>
<td>FGC、FGCT</td>
<td>表示从程序运行以来一共发生了0次Full GC（FGC，Full GC），总共耗时0秒。</td>
</tr>
</tbody>
</table>
<h3 id="查看虚拟机参数jinfo-命令">查看虚拟机参数：jinfo 命令<a hidden class="anchor" aria-hidden="true" href="#查看虚拟机参数jinfo-命令">#</a></h3>
<p>jinfo 可以用来查看正在运行的 Java 应用程序的扩展参数，甚至支持在运行时，修改部分参数。它的基本语法是：
<code>jinfo &lt;option&gt; &lt;pid&gt;</code></p>
<p>执行例子，查询 CMSInitiatingOccupancyFraction 参数值</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>$ jinfo -flag CMSInitiatingOccupancyFraction 2618
</span></span><span style="display:flex;"><span>-XX:CMSInitiatingOccupancyFraction=-1
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="导出堆到文件jmap-命令">导出堆到文件：jmap 命令<a hidden class="anchor" aria-hidden="true" href="#导出堆到文件jmap-命令">#</a></h3>
<p>jmap 是一个多功能命令，可以生成 Java 程序的 Dump 文件，也可以查看堆内对象实例的统计信息、查看 ClassLoader 的信息以及 finalizer 队列。
<code>jmap [option] vmid</code>
执行样例，使用 jmap 生成一个正在运行的 Eclipse 的 dump 快照文件的例子。例子中的2618是通过jps名称查询到的LVMID。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>$ jmap -dump:format=b,file=Desktop/dump.bin 2618
</span></span><span style="display:flex;"><span>Dumping heap to /Users/yurongchan/Desktop/dump.bin ...
</span></span><span style="display:flex;"><span>Heap dump file created
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="堆分析工具jhat-命令">堆分析工具：jhat 命令<a hidden class="anchor" aria-hidden="true" href="#堆分析工具jhat-命令">#</a></h3>
<p>jhat 命令用于分析 Java 应用的对快照内存。Sun JDK 提供了 jhat 命令与 jmap 搭配使用，来分析 jmap 生成的堆转储快照。jhat 内置了一个微型的 HTTP/HTML 服务器，生成 dump 文件的分析结果后，可以在浏览器中查看。下面我们用 jhat 来分析上面生成的 dump.bin 文件：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>$ jhat dump.bin 
</span></span><span style="display:flex;"><span>Reading from dump.bin...
</span></span><span style="display:flex;"><span>Dump file created Sun May 15 23:04:19 CST 2016
</span></span><span style="display:flex;"><span>Snapshot read, resolving...
</span></span><span style="display:flex;"><span>Resolving 13822 objects...
</span></span><span style="display:flex;"><span>Chasing references, expect 2 dots..
</span></span><span style="display:flex;"><span>Eliminating duplicate references..
</span></span><span style="display:flex;"><span>Snapshot resolved.
</span></span><span style="display:flex;"><span>Started HTTP server on port 7000
</span></span><span style="display:flex;"><span>Server is ready.
</span></span></code></pre></td></tr></table>
</div>
</div><p>之后在浏览器输入 http://localhost:7000 就可以看到分析结果，如下图所示：
（略）</p>
<p>不过一般情况下不用 jhat 命令来分析 dump 文件，主要有以下两个原因：一是一般不会再部署应用的服务器上分析 dump 文件，因为分析工作是一个耗时而且消耗硬件资源的过程。另一个原因是 jhat 的分析功能还比较简陋，比起后面介绍的 VisualVM 等工具还差得很多。</p>
<h3 id="查看线程堆栈jstack-命令">查看线程堆栈：jstack 命令<a hidden class="anchor" aria-hidden="true" href="#查看线程堆栈jstack-命令">#</a></h3>
<p>jstack 命令用于导出 Java 应用程序的线程堆栈。jstack命令格式：
<code>jstack [option] vmid</code></p>
<p>下面使用jstack查看一个线程堆栈的例子：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>nobody $ jstack -l 2618
</span></span><span style="display:flex;"><span>2016-05-15 23:39:04
</span></span><span style="display:flex;"><span>Full thread dump Java HotSpot(TM) 64-Bit Server VM (24.79-b02 mixed mode):
</span></span><span style="display:flex;"><span>&#34;Attach Listener&#34; daemon prio=5 tid=0x00007f83228e6000 nid=0x280b waiting on condition [0x0000000000000000]
</span></span><span style="display:flex;"><span>   java.lang.Thread.State: RUNNABLE
</span></span><span style="display:flex;"><span>   Locked ownable synchronizers:
</span></span><span style="display:flex;"><span>    - None
</span></span><span style="display:flex;"><span>&#34;DestroyJavaVM&#34; prio=5 tid=0x00007f832387e800 nid=0x1303 waiting on condition [0x0000000000000000]
</span></span><span style="display:flex;"><span>   java.lang.Thread.State: RUNNABLE
</span></span><span style="display:flex;"><span>   Locked ownable synchronizers:
</span></span><span style="display:flex;"><span>    - None
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="远程主机信息收集jstatd-命令">远程主机信息收集：jstatd 命令<a hidden class="anchor" aria-hidden="true" href="#远程主机信息收集jstatd-命令">#</a></h3>
<p>jstad 命令用于收集远程主机信息。</p>
<h3 id="多功能命令行jcmd-命令">多功能命令行：jcmd 命令<a hidden class="anchor" aria-hidden="true" href="#多功能命令行jcmd-命令">#</a></h3>
<p>jcmd 命令可以针对给定的 Java 虚拟机执行一条命令。</p>
<h3 id="性能统计工具hprof">性能统计工具：hprof<a hidden class="anchor" aria-hidden="true" href="#性能统计工具hprof">#</a></h3>
<h3 id="性能分析工具-visualvm">性能分析工具 VisualVM<a hidden class="anchor" aria-hidden="true" href="#性能分析工具-visualvm">#</a></h3>
<p>VisualVM是JDK自带的一个用于Java程序性能分析的工具，在JDK安装目录的bin文件夹下名称为jvisualvm.exe。
<a href="https://www.cnblogs.com/baby123/p/11551626.html">参考</a>
<a href="https://www.cnblogs.com/wade-xu/p/4369094.html">参考</a></p>
<p>安装插件失败，是因为插件中心的地址已经改为：
<code>https://visualvm.github.io/pluginscenters.html</code>
进入这个网页，找到JDK对应的版本的url，然后编辑插件中心的url，然后安装插件即可。</p>
<p>还可以单独安装visualVM工具，官网
<a href="https://visualvm.github.io/">https://visualvm.github.io/</a>
<a href="https://www.jianshu.com/p/9e4ccd705709">参考</a></p>
<h1 id="java的四种引用">java的四种引用<a hidden class="anchor" aria-hidden="true" href="#java的四种引用">#</a></h1>
<h2 id="引用与对象">引用与对象<a hidden class="anchor" aria-hidden="true" href="#引用与对象">#</a></h2>
<p>每种编程语言都有自己操作内存中元素的方式，例如在 C 和 C++ 里是通过指针，而在 Java 中则是通过“引用”。在 Java 中一切都被视为了对象，但是我们操作的标识符实际上是对象的一个引用（reference）。
创建一个引用，引用可以独立存在，并不一定需要与一个对象关联
<code>String s;</code>
通过将这个叫“引用”的标识符指向某个对象，之后便可以通过这个引用来实现操作对象了。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String str = <span style="color:#fff;font-weight:bold">new</span> String(<span style="color:#0ff;font-weight:bold">&#34;abc&#34;</span>);
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(str.<span style="color:#007f7f">toString</span>());
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 JDK1.2 之前，Java中的定义很传统：如果 reference 类型的数据中存储的数值代表的是另外一块内存的起始地址，就称为这块内存代表着一个引用。
Java 中的垃圾回收机制在判断是否回收某个对象的时候，都需要依据“引用”这个概念。
在不同垃圾回收算法中，对引用的判断方式有所不同：</p>
<ul>
<li>引用计数法：为每个对象添加一个引用计数器，每当有一个引用指向它时，计数器就加1，当引用失效时，计数器就减1，当计数器为0时，则认为该对象可以被回收（目前在Java中已经弃用这种方式了）。</li>
<li>可达性分析算法：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到GC Roots没有任何引用链相连时，则说明此对象不可用。
JDK1.2 之前，一个对象只有“已被引用”和&quot;未被引用&quot;两种状态，这将无法描述某些特殊情况下的对象，比如，当内存充足时需要保留，而内存紧张时才需要被抛弃的一类对象。</li>
</ul>
<p>所以在 JDK.1.2 之后，Java 对引用的概念进行了扩充，将引用分为了：强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）、虚引用（Phantom Reference）4 种，这 4 种引用的强度依次减弱。</p>
<h2 id="强引用">强引用<a hidden class="anchor" aria-hidden="true" href="#强引用">#</a></h2>
<p>Java中默认声明的就是强引用，比如：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">//只要obj还指向Object对象，Object对象就不会被回收</span>
</span></span><span style="display:flex;"><span>Object obj = <span style="color:#fff;font-weight:bold">new</span> Object();
</span></span><span style="display:flex;"><span><span style="color:#007f7f">//手动置null</span>
</span></span><span style="display:flex;"><span>obj = <span style="color:#fff;font-weight:bold">null</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><p>只要强引用存在，垃圾回收器将永远不会回收被引用的对象，哪怕内存不足时，JVM也会直接抛出OutOfMemoryError，不会去回收。如果想中断强引用与对象之间的联系，可以显示的将强引用赋值为null，这样一来，JVM就可以适时的回收对象了。</p>
<h2 id="软引用">软引用<a hidden class="anchor" aria-hidden="true" href="#软引用">#</a></h2>
<p>软引用是用来描述一些非必需但仍有用的对象。在内存足够的时候，软引用对象不会被回收，只有在内存不足时，系统则会回收软引用对象，如果回收了软引用对象之后仍然没有足够的内存，才会抛出内存溢出异常。这种特性常常被用来实现缓存技术，比如网页缓存，图片缓存等。
在 JDK1.2 之后，用java.lang.ref.SoftReference类来表示软引用。
下面以一个例子来进一步说明强引用和软引用的区别：
在运行下面的Java代码之前，需要先配置参数 -Xms2M -Xmx3M，将 JVM 的初始内存设为2M，最大可用内存为 3M。</p>
<p>首先先来测试一下强引用，在限制了 JVM 内存的前提下，下面的代码运行正常</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> TestOOM {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) {
</span></span><span style="display:flex;"><span>        testStrongReference();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> testStrongReference() {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 当 new byte为 1M 时，程序运行正常</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">byte</span>[] buff = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">byte</span>[1024 * 1024 * 1];
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是如果我们创建一个大小为 2M 的字节数组
<code>byte[] buff = new byte[1024 * 1024 * 2];</code>
则内存不够使用，程序直接报错，强引用并不会被回收
<code>Exception in thread &quot;main&quot; java.lang.OutOfMemoryError：Java Heap space</code></p>
<p>接着来看一下软引用会有什么不一样，在下面的示例中连续创建了 10 个大小为 1M 的字节数组，并赋值给了软引用，然后循环遍历将这些对象打印出来。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> TestOOM {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> List&lt;Object&gt; list = <span style="color:#fff;font-weight:bold">new</span> ArrayList&lt;&gt;();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> main(String[] args) {
</span></span><span style="display:flex;"><span>        testSoftReference();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> testSoftReference() {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 0; i &lt; 10; i++) {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">byte</span>[] buff = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">byte</span>[1024 * 1024];
</span></span><span style="display:flex;"><span>            SoftReference&lt;<span style="color:#fff;font-weight:bold">byte</span>[]&gt; sr = <span style="color:#fff;font-weight:bold">new</span> SoftReference&lt;&gt;(buff);
</span></span><span style="display:flex;"><span>            list.<span style="color:#007f7f">add</span>(sr);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">gc</span>(); <span style="color:#007f7f">//主动通知垃圾回收</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span>(<span style="color:#fff;font-weight:bold">int</span> i=0; i &lt; list.<span style="color:#007f7f">size</span>(); i++){
</span></span><span style="display:flex;"><span>            Object obj = ((SoftReference) list.<span style="color:#007f7f">get</span>(i)).<span style="color:#007f7f">get</span>();
</span></span><span style="display:flex;"><span>            System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(obj);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们发现无论循环创建多少个软引用对象，打印结果总是只有最后一个对象被保留，其他的obj全都被置空回收了。这里就说明了在内存不足的情况下，软引用将会被自动回收。
值得注意的一点 , 即使有 byte[] buff 引用指向对象, 且 buff 是一个strong reference, 但是 SoftReference sr 指向的对象仍然被回收了，这是因为Java的编译器发现了在之后的代码中, buff 已经没有被使用了, 所以自动进行了优化。
如果我们将上面示例稍微修改一下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> testSoftReference() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">byte</span>[] buff = <span style="color:#fff;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 0; i &lt; 10; i++) {
</span></span><span style="display:flex;"><span>        buff = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">byte</span>[1024 * 1024];
</span></span><span style="display:flex;"><span>        SoftReference&lt;<span style="color:#fff;font-weight:bold">byte</span>[]&gt; sr = <span style="color:#fff;font-weight:bold">new</span> SoftReference&lt;&gt;(buff);
</span></span><span style="display:flex;"><span>        list.<span style="color:#007f7f">add</span>(sr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">gc</span>(); <span style="color:#007f7f">//主动通知垃圾回收</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span>(<span style="color:#fff;font-weight:bold">int</span> i=0; i &lt; list.<span style="color:#007f7f">size</span>(); i++){
</span></span><span style="display:flex;"><span>        Object obj = ((SoftReference) list.<span style="color:#007f7f">get</span>(i)).<span style="color:#007f7f">get</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(obj);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;buff: &#34;</span> + buff.<span style="color:#007f7f">toString</span>());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>则 buff 会因为强引用的存在，而无法被垃圾回收，从而抛出OOM的错误。
如果一个对象惟一剩下的引用是软引用，那么该对象是软可及的（softly reachable）。垃圾收集器并不像其收集弱可及的对象一样尽量地收集软可及的对象，相反，它只在真正 “需要” 内存时才收集软可及的对象。</p>
<h2 id="弱引用">弱引用<a hidden class="anchor" aria-hidden="true" href="#弱引用">#</a></h2>
<p>弱引用的引用强度比软引用要更弱一些，无论内存是否足够，只要 JVM 开始进行垃圾回收，那些被弱引用关联的对象都会被回收。在 JDK1.2 之后，用 java.lang.ref.WeakReference 来表示弱引用。
我们以与软引用同样的方式来测试一下弱引用：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">void</span> testWeakReference() {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span> (<span style="color:#fff;font-weight:bold">int</span> i = 0; i &lt; 10; i++) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">byte</span>[] buff = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">byte</span>[1024 * 1024];
</span></span><span style="display:flex;"><span>        WeakReference&lt;<span style="color:#fff;font-weight:bold">byte</span>[]&gt; sr = <span style="color:#fff;font-weight:bold">new</span> WeakReference&lt;&gt;(buff);
</span></span><span style="display:flex;"><span>        list.<span style="color:#007f7f">add</span>(sr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">gc</span>(); <span style="color:#007f7f">//主动通知垃圾回收</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">for</span>(<span style="color:#fff;font-weight:bold">int</span> i=0; i &lt; list.<span style="color:#007f7f">size</span>(); i++){
</span></span><span style="display:flex;"><span>        Object obj = ((WeakReference) list.<span style="color:#007f7f">get</span>(i)).<span style="color:#007f7f">get</span>();
</span></span><span style="display:flex;"><span>        System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(obj);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以发现所有被弱引用关联的对象都被垃圾回收了。</p>
<h2 id="虚引用">虚引用<a hidden class="anchor" aria-hidden="true" href="#虚引用">#</a></h2>
<p>虚引用是最弱的一种引用关系，如果一个对象仅持有虚引用，那么它就和没有任何引用一样，它随时可能会被回收，在 JDK1.2 之后，用 PhantomReference 类来表示，通过查看这个类的源码，发现它只有一个构造函数和一个 get() 方法，而且它的 get() 方法仅仅是返回一个null，也就是说将永远无法通过虚引用来获取对象，虚引用必须要和 ReferenceQueue 引用队列一起使用。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> PhantomReference&lt;T&gt; <span style="color:#fff;font-weight:bold">extends</span> Reference&lt;T&gt; {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     * Returns this reference object&#39;s referent.  Because the referent of a
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     * phantom reference is always inaccessible, this method always returns
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     * &lt;code&gt;null&lt;/code&gt;.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     *
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     * @return  &lt;code&gt;null&lt;/code&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> T get() {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> PhantomReference(T referent, ReferenceQueue&lt;? <span style="color:#fff;font-weight:bold">super</span> T&gt; q) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">super</span>(referent, q);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么传入它的构造方法中的 ReferenceQueue 又是如何使用的呢？</p>
<h2 id="引用队列referencequeue">引用队列（ReferenceQueue）<a hidden class="anchor" aria-hidden="true" href="#引用队列referencequeue">#</a></h2>
<p>引用队列可以与软引用、弱引用以及虚引用一起配合使用，当垃圾回收器准备回收一个对象时，如果发现它还有引用，那么就会在回收对象之前，把这个引用加入到与之关联的引用队列中去。程序可以通过判断引用队列中是否已经加入了引用，来判断被引用的对象是否将要被垃圾回收，这样就可以在对象被回收之前采取一些必要的措施。
与软引用、弱引用不同，虚引用必须和引用队列一起使用。
<a href="https://www.cnblogs.com/liyutian/p/9690974.html">参考</a></p>
<h1 id="ionio">IO/NIO<a hidden class="anchor" aria-hidden="true" href="#ionio">#</a></h1>
<h2 id="阻塞io模型">阻塞IO模型<a hidden class="anchor" aria-hidden="true" href="#阻塞io模型">#</a></h2>
<p>最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。典型的阻塞 IO 模型的例子为：data = socket.read();如果数据没有就绪，就会一直阻塞在 read 方法。</p>
<h2 id="非阻塞io模型">非阻塞IO模型<a hidden class="anchor" aria-hidden="true" href="#非阻塞io模型">#</a></h2>
<p>当用户线程发起一个 read 操作后，并不需要等待，而是马上就得到了一个结果。如果结果是一个error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就说非阻塞 IO不会交出 CPU，而会一直占用 CPU。典型的非阻塞 IO 模型一般如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">while</span>(<span style="color:#fff;font-weight:bold">true</span>){
</span></span><span style="display:flex;"><span>	data = socket.<span style="color:#007f7f">read</span>();
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">if</span>(data!= error){
</span></span><span style="display:flex;"><span>		<span style="color:#007f7f">// 处理数据</span>
</span></span><span style="display:flex;"><span>		<span style="color:#fff;font-weight:bold">break</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是对于非阻塞 IO 就有一个非常严重的问题，在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高，因此一般情况下很少使用 while 循环这种方式来读取数据。</p>
<h2 id="多路复用io模型">多路复用IO模型<a hidden class="anchor" aria-hidden="true" href="#多路复用io模型">#</a></h2>
<p>多路复用 IO 模型是目前使用得比较多的模型。Java NIO 实际上就是多路复用 IO。在多路复用 IO模型中，会有一个线程不断去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作。因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。在 Java NIO 中，是通过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。多路复用 IO 模式，通过一个线程就可以管理多个 socket，只有当socket 真正有读写事件发生才会占用资源来进行实际的读写操作。因此，多路复用 IO 比较适合连接数比较多的情况。另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 中，不断地询问 socket 状态时通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高的多。不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的事件逐一进行响应。因此对于多路复用 IO 模型来说，一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询。</p>
<h2 id="信号驱动io模型">信号驱动IO模型<a hidden class="anchor" aria-hidden="true" href="#信号驱动io模型">#</a></h2>
<p>在信号驱动 IO 模型中，当用户线程发起一个 IO 请求操作，会给对应的 socket 注册一个信号函数，然后用户线程会继续执行，当内核数据就绪时会发送一个信号给用户线程，用户线程接收到信号之后，便在信号函数中调用 IO 读写操作来进行实际的 IO 请求操作。</p>
<h2 id="异步io模型">异步IO模型<a hidden class="anchor" aria-hidden="true" href="#异步io模型">#</a></h2>
<p>异步 IO 模型才是最理想的 IO 模型，在异步 IO 模型中，当用户线程发起 read 操作之后，立刻就可以开始去做其它的事。而另一方面，从内核的角度，当它受到一个 asynchronous read 之后，它会立刻返回，说明read 请求已经成功发起了，因此不会对用户线程产生任何 block。然后，内核会等待数据准备完成，然后将数据拷贝到用户线程，当这一切都完成之后，内核会给用户线程发送一个信号，告诉它 read 操作完成了。也就说用户线程完全不需要实际的整个 IO 操作是如何进行的，只需要先发起一个请求，当接收内核返回的成功信号时表示 IO 操作已经完成，可以直接去使用数据了。</p>
<p>也就说在异步 IO 模型中，IO 操作的两个阶段都不会阻塞用户线程，这两个阶段都是由内核自动完成，然后发送一个信号告知用户线程操作已完成。用户线程中不需要再次调用 IO 函数进行具体的读写。这点是和信号驱动模型有所不同的，在信号驱动模型中，当用户线程接收到信号表示数据已经就绪，然后需要用户线程调用IO 函数进行实际的读写操作；而在异步 IO 模型中，收到信号表示 IO 操作已经完成，不需要再在用户线程中调用 IO 函数进行实际的读写操作。</p>
<p>注意，异步 IO 是需要操作系统的底层支持，在 Java 7 中，提供了 Asynchronous IO。</p>
<h2 id="io">IO<a hidden class="anchor" aria-hidden="true" href="#io">#</a></h2>
<p><img loading="lazy" src="/posts/java/jvm/16.png">
<img loading="lazy" src="/posts/java/jvm/17.png">
<img loading="lazy" src="/posts/java/jvm/18.png"></p>
<h2 id="nio">NIO<a hidden class="anchor" aria-hidden="true" href="#nio">#</a></h2>
<p>NIO 主要有三大核心部分：Channel(通道)，Buffer(缓冲区)，Selector。传统 IO 基于字节流和字符流进行操作，而 NIO 基于 Channel 和 Buffer(缓冲区)进行操作，数据总是从通道读取到缓冲区中，或者从缓冲区写入到通道中。Selector(选择区)用于监听多个通道的事件（比如：连接打开，数据到达）。因此，单个线程可以监听多个数据通道。</p>
<p>NIO 和传统 IO 之间第一个最大的区别是，IO 是面向流的，NIO 是面向缓冲区的。</p>
<h3 id="nio的缓冲区">NIO的缓冲区<a hidden class="anchor" aria-hidden="true" href="#nio的缓冲区">#</a></h3>
<p>Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。NIO 的缓冲导向方法不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有您需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<h3 id="nio的非阻塞">NIO的非阻塞<a hidden class="anchor" aria-hidden="true" href="#nio的非阻塞">#</a></h3>
<p>IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取，或数据完全写入。该线程在此期间不能再干任何事情了。 NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<p><img loading="lazy" src="/posts/java/jvm/19.png"></p>
<h3 id="channel">Channel<a hidden class="anchor" aria-hidden="true" href="#channel">#</a></h3>
<p>首先说一下 Channel，国内大多翻译成“通道”。Channel 和 IO 中的 Stream(流)是差不多一个等级的。只不过 Stream 是单向的，譬如：InputStream，OutputStream，而 Channel 是双向的，既可以用来进行读操作，又可以用来进行写操作。NIO 中的 Channel 的主要实现有：</p>
<ul>
<li>FileChannel</li>
<li>DatagramChannel</li>
<li>SocketChannel</li>
<li>ServerSocketChannel
这里看名字就可以猜出个所以然来：分别可以对应文件 IO、UDP 和 TCP（Server 和 Client）。
下面演示的案例基本上就是围绕这 4 个类型的 Channel 进行陈述的。</li>
</ul>
<h3 id="buffer">Buffer<a hidden class="anchor" aria-hidden="true" href="#buffer">#</a></h3>
<p>Buffer，故名思意，缓冲区，实际上是一个容器，是一个连续数组。Channel 提供从文件、网络读取数据的渠道，但是读取或写入的数据都必须经由 Buffer。
<img loading="lazy" src="/posts/java/jvm/20.png"></p>
<p>上面的图描述了从一个客户端向服务端发送数据，然后服务端接收数据的过程。客户端发送数据时，必须先将数据存入 Buffer 中，然后将 Buffer 中的内容写入通道。服务端这边接收数据必须通过 Channel 将数据读入到 Buffer 中，然后再从 Buffer 中取出数据来处理。在 NIO 中，Buffer 是一个顶层父类，它是一个抽象类，常用的 Buffer 的子类有：
ByteBuffer、IntBuffer、 CharBuffer、 LongBuffer、 DoubleBuffer、FloatBuffer、ShortBuffer</p>
<h3 id="selector">Selector<a hidden class="anchor" aria-hidden="true" href="#selector">#</a></h3>
<p>Selector 类是 NIO 的核心类，Selector 能够检测多个注册的通道上是否有事件发生，如果有事件发生，便获取事件然后针对每个事件进行相应的响应处理。这样一来，只是用一个单线程就可以管理多个通道，也就是管理多个连接。这样使得只有在连接真正有读写事件发生时，才会调用函数来进行读写，就大大地减少了系统开销，并且不必为每个连接都创建一个线程，不用去维护多个线程，并且避免了多线程之间的上下文切换导致的开销。</p>
<h1 id="深入理解java虚拟机读书笔记">深入理解java虚拟机(读书笔记)<a hidden class="anchor" aria-hidden="true" href="#深入理解java虚拟机读书笔记">#</a></h1>
<p><a href="https://blog.csdn.net/zhanhaibo120/article/details/106175245/">参考</a></p>
<h2 id="虚拟机内存结构">虚拟机内存结构<a hidden class="anchor" aria-hidden="true" href="#虚拟机内存结构">#</a></h2>
<p>线程私有：虚拟机栈，本地方法栈，程序计数器
线程共享：堆，方法区（包括运行时常量池）</p>
<ul>
<li>
<p>程序计数器
当前程序锁执行的字节码行号指示器，记录下一条需要执行的指令。</p>
</li>
<li>
<p>虚拟机栈
生命周期与线程相同，每个方法在执行时都会创建一个栈帧。
方法执行的过程，就是栈帧入栈到出栈的过程。
栈帧用于存放局部变量表，操作数栈，动态链接，方法出口等信息。
局部变量表存放了编译期可知的基本数据类型和对象引用。</p>
</li>
<li>
<p>本地方法栈
为虚拟机使用到的Native方法服务。
目前HotSpot虚拟机将本地方法栈和虚拟机栈合二为一。</p>
</li>
<li>
<p>堆
存放对象实例，所有线程共享。</p>
</li>
<li>
<p>方法区（永久代）
存放被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等。</p>
</li>
<li>
<p>运行时常量池
方法区的一部分，用于存放编译期生成的各种字面量和符号引用。</p>
</li>
<li>
<p>字面量，符号引用，直接引用
字面量：通俗解释就是一个变量的值，但是这个值不能超过范围。
int a = 1; 1是a的字面量
213738648则不能是int的字面量，因为超出了int的范围。
符号引用：以一组符号来描述引用的目标，符号可以是任何形式的字面量，只要使用时能够无歧义的定位到目标即可。
直接引用：直接指向目标的指针（类变量，类方法）。
相对偏移量（实例变量，实例方法）。
一个能间接定位到目标的句柄。</p>
</li>
</ul>
<h2 id="对象在内存中的布局">对象在内存中的布局<a hidden class="anchor" aria-hidden="true" href="#对象在内存中的布局">#</a></h2>
<p>对象头（哈希码，GC分代年龄，数据指针，如果是数组还会有数组长度），实例数据，对齐填充</p>
<h2 id="判断对象是否死亡">判断对象是否死亡<a hidden class="anchor" aria-hidden="true" href="#判断对象是否死亡">#</a></h2>
<ul>
<li>
<p>引用计数算法
每个对象添加一个计数器，引用它加1，引用失效减1，为0则死亡，很难解决循环引用问题。</p>
</li>
<li>
<p>可达性分析算法
从gc root节点开始向下搜索，不可达则已死。</p>
</li>
</ul>
<p>可作为gc root节点的情况：</p>
<ul>
<li>虚拟机栈本地变量表引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>本地方法栈native方法引用的对象</li>
</ul>
<h2 id="强软弱虚">强/软/弱/虚<a hidden class="anchor" aria-hidden="true" href="#强软弱虚">#</a></h2>
<p>强引用，软引用，弱引用，虚引用</p>
<ul>
<li>强引用
new 关键字，强引用还在，则不会被回收</li>
<li>软引用
发生内存溢出钱，会把这些软引用对象列入回收范围，进行第二次回收时会将他们回收</li>
<li>弱引用
只能存活到下一次垃圾回收之前</li>
<li>虚引用
与对象的生存时间不发生关系，作用是在这个对象被回收的时候，收到一个系统通知</li>
</ul>
<h2 id="垃圾收集算法">垃圾收集算法<a hidden class="anchor" aria-hidden="true" href="#垃圾收集算法">#</a></h2>
<ul>
<li>
<p>标记—清除 Mark-Sweep
过程：标记可回收对象，进行清除
缺点：标记和清除效率低，清除后会产生内存碎片</p>
</li>
<li>
<p>复制算法
过程：将内存划分为相等的两块，将存活的对象复制到另一块内存，把已经使用的内存清理掉
缺点：使用的内存变为了原来的一半
进化：将一块内存按8:1的比例分为一块Eden区（80%）和两块Survivor区（10%）
每次使用Eden和一块Survivor，回收时，将存活的对象一次性复制到另一块Survivor上，如果另一块Survivor空间不足，则使用分配担保机制存入老年代</p>
</li>
<li>
<p>标记—整理 Mark—Compact
过程：所有存活的对象向一端移动，然后清除掉边界以外的内存</p>
</li>
<li>
<p>分代收集算法
过程：将堆分为新生代和老年代，根据区域特点选用不同的收集算法，如果新生代朝生夕死，则采用复制算法，老年代采用标记清除，或标记整理</p>
</li>
</ul>
<h2 id="hotspot虚拟机算法实现">HotSpot虚拟机算法实现<a hidden class="anchor" aria-hidden="true" href="#hotspot虚拟机算法实现">#</a></h2>
<ul>
<li>
<p>枚举根节点
回收时如果逐个检查引用（可达性分析）效率低下，通过OopMap数据结构来得知哪些地方存放着引用</p>
</li>
<li>
<p>安全点
不会为所有指令都生成OopMap，只会在特定位置生成，这些位置成为安全点。方法调用，循环跳转，异常跳转等会产生安全点</p>
</li>
</ul>
<h2 id="如何在gc发生时让所有线程都要附近的安全点停下">如何在GC发生时让所有线程都要附近的安全点停下<a hidden class="anchor" aria-hidden="true" href="#如何在gc发生时让所有线程都要附近的安全点停下">#</a></h2>
<ul>
<li>
<p>抢先式中断
中断全部线程，如果发现有线程不在安全点上，	那么恢复线程，让它跑到安全点上（几乎不使用）</p>
</li>
<li>
<p>主动式中断
设置一个标志，线程执行时去轮询这个标志，标志为true则线程挂起。标志和安全点是重合的</p>
</li>
<li>
<p>安全区域
一段代码片段，在这个区域中的任意地方开始GC都是安全的。为了解决处于Sleep或Blocked线程达到安全点的问题。
过程：如果进入到了安全区域，那么标识自己已经进入，GC时不用管已经标识过的。如果离开，则检查是否完成了节点枚举或者整个GC，如果未完成，则必须等待离开信号。</p>
</li>
</ul>
<h2 id="垃圾收集器">垃圾收集器<a hidden class="anchor" aria-hidden="true" href="#垃圾收集器">#</a></h2>
<ul>
<li>
<p>Serial
单线程新生代收集器，只会用一条线程完成收集工作
在Client模式下的虚拟机可以选择
新生代：复制算法
老年代：标记—整理</p>
</li>
<li>
<p>ParNew
Serial的多线程版本，收集过程以及算法与Serival一致，可与CMS老年代收集器配合</p>
</li>
<li>
<p>Parallel Scavenge
新生代收集器，多线程，主要关注吞吐量，适合在后台运算不需要太多交互的任务，采用复制算法</p>
</li>
<li>
<p>Serial Old
Serial 的老年代版本，采用 标记—整理</p>
</li>
<li>
<p>Parallel Old
Parallel Scavenge的老年代版本，采用多线程标记—整理</p>
</li>
<li>
<p>CMS
老年代收集器，关注停顿时间，采用标记—清除
4个过程，初始标记，并发标记，重新标记，并发清除
收集过程与用户线程并发执行
缺点：并发收集占用CPU资源，降低吞吐率。浮动垃圾，程序不断运行会产生新的垃圾。
JDK1.5老年代占用达到68%会触发，JDK1.6老年代占用达到92%会触发，触发的阈值可以设置，设置不当会导致FuLL GC 降低性能。
会出现内存碎片，可设置参数，多少次不压缩的Full GC之后，进行一次压缩的，默认0，每次都会压缩。</p>
</li>
<li>
<p>G1 垃圾收集器
特点：并行与并发，分代手机，空间整合，可预测的停顿
将Java堆分为多个大小相等的独立区域，跟踪每个区域里垃圾的价值，维护一个优先列表，优先回收价值最大的。
区域空间对象的引用使用Remembered Set记录，如果引用的对象处于不同的区域，通过Card Table把引用信息记录到被引用对象的Remembered Set中。
过程：初始标记，并发标记，最终标记，筛选回收</p>
</li>
</ul>
<h2 id="gc日志">GC日志<a hidden class="anchor" aria-hidden="true" href="#gc日志">#</a></h2>
<p><code>[DefNew:3324k -&gt; 1527k (3712k) ,0.025secs] 3324k152k(11904k) 0.03 secs</code>
DefNew表示GC发生的区域，区域名字与使用的收集器有关
中括号内部 3324k1527k(3712k)
GC前该区域已使用—&gt;GC后已使用（该区域总容量）
中括号外表示堆信息
secs表示GC花费时间</p>
<h2 id="内存分配">内存分配<a hidden class="anchor" aria-hidden="true" href="#内存分配">#</a></h2>
<ul>
<li>
<p>优先在Eden分配
如果Eden空间不足，会发生一次MinorGC（新生代GC），GC时如果所剩空间不足以存放新对象，Survivor空间又无法存入原有存活对象，那么会将原有对象移入老年代，新对象分配在Eden区</p>
</li>
<li>
<p>Serival和ParNew收集器可以通过设置来保证打对象直接进入老年代</p>
</li>
<li>
<p>长期存活的对象进入老年代
MinorGC时如果有存活对象能被Survivor容纳，那么年龄为1，每熬过一次MinorGC年龄加1，默认15岁会晋升到老年代
-XX：MaxTenuringThreshold 设置晋升年龄</p>
</li>
<li>
<p>10.4
如果Survivor空间中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或者等于该年龄的对象就可以直接进入老年代。</p>
</li>
<li>
<p>10.5
空间分配担保，老年代的连续空间大于新生代的对象总大小，或者两次晋升的平均大小，就会进行MinorGC，否则将进行FULLGC。</p>
</li>
</ul>
<h2 id="class类文件的结构">Class类文件的结构<a hidden class="anchor" aria-hidden="true" href="#class类文件的结构">#</a></h2>
<p>8位字节为基础单位的二进制流文件
8位字节以上的数据项，按照高位在前的方式存储
主要组成部分：无符号数和表</p>
<ul>
<li>
<p>无符号数
u1,u2,u4,u8 代表1字节，2字节，4字节和8字节
可以描述数字，索引引用，数量值，按照UTF-8构成的字符串值。</p>
</li>
<li>
<p>表
由多个无符号数或者其他表构成的复合数据类型，以_info结尾</p>
</li>
<li>
<p>Class文件内容顺序
1-4字节，魔数，0xCAFEBABE
5-6字节，次版本号
7-8字节，主版本号
常量池
访问标志
类索引
父类索引
接口索引
字段表集合
方法表集合
属性表集合
常量池：
Class文件中第一个表类型的数据，0x0016 =22 代表21项常量，索引为1-21，第0项表示“不引用任何一个常量池项目”
池中两大类常量：字面量和符号引用
字面量：文本字符串，声明为final的常量。
符号引用：
1.类和接口的全限定名
2.字段名称和描述符
3.方法名称和描述符
访问标志：
两个字节，类或者接口的访问信息，包括是类还是接口，是否是public,是否是abstract，是否是final（类）
类索引：
类的全限定名，u2
父类索引：
父类的全限定名，单根继承，所以只有一个，除了Object之外，其他父类索引都不为0，u2</p>
<p>接口索引：
u2类型集合，实现了哪些接口，顺序是implements关键字后从左至右
字段表集合：
类级变量（static）以及实例变量，不包括局部变量
方法表集合：
类中的方法
属性表集合：
描述某些专有信息，如方法的代码</p>
</li>
</ul>
<h2 id="类的生命周期">类的生命周期<a hidden class="anchor" aria-hidden="true" href="#类的生命周期">#</a></h2>
<p>加载，验证，准备，解析，初始化，使用，卸载，验证，准备，解析统称为连接</p>
<ul>
<li>
<p>五种初始化情况
1：使用new，读取或者设置一个类的静态字段，调用一个类的静态方法。被final修饰，编译器把结果放入常量池的静态字段除外。
2：对类进行反射调用的时候。
3：初始化一个类的时候，如果父类还没有初始化，先初始化父类。
4：初始化main方法的类。
5：java.lang.invoke.MethodHandle实例，解析结果为REF_getStatic,REF_putStatic,REF_invokeStatic的方法句柄</p>
</li>
<li>
<p>加载
加载过程要完成3件事
1：获取此类的二进制字节流
2：将字节流转化为方法区的运行时数据结构
3：在内存中生成一个对应的Class对象，作为方法区各种数据的访问入口</p>
</li>
<li>
<p>验证
确保字节流符合要求，并且不会危害虚拟机安全，4个阶段
文件格式验证，元数据验证，字节码验证，符号引用验证</p>
</li>
<li>
<p>准备
为类变量（static）分配内存并设置初始值</p>
</li>
<li>
<p>解析
将常量池内的符号引用替换为直接引用</p>
</li>
<li>
<p>初始化
执行类构造器的<code>&lt;clinit&gt;</code>方法的过程
clinit方法：由类中的所有类变量（static）的赋值动作和静态语句块合并产生。
静态语句块可为语句块之后的变量赋值，但不能访问。
虚拟机保证在子类的clinit方法执行之前，父类的clinit方法已经执行完毕，所以第一个被执行的clinit方法肯定是java.lang.Object。
父类的静态语句块优先于子类的变量赋值操作。
没有静态语句块也没有变量赋值操作，则不会生成clinit方法。
执行接口的clinit方法不需要执行父接口的clinit方法。
只有一个线程会执行到类的clinit方法。</p>
</li>
</ul>
<h2 id="类加载器-1">类加载器<a hidden class="anchor" aria-hidden="true" href="#类加载器-1">#</a></h2>
<p>即使两个类来源于同一个class文件，被同一个虚拟机加载，只要他们的类加载器不同，那这两个类必定不相等。</p>
<ul>
<li>
<p>三种系统提供的类加载器
启动类加载器：加载存放在JAVA_HOME\lib目录中的，仅按照文件名识别，如rt.jar。
扩展类加载器：加载JAVA_HOME\lib\ext目录中的。
应用程序类加载器：加载用户类路径（classpath）上指定的类库，如果没有自定义的加载器，则这个为默认。</p>
</li>
<li>
<p>双亲委派模型
图为双亲委派模型，除了顶层的启动类加载器外，其余的加载器都应当有自己的父类加载器，父子关系使用组合关系，复用父加载器的代码。
工作过程：如果要加载一个类，把这个请求委派给父类加载器，每一个都如此，所以最终都是由顶层启动类加载器加载，如果无法加载，则由自己去加载。
如Object类，所有加载器都要加载，会委派给顶层去加载，所以Object类在环境中都是同一个。</p>
</li>
</ul>
<h2 id="运行时栈帧的结构">运行时栈帧的结构<a hidden class="anchor" aria-hidden="true" href="#运行时栈帧的结构">#</a></h2>
<p>每一个方法从调用开始至执行完成都一应着一个栈帧在虚拟机栈中入栈到出站的过程。
栈帧包括：局部变量表，操作数栈，动态连接，方法返回地址和附加信息。
位于栈顶的栈帧才是有效的，与这个栈帧相关联的方法称为当前方法。</p>
<ul>
<li>
<p>局部变量表
用于存放方法参数，方法内部的局部变量。以Slot为单位，一个Slot可以存放32位以内的数据类型，long和double用两个Slot来存储。
变量表索引从0开始，如果执行的是非static方法，第0位索引表示方法所属对象的实例引用，即this关键字，从1开始按参数顺序占用Slot，在根据方法体内部定义的变量顺序分配其余的Slot。</p>
</li>
<li>
<p>操作数栈
后入先出的栈
方法刚开始执行的时候，这个操作数栈是空的，执行过程中会发生出栈，入栈的操作。</p>
</li>
<li>
<p>动态连接
每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，一部分符号引用会在运行期间转换为直接引用，成为动态连接。</p>
</li>
<li>
<p>方法的返回地址
两种方式退出方法
1.遇到方法返回的字节码指令，为正常出口
2.遇到了异常，并且在异常表中没有匹配的异常处理器（异常未被处理），称为异常出口，不会产生任何返回值。
方法正常退出时，调用者的PC计数器的值作为返回地址
异常退出时，通过异常处理器表来确定返回地址
退出方法执行的操作：恢复上层方法的局部变量表和操作数栈，把返回值（如果有）压入调用者的操作数栈，调整PC计数器的值，指向后一条指令（字节码）</p>
</li>
</ul>
<h2 id="方法调用">方法调用<a hidden class="anchor" aria-hidden="true" href="#方法调用">#</a></h2>
<p>唯一任务，确定要调用哪一个方法。
解析：在类加载的解析阶段，会将一部分符号引用转化为直接引用。条件为：编译器可知，运行期不可变。
例如：静态方法，私有方法，实例构造器，父类方法，final方法。</p>
<h2 id="分派">分派<a hidden class="anchor" aria-hidden="true" href="#分派">#</a></h2>
<ul>
<li>
<p>静态分派
Human man = new Man();
Human 称为变量的静态类型，Man为变量的实际类型。
静态分派的典型应用是方法重载，重载是根据参数的静态类型作为判定依据。</p>
</li>
<li>
<p>动态分派
主要体现在重写上，根据变量的实际类型来确定。
静态分派属于多分派类型，动态分派属于单分派类型。</p>
</li>
</ul>
<h2 id="虚方法表">虚方法表<a hidden class="anchor" aria-hidden="true" href="#虚方法表">#</a></h2>
<p>在方法区中建立一个虚方法表，在连接阶段进行初始化，用于存放方法的实际入口。如果方法的在子类没有被重写，那么地址入口与父类一致，如果重写了，则指向子类实现的入口地址。</p>
<h2 id="java内存模型jmm">Java内存模型（JMM）<a hidden class="anchor" aria-hidden="true" href="#java内存模型jmm">#</a></h2>
<p>定义程序中各个变量的访问规则，实例字段，静态字段，构成数组对象的元素。
不包括局部变量和方法参数，因为是线程私有。
所有变量存储在主内存，对应Java堆中的实例数据部分，每条线程有自己的工作内存，对应着虚拟机栈中的部分区域。
工作内存中保存了该线程使用到的变量（主内存的副本拷贝），对变量的所有操作都在工作内存中进行，工作内存中变量只对该线程可见，线程间变量值的传递通过主内存完成。</p>
<h2 id="内存间的交互">内存间的交互<a hidden class="anchor" aria-hidden="true" href="#内存间的交互">#</a></h2>
<p>8种操作
lock：将主内存变量标识为一条线程占用，即上锁。
unlock：将主内存lock状态的变量释放，其他线程可锁定，即
解锁。
read：将主内存变量的值传送到工作内存中，为load准备。
load：将read获取到的值放入工作内存的变量副本。
use：将工作内存中的变量值传递给执行引擎。
assign：将执行引擎接收到的值赋值给工作内存的变量。
store：将工作内存的变量值传递到主内存，为write准备。
write：将store获取到的值放入主内存。</p>
<h2 id="volatile变量">volatile变量<a hidden class="anchor" aria-hidden="true" href="#volatile变量">#</a></h2>
<p>作用：保证此变量对所有线程的可见性。禁止指令的重排序优化。
效率：volatile变量读操作性能与普通变量差别不大，写操作会慢一些。
因为需要在本地代码中插入许多内存屏障来保证不会发生乱序执行，开销一般来讲比锁要低。
规则：每次使用变量前都必须从主内存中刷新值，保证能看见其线程对变量的修改。
每次修改变量后都必须同步回主内存中，保证其他线程可以看到自己的修改。
变量不会被指令重排序优化，保证代码的执行顺序与程序顺序相同。
非原子性协定：
允许虚拟机将没有被volatile修改的64位数据分为两次32位操作来进行。long和double
目前虚拟机几乎都将64位数据读写操作做为原子操作，所以long和double一般不需要用volatile修饰。</p>
<h2 id="三种特性">三种特性<a hidden class="anchor" aria-hidden="true" href="#三种特性">#</a></h2>
<ul>
<li>
<p>原子性
基本数据类型的读写具备原子性，同步块中的也具备原子性。</p>
</li>
<li>
<p>可见性
一个线程修改了共享变量的值，其他线程立即得知。
普通变量和volatile变量都是如此，volatile变量是立即刷新主内存，普通变量则不会。</p>
</li>
<li>
<p>有序性
如果在本线程内观察，所有操作都是有序的，一个线程中观察另一个线程，所有操作都是无序的。
前半句：线程内表现都是串行。
后半句：指令重排序，工作内存与主内存同步延迟的现象。</p>
</li>
</ul>
<h2 id="先行发生原则">先行发生原则<a hidden class="anchor" aria-hidden="true" href="#先行发生原则">#</a></h2>
<p>操作A先行发生与操作B，A发生在B操作之前，A产生的影响（赋值，方法调用等）可以被B观察到。
Java中天然的先行发生关系：
1程序次序规则：一个线程内，按照控制流程顺序，前面的操作，先行发生与后面的操作。
2 管程锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作，时间先后。
3 volatile变量规则：对变量的写操作先行发生于后面的读操作，时间先后。
4 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作。
5 线程终止规则：线程中所有操作都先行发生于此线程的终止检测。
6 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生。
7 对象终结规则：一个对象的初始化完成先行发生于它的finalsize()方法开始。
8 传递性规则：操作A先行发生于操作B，B先C，可以得出，A先行发生于C的结论。
一个操作时间上的先发生，不代表这个操作会是先行发生。
时间先后与先行发生原则没有太大关系。</p>
<h2 id="java线程调度">Java线程调度<a hidden class="anchor" aria-hidden="true" href="#java线程调度">#</a></h2>
<p>协同式和抢占式</p>
<ul>
<li>
<p>协同式
线程自己工作执行完成以后，主动通知系统切换到另外一个线程，不存在同步问题。
缺点：一个线程阻塞会导致整个系统崩溃。</p>
</li>
<li>
<p>抢占式
每个线程由系统分配执行时间，切换不由线程本身决定，不会有一个线程导致系统崩溃的问题。</p>
</li>
</ul>
<h2 id="线程的状态">线程的状态<a hidden class="anchor" aria-hidden="true" href="#线程的状态">#</a></h2>
<p>新建，运行，无限期等待，限期等待，阻塞</p>
<ul>
<li>
<p>新建
创建后未启动的线程。</p>
</li>
<li>
<p>运行
Running和Ready 可能在执行，也可能在等待CPU为他分配执行时间。</p>
</li>
<li>
<p>无限期等待
不会被分配执行时间，需要等待显示的唤醒。</p>
</li>
<li>
<p>限期等待
不会被分配执行时间，一定时间后由系统自动唤醒。</p>
</li>
<li>
<p>阻塞
线程被阻塞，等待获取一个排他锁。``</p>
</li>
<li>
<p>结束
已终止，结束执行。</p>
</li>
</ul>
<h2 id="线程安全">线程安全<a hidden class="anchor" aria-hidden="true" href="#线程安全">#</a></h2>
<p>不可变，绝对线程安全，相对线程安全，线程兼容，线程对立</p>
<ul>
<li>
<p>不可变
final 关键字。</p>
</li>
<li>
<p>绝对线程安全
不管运行时环境如何，调用者都不需要任何额外的同步措施。</p>
</li>
<li>
<p>相对线程安全
常说的线程安全，保证对这个对象单独的操作是线程安全的。
Vector，HashTable，Collections的synchronizedConllection()方法</p>
</li>
<li>
<p>线程兼容
常说的线程不安全，对象本身并不是线程安全，调用时使用同步手段来保证线程安全。</p>
</li>
<li>
<p>线程对立
无论是否采取了同步措施，都无法在多线程环境中使用。</p>
</li>
</ul>
<h2 id="线程安全的实现方法">线程安全的实现方法<a hidden class="anchor" aria-hidden="true" href="#线程安全的实现方法">#</a></h2>
<ul>
<li>
<p>互斥同步（阻塞）
共享数据在同一时刻只能被一个线程使用，如synchronized关键字和并发包中的ReentrantLock。
会在同步块的前后分别形成monitorenter和monitorexit
需要一个引用类型的参数来指明要锁定和解锁的对象。
如果没有明确指定，去取对象的对象实例（实例方法）或者Class对象（类方法static）来作为锁对象。</p>
</li>
<li>
<p>非阻塞同步
先进行操作，如果没有其他线程争用，则操作成功，如果有争用，则采取补偿措施（不断尝试，直到成功为止）。</p>
</li>
</ul>
<h3 id="无同步方案">无同步方案<a hidden class="anchor" aria-hidden="true" href="#无同步方案">#</a></h3>
<ul>
<li>
<p>可重入代码
如果一个方法，只要输入了相同的参数，就能返回相同的结果，则满足可重入行的要求，为线程安全。</p>
</li>
<li>
<p>线程本地存储
共享数据的代码能否在一个线程中执行，如果能则共享数据的可见范围限制在一个线程内。
如 生成者—消费者模式。
Web应用交互，一个请求对应一个线程。</p>
</li>
</ul>
<h2 id="锁优化">锁优化<a hidden class="anchor" aria-hidden="true" href="#锁优化">#</a></h2>
<ul>
<li>
<p>自旋锁与自适应自旋
互斥同步性能最大影响是阻塞，挂起线程和恢复线程都需要转入内核态来完成。
自旋锁是让线程执行一个忙循环，而不是挂起。
JDK1.6默认开始，并增加了自适应的自旋锁。
根据每次自旋的效果，来判定获取该对象的锁是自旋还是挂起，如果自旋的话，循环的次数。
因为自旋锁属于占用执行时间，所以不适宜等待时间过长，因此根据对象以往获取锁的状态来判定，如果自旋时间过长还得不到锁，则放弃自旋，直接选择挂起线程。</p>
</li>
<li>
<p>锁消除
一段代码中，堆上的所有数据都不会逃逸出去，被其他线程访问到，就可以把他们当做栈上的数据。无需同步加锁进行。</p>
</li>
<li>
<p>锁粗化
如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，
将会把锁范围扩展到操作序列外部。如：</p>
</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>StringBuffer sb = new StringBuffer();
</span></span><span style="display:flex;"><span>sb.append(s1);
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>sb.append(s5);
</span></span><span style="display:flex;"><span>sb.toString();
</span></span></code></pre></td></tr></table>
</div>
</div><p>则会将锁扩展到第一个append之前至最后一个append之后。</p>
<ul>
<li>
<p>轻量级锁
减少传统重量级锁使用操作系统互斥量产生的性能消耗。</p>
</li>
<li>
<p>偏向锁
无竞争的情况下无需同步线程。
线程第一次获取对象锁，CAS操作把线程ID记录到对象头中，CAS成功则这个线程每次进入到这个锁相关的同步块时，无需任何同步操作。
如果有另外一个线程尝试获取该锁时，偏向模式结束。</p>
</li>
</ul>
<h2 id="编译优化技术">编译优化技术<a hidden class="anchor" aria-hidden="true" href="#编译优化技术">#</a></h2>
<ul>
<li>
<p>公共子表达式消除
如果一个表达式E已经经过计算，并且E中所有变量的值都没有发生变化，那么E为公共表达式。</p>
</li>
<li>
<p>数组边界检查消除
编译期能判断变量的取值范围永远在[0,arr.length]之间，则无线检查。
例如，在一个循环中进行数组的访问。</p>
</li>
<li>
<p>方法内联</p>
</li>
<li>
<p>逃逸分析
定义一个对象后，被外部方法调用，或当做参数传递，称为方法逃逸。被其他线程访问，称为线程逃逸。
别的方法和线程无法访问到这个对象，则不会逃逸，可以优化。
栈上分配：不会逃逸的对象分配在栈上，方法结束，自动销毁。
同步消除：不会逃逸则同步措施可以消除。
标量替换：
数据无法继续分解则成为标量，如基本类型。
可以分解成为聚合量，如Java对象。
如果不会逃逸，创建一个Java对象时，不直接创建该对象，而是创建若干个标量代替</p>
</li>
</ul>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://funny-toffee-4aa7c3.netlify.app/tags/java/">Java</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://funny-toffee-4aa7c3.netlify.app/">Wjy&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>