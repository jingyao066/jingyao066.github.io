<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>面试 | Wjy&#39;s Blog</title>
<meta name="keywords" content="其他">
<meta name="description" content="整体参考
参考2
java基础
Java如何进行高效的数组拷贝？
Arrays.copyOf 或 System.arraycopy
这是两个native方法，效率比自己new数组，然后for循环复制快得多。
float f = 3.4; 能否通过编译？
不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型会损失精度，因此需要强制类型转换，float f = (float)3.4 或 float f = 3.4F">
<meta name="author" content="Wjy">
<link rel="canonical" href="https://009965.xyz/posts/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://009965.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://009965.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://009965.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://009965.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://009965.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://009965.xyz/posts/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="https://009965.xyz/posts/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/">
  <meta property="og:site_name" content="Wjy&#39;s Blog">
  <meta property="og:title" content="面试">
  <meta property="og:description" content="整体参考 参考2
java基础 Java如何进行高效的数组拷贝？ Arrays.copyOf 或 System.arraycopy 这是两个native方法，效率比自己new数组，然后for循环复制快得多。
float f = 3.4; 能否通过编译？ 不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型会损失精度，因此需要强制类型转换，float f = (float)3.4 或 float f = 3.4F">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:tag" content="其他">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="面试">
<meta name="twitter:description" content="整体参考
参考2
java基础
Java如何进行高效的数组拷贝？
Arrays.copyOf 或 System.arraycopy
这是两个native方法，效率比自己new数组，然后for循环复制快得多。
float f = 3.4; 能否通过编译？
不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型会损失精度，因此需要强制类型转换，float f = (float)3.4 或 float f = 3.4F">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://009965.xyz/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "面试",
      "item": "https://009965.xyz/posts/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "面试",
  "name": "面试",
  "description": "整体参考 参考2\njava基础 Java如何进行高效的数组拷贝？ Arrays.copyOf 或 System.arraycopy 这是两个native方法，效率比自己new数组，然后for循环复制快得多。\nfloat f = 3.4; 能否通过编译？ 不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型会损失精度，因此需要强制类型转换，float f = (float)3.4 或 float f = 3.4F\n",
  "keywords": [
    "其他"
  ],
  "articleBody": "整体参考 参考2\njava基础 Java如何进行高效的数组拷贝？ Arrays.copyOf 或 System.arraycopy 这是两个native方法，效率比自己new数组，然后for循环复制快得多。\nfloat f = 3.4; 能否通过编译？ 不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型会损失精度，因此需要强制类型转换，float f = (float)3.4 或 float f = 3.4F\n两数交换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 // 1、第三变量 public void swapOne(){ int a = 4; int b = 5; int c = a; a = b; b = c; System.out.println(\"a:\"+a); //a:5 System.out.println(\"b:\"+b); //a:4 } // 2、数学计算 public void swapTwo(){ int a = 4; int b = 5; a=a+b; b=a-b; a=a-b; System.out.println(\"a:\"+a); //a:5 System.out.println(\"b:\"+b); //a:4 } // 3、异或运算 public void swapThree(){ int a = 4; int b = 5; a = a ^ b; // 0101 ^ 0100 ===\u003e 0001，此时a的值为1 b = a ^ b; // 0001 ^ 0100 ===\u003e 0101，此时b的值为5 a = a ^ b; // 0001 ^ 0101 ===\u003e 0100，此时a的值为4 System.out.println(\"a:\"+a); //a:5 System.out.println(\"b:\"+b); //a:4 } 为什么finally里的代码一定会执行？ 编译器在编译的时候，会把finally里面的代码复制多份，分别放在try和catch内所有能够正常执行以及异常执行逻辑的出口处，最直观的就是我们可以在字节码文件里看到很多份finally内部代码。\nint和Integer有什么区别？ 为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型。从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。\n1 2 3 4 5 6 7 8 Integer a = new Integer(3); // 将3自动装箱成Integer类型 Integer b = 3; int c = 3; // false 两个引用没有引用同一对象 System.out.println(a == b); // true a自动拆箱成int类型再和c比较 System.out.println(a == c); \u0026和\u0026\u0026的区别？ \u0026运算符有两种用法：(1)按位与；(2)逻辑与。 \u0026\u0026运算符是短路与运算。 \u0026\u0026左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。\n构造器（constructor）是否可被重写（override）？ 答：构造器不能被继承，因此不能被重写，但可以被重载。\n两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？ 不对，如果两个对象x和y满足x.equals(y) == true，它们的哈希码（hash code）应当相同。\n如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同； 如果两个对象的hashCode相同，它们并不一定相同。 char 型变量中能不能存贮一个中文汉字，为什么？ 可以，因为Java中使用的编码是Unicode一个char类型占2个字节（16比特），所以放一个中文是没问题的。\nstring s = “hello world”; s += 'a'; int len = s.length; s = 100; s = s+100 3错。\n用多线程计算出1-10000之间的素数 不用uuid生成订单号 求1-100之间所有质数和 注：质数是只能被1和它本身整除的数 1不是质数\n什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言？ Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。\nJDK和JRE的区别是什么？ JRE：Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。 JDK：Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。\n是否可以在static环境中访问非static变量？(不可以) static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。\nJava支持的数据类型有哪些？什么是自动拆装箱？ Java语言支持的8中基本数据类型是： byte、short、int、long、float、double、boolean、char 自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。 Integer a = 1; 这就是一个自动装箱，如果没有自动装箱的话，需要这样 Integer a=new Integer(1);\nint b = a; 这就是一个自动拆箱，如果没有自动拆箱的话，需要这样： int b = a.intValue(); 自动装箱和自动拆箱是简化了基本数据类型和相对应对象的转化步骤。\n什么是值传递和引用传递？ 对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。 对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。\n进程和线程的区别是什么？ 进程是执行着的应用程序，而线程是进程内部的一个执行序列。 一个进程可以有多个线程。\n什么是死锁(deadlock)？ 两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。\n如何确保N个线程可以访问N个资源同时又不导致死锁？ 使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。\n什么是迭代器(Iterator)？ Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。\nIterator和ListIterator的区别是什么？ Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。 Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。 ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。\nJava中的HashMap的工作原理是什么？ Java中的HashMap是以键值对(key-value)的形式存储元素的。 HashMap需要一个hash函数，它使用hashCode()和equals()方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。\n遍历Map entrySet().iterator()效率高，建议使用。 1 2 3 4 5 6 7 Map map = new HashMap(); Iterator iter = map.entrySet().iterator(); while (iter.hasNext()) { Map.Entry entry = (Map.Entry) iter.next(); Object key = entry.getKey(); Object val = entry.getValue(); } keySet().iterator()效率低，不要使用。原因：keySet其实是遍历了2次，一次是转为iterator，一次就从hashmap中取出key所对于的value。 1 2 3 4 5 6 Map map = new HashMap(); Iterator iter = map.keySet().iterator(); while (iter.hasNext()) { Object key = iter.next(); Object val = map.get(key); } foreach 遍历 map.entrySet() 效率高，建议使用。 1 2 3 4 for(Map.Entry entry: map.entrySet()){ Object key = entry.getKey(); Object val = entry.getValue(); } foreach 遍历 map.keySet() 效率低，不要使用。 1 2 3 4 for(Map.Entry entry: map.entrySet()){ Object key = entry.getKey(); Object val = entry.getValue(); } 数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？ Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。 Array大小是固定的，ArrayList的大小是动态变化的。\n九种基本数据类型的大小，以及他们的封装类(一个字节是8位) 基本类型 大小(字节) 默认值 封装类 byte 1 (byte)0 Byte short 2 (short)0 Short int 4 0 Integer long 8 0L Long float 4 0.0f Float double 8 0.0d Double boolean - false Boolean char 2 \\u0000(null) Character void - - Void equals、==、hashcode 区别 基本数据类型 byte/int/double/boolean等，用==，比较的是值。\n引用类型(就是对象) 用==比较的是内存地址，同一个new出来的对象，为true，反之为false。 对象是存放在堆中的，栈中存放的是对象的引用(地址)，由此可见==比较的是栈中的值。 如果要比较堆中的对象是否相同，要重写equals方法。\nequals：比较对象的内容（就是最表面的值）\n1 2 3 4 5 6 String a = \"1\"; String b = \"1\"; String c = new String(\"1\"); System.out.println(a==b); //true,是一块内存地址 System.out.println(a==c); //false,不是一块内存地址 System.out.println(a.equals(b)); //true,比较的是值 Java的四种引用，强弱软虚，用到的场景 强引用：如果一个对象具有强引用，那垃圾回收器绝不会回收它。 Object obj = new Object(); // 强引用\n软引用：内存够，不会被回收，反之会被回收。 引用可用来实现内存敏感的高速缓存。\n弱引用：垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。\n虚引用：任何时候都可能被垃圾回收器回收。\nHashcode的作用 根据对象的内存地址进行相关计算，得到的int类型数值，就是hashCode。 可以用来用来鉴定2个对象是否相等。\nString、StringBuffer与StringBuilder的区别。 string：字符串常量，不可改变的对象 StringBuffer：字符串变量，可变对象，线程安全，效率低 StringBuilder：字符串变量，可变对象，线程不安全，效率高\n以下程序的运行结果是什么 1 2 3 4 5 6 7 8 Long a = 1L; int b = 1; System.out.println(a == b); //true Map map = new HashMap\u003c\u003e(); map.put(\"a\",a); map.put(\"b\",b); System.out.println(map.get(\"a\") == map.get(\"b\"));//false 集合Collection 本部分参考\n说说List,Set,Map三者的区别？ List(对付顺序的好帮手)： 存储的元素是有序的、可重复的。 Set(注重独一无二的性质): 存储的元素是无序的、不可重复的。 Map(用 Key 来搜索的专家): 使用键值对（kye-value）存储，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。\nArraylist 与 LinkedList 区别? ArrayList 底层基于动态数组实现，LinkedList 底层基于双向链表实现。 对于随机访问（按 index 访问，get/set方法）：ArrayList 通过 index 直接定位到数组对应位置的节点，而 LinkedList需要从头结点或尾节点开始遍历，直到寻找到目标节点，因此在效率上 ArrayList 优于 LinkedList。 对于随机插入和删除：ArrayList 需要移动目标节点后面的节点（使用System.arraycopy 方法移动节点），而 LinkedList 只需修改目标节点前后节点的 next 或 prev 属性即可，因此在效率上 LinkedList 优于 ArrayList。 对于顺序插入和删除：由于 ArrayList 不需要移动节点，因此在效率上比 LinkedList 更好。这也是为什么在实际使用中 ArrayList 更多，因为大部分情况下我们的使用都是顺序插入。 两者都不是线程安全的。 内存空间占用： ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。 ArrayList 和 Vector 的区别。 Vector 和 ArrayList 的实现几乎是一样的，区别在于： Vector 在方法上使用了 synchronized 来保证线程安全，同时由于这个原因，在性能上 ArrayList 会有更好的表现。\nHashSet 是如何保证不重复的？ HashSet 底层使用 HashMap 来实现，见下面的源码，元素放在 HashMap 的 key 里，value 为固定的 Object 对象。当 add 时调用 HashMap 的 put 方法，如果元素不存在，则返回 null 表示 add 成功，否则 add 失败。 由于 HashMap 的 Key 值本身就不允许重复，HashSet 正好利用 HashMap 中 key 不重复的特性来校验重复元素，简直太妙了。\nMap HashMap 有哪些重要属性？分别用于做什么的？ 除了用来存储我们的节点 table 数组外，HashMap 还有以下几个重要属性：\nsize：HashMap 已经存储的节点个数。 loadFactor：负载因子，扩容阈值 = 容量 * 负载因子。 threshold：扩容阈值，当 HashMap 的元素个数达到该值，触发扩容。 HashMap 的默认初始容量是多少？HashMap 的容量有什么限制吗？ 默认初始容量是16。HashMap 的容量必须是2的N次方，HashMap 会根据我们传入的容量计算一个“大于等于该容量的最小的 2 的 N 次方”，例如传 16，容量为16；传17，容量为32。 “大于等于该容量的最小的2的N次方”是怎么算的？\nHashMap 的容量必须是 2 的 N 次方，这是为什么？ 核心目的是：实现节点均匀分布，减少 hash 冲突。\nHashMap 是线程安全的吗？ 不是。HashMap 在并发下存在数据覆盖、遍历的同时进行修改会抛出 ConcurrentModificationException异常等问题，JDK1.8之前还存在死循环问题。\n介绍一下死循环问题？ 导致死循环的根本原因是 JDK 1.7 扩容采用的是“头插法”，会导致同一索引位置的节点在扩容后顺序反掉，在并发插入触发扩容时形成环，从而产生死循环。而 JDK 1.8 之后采用的是“尾插法”，扩容后节点顺序不会反掉，不存在死循环问题。\n总结下 JDK 1.8 HashMap主要进行了哪些优化？ 底层数据结构从“数组+链表”改成“数组+链表+红黑树”，主要是优化了 hash 冲突较严重时，链表过长的查找性能：O(n) -\u003e O(logn)。 计算 table 初始容量的方式发生了改变，老的方式是从1开始不断向左进行移位运算，直到找到大于等于入参容量的值；新的方式则是通过“5个移位+或等于运算”来计算。 优化了 hash 值的计算方式，老的通过一顿瞎JB操作，新的只是简单的让高16位参与了运算。 扩容时插入方式从“头插法”改成“尾插法”，避免了并发下的死循环。 扩容时计算节点在新表的索引位置方式从“h \u0026 (length-1)”改成“hash \u0026 oldCap”，性能可能提升不大，但设计更巧妙、更优雅。 HashMap 的底层数据结构 在 JDK 1.8，HashMap 底层是由 “数组+链表+红黑树” 组成，如下图所示，而在 JDK 1.8 之前是由 “数组+链表” 组成。\n为什么使用“数组+链表”？ 使用 “数组+链表” 是为了解决 hash 冲突的问题。 数组和链表有如下特点： 数组：查找容易，通过 index 快速定位；插入和删除困难，需要移动插入和删除位置之后的节点； 链表：查找困难，需要从头结点或尾节点开始遍历，直到寻找到目标节点；插入和删除容易，只需修改目标节点前后节点的 next 或 prev 属性即可； HashMap 巧妙的将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做 “拉链法” 的方式来解决哈希冲突。\n首先通过 index 快速定位到索引位置，利用了数组的优点；然后遍历链表找到节点，进行节点的新增/修改/删除操作，利用了链表的优点。\n为什么要改成“数组+链表+红黑树”？ 通过上题可以看出，“数组+链表” 已经充分发挥了这两种数据结构的优点，是个很不错的组合了。 但是这种组合仍然存在问题，就是在定位到索引位置后，需要先遍历链表找到节点，这个地方如果链表很长的话，也就是 hash 冲突很严重的时候，会有查找性能问题，因此在 JDK1.8中，通过引入红黑树，来优化这个问题。 使用链表的查找性能是 O(n)，而使用红黑树是 O(logn)。\n那在什么时候用链表？什么时候用红黑树？ 对于插入，默认情况下是使用链表节点。当同一个索引位置的节点在新增后超过8个（阈值8）：如果此时数组长度大于等于 64，则会触发链表节点转红黑树节点（treeifyBin）；而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容，因为此时的数据量还比较小。\n对于移除，当同一个索引位置的节点在移除后达到 6 个（阈值6），并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点（untreeify）。\n为什么链表转红黑树的阈值是8？ 我们平时在进行方案设计时，必须考虑的两个很重要的因素是：时间和空间。对于 HashMap 也是同样的道理，简单来说，阈值为8是在时间和空间上权衡的结果。\n红黑树节点大小约为链表节点的2倍，在节点太少时，红黑树的查找性能优势并不明显，付出2倍空间的代价作者觉得不值得。\n理想情况下，使用随机的哈希码，节点分布在 hash 桶中的频率遵循泊松分布，按照泊松分布的公式计算，链表中节点个数为8时的概率为 0.00000006，这个概率足够低了，并且到8个节点时，红黑树的性能优势也会开始展现出来，因此8是一个较合理的数字。\n那为什么转回链表节点是用的6而不是复用8？ 如果我们设置节点多于8个转红黑树，少于8个就马上转链表，当节点个数在8徘徊时，就会频繁进行红黑树和链表的转换，造成性能的损耗。\n简述ConcurrentHashMap实现原理，它是如何保证线程安全的。 ConcurrentHashMap 是 HashMap 的线程安全版本，和 HashMap 一样，在JDK 1.8 中进行了较大的优化。 JDK1.7：底层结构为：分段的数组+链表；实现线程安全的方式：分段锁（Segment，继承了ReentrantLock） JDK1.8：底层结构为：数组+链表+红黑树；实现线程安全的方式：CAS + Synchronized\n区别：\nJDK1.8 中降低锁的粒度。JDK1.7 版本锁的粒度是基于 Segment 的，包含多个节点（HashEntry），而 JDK1.8 锁的粒度就是单节点（Node）。 JDK1.8 版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用 synchronized 来进行同步，所以不需要分段锁的概念，也就不需要 Segment 这种数据结构了，当前还保留仅为了兼容。 JDK1.8 使用红黑树来优化链表，跟 HashMap 一样，优化了极端情况下，链表过长带来的性能问题。 JDK1.8 使用内置锁 synchronized 来代替重入锁 ReentrantLock，synchronized 是官方一直在不断优化的，现在性能已经比较可观，也是官方推荐使用的加锁方式。 Linux RocketMQ RocketMQ由哪些角色组成，每个角色作用和特点是什么？ Broker：就是MQ本身，负责收发消息、持久化消息等。 Nameserver：无状态，动态列表；这也是和zookeeper的重要区别之一。zookeeper是有状态的。 Producer：消息生产者，负责发消息到Broker。 Consumer：消息消费者，负责从Broker上拉取消息进行消费，消费完进行ack。\nRocketMQ Broker中的消息被消费后会立即删除吗？ 不会，每条消息都会持久化到CommitLog中，每个Consumer连接到Broker后会维持消费进度信息，当有消息消费后只是当前Consumer的消费进度（CommitLog的offset）更新了。\n追问：那么消息会堆积吗？什么时候清理过期消息？ 4.6版本默认48小时后会删除不再使用的CommitLog文件。\nRocketMQ消费模式有几种？ 消费模型由Consumer决定，消费维度为Topic。\n集群消费 一条消息只会被同Group中的一个Consumer消费。 多个Group同时消费一个Topic时，每个Group都会有一个Consumer消费到数据。\n广播消费 消息将对一 个Consumer Group 下的各个 Consumer 实例都消费一遍。\nRedis 简单介绍redis Redis 就是一个使用 C 语言开发的数据库，不过与传统数据库不同的是 Redis 的数据是存在内存中的 ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。 另外，Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。 Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。\n缓存数据的处理流程是怎样的？ 如果用户请求的数据在缓存中就直接返回。 缓存中不存在的话就看数据库中是否存在。 数据库中存在的话就更新缓存中的数据。 数据库中不存在的话就返回空数据。 为什么要用 Redis/为什么要用缓存？ 简单来说，使用缓存主要是为了提升用户体验以及应对更多的用户。 下面我们主要从“高性能”和“高并发”这两点来看待这个问题。\n高性能 ： 假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。 这样有什么好处呢？ 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。 不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！\n高并发： 一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。\nQPS（Query Per Second）：服务器每秒可以执行的查询次数；\n所以，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高的系统整体的并发。\nRedis 常见数据结构以及使用场景分析 你可以自己本机安装 redis 或者通过 redis 官网提供的在线 redis 环境。\nstring string 是redis最简单的 key-value 类型。 常用命令: set、get、strlen、exists、dect、incr、setex等等。 应用场景 ：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。\n普通字符串的基本操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 设置 key-value 类型的值 set key value # 根据 key 获得对应的 value get key # 判断某个 key 是否存在 exists key # 返回 key 所储存的字符串值的长度。 strlen key # 删除某个 key 对应的值 del key get key (nil) list list 即是 链表。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 LinkedList，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。 常用命令: rpush、lpop、lpush、rpop、lrange、llen 等。 应用场景: 发布与订阅或者说消息队列、慢查询。\nlist的简单使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 向 list 的头部（右边）添加元素 rpush myList value1 # 向list的头部（最右边）添加多个元素 rpush myList value2 value3 # 将 list的尾部(最左边)元素取出 lpop myList # 查看对应下标的list列表， 0 为 start,1为 end lrange myList 0 1 # 查看列表中的所有元素，-1表示倒数第一 lrange myList 0 -1 # 通过 llen 查看链表长度： llen myList hash 介绍 ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。 常用命令： hset、hmset、hexists、hget、hgetall、hkeys、hvals 等。 应用场景: 系统中对象数据的存储。\nhash的简单使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 127.0.0.1:6379\u003e hmset userInfoKey name \"guide\" description \"dev\" age \"24\" OK 127.0.0.1:6379\u003e hexists userInfoKey name # 查看 key 对应的 value中指定的字段是否存在。 (integer) 1 127.0.0.1:6379\u003e hget userInfoKey name # 获取存储在哈希表中指定字段的值。 \"guide\" 127.0.0.1:6379\u003e hget userInfoKey age \"24\" 127.0.0.1:6379\u003e hgetall userInfoKey # 获取在哈希表中指定 key 的所有字段和值 1) \"name\" 2) \"guide\" 3) \"description\" 4) \"dev\" 5) \"age\" 6) \"24\" 127.0.0.1:6379\u003e hkeys userInfoKey # 获取 key 列表 1) \"name\" 2) \"description\" 3) \"age\" 127.0.0.1:6379\u003e hvals userInfoKey # 获取 value 列表 1) \"guide\" 2) \"dev\" 3) \"24\" 127.0.0.1:6379\u003e hset userInfoKey name \"GuideGeGe\" # 修改某个字段对应的值 127.0.0.1:6379\u003e hget userInfoKey name \"GuideGeGe\" set 介绍 ： set 类似于 Java 中的 HashSet 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。\n交集：给定两个集合A，B，即属于几个A，也属于集合B的集合，叫做集合A与集合B的交集。 并集：给定两个集合A，B，把他们所有的元素合并在一起组成的集合，叫做集合A与集合B的并集，记作A∪B，读作A并B。 差集：给定两个集合A和B，所有属于A且不属于B的元素的集合被称为A与B的差集。 示例：对于集合A = {a, b, c, d}和集合B = {b, c, w}，则A与B 的差集为{a, d}\n常用命令： sadd、spop、smembers、sismember、scard、sinterstore、sunion 等。 应用场景: 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景\nset的简单使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 127.0.0.1:6379\u003e sadd mySet value1 value2 # 添加元素进去 (integer) 2 127.0.0.1:6379\u003e sadd mySet value1 # 不允许有重复元素 (integer) 0 127.0.0.1:6379\u003e smembers mySet # 查看 set 中所有的元素 1) \"value1\" 2) \"value2\" 127.0.0.1:6379\u003e scard mySet # 查看 set 的长度 (integer) 2 127.0.0.1:6379\u003e sismember mySet value1 # 检查某个元素是否存在set 中，只能接收单个元素 (integer) 1 127.0.0.1:6379\u003e sadd mySet2 value2 value3 (integer) 2 127.0.0.1:6379\u003e sinterstore mySet3 mySet mySet2 # 获取 mySet 和 mySet2 的交集并存放在 mySet3 中 (integer) 1 127.0.0.1:6379\u003e smembers mySet3 1) \"value2\" sorted set 介绍： 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。 常用命令： zadd、zcard、zscore、zrange、zrevrange、zrem 等。 应用场景： 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。\nsorted set 的简单使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 127.0.0.1:6379\u003e zadd myZset 3.0 value1 # 添加元素到 sorted set 中 3.0 为权重 (integer) 1 127.0.0.1:6379\u003e zadd myZset 2.0 value2 1.0 value3 # 一次添加多个元素 (integer) 2 127.0.0.1:6379\u003e zcard myZset # 查看 sorted set 中的元素数量 (integer) 3 127.0.0.1:6379\u003e zscore myZset value1 # 查看某个 value 的权重 \"3\" 127.0.0.1:6379\u003e zrange myZset 0 -1 # 顺序输出某个范围区间的元素，0 -1 表示输出所有元素 1) \"value3\" 2) \"value2\" 3) \"value1\" 127.0.0.1:6379\u003e zrange myZset 0 1 # 顺序输出某个范围区间的元素，0 为 start 1 为 stop 1) \"value3\" 2) \"value2\" 127.0.0.1:6379\u003e zrevrange myZset 0 1 # 逆序输出某个范围区间的元素，0 为 start 1 为 stop 1) \"value1\" 2) \"value2\" Redis 单线程模型详解 Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型 （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。 既然是单线程，那怎么监听大量的客户端连接呢？ Redis 通过IO 多路复用程序 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。 这样的好处非常明显： I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 Selector 组件很像）。\n另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件： 1. 文件事件; 2. 时间事件。 时间事件不需要多花时间了解，我们接触最多的还是 文件事件（客户端进行读取写入等操作，涉及一系列网络通信）。 《Redis 设计与实现》有一段话是如是介绍文件事件的，我觉得写得挺不错。\n1 2 3 4 5 Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。 虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。 Redis 没有使用多线程？为什么不使用多线程？ 虽然说 Redis 是单线程模型，但是， 实际上，Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。 不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。 大体上来说，Redis 6.0 之前主要还是单线程处理。 那，Redis6.0 之前 为什么不使用多线程？\n我觉得主要原因有下面 3 个：\n单线程编程容易并且更容易维护； Redis 的性能瓶颈不是 CPU ，而是在内存和网络； 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。 Redis6.0 之后为何引入了多线程？ Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。 虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。\nRedis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 redis.conf ： io-threads-do-reads yes 开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 redis.conf : io-threads 4 #官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程\nRedis 给缓存数据设置过期时间有啥用？ 一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？ 因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接Out of memory。 Redis 自带了给缓存数据设置过期时间的功能，比如：\n1 2 3 4 5 6 127.0.0.1:6379\u003e exp key 60 # 数据在 60s 后过期 (integer) 1 127.0.0.1:6379\u003e setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire) OK 127.0.0.1:6379\u003e ttl key # 查看数据还有多久过期 (integer) 56 注意：Redis中除了字符串类型有自己独有设置过期时间的命令 setex 外，其他方法都需要依靠 expire 命令来设置过期时间 。另外， persist 命令可以移除一个键的过期时间：\n过期时间除了有助于缓解内存的消耗，还有什么其他用么？ 很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在1分钟内有效，用户登录的 token 可能只在 1 天内有效。 如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。\nRedis是如何判断数据是否过期的呢？ Redis 通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。\n过期的数据的删除策略了解么？ 如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：\n惰性删除 ：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。 定期删除 ： 每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。 定期删除对内存更加友好，惰性删除对CPU更加友好。两者各有千秋，所以Redis 采用的是 定期删除+惰性/懒汉式删除 。 但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就Out of memory了。 怎么解决这个问题呢？答案就是： Redis 内存淘汰机制。\nRedis 内存淘汰机制了解么？ Redis 提供 6 种数据淘汰策略：\nvolatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰 allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的） allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰 no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！ 4.0 版本后增加以下两种：\nvolatile-lfu（least frequently used）：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰 allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复) 很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。\nRedis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。\n快照（snapshotting）持久化（RDB） Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。\n快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：\n1 2 3 4 5 6 7 8 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。 save 900 1 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。 save 300 10 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。 save 60 10000 AOF（append-only file）持久化 与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启： appendonly yes\n开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。\n在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：\n1 2 3 appendfsync always #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度 appendfsync everysec #每秒钟同步一次，显示地将多个写命令同步到硬盘 appendfsync no #让操作系统决定何时进行同步 为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。\nRedis 事务 Redis 可以通过 MULTI，EXEC，DISCARD 和 WATCH 等命令来实现事务(transaction)功能。\n1 2 3 4 5 6 7 8 9 \u003e MULTI OK \u003e INCR foo QUEUED \u003e INCR bar QUEUED \u003e EXEC 1) (integer) 1 2) (integer) 1 使用 MULTI命令后可以输入多个命令。Redis不会立即执行这些命令，而是将它们放到队列，当调用了EXEC命令将执行所有命令。\n但是，Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： 1. 原子性，2. 隔离性，3. 持久性，4. 一致性。\n原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的； Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。 Redis官网也解释了自己为啥不支持回滚。简单来说就是Redis开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。 你可以将Redis中的事务就理解为 ：Redis事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。\n缓存穿透 缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。\n解决办法： 最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。\n缓存无效 key 如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： SET key value EX 10086 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。\n另外，这里多说一嘴，一般情况下我们是这样设计 key 的： 表名:列名:主键名:主键值 。 如果用 Java 代码展示的话，差不多是下面这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public Object getObjectInclNullById(Integer id) { // 从缓存中获取数据 Object cacheValue = cache.get(id); // 缓存为空 if (cacheValue == null) { // 从数据库中获取 Object storageValue = storage.get(key); // 缓存空对象 cache.set(key, storageValue); // 如果存储数据为空，需要设置一个过期时间(300秒) if (storageValue == null) { // 必须设置过期时间，否则有被攻击的风险 cache.expire(key, 60 * 5); } return storageValue; } return cacheValue; } 布隆过滤器 布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。\n具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。 但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： 布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。\n为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！ 我们先来看一下，当一个元素加入布隆过滤器中的时候，会进行哪些操作： 使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。根据得到的哈希值，在位数组中把对应下标的值置为 1。 我们再来看一下，当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：\n对给定元素再次进行相同的哈希计算； 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。 然后，一定会出现这样一种情况：不同的字符串可能哈希出来的位置相同。 （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）\n缓存雪崩 缓存雪崩就是：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。\n还有一种缓存雪崩的场景是（缓存击穿）：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。缓存击穿指并发查同一条数据。\n举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。\n针对 Redis 服务不可用的情况：\n采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。 限流，避免同时处理大量的请求。 针对热点缓存失效的情况：\n设置不同的失效时间比如随机设置缓存的失效时间。 缓存永不失效。 如何保证缓存和数据库数据的一致性？ 我们更新数据时，通常先更新数据库，然后更新缓存。 那么如果数据库更新成功了，而缓存没更新成功，那么就造成了数据库和缓存不一致的问题。\nCache Aside Pattern（旁路缓存模式）： 增加cache更新重试机制（常用）： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。\nMYSQL 什么是mysql MySQL 是一种关系型数据库，在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。阿里巴巴数据库系统也大量用到了 MySQL，因此它的稳定性是有保障的。MySQL是开放源代码的，因此任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL的默认端口号是3306。\nSQL的执行顺序 存储引擎 查看MySQL提供的所有存储引擎 show engines; 从上图我们可以查看出 MySQL 当前默认的存储引擎是InnoDB,并且在5.7版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。\n查看MySQL当前默认的存储引擎 show variables like '%storage_engine%';\n查看表的存储引擎 show table status like \"table_name\" ;\nMyISAM和InnoDB区别 MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。\n大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。\n两者的对比：\n是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。 是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。 是否支持外键： MyISAM不支持，而InnoDB支持。 是否支持MVCC ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。 《MySQL高性能》上面有一句话这样写到: 不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。\n什么是回表查询？如何避免？ 对于mysql数据库的InnoDB引擎，它的非主键索引是非聚簇索引，索引文件和数据文件分开存储，索引文件B+树的叶节点只保存主键，在进行查询时，需要先去索引文件找到id，再根据id去数据文件查找具体数据，这种现象就叫回表查询。\n解决方式：将查询sql中的字段添加到联合索引里面，只要保证查询语句里面的字段都在索引文件中，就无需进行回表查询。\n字符集及校对规则 MySQL采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采用默认字符集）\n索引 什么是索引 索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据。\n索引的种类 普通索引：仅加速查询 唯一索引：加速查询 + 列值唯一（可以有null） 主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个 组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并 全文索引：对文本的内容进行分词，进行搜索\n创建索引的时机 一般来说，在WHERE和JOIN中出现的列需要建立索引，但也不完全如此，因为MySQL只对 \u003c，\u003c=，=，\u003e，\u003e=，BETWEEN，IN，以及某些时候的LIKE才会使用索引。 like有几种使用方式： 通配符在前：%王靖尧，这种情况，mysql不会使用索引。 通配符在后：王靖尧%，会使用索引 通配符在前后：%王靖尧%，会使用索引\n例如：\n1 2 3 4 SELECT t.name FROM mytable_t LEFT JOIN mytable_m ON t.name = m.username WHERE m.age=20 AND m.city = '北京'; 此时就需要对city和age建立索引，由于mytable_m表的userame也出现在了JOIN子句中，也有对它建立索引的必要。\n哪些情况索引会失效？ like通配符在前：%王靖尧，这种情况，索引会失效。 当 or 条件中有未建立索引的列才失效，要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引。 存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引。 where 子句里对索引列上有数学运算或者函数，会导致索引失效而转向全表扫描。 对于多列索引（复合索引），条件中没有索引的第一个字段，则不会使用索引。 索引采用的哪种数据结构呢？ MySQL索引使用的数据结构主要有BTree索引和哈希索引 ，InnoDB引擎，默认的是B+树索引。\n哈希索引，底层就是哈希表，哈希表是一种以key-value存储数据的结构，适合单条记录查询。 而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。\n哈希索引适合等值查询，但是无法进行范围查询 哈希索引没办法利用索引完成排序 哈希索引不支持多列联合索引的最左匹配规则 如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题 刚刚我们聊到B+ Tree ，那你知道B+ Tree的叶子节点都可以存哪些东西吗？ InnoDB的B+ Tree可能存储的是整行数据，也有可能是主键的值。 那这两者有什么区别吗？ B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。 B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引。\n聚簇索引和非聚簇索引，在查询数据的时候有区别吗？ 聚簇索引查询会更快。 为什么呢？ 因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询。\n非主键索引一定会查询多次吗？ 通过覆盖索引，非主键索引可以只查询一次。 覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。 如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。 当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。\n联合索引、最左前缀匹配 创建索引的时候都会考虑哪些因素呢？ 我们一般对于查询概率比较高，经常作为where条件的字段设置索引。\n用过联合索引吗？ 用过呀，我们有对一些表中创建过联合索引。\n在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？ 我们把识别度最高的字段放到最前面。\n为什么这么做呢？ 因为最左前缀匹配。 因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。\n你们创建的那么多索引，到底有没有生效，或者说你们的SQL语句有没有使用索引查询你们有统计过吗？ 这个还没有统计过，除非遇到慢SQL的时候我们才会去排查\n那排查的时候，有什么手段可以知道有没有走索引查询呢？ 可以通过explain查看sql语句的执行计划，通过执行计划来分析索引使用情况。 explain的结果共包含12个字段，简单介绍几个重要的：\nid，执行顺序 select_type，查询中每个select的查询类型 type，重点关注的字段，该字段直接反映我们SQL的性能是否高效，这个字段值较多，只需关注重点几个：性能由好到差依次为：system-\u003econst-\u003eeq_ref-\u003eref-\u003erange-\u003eindex-\u003eall 那什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？ 查询优化器。 在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。\n查询缓存的使用 执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用。 my.cnf加入以下配置，重启MySQL开启查询缓存\n1 2 query_cache_type=1 query_cache_size=600000 MySQL执行以下命令也可以开启查询缓存\n1 2 set global query_cache_type=1; set global query_cache_size=600000; 如上，开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。\n缓存建立之后，MySQL的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。\n缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。 因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。此外，还可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要缓存： select sql_no_cache count(*) from usr;\n什么是事务? 事务是逻辑上的一组操作，要么都执行，要么都不执行。 事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。\n事物的四大特性(ACID) 原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 并发事务带来哪些问题? 在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。\n脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。\n丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。\n不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。\n幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n不可重复读和幻读区别： 不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。\n事务隔离级别有哪些?MySQL的默认隔离级别是? SQL 标准定义了四个隔离级别：\nREAD-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 隔离级别 脏读 不可重复读 幻读 READ-UNCOMMITTED √ √ √ READ-COMMITTED × √ √ REPEATABLE-READ × × √ SERIALIZABLE × × × MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过SELECT @@tx_isolation;命令来查看。\n这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) ，但是你要知道的是InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） 并不会有任何性能损失。\nInnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。\n锁机制与InnoDB锁算法 MyISAM和InnoDB存储引擎使用的锁：\nMyISAM采用表级锁(table-level locking)。 InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁 表级锁和行级锁对比：\n表级锁： MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。 行级锁： MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。 InnoDB存储引擎的锁的算法有三种：\nRecord lock：单个行记录上的锁 Gap lock：间隙锁，锁定一个范围，不包括记录本身 Next-key lock：record+gap 锁定一个范围，包含记录本身 相关知识点：\ninnodb对于行的查询使用next-key lock Next-locking keying为了解决Phantom Problem幻读问题 当查询的索引含有唯一属性时，将next-key lock降级为record key Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生 有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1 大表优化 当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：\n限定数据的范围 务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；\n读/写分离 经典的数据库拆分方案，主库负责写，从库负责读；\n垂直拆分 根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。 简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。\n垂直拆分的优点： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。 垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；\n水平拆分 保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。 水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。\n水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。\n水平拆分能够支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。\n下面补充一下数据库分片的两种常见方案：\n客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。 中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。 详细内容可以参考： MySQL大表优化方案: https://segmentfault.com/a/1190000006158186\n解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池? 池化设计应该不是一个新名词。我们常见的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。就好比你去食堂打饭，打饭的大妈会先把饭盛好几份放那里，你来了就直接拿着饭盒加菜即可，不用再临时又盛饭又打菜，效率就高了。除了初始化资源，池化设计还包括如下这些特征：池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。这篇文章对池化设计思想介绍的还不错，直接复制过来，避免重复造轮子了。\n数据库连接本质就是一个 socket 的连接。数据库服务端还要维护一些缓存和用户权限信息之类的 所以占用了一些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。**在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中。 **连接池还减少了用户必须等待建立与数据库的连接的时间。\n分库分表之后,id 主键如何处理？ 因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。 生成全局 id 有下面这几种方式：\nUUID：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。 数据库自增 id : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。 利用 redis 生成 id : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。 Twitter的snowflake算法 ：Github 地址：https://github.com/twitter-archive/snowflake。 美团的Leaf分布式ID生成系统 ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章：https://tech.meituan.com/2017/04/21/mt-leaf.html 。 一条SQL语句在MySQL中如何执行的 MySQL高性能优化规范建议 https://www.cnblogs.com/huchong/p/10219318.html\n一条SQL语句执行得很慢的原因有哪些？ https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==\u0026mid=2247485185\u0026idx=1\u0026sn=66ef08b4ab6af5757792223a83fc0d45\u0026chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47\u0026token=79317275\u0026lang=zh_CN#rd\n后端程序员必备：书写高质量SQL的30条建议 https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==\u0026mid=2247486461\u0026idx=1\u0026sn=60a22279196d084cc398936fe3b37772\u0026chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed\u0026token=1987003517\u0026lang=zh_CN#rd\nSpring 什么是 Spring 框架? Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。Spring 官网：https://spring.io/。\n我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。\nSpring包含哪些模块？ Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。 Spring Aspects ： 该模块为与AspectJ的集成提供支持。 Spring AOP ：提供了面向切面的编程实现。 Spring JDBC : Java数据库连接。 Spring JMS ：Java消息服务。 Spring ORM : 用于支持Hibernate等ORM工具。 Spring Web : 为创建Web应用程序提供支持。 Spring Test : 提供了对 JUnit 和 TestNG 测试的支持。\nSpring IOC IoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语言中也有应用，并非 Spring 特有。 IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。\n将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。\nSpring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。\n推荐阅读\nAOP AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。\nSpring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理\n当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。\n使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。\nSpring AOP 和 AspectJ AOP 有什么区别？ Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。 Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单， 如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。\nSpring 中的 bean 的作用域有哪些? singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。 prototype : 每次请求都会创建一个新的 bean 实例。 request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。 session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。\nSpring 中的单例 bean 的线程安全问题了解吗？ 大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。\n常见的有两种解决办法：\n在Bean对象中尽量避免定义可变的成员变量（不太现实）。 在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。 @Component 和 @Bean 的区别是什么？ 作用对象不同: @Component 注解作用于类，而@Bean注解作用于方法。 @Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了Spring这是某个类的示例，当我需要用它的时候还给我。 @Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。 @Bean注解使用示例：\n1 2 3 4 5 6 7 8 @Configuration public class AppConfig { @Bean public TransferService transferService() { return new TransferServiceImpl(); } } 上面的代码相当于下面的 xml 配置\n1 2 3 ",
  "wordCount" : "51025",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Wjy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://009965.xyz/posts/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Wjy's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://009965.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://009965.xyz/" accesskey="h" title="Wjy&#39;s Blog (Alt + H)">Wjy&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://009965.xyz/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://009965.xyz/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://009965.xyz/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://009965.xyz/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://009965.xyz/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://009965.xyz/">Home</a>&nbsp;»&nbsp;<a href="https://009965.xyz/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      面试
    </h1>
    <div class="post-meta">Wjy

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#java%e5%9f%ba%e7%a1%80" aria-label="java基础">java基础</a><ul>
                        
                <li>
                    <a href="#java%e5%a6%82%e4%bd%95%e8%bf%9b%e8%a1%8c%e9%ab%98%e6%95%88%e7%9a%84%e6%95%b0%e7%bb%84%e6%8b%b7%e8%b4%9d" aria-label="Java如何进行高效的数组拷贝？">Java如何进行高效的数组拷贝？</a></li>
                <li>
                    <a href="#float-f--34-%e8%83%bd%e5%90%a6%e9%80%9a%e8%bf%87%e7%bc%96%e8%af%91" aria-label="float f = 3.4; 能否通过编译？">float f = 3.4; 能否通过编译？</a></li>
                <li>
                    <a href="#%e4%b8%a4%e6%95%b0%e4%ba%a4%e6%8d%a2" aria-label="两数交换">两数交换</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88finally%e9%87%8c%e7%9a%84%e4%bb%a3%e7%a0%81%e4%b8%80%e5%ae%9a%e4%bc%9a%e6%89%a7%e8%a1%8c" aria-label="为什么finally里的代码一定会执行？">为什么finally里的代码一定会执行？</a></li>
                <li>
                    <a href="#int%e5%92%8cinteger%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="int和Integer有什么区别？">int和Integer有什么区别？</a></li>
                <li>
                    <a href="#%e5%92%8c%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="&amp;和&amp;&amp;的区别？">&amp;和&amp;&amp;的区别？</a></li>
                <li>
                    <a href="#%e6%9e%84%e9%80%a0%e5%99%a8constructor%e6%98%af%e5%90%a6%e5%8f%af%e8%a2%ab%e9%87%8d%e5%86%99override" aria-label="构造器（constructor）是否可被重写（override）？">构造器（constructor）是否可被重写（override）？</a></li>
                <li>
                    <a href="#%e4%b8%a4%e4%b8%aa%e5%af%b9%e8%b1%a1%e5%80%bc%e7%9b%b8%e5%90%8cxequalsy--true%e4%bd%86%e5%8d%b4%e5%8f%af%e6%9c%89%e4%b8%8d%e5%90%8c%e7%9a%84hash-code%e8%bf%99%e5%8f%a5%e8%af%9d%e5%af%b9%e4%b8%8d%e5%af%b9" aria-label="两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？">两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</a></li>
                <li>
                    <a href="#char-%e5%9e%8b%e5%8f%98%e9%87%8f%e4%b8%ad%e8%83%bd%e4%b8%8d%e8%83%bd%e5%ad%98%e8%b4%ae%e4%b8%80%e4%b8%aa%e4%b8%ad%e6%96%87%e6%b1%89%e5%ad%97%e4%b8%ba%e4%bb%80%e4%b9%88" aria-label="char 型变量中能不能存贮一个中文汉字，为什么？">char 型变量中能不能存贮一个中文汉字，为什么？</a></li>
                <li>
                    <a href="#string-s--hello-world" aria-label="string s = &ldquo;hello world&rdquo;;">string s = &ldquo;hello world&rdquo;;</a></li>
                <li>
                    <a href="#%e7%94%a8%e5%a4%9a%e7%ba%bf%e7%a8%8b%e8%ae%a1%e7%ae%97%e5%87%ba1-10000%e4%b9%8b%e9%97%b4%e7%9a%84%e7%b4%a0%e6%95%b0" aria-label="用多线程计算出1-10000之间的素数">用多线程计算出1-10000之间的素数</a></li>
                <li>
                    <a href="#%e4%b8%8d%e7%94%a8uuid%e7%94%9f%e6%88%90%e8%ae%a2%e5%8d%95%e5%8f%b7" aria-label="不用uuid生成订单号">不用uuid生成订单号</a></li>
                <li>
                    <a href="#%e6%b1%821-100%e4%b9%8b%e9%97%b4%e6%89%80%e6%9c%89%e8%b4%a8%e6%95%b0%e5%92%8c" aria-label="求1-100之间所有质数和">求1-100之间所有质数和</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%afjava%e8%99%9a%e6%8b%9f%e6%9c%ba%e4%b8%ba%e4%bb%80%e4%b9%88java%e8%a2%ab%e7%a7%b0%e4%bd%9c%e6%98%af%e5%b9%b3%e5%8f%b0%e6%97%a0%e5%85%b3%e7%9a%84%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80" aria-label="什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言？">什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言？</a></li>
                <li>
                    <a href="#jdk%e5%92%8cjre%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="JDK和JRE的区别是什么？">JDK和JRE的区别是什么？</a></li>
                <li>
                    <a href="#%e6%98%af%e5%90%a6%e5%8f%af%e4%bb%a5%e5%9c%a8static%e7%8e%af%e5%a2%83%e4%b8%ad%e8%ae%bf%e9%97%ae%e9%9d%9estatic%e5%8f%98%e9%87%8f%e4%b8%8d%e5%8f%af%e4%bb%a5" aria-label="是否可以在static环境中访问非static变量？(不可以)">是否可以在static环境中访问非static变量？(不可以)</a></li>
                <li>
                    <a href="#java%e6%94%af%e6%8c%81%e7%9a%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e6%9c%89%e5%93%aa%e4%ba%9b%e4%bb%80%e4%b9%88%e6%98%af%e8%87%aa%e5%8a%a8%e6%8b%86%e8%a3%85%e7%ae%b1" aria-label="Java支持的数据类型有哪些？什么是自动拆装箱？">Java支持的数据类型有哪些？什么是自动拆装箱？</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%80%bc%e4%bc%a0%e9%80%92%e5%92%8c%e5%bc%95%e7%94%a8%e4%bc%a0%e9%80%92" aria-label="什么是值传递和引用传递？">什么是值传递和引用传递？</a></li>
                <li>
                    <a href="#%e8%bf%9b%e7%a8%8b%e5%92%8c%e7%ba%bf%e7%a8%8b%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="进程和线程的区别是什么？">进程和线程的区别是什么？</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%ad%bb%e9%94%81deadlock" aria-label="什么是死锁(deadlock)？">什么是死锁(deadlock)？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e7%a1%ae%e4%bf%9dn%e4%b8%aa%e7%ba%bf%e7%a8%8b%e5%8f%af%e4%bb%a5%e8%ae%bf%e9%97%aen%e4%b8%aa%e8%b5%84%e6%ba%90%e5%90%8c%e6%97%b6%e5%8f%88%e4%b8%8d%e5%af%bc%e8%87%b4%e6%ad%bb%e9%94%81" aria-label="如何确保N个线程可以访问N个资源同时又不导致死锁？">如何确保N个线程可以访问N个资源同时又不导致死锁？</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e8%bf%ad%e4%bb%a3%e5%99%a8iterator" aria-label="什么是迭代器(Iterator)？">什么是迭代器(Iterator)？</a></li>
                <li>
                    <a href="#iterator%e5%92%8clistiterator%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="Iterator和ListIterator的区别是什么？">Iterator和ListIterator的区别是什么？</a></li>
                <li>
                    <a href="#java%e4%b8%ad%e7%9a%84hashmap%e7%9a%84%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86%e6%98%af%e4%bb%80%e4%b9%88" aria-label="Java中的HashMap的工作原理是什么？">Java中的HashMap的工作原理是什么？</a></li>
                <li>
                    <a href="#%e9%81%8d%e5%8e%86map" aria-label="遍历Map">遍历Map</a></li>
                <li>
                    <a href="#%e6%95%b0%e7%bb%84array%e5%92%8c%e5%88%97%e8%a1%a8arraylist%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e5%ba%94%e8%af%a5%e4%bd%bf%e7%94%a8array%e8%80%8c%e4%b8%8d%e6%98%afarraylist" aria-label="数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？">数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？</a></li>
                <li>
                    <a href="#%e4%b9%9d%e7%a7%8d%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%a4%a7%e5%b0%8f%e4%bb%a5%e5%8f%8a%e4%bb%96%e4%bb%ac%e7%9a%84%e5%b0%81%e8%a3%85%e7%b1%bb%e4%b8%80%e4%b8%aa%e5%ad%97%e8%8a%82%e6%98%af8%e4%bd%8d" aria-label="九种基本数据类型的大小，以及他们的封装类(一个字节是8位)">九种基本数据类型的大小，以及他们的封装类(一个字节是8位)</a></li>
                <li>
                    <a href="#equalshashcode--%e5%8c%ba%e5%88%ab" aria-label="equals、==、hashcode  区别">equals、==、hashcode  区别</a></li>
                <li>
                    <a href="#java%e7%9a%84%e5%9b%9b%e7%a7%8d%e5%bc%95%e7%94%a8%e5%bc%ba%e5%bc%b1%e8%bd%af%e8%99%9a%e7%94%a8%e5%88%b0%e7%9a%84%e5%9c%ba%e6%99%af" aria-label="Java的四种引用，强弱软虚，用到的场景">Java的四种引用，强弱软虚，用到的场景</a></li>
                <li>
                    <a href="#hashcode%e7%9a%84%e4%bd%9c%e7%94%a8" aria-label="Hashcode的作用">Hashcode的作用</a></li>
                <li>
                    <a href="#stringstringbuffer%e4%b8%8estringbuilder%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="String、StringBuffer与StringBuilder的区别。">String、StringBuffer与StringBuilder的区别。</a></li>
                <li>
                    <a href="#%e4%bb%a5%e4%b8%8b%e7%a8%8b%e5%ba%8f%e7%9a%84%e8%bf%90%e8%a1%8c%e7%bb%93%e6%9e%9c%e6%98%af%e4%bb%80%e4%b9%88" aria-label="以下程序的运行结果是什么">以下程序的运行结果是什么</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%9b%86%e5%90%88collection" aria-label="集合Collection">集合Collection</a><ul>
                        
                <li>
                    <a href="#%e8%af%b4%e8%af%b4listsetmap%e4%b8%89%e8%80%85%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="说说List,Set,Map三者的区别？">说说List,Set,Map三者的区别？</a></li>
                <li>
                    <a href="#arraylist-%e4%b8%8e-linkedlist-%e5%8c%ba%e5%88%ab" aria-label="Arraylist 与 LinkedList 区别?">Arraylist 与 LinkedList 区别?</a></li>
                <li>
                    <a href="#arraylist-%e5%92%8c-vector-%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="ArrayList 和 Vector 的区别。">ArrayList 和 Vector 的区别。</a></li>
                <li>
                    <a href="#hashset-%e6%98%af%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e4%b8%8d%e9%87%8d%e5%a4%8d%e7%9a%84" aria-label="HashSet 是如何保证不重复的？">HashSet 是如何保证不重复的？</a></li>
                <li>
                    <a href="#map" aria-label="Map">Map</a><ul>
                        
                <li>
                    <a href="#hashmap-%e6%9c%89%e5%93%aa%e4%ba%9b%e9%87%8d%e8%a6%81%e5%b1%9e%e6%80%a7%e5%88%86%e5%88%ab%e7%94%a8%e4%ba%8e%e5%81%9a%e4%bb%80%e4%b9%88%e7%9a%84" aria-label="HashMap 有哪些重要属性？分别用于做什么的？">HashMap 有哪些重要属性？分别用于做什么的？</a></li>
                <li>
                    <a href="#hashmap-%e7%9a%84%e9%bb%98%e8%ae%a4%e5%88%9d%e5%a7%8b%e5%ae%b9%e9%87%8f%e6%98%af%e5%a4%9a%e5%b0%91hashmap-%e7%9a%84%e5%ae%b9%e9%87%8f%e6%9c%89%e4%bb%80%e4%b9%88%e9%99%90%e5%88%b6%e5%90%97" aria-label="HashMap 的默认初始容量是多少？HashMap 的容量有什么限制吗？">HashMap 的默认初始容量是多少？HashMap 的容量有什么限制吗？</a></li>
                <li>
                    <a href="#hashmap-%e7%9a%84%e5%ae%b9%e9%87%8f%e5%bf%85%e9%a1%bb%e6%98%af-2-%e7%9a%84-n-%e6%ac%a1%e6%96%b9%e8%bf%99%e6%98%af%e4%b8%ba%e4%bb%80%e4%b9%88" aria-label="HashMap 的容量必须是 2 的 N 次方，这是为什么？">HashMap 的容量必须是 2 的 N 次方，这是为什么？</a></li>
                <li>
                    <a href="#hashmap-%e6%98%af%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84%e5%90%97" aria-label="HashMap 是线程安全的吗？">HashMap 是线程安全的吗？</a></li>
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b%e6%ad%bb%e5%be%aa%e7%8e%af%e9%97%ae%e9%a2%98" aria-label="介绍一下死循环问题？">介绍一下死循环问题？</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93%e4%b8%8b-jdk-18-hashmap%e4%b8%bb%e8%a6%81%e8%bf%9b%e8%a1%8c%e4%ba%86%e5%93%aa%e4%ba%9b%e4%bc%98%e5%8c%96" aria-label="总结下 JDK 1.8 HashMap主要进行了哪些优化？">总结下 JDK 1.8 HashMap主要进行了哪些优化？</a></li>
                <li>
                    <a href="#hashmap-%e7%9a%84%e5%ba%95%e5%b1%82%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="HashMap 的底层数据结构">HashMap 的底层数据结构</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bd%bf%e7%94%a8%e6%95%b0%e7%bb%84%e9%93%be%e8%a1%a8" aria-label="为什么使用“数组&#43;链表”？">为什么使用“数组+链表”？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e6%94%b9%e6%88%90%e6%95%b0%e7%bb%84%e9%93%be%e8%a1%a8%e7%ba%a2%e9%bb%91%e6%a0%91" aria-label="为什么要改成“数组&#43;链表&#43;红黑树”？">为什么要改成“数组+链表+红黑树”？</a></li>
                <li>
                    <a href="#%e9%82%a3%e5%9c%a8%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e7%94%a8%e9%93%be%e8%a1%a8%e4%bb%80%e4%b9%88%e6%97%b6%e5%80%99%e7%94%a8%e7%ba%a2%e9%bb%91%e6%a0%91" aria-label="那在什么时候用链表？什么时候用红黑树？">那在什么时候用链表？什么时候用红黑树？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%93%be%e8%a1%a8%e8%bd%ac%e7%ba%a2%e9%bb%91%e6%a0%91%e7%9a%84%e9%98%88%e5%80%bc%e6%98%af8" aria-label="为什么链表转红黑树的阈值是8？">为什么链表转红黑树的阈值是8？</a></li>
                <li>
                    <a href="#%e9%82%a3%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bd%ac%e5%9b%9e%e9%93%be%e8%a1%a8%e8%8a%82%e7%82%b9%e6%98%af%e7%94%a8%e7%9a%846%e8%80%8c%e4%b8%8d%e6%98%af%e5%a4%8d%e7%94%a88" aria-label="那为什么转回链表节点是用的6而不是复用8？">那为什么转回链表节点是用的6而不是复用8？</a></li>
                <li>
                    <a href="#%e7%ae%80%e8%bf%b0concurrenthashmap%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86%e5%ae%83%e6%98%af%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e7%9a%84" aria-label="简述ConcurrentHashMap实现原理，它是如何保证线程安全的。">简述ConcurrentHashMap实现原理，它是如何保证线程安全的。</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#linux" aria-label="Linux">Linux</a></li>
                <li>
                    <a href="#rocketmq" aria-label="RocketMQ">RocketMQ</a><ul>
                        
                <li>
                    <a href="#rocketmq%e7%94%b1%e5%93%aa%e4%ba%9b%e8%a7%92%e8%89%b2%e7%bb%84%e6%88%90%e6%af%8f%e4%b8%aa%e8%a7%92%e8%89%b2%e4%bd%9c%e7%94%a8%e5%92%8c%e7%89%b9%e7%82%b9%e6%98%af%e4%bb%80%e4%b9%88" aria-label="RocketMQ由哪些角色组成，每个角色作用和特点是什么？">RocketMQ由哪些角色组成，每个角色作用和特点是什么？</a></li>
                <li>
                    <a href="#rocketmq-broker%e4%b8%ad%e7%9a%84%e6%b6%88%e6%81%af%e8%a2%ab%e6%b6%88%e8%b4%b9%e5%90%8e%e4%bc%9a%e7%ab%8b%e5%8d%b3%e5%88%a0%e9%99%a4%e5%90%97" aria-label="RocketMQ Broker中的消息被消费后会立即删除吗？">RocketMQ Broker中的消息被消费后会立即删除吗？</a></li>
                <li>
                    <a href="#rocketmq%e6%b6%88%e8%b4%b9%e6%a8%a1%e5%bc%8f%e6%9c%89%e5%87%a0%e7%a7%8d" aria-label="RocketMQ消费模式有几种？">RocketMQ消费模式有几种？</a></li></ul>
                </li>
                <li>
                    <a href="#redis" aria-label="Redis">Redis</a><ul>
                        
                <li>
                    <a href="#%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8dredis" aria-label="简单介绍redis">简单介绍redis</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%ad%98%e6%95%b0%e6%8d%ae%e7%9a%84%e5%a4%84%e7%90%86%e6%b5%81%e7%a8%8b%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84" aria-label="缓存数据的处理流程是怎样的？">缓存数据的处理流程是怎样的？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-redis%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e7%bc%93%e5%ad%98" aria-label="为什么要用 Redis/为什么要用缓存？">为什么要用 Redis/为什么要用缓存？</a></li>
                <li>
                    <a href="#redis-%e5%b8%b8%e8%a7%81%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e4%bb%a5%e5%8f%8a%e4%bd%bf%e7%94%a8%e5%9c%ba%e6%99%af%e5%88%86%e6%9e%90" aria-label="Redis 常见数据结构以及使用场景分析">Redis 常见数据结构以及使用场景分析</a><ul>
                        
                <li>
                    <a href="#string" aria-label="string">string</a></li>
                <li>
                    <a href="#list" aria-label="list">list</a></li>
                <li>
                    <a href="#hash" aria-label="hash">hash</a></li>
                <li>
                    <a href="#set" aria-label="set">set</a></li>
                <li>
                    <a href="#sorted-set" aria-label="sorted set">sorted set</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e5%8d%95%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b%e8%af%a6%e8%a7%a3" aria-label="Redis 单线程模型详解">Redis 单线程模型详解</a></li>
                <li>
                    <a href="#redis-%e6%b2%a1%e6%9c%89%e4%bd%bf%e7%94%a8%e5%a4%9a%e7%ba%bf%e7%a8%8b%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e4%bd%bf%e7%94%a8%e5%a4%9a%e7%ba%bf%e7%a8%8b" aria-label="Redis 没有使用多线程？为什么不使用多线程？">Redis 没有使用多线程？为什么不使用多线程？</a></li>
                <li>
                    <a href="#redis60-%e4%b9%8b%e5%90%8e%e4%b8%ba%e4%bd%95%e5%bc%95%e5%85%a5%e4%ba%86%e5%a4%9a%e7%ba%bf%e7%a8%8b" aria-label="Redis6.0 之后为何引入了多线程？">Redis6.0 之后为何引入了多线程？</a></li>
                <li>
                    <a href="#redis-%e7%bb%99%e7%bc%93%e5%ad%98%e6%95%b0%e6%8d%ae%e8%ae%be%e7%bd%ae%e8%bf%87%e6%9c%9f%e6%97%b6%e9%97%b4%e6%9c%89%e5%95%a5%e7%94%a8" aria-label="Redis 给缓存数据设置过期时间有啥用？">Redis 给缓存数据设置过期时间有啥用？</a></li>
                <li>
                    <a href="#redis%e6%98%af%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e6%95%b0%e6%8d%ae%e6%98%af%e5%90%a6%e8%bf%87%e6%9c%9f%e7%9a%84%e5%91%a2" aria-label="Redis是如何判断数据是否过期的呢？">Redis是如何判断数据是否过期的呢？</a></li>
                <li>
                    <a href="#%e8%bf%87%e6%9c%9f%e7%9a%84%e6%95%b0%e6%8d%ae%e7%9a%84%e5%88%a0%e9%99%a4%e7%ad%96%e7%95%a5%e4%ba%86%e8%a7%a3%e4%b9%88" aria-label="过期的数据的删除策略了解么？">过期的数据的删除策略了解么？</a></li>
                <li>
                    <a href="#redis-%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e6%9c%ba%e5%88%b6%e4%ba%86%e8%a7%a3%e4%b9%88" aria-label="Redis 内存淘汰机制了解么？">Redis 内存淘汰机制了解么？</a></li>
                <li>
                    <a href="#redis-%e6%8c%81%e4%b9%85%e5%8c%96%e6%9c%ba%e5%88%b6%e6%80%8e%e4%b9%88%e4%bf%9d%e8%af%81-redis-%e6%8c%82%e6%8e%89%e4%b9%8b%e5%90%8e%e5%86%8d%e9%87%8d%e5%90%af%e6%95%b0%e6%8d%ae%e5%8f%af%e4%bb%a5%e8%bf%9b%e8%a1%8c%e6%81%a2%e5%a4%8d" aria-label="Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)">Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)</a><ul>
                        
                <li>
                    <a href="#%e5%bf%ab%e7%85%a7snapshotting%e6%8c%81%e4%b9%85%e5%8c%96rdb" aria-label="快照（snapshotting）持久化（RDB）">快照（snapshotting）持久化（RDB）</a></li>
                <li>
                    <a href="#aofappend-only-file%e6%8c%81%e4%b9%85%e5%8c%96" aria-label="AOF（append-only file）持久化">AOF（append-only file）持久化</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e4%ba%8b%e5%8a%a1" aria-label="Redis 事务">Redis 事务</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f" aria-label="缓存穿透">缓存穿透</a><ul>
                        
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95" aria-label="解决办法：">解决办法：</a><ul>
                        
                <li>
                    <a href="#%e7%bc%93%e5%ad%98%e6%97%a0%e6%95%88-key" aria-label="缓存无效 key">缓存无效 key</a></li>
                <li>
                    <a href="#%e5%b8%83%e9%9a%86%e8%bf%87%e6%bb%a4%e5%99%a8" aria-label="布隆过滤器">布隆过滤器</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9" aria-label="缓存雪崩">缓存雪崩</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e7%bc%93%e5%ad%98%e5%92%8c%e6%95%b0%e6%8d%ae%e5%ba%93%e6%95%b0%e6%8d%ae%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7" aria-label="如何保证缓存和数据库数据的一致性？">如何保证缓存和数据库数据的一致性？</a></li></ul>
                </li>
                <li>
                    <a href="#mysql" aria-label="MYSQL">MYSQL</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%afmysql" aria-label="什么是mysql">什么是mysql</a></li>
                <li>
                    <a href="#sql%e7%9a%84%e6%89%a7%e8%a1%8c%e9%a1%ba%e5%ba%8f" aria-label="SQL的执行顺序">SQL的执行顺序</a></li>
                <li>
                    <a href="#%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e" aria-label="存储引擎">存储引擎</a><ul>
                        
                <li>
                    <a href="#myisam%e5%92%8cinnodb%e5%8c%ba%e5%88%ab" aria-label="MyISAM和InnoDB区别">MyISAM和InnoDB区别</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%9b%9e%e8%a1%a8%e6%9f%a5%e8%af%a2%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d" aria-label="什么是回表查询？如何避免？">什么是回表查询？如何避免？</a></li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e9%9b%86%e5%8f%8a%e6%a0%a1%e5%af%b9%e8%a7%84%e5%88%99" aria-label="字符集及校对规则">字符集及校对规则</a></li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95" aria-label="索引">索引</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%b4%a2%e5%bc%95" aria-label="什么是索引">什么是索引</a></li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95%e7%9a%84%e7%a7%8d%e7%b1%bb" aria-label="索引的种类">索引的种类</a></li>
                <li>
                    <a href="#%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95%e7%9a%84%e6%97%b6%e6%9c%ba" aria-label="创建索引的时机">创建索引的时机</a></li>
                <li>
                    <a href="#%e5%93%aa%e4%ba%9b%e6%83%85%e5%86%b5%e7%b4%a2%e5%bc%95%e4%bc%9a%e5%a4%b1%e6%95%88" aria-label="哪些情况索引会失效？">哪些情况索引会失效？</a></li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95%e9%87%87%e7%94%a8%e7%9a%84%e5%93%aa%e7%a7%8d%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e5%91%a2" aria-label="索引采用的哪种数据结构呢？">索引采用的哪种数据结构呢？</a></li>
                <li>
                    <a href="#%e5%88%9a%e5%88%9a%e6%88%91%e4%bb%ac%e8%81%8a%e5%88%b0b-tree-%e9%82%a3%e4%bd%a0%e7%9f%a5%e9%81%93b-tree%e7%9a%84%e5%8f%b6%e5%ad%90%e8%8a%82%e7%82%b9%e9%83%bd%e5%8f%af%e4%bb%a5%e5%ad%98%e5%93%aa%e4%ba%9b%e4%b8%9c%e8%a5%bf%e5%90%97" aria-label="刚刚我们聊到B&#43; Tree ，那你知道B&#43; Tree的叶子节点都可以存哪些东西吗？">刚刚我们聊到B+ Tree ，那你知道B+ Tree的叶子节点都可以存哪些东西吗？</a></li>
                <li>
                    <a href="#%e9%9d%9e%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95%e4%b8%80%e5%ae%9a%e4%bc%9a%e6%9f%a5%e8%af%a2%e5%a4%9a%e6%ac%a1%e5%90%97" aria-label="非主键索引一定会查询多次吗？">非主键索引一定会查询多次吗？</a></li>
                <li>
                    <a href="#%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95%e6%9c%80%e5%b7%a6%e5%89%8d%e7%bc%80%e5%8c%b9%e9%85%8d" aria-label="联合索引、最左前缀匹配">联合索引、最左前缀匹配</a></li>
                <li>
                    <a href="#%e4%bd%a0%e4%bb%ac%e5%88%9b%e5%bb%ba%e7%9a%84%e9%82%a3%e4%b9%88%e5%a4%9a%e7%b4%a2%e5%bc%95%e5%88%b0%e5%ba%95%e6%9c%89%e6%b2%a1%e6%9c%89%e7%94%9f%e6%95%88%e6%88%96%e8%80%85%e8%af%b4%e4%bd%a0%e4%bb%ac%e7%9a%84sql%e8%af%ad%e5%8f%a5%e6%9c%89%e6%b2%a1%e6%9c%89%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95%e6%9f%a5%e8%af%a2%e4%bd%a0%e4%bb%ac%e6%9c%89%e7%bb%9f%e8%ae%a1%e8%bf%87%e5%90%97" aria-label="你们创建的那么多索引，到底有没有生效，或者说你们的SQL语句有没有使用索引查询你们有统计过吗？">你们创建的那么多索引，到底有没有生效，或者说你们的SQL语句有没有使用索引查询你们有统计过吗？</a></li>
                <li>
                    <a href="#%e9%82%a3%e6%8e%92%e6%9f%a5%e7%9a%84%e6%97%b6%e5%80%99%e6%9c%89%e4%bb%80%e4%b9%88%e6%89%8b%e6%ae%b5%e5%8f%af%e4%bb%a5%e7%9f%a5%e9%81%93%e6%9c%89%e6%b2%a1%e6%9c%89%e8%b5%b0%e7%b4%a2%e5%bc%95%e6%9f%a5%e8%af%a2%e5%91%a2" aria-label="那排查的时候，有什么手段可以知道有没有走索引查询呢？">那排查的时候，有什么手段可以知道有没有走索引查询呢？</a></li>
                <li>
                    <a href="#%e9%82%a3%e4%bb%80%e4%b9%88%e6%83%85%e5%86%b5%e4%b8%8b%e4%bc%9a%e5%8f%91%e7%94%9f%e6%98%8e%e6%98%8e%e5%88%9b%e5%bb%ba%e4%ba%86%e7%b4%a2%e5%bc%95%e4%bd%86%e6%98%af%e6%89%a7%e8%a1%8c%e7%9a%84%e6%97%b6%e5%80%99%e5%b9%b6%e6%b2%a1%e6%9c%89%e9%80%9a%e8%bf%87%e7%b4%a2%e5%bc%95%e5%91%a2" aria-label="那什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？">那什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%9f%a5%e8%af%a2%e7%bc%93%e5%ad%98%e7%9a%84%e4%bd%bf%e7%94%a8" aria-label="查询缓存的使用">查询缓存的使用</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%ba%8b%e5%8a%a1" aria-label="什么是事务?">什么是事务?</a></li>
                <li>
                    <a href="#%e4%ba%8b%e7%89%a9%e7%9a%84%e5%9b%9b%e5%a4%a7%e7%89%b9%e6%80%a7acid" aria-label="事物的四大特性(ACID)">事物的四大特性(ACID)</a></li>
                <li>
                    <a href="#%e5%b9%b6%e5%8f%91%e4%ba%8b%e5%8a%a1%e5%b8%a6%e6%9d%a5%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98" aria-label="并发事务带来哪些问题?">并发事务带来哪些问题?</a></li>
                <li>
                    <a href="#%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e6%9c%89%e5%93%aa%e4%ba%9bmysql%e7%9a%84%e9%bb%98%e8%ae%a4%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e6%98%af" aria-label="事务隔离级别有哪些?MySQL的默认隔离级别是?">事务隔离级别有哪些?MySQL的默认隔离级别是?</a></li>
                <li>
                    <a href="#%e9%94%81%e6%9c%ba%e5%88%b6%e4%b8%8einnodb%e9%94%81%e7%ae%97%e6%b3%95" aria-label="锁机制与InnoDB锁算法">锁机制与InnoDB锁算法</a></li>
                <li>
                    <a href="#%e5%a4%a7%e8%a1%a8%e4%bc%98%e5%8c%96" aria-label="大表优化">大表优化</a><ul>
                        
                <li>
                    <a href="#%e9%99%90%e5%ae%9a%e6%95%b0%e6%8d%ae%e7%9a%84%e8%8c%83%e5%9b%b4" aria-label="限定数据的范围">限定数据的范围</a></li>
                <li>
                    <a href="#%e8%af%bb%e5%86%99%e5%88%86%e7%a6%bb" aria-label="读/写分离">读/写分离</a></li>
                <li>
                    <a href="#%e5%9e%82%e7%9b%b4%e6%8b%86%e5%88%86" aria-label="垂直拆分">垂直拆分</a></li>
                <li>
                    <a href="#%e6%b0%b4%e5%b9%b3%e6%8b%86%e5%88%86" aria-label="水平拆分">水平拆分</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%a7%a3%e9%87%8a%e4%b8%80%e4%b8%8b%e4%bb%80%e4%b9%88%e6%98%af%e6%b1%a0%e5%8c%96%e8%ae%be%e8%ae%a1%e6%80%9d%e6%83%b3%e4%bb%80%e4%b9%88%e6%98%af%e6%95%b0%e6%8d%ae%e5%ba%93%e8%bf%9e%e6%8e%a5%e6%b1%a0%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e6%95%b0%e6%8d%ae%e5%ba%93%e8%bf%9e%e6%8e%a5%e6%b1%a0" aria-label="解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?">解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?</a></li>
                <li>
                    <a href="#%e5%88%86%e5%ba%93%e5%88%86%e8%a1%a8%e4%b9%8b%e5%90%8eid-%e4%b8%bb%e9%94%ae%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86" aria-label="分库分表之后,id 主键如何处理？">分库分表之后,id 主键如何处理？</a></li>
                <li>
                    <a href="#%e4%b8%80%e6%9d%a1sql%e8%af%ad%e5%8f%a5%e5%9c%a8mysql%e4%b8%ad%e5%a6%82%e4%bd%95%e6%89%a7%e8%a1%8c%e7%9a%84" aria-label="一条SQL语句在MySQL中如何执行的">一条SQL语句在MySQL中如何执行的</a></li>
                <li>
                    <a href="#mysql%e9%ab%98%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e8%a7%84%e8%8c%83%e5%bb%ba%e8%ae%ae" aria-label="MySQL高性能优化规范建议">MySQL高性能优化规范建议</a></li>
                <li>
                    <a href="#%e4%b8%80%e6%9d%a1sql%e8%af%ad%e5%8f%a5%e6%89%a7%e8%a1%8c%e5%be%97%e5%be%88%e6%85%a2%e7%9a%84%e5%8e%9f%e5%9b%a0%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="一条SQL语句执行得很慢的原因有哪些？">一条SQL语句执行得很慢的原因有哪些？</a></li>
                <li>
                    <a href="#%e5%90%8e%e7%ab%af%e7%a8%8b%e5%ba%8f%e5%91%98%e5%bf%85%e5%a4%87%e4%b9%a6%e5%86%99%e9%ab%98%e8%b4%a8%e9%87%8fsql%e7%9a%8430%e6%9d%a1%e5%bb%ba%e8%ae%ae" aria-label="后端程序员必备：书写高质量SQL的30条建议">后端程序员必备：书写高质量SQL的30条建议</a></li></ul>
                </li>
                <li>
                    <a href="#spring" aria-label="Spring">Spring</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-spring-%e6%a1%86%e6%9e%b6" aria-label="什么是 Spring 框架?">什么是 Spring 框架?</a></li>
                <li>
                    <a href="#spring%e5%8c%85%e5%90%ab%e5%93%aa%e4%ba%9b%e6%a8%a1%e5%9d%97" aria-label="Spring包含哪些模块？">Spring包含哪些模块？</a></li>
                <li>
                    <a href="#spring-ioc" aria-label="Spring IOC">Spring IOC</a></li>
                <li>
                    <a href="#aop" aria-label="AOP">AOP</a></li>
                <li>
                    <a href="#spring-%e4%b8%ad%e7%9a%84-bean-%e7%9a%84%e4%bd%9c%e7%94%a8%e5%9f%9f%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="Spring 中的 bean 的作用域有哪些?">Spring 中的 bean 的作用域有哪些?</a></li>
                <li>
                    <a href="#spring-%e4%b8%ad%e7%9a%84%e5%8d%95%e4%be%8b-bean-%e7%9a%84%e7%ba%bf%e7%a8%8b%e5%ae%89%e5%85%a8%e9%97%ae%e9%a2%98%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="Spring 中的单例 bean 的线程安全问题了解吗？">Spring 中的单例 bean 的线程安全问题了解吗？</a></li>
                <li>
                    <a href="#component-%e5%92%8c-bean-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="@Component 和 @Bean 的区别是什么？">@Component 和 @Bean 的区别是什么？</a></li>
                <li>
                    <a href="#%e5%b0%86%e4%b8%80%e4%b8%aa%e7%b1%bb%e5%a3%b0%e6%98%8e%e4%b8%baspring%e7%9a%84-bean-%e7%9a%84%e6%b3%a8%e8%a7%a3%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="将一个类声明为Spring的 bean 的注解有哪些?">将一个类声明为Spring的 bean 的注解有哪些?</a></li>
                <li>
                    <a href="#spring-%e4%b8%ad%e7%9a%84-bean-%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f" aria-label="Spring 中的 bean 生命周期?">Spring 中的 bean 生命周期?</a></li>
                <li>
                    <a href="#%e8%af%b4%e8%af%b4%e8%87%aa%e5%b7%b1%e5%af%b9%e4%ba%8e-spring-mvc-%e4%ba%86%e8%a7%a3" aria-label="说说自己对于 Spring MVC 了解?">说说自己对于 Spring MVC 了解?</a></li>
                <li>
                    <a href="#spring-mvc-%e7%9a%84%e8%bf%90%e8%a1%8c%e6%b5%81%e7%a8%8b%e9%87%8d%e8%a6%81" aria-label="Spring MVC 的运行流程（重要）：">Spring MVC 的运行流程（重要）：</a></li>
                <li>
                    <a href="#spring-%e6%a1%86%e6%9e%b6%e4%b8%ad%e7%94%a8%e5%88%b0%e4%ba%86%e5%93%aa%e4%ba%9b%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f" aria-label="Spring 框架中用到了哪些设计模式？">Spring 框架中用到了哪些设计模式？</a></li>
                <li>
                    <a href="#spring-%e4%ba%8b%e5%8a%a1" aria-label="Spring 事务">Spring 事务</a></li>
                <li>
                    <a href="#spring-%e4%ba%8b%e5%8a%a1%e4%b8%ad%e7%9a%84%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d" aria-label="Spring 事务中的隔离级别有哪几种?">Spring 事务中的隔离级别有哪几种?</a></li>
                <li>
                    <a href="#spring-%e4%ba%8b%e5%8a%a1%e4%bc%a0%e6%92%ad%e8%a1%8c%e4%b8%ba%e6%9c%89%e5%87%a0%e7%a7%8d" aria-label="Spring 事务传播行为有几种?">Spring 事务传播行为有几种?</a></li>
                <li>
                    <a href="#transactionalrollbackfor--exceptionclass%e6%b3%a8%e8%a7%a3%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="@Transactional(rollbackFor = Exception.class)注解了解吗？">@Transactional(rollbackFor = Exception.class)注解了解吗？</a></li></ul>
                </li>
                <li>
                    <a href="#springboot" aria-label="SpringBoot">SpringBoot</a><ul>
                        
                <li>
                    <a href="#springboot%e7%9a%84%e4%bc%98%e7%82%b9" aria-label="SpringBoot的优点">SpringBoot的优点</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%afspring-boot-starter" aria-label="什么是Spring Boot Starter？">什么是Spring Boot Starter？</a></li>
                <li>
                    <a href="#springboot%e7%9a%84%e5%90%af%e5%8a%a8%e6%b5%81%e7%a8%8b" aria-label="SpringBoot的启动流程">SpringBoot的启动流程</a></li></ul>
                </li>
                <li>
                    <a href="#dubbo" aria-label="Dubbo">Dubbo</a><ul>
                        
                <li>
                    <a href="#dubbo%e9%87%8c%e9%9d%a2%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d%e8%8a%82%e7%82%b9%e8%a7%92%e8%89%b2" aria-label="Dubbo里面有哪几种节点角色？">Dubbo里面有哪几种节点角色？</a></li>
                <li>
                    <a href="#%e6%9c%8d%e5%8a%a1%e6%b3%a8%e5%86%8c%e4%b8%8e%e5%8f%91%e7%8e%b0%e7%9a%84%e6%b5%81%e7%a8%8b%e5%9b%be" aria-label="服务注册与发现的流程图">服务注册与发现的流程图</a></li>
                <li>
                    <a href="#dubbo%e9%bb%98%e8%ae%a4%e4%bd%bf%e7%94%a8%e4%bb%80%e4%b9%88%e6%b3%a8%e5%86%8c%e4%b8%ad%e5%bf%83%e8%bf%98%e6%9c%89%e5%88%ab%e7%9a%84%e9%80%89%e6%8b%a9%e5%90%97" aria-label="Dubbo默认使用什么注册中心，还有别的选择吗？">Dubbo默认使用什么注册中心，还有别的选择吗？</a></li>
                <li>
                    <a href="#dubbo-%e6%a0%b8%e5%bf%83%e7%9a%84%e9%85%8d%e7%bd%ae%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="Dubbo 核心的配置有哪些？">Dubbo 核心的配置有哪些？</a></li>
                <li>
                    <a href="#%e5%9c%a8-provider-%e4%b8%8a%e5%8f%af%e4%bb%a5%e9%85%8d%e7%bd%ae%e7%9a%84-consumer-%e7%ab%af%e7%9a%84%e5%b1%9e%e6%80%a7%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="在 Provider 上可以配置的 Consumer 端的属性有哪些？">在 Provider 上可以配置的 Consumer 端的属性有哪些？</a></li>
                <li>
                    <a href="#dubbo%e5%90%af%e5%8a%a8%e6%97%b6%e5%a6%82%e6%9e%9c%e4%be%9d%e8%b5%96%e7%9a%84%e6%9c%8d%e5%8a%a1%e4%b8%8d%e5%8f%af%e7%94%a8%e4%bc%9a%e6%80%8e%e6%a0%b7" aria-label="Dubbo启动时如果依赖的服务不可用会怎样？">Dubbo启动时如果依赖的服务不可用会怎样？</a></li>
                <li>
                    <a href="#dubbo%e6%8e%a8%e8%8d%90%e4%bd%bf%e7%94%a8%e4%bb%80%e4%b9%88%e5%ba%8f%e5%88%97%e5%8c%96%e6%a1%86%e6%9e%b6%e4%bd%a0%e7%9f%a5%e9%81%93%e7%9a%84%e8%bf%98%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="Dubbo推荐使用什么序列化框架，你知道的还有哪些？">Dubbo推荐使用什么序列化框架，你知道的还有哪些？</a></li>
                <li>
                    <a href="#dubbo%e9%bb%98%e8%ae%a4%e4%bd%bf%e7%94%a8%e7%9a%84%e6%98%af%e4%bb%80%e4%b9%88%e9%80%9a%e4%bf%a1%e6%a1%86%e6%9e%b6" aria-label="Dubbo默认使用的是什么通信框架">Dubbo默认使用的是什么通信框架</a></li>
                <li>
                    <a href="#dubbo%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d%e9%9b%86%e7%be%a4%e5%ae%b9%e9%94%99%e6%96%b9%e6%a1%88%e9%bb%98%e8%ae%a4%e6%98%af%e5%93%aa%e7%a7%8d" aria-label="Dubbo有哪几种集群容错方案，默认是哪种？">Dubbo有哪几种集群容错方案，默认是哪种？</a></li>
                <li>
                    <a href="#dubbo%e6%9c%89%e5%93%aa%e5%87%a0%e7%a7%8d%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1%e7%ad%96%e7%95%a5%e9%bb%98%e8%ae%a4%e6%98%af%e5%93%aa%e7%a7%8d" aria-label="Dubbo有哪几种负载均衡策略，默认是哪种？">Dubbo有哪几种负载均衡策略，默认是哪种？</a></li>
                <li>
                    <a href="#%e5%bd%93%e4%b8%80%e4%b8%aa%e6%9c%8d%e5%8a%a1%e6%8e%a5%e5%8f%a3%e6%9c%89%e5%a4%9a%e7%a7%8d%e5%ae%9e%e7%8e%b0%e6%97%b6%e6%80%8e%e4%b9%88%e5%81%9a" aria-label="当一个服务接口有多种实现时怎么做？">当一个服务接口有多种实现时怎么做？</a></li>
                <li>
                    <a href="#%e6%9c%8d%e5%8a%a1%e4%b8%8a%e7%ba%bf%e6%80%8e%e4%b9%88%e5%85%bc%e5%ae%b9%e6%97%a7%e7%89%88%e6%9c%ac" aria-label="服务上线怎么兼容旧版本？">服务上线怎么兼容旧版本？</a></li>
                <li>
                    <a href="#dubbo%e5%8f%af%e4%bb%a5%e5%af%b9%e7%bb%93%e6%9e%9c%e8%bf%9b%e8%a1%8c%e7%bc%93%e5%ad%98%e5%90%97" aria-label="Dubbo可以对结果进行缓存吗？">Dubbo可以对结果进行缓存吗？</a></li>
                <li>
                    <a href="#dubbo%e6%9c%8d%e5%8a%a1%e4%b9%8b%e9%97%b4%e7%9a%84%e8%b0%83%e7%94%a8%e6%98%af%e9%98%bb%e5%a1%9e%e7%9a%84%e5%90%97" aria-label="Dubbo服务之间的调用是阻塞的吗？">Dubbo服务之间的调用是阻塞的吗？</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a4%9a%e7%ba%bf%e7%a8%8b" aria-label="多线程">多线程</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e7%a8%8b%e5%92%8c%e8%bf%9b%e7%a8%8b" aria-label="什么是线程和进程?">什么是线程和进程?</a></li>
                <li>
                    <a href="#%e5%b9%b6%e5%8f%91%e4%b8%8e%e5%b9%b6%e8%a1%8c%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="并发与并行的区别?">并发与并行的区别?</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81" aria-label="线程的状态">线程的状态</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e4%b9%8b%e9%97%b4%e5%a6%82%e4%bd%95%e9%80%9a%e4%bf%a1" aria-label="线程之间如何通信">线程之间如何通信</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%8a%e4%b8%8b%e6%96%87%e5%88%87%e6%8d%a2" aria-label="什么是上下文切换?">什么是上下文切换?</a></li>
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%ba%bf%e7%a8%8b%e6%ad%bb%e9%94%81%e5%a6%82%e4%bd%95%e9%81%bf%e5%85%8d%e6%ad%bb%e9%94%81" aria-label="什么是线程死锁?如何避免死锁?">什么是线程死锁?如何避免死锁?</a></li>
                <li>
                    <a href="#sleep-%e6%96%b9%e6%b3%95%e5%92%8c-wait-%e6%96%b9%e6%b3%95%e5%8c%ba%e5%88%ab" aria-label="sleep() 方法和 wait() 方法区别">sleep() 方法和 wait() 方法区别</a></li>
                <li>
                    <a href="#%e8%b0%83%e7%94%a8-start-%e6%96%b9%e6%b3%95%e6%97%b6%e4%bc%9a%e6%89%a7%e8%a1%8c-run-%e6%96%b9%e6%b3%95%e4%b8%ba%e4%bb%80%e4%b9%88%e6%88%91%e4%bb%ac%e4%b8%8d%e8%83%bd%e7%9b%b4%e6%8e%a5%e8%b0%83%e7%94%a8-run-%e6%96%b9%e6%b3%95" aria-label="调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？">调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？</a></li>
                <li>
                    <a href="#synchronized-%e5%85%b3%e9%94%ae%e5%ad%97" aria-label="synchronized 关键字">synchronized 关键字</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-synchronized-%e5%85%b3%e9%94%ae%e5%ad%97" aria-label="如何使用 synchronized 关键字">如何使用 synchronized 关键字</a></li>
                <li>
                    <a href="#synchronized-%e5%85%b3%e9%94%ae%e5%ad%97%e7%9a%84%e5%ba%95%e5%b1%82%e5%8e%9f%e7%90%86" aria-label="synchronized 关键字的底层原理">synchronized 关键字的底层原理</a></li>
                <li>
                    <a href="#synchronized-%e5%85%b3%e9%94%ae%e5%ad%97%e5%92%8c-volatile-%e5%85%b3%e9%94%ae%e5%ad%97%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="synchronized 关键字和 volatile 关键字的区别">synchronized 关键字和 volatile 关键字的区别</a></li>
                <li>
                    <a href="#threadlocal" aria-label="ThreadLocal">ThreadLocal</a></li>
                <li>
                    <a href="#threadlocal-%e5%86%85%e5%ad%98%e6%b3%84%e9%9c%b2%e9%97%ae%e9%a2%98" aria-label="ThreadLocal 内存泄露问题">ThreadLocal 内存泄露问题</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e4%bd%bf%e7%94%a8%e7%ba%bf%e7%a8%8b%e6%b1%a0" aria-label="为什么要使用线程池？">为什么要使用线程池？</a></li>
                <li>
                    <a href="#%e5%ae%9e%e7%8e%b0-runnable-%e6%8e%a5%e5%8f%a3%e5%92%8c-callable-%e6%8e%a5%e5%8f%a3%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="实现 Runnable 接口和 Callable 接口的区别">实现 Runnable 接口和 Callable 接口的区别</a></li>
                <li>
                    <a href="#%e6%89%a7%e8%a1%8c-execute%e6%96%b9%e6%b3%95%e5%92%8c-submit%e6%96%b9%e6%b3%95%e7%9a%84%e5%8c%ba%e5%88%ab" aria-label="执行 execute()方法和 submit()方法的区别">执行 execute()方法和 submit()方法的区别</a></li>
                <li>
                    <a href="#%e7%ba%bf%e7%a8%8b%e6%b1%a0threadpoolexecutor%e6%9e%84%e9%80%a0%e5%87%bd%e6%95%b0%e9%87%8d%e8%a6%81%e5%8f%82%e6%95%b0" aria-label="线程池ThreadPoolExecutor构造函数重要参数">线程池ThreadPoolExecutor构造函数重要参数</a></li>
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d%e4%b8%80%e4%b8%8b-atomic-%e5%8e%9f%e5%ad%90%e7%b1%bb" aria-label="介绍一下 Atomic 原子类">介绍一下 Atomic 原子类</a></li>
                <li>
                    <a href="#aqs-%e4%ba%86%e8%a7%a3%e4%b9%88" aria-label="AQS 了解么？">AQS 了解么？</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c" aria-label="网络">网络</a><ul>
                        
                <li>
                    <a href="#tcpip-%e7%bd%91%e7%bb%9c%e6%a8%a1%e5%9e%8b%e6%9c%89%e5%87%a0%e5%b1%82%e5%88%86%e5%88%ab%e6%9c%89%e4%bb%80%e4%b9%88%e7%94%a8" aria-label="TCP/IP 网络模型有几层？分别有什么用？">TCP/IP 网络模型有几层？分别有什么用？</a></li>
                <li>
                    <a href="#%e7%ae%80%e5%8d%95%e4%bb%8b%e7%bb%8d-http-%e5%8d%8f%e8%ae%ae" aria-label="简单介绍 HTTP 协议">简单介绍 HTTP 协议</a></li>
                <li>
                    <a href="#get-%e5%92%8c-post%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="GET 和 POST有什么区别？">GET 和 POST有什么区别？</a></li>
                <li>
                    <a href="#ping-%e7%9a%84%e4%bd%9c%e7%94%a8" aria-label="PING 的作用？">PING 的作用？</a></li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e7%9a%84-http-%e7%8a%b6%e6%80%81%e7%a0%81%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="常见的 HTTP 状态码有哪些">常见的 HTTP 状态码有哪些</a></li>
                <li>
                    <a href="#http11-%e5%92%8c-http10-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="HTTP1.1 和 HTTP1.0 的区别有哪些？">HTTP1.1 和 HTTP1.0 的区别有哪些？</a></li>
                <li>
                    <a href="#https-%e5%92%8c-http-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="HTTPS 和 HTTP 的区别是什么？">HTTPS 和 HTTP 的区别是什么？</a></li>
                <li>
                    <a href="#http2-%e5%92%8c-http11-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="HTTP2 和 HTTP1.1 的区别是什么？">HTTP2 和 HTTP1.1 的区别是什么？</a></li>
                <li>
                    <a href="#http3-%e5%92%8c-http2-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="HTTP3 和 HTTP2 的区别是什么？">HTTP3 和 HTTP2 的区别是什么？</a></li>
                <li>
                    <a href="#tcp-%e5%bb%ba%e7%ab%8b%e8%bf%9e%e6%8e%a5%e7%9a%84%e8%bf%87%e7%a8%8b%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84" aria-label="TCP 建立连接的过程是怎样的？">TCP 建立连接的过程是怎样的？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b" aria-label="为什么是三次握手？">为什么是三次握手？</a></li>
                <li>
                    <a href="#tcp-%e6%96%ad%e5%bc%80%e8%bf%9e%e6%8e%a5%e7%9a%84%e8%bf%87%e7%a8%8b%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84" aria-label="TCP 断开连接的过程是怎样的？">TCP 断开连接的过程是怎样的？</a></li>
                <li>
                    <a href="#%e7%ac%ac%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%ad%89%e5%be%852msl60s" aria-label="第四次挥手为什么要等待2MSL(60s)">第四次挥手为什么要等待2MSL(60s)</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b" aria-label="为什么是四次挥手？">为什么是四次挥手？</a></li>
                <li>
                    <a href="#tcp-%e6%bb%91%e5%8a%a8%e7%aa%97%e6%98%af%e4%bb%80%e4%b9%88" aria-label="TCP 滑动窗⼝是什么？">TCP 滑动窗⼝是什么？</a></li>
                <li>
                    <a href="#%e5%8f%91%e9%80%81%e6%96%b9%e4%b8%80%e7%9b%b4%e5%8f%91%e9%80%81%e6%95%b0%e6%8d%ae%e4%bd%86%e6%98%af%e6%8e%a5%e6%94%b6%e6%96%b9%e5%a4%84%e7%90%86%e4%b8%8d%e8%bf%87%e6%9d%a5%e6%80%8e%e4%b9%88%e5%8a%9e%e6%b5%81%e9%87%8f%e6%8e%a7%e5%88%b6" aria-label="发送方一直发送数据，但是接收方处理不过来怎么办？（流量控制）">发送方一直发送数据，但是接收方处理不过来怎么办？（流量控制）</a></li>
                <li>
                    <a href="#tcp-%e5%8d%8a%e8%bf%9e%e6%8e%a5%e9%98%9f%e5%88%97%e5%92%8c%e5%85%a8%e8%bf%9e%e6%8e%a5%e9%98%9f%e5%88%97%e6%98%af%e4%bb%80%e4%b9%88" aria-label="TCP 半连接队列和全连接队列是什么？">TCP 半连接队列和全连接队列是什么？</a></li>
                <li>
                    <a href="#%e7%b2%98%e5%8c%85%e6%8b%86%e5%8c%85%e6%98%af%e6%80%8e%e4%b9%88%e5%8f%91%e7%94%9f%e7%9a%84%e6%80%8e%e4%b9%88%e8%a7%a3%e5%86%b3%e8%bf%99%e4%b8%aa%e9%97%ae%e9%a2%98" aria-label="粘包/拆包是怎么发生的？怎么解决这个问题？">粘包/拆包是怎么发生的？怎么解决这个问题？</a></li>
                <li>
                    <a href="#%e6%b5%8f%e8%a7%88%e5%99%a8%e5%9c%b0%e5%9d%80%e6%a0%8f%e8%be%93%e5%85%a5%e7%bd%91%e7%ab%99%e6%8c%89%e5%9b%9e%e8%bd%a6%e5%90%8e%e5%8f%91%e7%94%9f%e4%ba%86%e4%bb%80%e4%b9%88" aria-label="浏览器地址栏输入网站按回车后发生了什么？">浏览器地址栏输入网站按回车后发生了什么？</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88" aria-label="解决方案">解决方案</a><ul>
                        
                <li>
                    <a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1" aria-label="分布式事务">分布式事务</a><ul>
                        
                <li>
                    <a href="#%e4%b8%a4%e9%98%b6%e6%ae%b5%e6%8f%90%e4%ba%a42pc" aria-label="两阶段提交（2PC）">两阶段提交（2PC）</a></li>
                <li>
                    <a href="#%e8%a1%a5%e5%81%bf%e4%ba%8b%e5%8a%a1tcc" aria-label="补偿事务（TCC）">补偿事务（TCC）</a></li>
                <li>
                    <a href="#%e6%a0%87%e5%87%86%e7%ad%94%e6%a1%88-%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1%e9%97%ae%e9%a2%98%e7%9a%84" aria-label="标准答案: 如何解决分布式事务问题的？">标准答案: 如何解决分布式事务问题的？</a><ul>
                        
                <li>
                    <a href="#%e5%bc%ba%e4%b8%80%e8%87%b4%e6%80%a7%e5%9c%ba%e6%99%af" aria-label="强一致性场景">强一致性场景</a></li>
                <li>
                    <a href="#%e5%bc%b1%e4%b8%80%e8%87%b4%e6%80%a7%e5%9c%ba%e6%99%af" aria-label="弱一致性场景">弱一致性场景</a></li>
                <li>
                    <a href="#%e6%9c%80%e7%bb%88%e4%b8%80%e8%87%b4%e6%80%a7%e5%9c%ba%e6%99%af" aria-label="最终一致性场景">最终一致性场景</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%a7%92%e6%9d%80%e7%b3%bb%e7%bb%9f%e8%ae%be%e8%ae%a1%e5%8c%85%e5%90%ab%e5%a6%82%e4%bd%95%e9%98%b2%e6%ad%a2%e8%b6%85%e5%8d%96" aria-label="秒杀系统设计（包含如何防止超卖）">秒杀系统设计（包含如何防止超卖）</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8e-0-%e5%88%b0-1000" aria-label="从 0 到 1000">从 0 到 1000</a></li>
                <li>
                    <a href="#%e4%bb%8e-1000-%e5%88%b0-100%e4%b8%87" aria-label="从 1000 到 100万">从 1000 到 100万</a><ul>
                        
                <li>
                    <a href="#%e6%82%b2%e8%a7%82%e9%94%81" aria-label="悲观锁">悲观锁</a></li>
                <li>
                    <a href="#%e4%b9%90%e8%a7%82%e9%94%81" aria-label="乐观锁">乐观锁</a></li>
                <li>
                    <a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81" aria-label="分布式锁">分布式锁</a></li>
                <li>
                    <a href="#%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97" aria-label="消息队列">消息队列</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%bb%8e%e7%94%b5%e5%95%86%e7%b3%bb%e7%bb%9f%e5%88%b0%e7%a7%92%e6%9d%80%e7%b3%bb%e7%bb%9f" aria-label="从电商系统到秒杀系统">从电商系统到秒杀系统</a><ul>
                        
                <li>
                    <a href="#%e6%b5%81%e9%87%8f%e9%99%90%e5%88%b6" aria-label="流量限制">流量限制</a><ul>
                        
                <li>
                    <a href="#%e9%99%90%e6%b5%81%e5%99%a8%e5%88%86%e4%b8%ba%e5%89%8d%e7%ab%af%e9%99%90%e6%b5%81%e4%b8%8e%e5%90%8e%e7%ab%af%e9%99%90%e6%b5%81" aria-label="限流器（分为前端限流与后端限流：）">限流器（分为前端限流与后端限流：）</a></li>
                <li>
                    <a href="#%e8%b4%9f%e8%bd%bd%e5%9d%87%e8%a1%a1" aria-label="负载均衡">负载均衡</a></li>
                <li>
                    <a href="#%e5%ae%89%e5%85%a8%e9%aa%8c%e8%af%81%e7%bb%84%e4%bb%b6%e5%88%86%e4%b8%ba%e5%89%8d%e7%ab%af%e5%ae%89%e5%85%a8%e9%aa%8c%e8%af%81%e4%bb%a5%e5%8f%8a%e5%90%8e%e7%ab%af%e5%ae%89%e5%85%a8%e9%aa%8c%e8%af%81" aria-label="安全验证组件（分为前端安全验证以及后端安全验证：）">安全验证组件（分为前端安全验证以及后端安全验证：）</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%83%ad%e9%97%a8%e8%b5%84%e6%ba%90%e9%9a%94%e7%a6%bb" aria-label="热门资源隔离">热门资源隔离</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%9d%a2%e8%af%95%e4%b8%ad%e7%9a%84%e5%9b%9e%e7%ad%94%e6%96%b9%e5%bc%8f" aria-label="面试中的回答方式">面试中的回答方式</a><ul>
                        
                <li>
                    <a href="#%e6%8f%8f%e8%bf%b0%e7%b3%bb%e7%bb%9f%e7%89%b9%e7%82%b9" aria-label="描述系统特点">描述系统特点</a></li>
                <li>
                    <a href="#%e7%90%86%e8%a7%a3%e6%a0%b8%e5%bf%83%e9%97%ae%e9%a2%98" aria-label="理解核心问题">理解核心问题</a></li>
                <li>
                    <a href="#%e6%8f%90%e5%87%ba%e4%b8%bb%e8%a6%81%e6%96%b9%e6%a1%88" aria-label="提出主要方案">提出主要方案</a></li>
                <li>
                    <a href="#%e6%a0%b9%e6%8d%ae%e9%9d%a2%e8%af%95%e5%ae%98%e5%8f%8d%e9%a6%88%e5%9b%9e%e7%ad%94" aria-label="根据面试官反馈回答">根据面试官反馈回答</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e7%bc%93%e5%ad%98%e5%92%8c%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7" aria-label="如何保证缓存和数据库的一致性？">如何保证缓存和数据库的一致性？</a><ul>
                        
                <li>
                    <a href="#%e5%b9%b6%e5%8f%91%e5%bc%95%e5%8f%91%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7%e9%97%ae%e9%a2%98" aria-label="并发引发的一致性问题">并发引发的一致性问题</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e7%bc%93%e5%ad%98%e5%8f%af%e4%bb%a5%e4%bf%9d%e8%af%81%e4%b8%80%e8%87%b4%e6%80%a7%e5%90%97" aria-label="删除缓存可以保证一致性吗？">删除缓存可以保证一致性吗？</a><ul>
                        
                <li>
                    <a href="#%e5%85%88%e5%88%a0%e7%bc%93%e5%ad%98%e5%90%8e%e6%9b%b4%e6%96%b0%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="先删缓存，后更新数据库">先删缓存，后更新数据库</a></li>
                <li>
                    <a href="#%e5%85%88%e6%9b%b4%e6%96%b0%e6%95%b0%e6%8d%ae%e5%ba%93%e5%90%8e%e5%88%a0%e7%bc%93%e5%ad%98" aria-label="先更新数据库，后删缓存">先更新数据库，后删缓存</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%80%9a%e8%bf%87mq%e4%bf%9d%e8%af%81%e4%b8%a4%e6%ad%a5%e6%93%8d%e4%bd%9c%e9%83%bd%e6%89%a7%e8%a1%8c%e6%88%90%e5%8a%9f" aria-label="通过MQ保证两步操作都执行成功">通过MQ保证两步操作都执行成功</a></li>
                <li>
                    <a href="#%e9%80%9a%e8%bf%87mysql-binlog" aria-label="通过MYSQL binlog">通过MYSQL binlog</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%8f%8d%e9%97%ae%e9%9d%a2%e8%af%95%e5%ae%98" aria-label="反问面试官">反问面试官</a><ul>
                        
                <li>
                    <a href="#%e8%81%8c%e8%b4%a3" aria-label="职责">职责</a></li>
                <li>
                    <a href="#%e6%8a%80%e6%9c%af" aria-label="技术">技术</a></li>
                <li>
                    <a href="#%e5%85%ac%e5%8f%b8" aria-label="公司">公司</a></li>
                <li>
                    <a href="#%e5%be%85%e9%81%87" aria-label="待遇">待遇</a></li>
                <li>
                    <a href="#%e4%bc%91%e5%81%87" aria-label="休假">休假</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><p><a href="https://snailclimb.gitee.io/javaguide-interview/#/">整体参考</a>
<a href="https://blog.csdn.net/HarderXin/article/details/103971493">参考2</a></p>
<h1 id="java基础">java基础<a hidden class="anchor" aria-hidden="true" href="#java基础">#</a></h1>
<h2 id="java如何进行高效的数组拷贝">Java如何进行高效的数组拷贝？<a hidden class="anchor" aria-hidden="true" href="#java如何进行高效的数组拷贝">#</a></h2>
<p><code>Arrays.copyOf 或 System.arraycopy</code>
这是两个native方法，效率比自己new数组，然后for循环复制快得多。</p>
<h2 id="float-f--34-能否通过编译">float f = 3.4; 能否通过编译？<a hidden class="anchor" aria-hidden="true" href="#float-f--34-能否通过编译">#</a></h2>
<p>不正确。3.4是双精度数，将双精度型（double）赋值给浮点型（float）属于下转型会损失精度，因此需要强制类型转换，<code>float f = (float)3.4 或 float f = 3.4F</code></p>
<h2 id="两数交换">两数交换<a hidden class="anchor" aria-hidden="true" href="#两数交换">#</a></h2>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">// 1、第三变量</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> swapOne(){
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> a = 4;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> b = 5;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> c = a;
</span></span><span style="display:flex;"><span>    a = b;
</span></span><span style="display:flex;"><span>    b = c;
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;a:&#34;</span>+a); <span style="color:#007f7f">//a:5</span>
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;b:&#34;</span>+b); <span style="color:#007f7f">//a:4</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 2、数学计算</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> swapTwo(){
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> a = 4;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> b = 5;
</span></span><span style="display:flex;"><span>    a=a+b;
</span></span><span style="display:flex;"><span>    b=a-b;
</span></span><span style="display:flex;"><span>    a=a-b;
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;a:&#34;</span>+a); <span style="color:#007f7f">//a:5</span>
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;b:&#34;</span>+b); <span style="color:#007f7f">//a:4</span>
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 3、异或运算</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> swapThree(){
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> a = 4;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> b = 5;
</span></span><span style="display:flex;"><span>    a = a ^ b; <span style="color:#007f7f">// 0101 ^ 0100 ===&gt; 0001，此时a的值为1</span>
</span></span><span style="display:flex;"><span>    b = a ^ b; <span style="color:#007f7f">// 0001 ^ 0100 ===&gt; 0101，此时b的值为5</span>
</span></span><span style="display:flex;"><span>    a = a ^ b; <span style="color:#007f7f">// 0001 ^ 0101 ===&gt; 0100，此时a的值为4</span>
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;a:&#34;</span>+a); <span style="color:#007f7f">//a:5</span>
</span></span><span style="display:flex;"><span>    System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(<span style="color:#0ff;font-weight:bold">&#34;b:&#34;</span>+b); <span style="color:#007f7f">//a:4</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="为什么finally里的代码一定会执行">为什么finally里的代码一定会执行？<a hidden class="anchor" aria-hidden="true" href="#为什么finally里的代码一定会执行">#</a></h2>
<p>编译器在编译的时候，会把finally里面的代码复制多份，分别放在try和catch内所有能够正常执行以及异常执行逻辑的出口处，最直观的就是我们可以在字节码文件里看到很多份finally内部代码。</p>
<h2 id="int和integer有什么区别">int和Integer有什么区别？<a hidden class="anchor" aria-hidden="true" href="#int和integer有什么区别">#</a></h2>
<p>为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型。从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Integer a = <span style="color:#fff;font-weight:bold">new</span> Integer(3);
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 将3自动装箱成Integer类型</span>
</span></span><span style="display:flex;"><span>Integer b = 3;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> c = 3;
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// false 两个引用没有引用同一对象</span>
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a == b);
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// true a自动拆箱成int类型再和c比较</span>
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a == c);
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="和的区别">&amp;和&amp;&amp;的区别？<a hidden class="anchor" aria-hidden="true" href="#和的区别">#</a></h2>
<p>&amp;运算符有两种用法：(1)按位与；(2)逻辑与。
&amp;&amp;运算符是短路与运算。
&amp;&amp;左边的表达式的值是false，右边的表达式会被直接短路掉，不会进行运算。</p>
<h2 id="构造器constructor是否可被重写override">构造器（constructor）是否可被重写（override）？<a hidden class="anchor" aria-hidden="true" href="#构造器constructor是否可被重写override">#</a></h2>
<p>答：构造器不能被继承，因此不能被重写，但可以被重载。</p>
<h2 id="两个对象值相同xequalsy--true但却可有不同的hash-code这句话对不对">两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？<a hidden class="anchor" aria-hidden="true" href="#两个对象值相同xequalsy--true但却可有不同的hash-code这句话对不对">#</a></h2>
<p>不对，如果两个对象x和y满足<code>x.equals(y) == true</code>，它们的哈希码（hash code）应当相同。</p>
<ul>
<li>如果两个对象相同（equals方法返回true），那么它们的hashCode值一定要相同；</li>
<li>如果两个对象的hashCode相同，它们并不一定相同。</li>
</ul>
<h2 id="char-型变量中能不能存贮一个中文汉字为什么">char 型变量中能不能存贮一个中文汉字，为什么？<a hidden class="anchor" aria-hidden="true" href="#char-型变量中能不能存贮一个中文汉字为什么">#</a></h2>
<p>可以，因为Java中使用的编码是Unicode一个char类型占2个字节（16比特），所以放一个中文是没问题的。</p>
<h2 id="string-s--hello-world">string s = &ldquo;hello world&rdquo;;<a hidden class="anchor" aria-hidden="true" href="#string-s--hello-world">#</a></h2>
<ol>
<li><code>s += 'a';</code></li>
<li><code>int len = s.length;</code></li>
<li><code>s = 100;</code></li>
<li><code>s = s+100</code></li>
</ol>
<p>3错。</p>
<h2 id="用多线程计算出1-10000之间的素数">用多线程计算出1-10000之间的素数<a hidden class="anchor" aria-hidden="true" href="#用多线程计算出1-10000之间的素数">#</a></h2>
<h2 id="不用uuid生成订单号">不用uuid生成订单号<a hidden class="anchor" aria-hidden="true" href="#不用uuid生成订单号">#</a></h2>
<h2 id="求1-100之间所有质数和">求1-100之间所有质数和<a hidden class="anchor" aria-hidden="true" href="#求1-100之间所有质数和">#</a></h2>
<p>注：质数是只能被1和它本身整除的数
1不是质数</p>
<h2 id="什么是java虚拟机为什么java被称作是平台无关的编程语言">什么是Java虚拟机？为什么Java被称作是“平台无关的编程语言？<a hidden class="anchor" aria-hidden="true" href="#什么是java虚拟机为什么java被称作是平台无关的编程语言">#</a></h2>
<p>Java虚拟机是一个可以执行Java字节码的虚拟机进程。Java源文件被编译成能被Java虚拟机执行的字节码文件。Java被设计成允许应用程序可以运行在任意的平台，而不需要程序员为每一个平台单独重写或者是重新编译。Java虚拟机让这个变为可能，因为它知道底层硬件平台的指令长度和其他特性。</p>
<h2 id="jdk和jre的区别是什么">JDK和JRE的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#jdk和jre的区别是什么">#</a></h2>
<p>JRE：Java运行时环境(JRE)是将要执行Java程序的Java虚拟机。它同时也包含了执行applet需要的浏览器插件。
JDK：Java开发工具包(JDK)是完整的Java软件开发包，包含了JRE，编译器和其他的工具(比如：JavaDoc，Java调试器)，可以让开发者开发、编译、执行Java应用程序。</p>
<h2 id="是否可以在static环境中访问非static变量不可以">是否可以在static环境中访问非static变量？(不可以)<a hidden class="anchor" aria-hidden="true" href="#是否可以在static环境中访问非static变量不可以">#</a></h2>
<p>static变量在Java中是属于类的，它在所有的实例中的值是一样的。当类被Java虚拟机载入的时候，会对static变量进行初始化。如果你的代码尝试不用实例来访问非static的变量，编译器会报错，因为这些变量还没有被创建出来，还没有跟任何实例关联上。</p>
<h2 id="java支持的数据类型有哪些什么是自动拆装箱">Java支持的数据类型有哪些？什么是自动拆装箱？<a hidden class="anchor" aria-hidden="true" href="#java支持的数据类型有哪些什么是自动拆装箱">#</a></h2>
<p>Java语言支持的8中基本数据类型是：
byte、short、int、long、float、double、boolean、char
自动装箱是Java编译器在基本数据类型和对应的对象包装类型之间做的一个转化。
<code>Integer a = 1;</code>
这就是一个自动装箱，如果没有自动装箱的话，需要这样
<code>Integer  a=new Integer(1);</code></p>
<p><code>int b = a;</code>
这就是一个自动拆箱，如果没有自动拆箱的话，需要这样：
<code>int b = a.intValue();</code>
自动装箱和自动拆箱是简化了基本数据类型和相对应对象的转化步骤。</p>
<h2 id="什么是值传递和引用传递">什么是值传递和引用传递？<a hidden class="anchor" aria-hidden="true" href="#什么是值传递和引用传递">#</a></h2>
<p>对象被值传递，意味着传递了对象的一个副本。因此，就算是改变了对象副本，也不会影响源对象的值。
对象被引用传递，意味着传递的并不是实际的对象，而是对象的引用。因此，外部对引用对象所做的改变会反映到所有的对象上。</p>
<h2 id="进程和线程的区别是什么">进程和线程的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#进程和线程的区别是什么">#</a></h2>
<p>进程是执行着的应用程序，而线程是进程内部的一个执行序列。
一个进程可以有多个线程。</p>
<h2 id="什么是死锁deadlock">什么是死锁(deadlock)？<a hidden class="anchor" aria-hidden="true" href="#什么是死锁deadlock">#</a></h2>
<p>两个进程都在等待对方执行完毕才能继续往下执行的时候就发生了死锁。结果就是两个进程都陷入了无限的等待中。</p>
<h2 id="如何确保n个线程可以访问n个资源同时又不导致死锁">如何确保N个线程可以访问N个资源同时又不导致死锁？<a hidden class="anchor" aria-hidden="true" href="#如何确保n个线程可以访问n个资源同时又不导致死锁">#</a></h2>
<p>使用多线程的时候，一种非常简单的避免死锁的方式就是：指定获取锁的顺序，并强制线程按照指定的顺序获取锁。因此，如果所有的线程都是以同样的顺序加锁和释放锁，就不会出现死锁了。</p>
<h2 id="什么是迭代器iterator">什么是迭代器(Iterator)？<a hidden class="anchor" aria-hidden="true" href="#什么是迭代器iterator">#</a></h2>
<p>Iterator接口提供了很多对集合元素进行迭代的方法。每一个集合类都包含了可以返回迭代器实例的迭代方法。迭代器可以在迭代的过程中删除底层集合的元素。</p>
<h2 id="iterator和listiterator的区别是什么">Iterator和ListIterator的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#iterator和listiterator的区别是什么">#</a></h2>
<p>Iterator可用来遍历Set和List集合，但是ListIterator只能用来遍历List。
Iterator对集合只能是前向遍历，ListIterator既可以前向也可以后向。
ListIterator实现了Iterator接口，并包含其他的功能，比如：增加元素，替换元素，获取前一个和后一个元素的索引，等等。</p>
<h2 id="java中的hashmap的工作原理是什么">Java中的HashMap的工作原理是什么？<a hidden class="anchor" aria-hidden="true" href="#java中的hashmap的工作原理是什么">#</a></h2>
<p>Java中的HashMap是以键值对(key-value)的形式存储元素的。
HashMap需要一个hash函数，它使用<code>hashCode()</code>和<code>equals()</code>方法来向集合/从集合添加和检索元素。当调用put()方法的时候，HashMap会计算key的hash值，然后把键值对存储在集合中合适的索引上。如果key已经存在了，value会被更新成新值。HashMap的一些重要的特性是它的容量(capacity)，负载因子(load factor)和扩容极限(threshold resizing)。</p>
<h2 id="遍历map">遍历Map<a hidden class="anchor" aria-hidden="true" href="#遍历map">#</a></h2>
<ul>
<li><code>entrySet().iterator()</code>效率高，建议使用。</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Map map = <span style="color:#fff;font-weight:bold">new</span> HashMap();
</span></span><span style="display:flex;"><span>Iterator iter = map.<span style="color:#007f7f">entrySet</span>().<span style="color:#007f7f">iterator</span>();
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">while</span> (iter.<span style="color:#007f7f">hasNext</span>()) {
</span></span><span style="display:flex;"><span>    Map.<span style="color:#007f7f">Entry</span> entry = (Map.<span style="color:#007f7f">Entry</span>) iter.<span style="color:#007f7f">next</span>();
</span></span><span style="display:flex;"><span>    Object key = entry.<span style="color:#007f7f">getKey</span>();
</span></span><span style="display:flex;"><span>    Object val = entry.<span style="color:#007f7f">getValue</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>keySet().iterator()</code>效率低，不要使用。原因：keySet其实是遍历了2次，一次是转为iterator，一次就从hashmap中取出key所对于的value。</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Map map = <span style="color:#fff;font-weight:bold">new</span> HashMap();
</span></span><span style="display:flex;"><span>Iterator iter = map.<span style="color:#007f7f">keySet</span>().<span style="color:#007f7f">iterator</span>();
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">while</span> (iter.<span style="color:#007f7f">hasNext</span>()) {
</span></span><span style="display:flex;"><span>    Object key = iter.<span style="color:#007f7f">next</span>();
</span></span><span style="display:flex;"><span>    Object val = map.<span style="color:#007f7f">get</span>(key);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>foreach 遍历 map.entrySet() 效率高，建议使用。</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">for</span>(Map.<span style="color:#007f7f">Entry</span>&lt;String, String&gt; entry: map.<span style="color:#007f7f">entrySet</span>()){
</span></span><span style="display:flex;"><span>    Object key = entry.<span style="color:#007f7f">getKey</span>();
</span></span><span style="display:flex;"><span>    Object val = entry.<span style="color:#007f7f">getValue</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>foreach 遍历 map.keySet() 效率低，不要使用。</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">for</span>(Map.<span style="color:#007f7f">Entry</span>&lt;String, String&gt; entry: map.<span style="color:#007f7f">entrySet</span>()){
</span></span><span style="display:flex;"><span>    Object key = entry.<span style="color:#007f7f">getKey</span>();
</span></span><span style="display:flex;"><span>    Object val = entry.<span style="color:#007f7f">getValue</span>();
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="数组array和列表arraylist有什么区别什么时候应该使用array而不是arraylist">数组(Array)和列表(ArrayList)有什么区别？什么时候应该使用Array而不是ArrayList？<a hidden class="anchor" aria-hidden="true" href="#数组array和列表arraylist有什么区别什么时候应该使用array而不是arraylist">#</a></h2>
<p>Array可以包含基本类型和对象类型，ArrayList只能包含对象类型。
Array大小是固定的，ArrayList的大小是动态变化的。</p>
<h2 id="九种基本数据类型的大小以及他们的封装类一个字节是8位">九种基本数据类型的大小，以及他们的封装类(一个字节是8位)<a hidden class="anchor" aria-hidden="true" href="#九种基本数据类型的大小以及他们的封装类一个字节是8位">#</a></h2>
<table>
<thead>
<tr>
<th>基本类型</th>
<th>大小(字节)</th>
<th>默认值</th>
<th>封装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>1</td>
<td>(byte)0</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>2</td>
<td>(short)0</td>
<td>Short</td>
</tr>
<tr>
<td>int</td>
<td>4</td>
<td>0</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>8</td>
<td>0L</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>4</td>
<td>0.0f</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>0.0d</td>
<td>Double</td>
</tr>
<tr>
<td>boolean</td>
<td>-</td>
<td>false</td>
<td>Boolean</td>
</tr>
<tr>
<td>char</td>
<td>2</td>
<td>\u0000(null)</td>
<td>Character</td>
</tr>
<tr>
<td>void</td>
<td>-</td>
<td>-</td>
<td>Void</td>
</tr>
</tbody>
</table>
<h2 id="equalshashcode--区别">equals、==、hashcode  区别<a hidden class="anchor" aria-hidden="true" href="#equalshashcode--区别">#</a></h2>
<ul>
<li>
<p>基本数据类型
byte/int/double/boolean等，用==，比较的是值。</p>
</li>
<li>
<p>引用类型(就是对象)
用==比较的是内存地址，同一个new出来的对象，为true，反之为false。
对象是存放在堆中的，栈中存放的是对象的引用(地址)，由此可见==比较的是栈中的值。
如果要比较堆中的对象是否相同，要重写equals方法。</p>
</li>
</ul>
<p>equals：比较对象的内容（就是最表面的值）</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>String a = <span style="color:#0ff;font-weight:bold">&#34;1&#34;</span>;
</span></span><span style="display:flex;"><span>String b = <span style="color:#0ff;font-weight:bold">&#34;1&#34;</span>;
</span></span><span style="display:flex;"><span>String c = <span style="color:#fff;font-weight:bold">new</span> String(<span style="color:#0ff;font-weight:bold">&#34;1&#34;</span>);
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a==b); <span style="color:#007f7f">//true,是一块内存地址</span>
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a==c); <span style="color:#007f7f">//false,不是一块内存地址</span>
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a.<span style="color:#007f7f">equals</span>(b)); <span style="color:#007f7f">//true,比较的是值</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="java的四种引用强弱软虚用到的场景">Java的四种引用，强弱软虚，用到的场景<a hidden class="anchor" aria-hidden="true" href="#java的四种引用强弱软虚用到的场景">#</a></h2>
<ul>
<li>
<p>强引用：如果一个对象具有强引用，那垃圾回收器绝不会回收它。
<code>Object obj = new Object();   //  强引用</code></p>
</li>
<li>
<p>软引用：内存够，不会被回收，反之会被回收。
引用可用来实现内存敏感的高速缓存。</p>
</li>
<li>
<p>弱引用：垃圾回收器一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p>
</li>
<li>
<p>虚引用：任何时候都可能被垃圾回收器回收。</p>
</li>
</ul>
<h2 id="hashcode的作用">Hashcode的作用<a hidden class="anchor" aria-hidden="true" href="#hashcode的作用">#</a></h2>
<p>根据对象的内存地址进行相关计算，得到的int类型数值，就是hashCode。
可以用来用来鉴定2个对象是否相等。</p>
<h2 id="stringstringbuffer与stringbuilder的区别">String、StringBuffer与StringBuilder的区别。<a hidden class="anchor" aria-hidden="true" href="#stringstringbuffer与stringbuilder的区别">#</a></h2>
<p>string：字符串常量，不可改变的对象
StringBuffer：字符串变量，可变对象，线程安全，效率低
StringBuilder：字符串变量，可变对象，线程不安全，效率高</p>
<h2 id="以下程序的运行结果是什么">以下程序的运行结果是什么<a hidden class="anchor" aria-hidden="true" href="#以下程序的运行结果是什么">#</a></h2>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>Long a = 1L;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">int</span> b = 1;
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(a == b); <span style="color:#007f7f">//true</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Map&lt;String,Object&gt; map = <span style="color:#fff;font-weight:bold">new</span> HashMap&lt;&gt;();
</span></span><span style="display:flex;"><span>map.<span style="color:#007f7f">put</span>(<span style="color:#0ff;font-weight:bold">&#34;a&#34;</span>,a);
</span></span><span style="display:flex;"><span>map.<span style="color:#007f7f">put</span>(<span style="color:#0ff;font-weight:bold">&#34;b&#34;</span>,b);
</span></span><span style="display:flex;"><span>System.<span style="color:#007f7f">out</span>.<span style="color:#007f7f">println</span>(map.<span style="color:#007f7f">get</span>(<span style="color:#0ff;font-weight:bold">&#34;a&#34;</span>) == map.<span style="color:#007f7f">get</span>(<span style="color:#0ff;font-weight:bold">&#34;b&#34;</span>));<span style="color:#007f7f">//false</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="集合collection">集合Collection<a hidden class="anchor" aria-hidden="true" href="#集合collection">#</a></h1>
<p><a href="https://joonwhee.blog.csdn.net/article/details/115712641">本部分参考</a></p>
<h2 id="说说listsetmap三者的区别">说说List,Set,Map三者的区别？<a hidden class="anchor" aria-hidden="true" href="#说说listsetmap三者的区别">#</a></h2>
<p>List(对付顺序的好帮手)： 存储的元素是有序的、可重复的。
Set(注重独一无二的性质): 存储的元素是无序的、不可重复的。
Map(用 Key 来搜索的专家): 使用键值对（kye-value）存储，Key 是无序的、不可重复的，value 是无序的、可重复的，每个键最多映射到一个值。</p>
<h2 id="arraylist-与-linkedlist-区别">Arraylist 与 LinkedList 区别?<a hidden class="anchor" aria-hidden="true" href="#arraylist-与-linkedlist-区别">#</a></h2>
<ul>
<li>ArrayList 底层基于动态数组实现，LinkedList 底层基于双向链表实现。</li>
<li>对于随机访问（按 index 访问，get/set方法）：ArrayList 通过 index 直接定位到数组对应位置的节点，而 LinkedList需要从头结点或尾节点开始遍历，直到寻找到目标节点，因此在效率上 ArrayList 优于 LinkedList。</li>
<li>对于随机插入和删除：ArrayList 需要移动目标节点后面的节点（使用System.arraycopy 方法移动节点），而 LinkedList 只需修改目标节点前后节点的 next 或 prev 属性即可，因此在效率上 LinkedList 优于 ArrayList。</li>
<li>对于顺序插入和删除：由于 ArrayList 不需要移动节点，因此在效率上比 LinkedList 更好。这也是为什么在实际使用中 ArrayList 更多，因为大部分情况下我们的使用都是顺序插入。</li>
<li>两者都不是线程安全的。</li>
<li>内存空间占用： ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>
<h2 id="arraylist-和-vector-的区别">ArrayList 和 Vector 的区别。<a hidden class="anchor" aria-hidden="true" href="#arraylist-和-vector-的区别">#</a></h2>
<p>Vector 和 ArrayList 的实现几乎是一样的，区别在于：
Vector 在方法上使用了 synchronized 来保证线程安全，同时由于这个原因，在性能上 ArrayList 会有更好的表现。</p>
<h2 id="hashset-是如何保证不重复的">HashSet 是如何保证不重复的？<a hidden class="anchor" aria-hidden="true" href="#hashset-是如何保证不重复的">#</a></h2>
<p>HashSet 底层使用 HashMap 来实现，见下面的源码，元素放在 HashMap 的 key 里，value 为固定的 Object 对象。当 add 时调用 HashMap 的 put 方法，如果元素不存在，则返回 null 表示 add 成功，否则 add 失败。
由于 HashMap 的 Key 值本身就不允许重复，HashSet 正好利用 HashMap 中 key 不重复的特性来校验重复元素，简直太妙了。</p>
<h2 id="map">Map<a hidden class="anchor" aria-hidden="true" href="#map">#</a></h2>
<h3 id="hashmap-有哪些重要属性分别用于做什么的">HashMap 有哪些重要属性？分别用于做什么的？<a hidden class="anchor" aria-hidden="true" href="#hashmap-有哪些重要属性分别用于做什么的">#</a></h3>
<p>除了用来存储我们的节点 table 数组外，HashMap 还有以下几个重要属性：</p>
<ul>
<li>size：HashMap 已经存储的节点个数。</li>
<li>loadFactor：负载因子，扩容阈值 = 容量 * 负载因子。</li>
<li>threshold：扩容阈值，当 HashMap 的元素个数达到该值，触发扩容。</li>
</ul>
<h3 id="hashmap-的默认初始容量是多少hashmap-的容量有什么限制吗">HashMap 的默认初始容量是多少？HashMap 的容量有什么限制吗？<a hidden class="anchor" aria-hidden="true" href="#hashmap-的默认初始容量是多少hashmap-的容量有什么限制吗">#</a></h3>
<p>默认初始容量是16。HashMap 的容量必须是2的N次方，HashMap 会根据我们传入的容量计算一个“大于等于该容量的最小的 2 的 N 次方”，例如传 16，容量为16；传17，容量为32。
“大于等于该容量的最小的2的N次方”是怎么算的？</p>
<h3 id="hashmap-的容量必须是-2-的-n-次方这是为什么">HashMap 的容量必须是 2 的 N 次方，这是为什么？<a hidden class="anchor" aria-hidden="true" href="#hashmap-的容量必须是-2-的-n-次方这是为什么">#</a></h3>
<p>核心目的是：实现节点均匀分布，减少 hash 冲突。</p>
<h3 id="hashmap-是线程安全的吗">HashMap 是线程安全的吗？<a hidden class="anchor" aria-hidden="true" href="#hashmap-是线程安全的吗">#</a></h3>
<p>不是。HashMap 在并发下存在数据覆盖、遍历的同时进行修改会抛出 <code>ConcurrentModificationException</code>异常等问题，JDK1.8之前还存在死循环问题。</p>
<h3 id="介绍一下死循环问题">介绍一下死循环问题？<a hidden class="anchor" aria-hidden="true" href="#介绍一下死循环问题">#</a></h3>
<p>导致死循环的根本原因是 JDK 1.7 扩容采用的是“头插法”，会导致同一索引位置的节点在扩容后顺序反掉，在并发插入触发扩容时形成环，从而产生死循环。而 JDK 1.8 之后采用的是“尾插法”，扩容后节点顺序不会反掉，不存在死循环问题。</p>
<h3 id="总结下-jdk-18-hashmap主要进行了哪些优化">总结下 JDK 1.8 HashMap主要进行了哪些优化？<a hidden class="anchor" aria-hidden="true" href="#总结下-jdk-18-hashmap主要进行了哪些优化">#</a></h3>
<ul>
<li>底层数据结构从“数组+链表”改成“数组+链表+红黑树”，主要是优化了 hash 冲突较严重时，链表过长的查找性能：O(n) -&gt; O(logn)。</li>
<li>计算 table 初始容量的方式发生了改变，老的方式是从1开始不断向左进行移位运算，直到找到大于等于入参容量的值；新的方式则是通过“5个移位+或等于运算”来计算。</li>
<li>优化了 hash 值的计算方式，老的通过一顿瞎JB操作，新的只是简单的让高16位参与了运算。</li>
<li>扩容时插入方式从“头插法”改成“尾插法”，避免了并发下的死循环。</li>
<li>扩容时计算节点在新表的索引位置方式从“h &amp; (length-1)”改成“hash &amp; oldCap”，性能可能提升不大，但设计更巧妙、更优雅。</li>
</ul>
<h3 id="hashmap-的底层数据结构">HashMap 的底层数据结构<a hidden class="anchor" aria-hidden="true" href="#hashmap-的底层数据结构">#</a></h3>
<p>在 JDK 1.8，HashMap 底层是由 “数组+链表+红黑树” 组成，如下图所示，而在 JDK 1.8 之前是由 “数组+链表” 组成。</p>
<h3 id="为什么使用数组链表">为什么使用“数组+链表”？<a hidden class="anchor" aria-hidden="true" href="#为什么使用数组链表">#</a></h3>
<p>使用 “数组+链表” 是为了解决 hash 冲突的问题。
数组和链表有如下特点：
数组：查找容易，通过 index 快速定位；插入和删除困难，需要移动插入和删除位置之后的节点；
链表：查找困难，需要从头结点或尾节点开始遍历，直到寻找到目标节点；插入和删除容易，只需修改目标节点前后节点的 next 或 prev 属性即可；
HashMap 巧妙的将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做 “拉链法” 的方式来解决哈希冲突。</p>
<p>首先通过 index 快速定位到索引位置，利用了数组的优点；然后遍历链表找到节点，进行节点的新增/修改/删除操作，利用了链表的优点。</p>
<h3 id="为什么要改成数组链表红黑树">为什么要改成“数组+链表+红黑树”？<a hidden class="anchor" aria-hidden="true" href="#为什么要改成数组链表红黑树">#</a></h3>
<p>通过上题可以看出，“数组+链表” 已经充分发挥了这两种数据结构的优点，是个很不错的组合了。
但是这种组合仍然存在问题，就是在定位到索引位置后，需要先遍历链表找到节点，这个地方如果链表很长的话，也就是 hash 冲突很严重的时候，会有查找性能问题，因此在 JDK1.8中，通过引入红黑树，来优化这个问题。
使用链表的查找性能是 O(n)，而使用红黑树是 O(logn)。</p>
<h3 id="那在什么时候用链表什么时候用红黑树">那在什么时候用链表？什么时候用红黑树？<a hidden class="anchor" aria-hidden="true" href="#那在什么时候用链表什么时候用红黑树">#</a></h3>
<p>对于插入，默认情况下是使用链表节点。当同一个索引位置的节点在新增后超过8个（阈值8）：如果此时数组长度大于等于 64，则会触发链表节点转红黑树节点（treeifyBin）；而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容，因为此时的数据量还比较小。</p>
<p>对于移除，当同一个索引位置的节点在移除后达到 6 个（阈值6），并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点（untreeify）。</p>
<h3 id="为什么链表转红黑树的阈值是8">为什么链表转红黑树的阈值是8？<a hidden class="anchor" aria-hidden="true" href="#为什么链表转红黑树的阈值是8">#</a></h3>
<p>我们平时在进行方案设计时，必须考虑的两个很重要的因素是：时间和空间。对于 HashMap 也是同样的道理，简单来说，阈值为8是在时间和空间上权衡的结果。</p>
<p>红黑树节点大小约为链表节点的2倍，在节点太少时，红黑树的查找性能优势并不明显，付出2倍空间的代价作者觉得不值得。</p>
<p>理想情况下，使用随机的哈希码，节点分布在 hash 桶中的频率遵循泊松分布，按照泊松分布的公式计算，链表中节点个数为8时的概率为 0.00000006，这个概率足够低了，并且到8个节点时，红黑树的性能优势也会开始展现出来，因此8是一个较合理的数字。</p>
<h3 id="那为什么转回链表节点是用的6而不是复用8">那为什么转回链表节点是用的6而不是复用8？<a hidden class="anchor" aria-hidden="true" href="#那为什么转回链表节点是用的6而不是复用8">#</a></h3>
<p>如果我们设置节点多于8个转红黑树，少于8个就马上转链表，当节点个数在8徘徊时，就会频繁进行红黑树和链表的转换，造成性能的损耗。</p>
<h3 id="简述concurrenthashmap实现原理它是如何保证线程安全的">简述ConcurrentHashMap实现原理，它是如何保证线程安全的。<a hidden class="anchor" aria-hidden="true" href="#简述concurrenthashmap实现原理它是如何保证线程安全的">#</a></h3>
<p>ConcurrentHashMap 是 HashMap 的线程安全版本，和 HashMap 一样，在JDK 1.8 中进行了较大的优化。
JDK1.7：底层结构为：分段的数组+链表；实现线程安全的方式：分段锁（Segment，继承了ReentrantLock）
JDK1.8：底层结构为：数组+链表+红黑树；实现线程安全的方式：CAS + Synchronized</p>
<p>区别：</p>
<ul>
<li>JDK1.8 中降低锁的粒度。JDK1.7 版本锁的粒度是基于 Segment 的，包含多个节点（HashEntry），而 JDK1.8 锁的粒度就是单节点（Node）。</li>
<li>JDK1.8 版本的数据结构变得更加简单，使得操作也更加清晰流畅，因为已经使用 synchronized 来进行同步，所以不需要分段锁的概念，也就不需要 Segment 这种数据结构了，当前还保留仅为了兼容。</li>
<li>JDK1.8 使用红黑树来优化链表，跟 HashMap 一样，优化了极端情况下，链表过长带来的性能问题。</li>
<li>JDK1.8 使用内置锁 synchronized 来代替重入锁 ReentrantLock，synchronized 是官方一直在不断优化的，现在性能已经比较可观，也是官方推荐使用的加锁方式。</li>
</ul>
<h1 id="linux">Linux<a hidden class="anchor" aria-hidden="true" href="#linux">#</a></h1>
<h1 id="rocketmq">RocketMQ<a hidden class="anchor" aria-hidden="true" href="#rocketmq">#</a></h1>
<h2 id="rocketmq由哪些角色组成每个角色作用和特点是什么">RocketMQ由哪些角色组成，每个角色作用和特点是什么？<a hidden class="anchor" aria-hidden="true" href="#rocketmq由哪些角色组成每个角色作用和特点是什么">#</a></h2>
<p>Broker：就是MQ本身，负责收发消息、持久化消息等。
Nameserver：无状态，动态列表；这也是和zookeeper的重要区别之一。zookeeper是有状态的。
Producer：消息生产者，负责发消息到Broker。
Consumer：消息消费者，负责从Broker上拉取消息进行消费，消费完进行ack。</p>
<h2 id="rocketmq-broker中的消息被消费后会立即删除吗">RocketMQ Broker中的消息被消费后会立即删除吗？<a hidden class="anchor" aria-hidden="true" href="#rocketmq-broker中的消息被消费后会立即删除吗">#</a></h2>
<p>不会，每条消息都会持久化到CommitLog中，每个Consumer连接到Broker后会维持消费进度信息，当有消息消费后只是当前Consumer的消费进度（CommitLog的offset）更新了。</p>
<p>追问：那么消息会堆积吗？什么时候清理过期消息？
4.6版本默认48小时后会删除不再使用的CommitLog文件。</p>
<h2 id="rocketmq消费模式有几种">RocketMQ消费模式有几种？<a hidden class="anchor" aria-hidden="true" href="#rocketmq消费模式有几种">#</a></h2>
<p>消费模型由Consumer决定，消费维度为Topic。</p>
<ul>
<li>
<p>集群消费
一条消息只会被同Group中的一个Consumer消费。
多个Group同时消费一个Topic时，每个Group都会有一个Consumer消费到数据。</p>
</li>
<li>
<p>广播消费
消息将对一 个Consumer Group 下的各个 Consumer 实例都消费一遍。</p>
</li>
</ul>
<h1 id="redis">Redis<a hidden class="anchor" aria-hidden="true" href="#redis">#</a></h1>
<h2 id="简单介绍redis">简单介绍redis<a hidden class="anchor" aria-hidden="true" href="#简单介绍redis">#</a></h2>
<p>Redis 就是一个使用 C 语言开发的数据库，不过与传统数据库不同的是 Redis 的数据是存在内存中的 ，也就是它是内存数据库，所以读写速度非常快，因此 Redis 被广泛应用于缓存方向。
另外，Redis 除了做缓存之外，Redis 也经常用来做分布式锁，甚至是消息队列。
Redis 提供了多种数据类型来支持不同的业务场景。Redis 还支持事务 、持久化、Lua 脚本、多种集群方案。</p>
<h2 id="缓存数据的处理流程是怎样的">缓存数据的处理流程是怎样的？<a hidden class="anchor" aria-hidden="true" href="#缓存数据的处理流程是怎样的">#</a></h2>
<ol>
<li>如果用户请求的数据在缓存中就直接返回。</li>
<li>缓存中不存在的话就看数据库中是否存在。</li>
<li>数据库中存在的话就更新缓存中的数据。</li>
<li>数据库中不存在的话就返回空数据。</li>
</ol>
<h2 id="为什么要用-redis为什么要用缓存">为什么要用 Redis/为什么要用缓存？<a hidden class="anchor" aria-hidden="true" href="#为什么要用-redis为什么要用缓存">#</a></h2>
<p>简单来说，使用缓存主要是为了提升用户体验以及应对更多的用户。
下面我们主要从“高性能”和“高并发”这两点来看待这个问题。</p>
<p>高性能 ：
假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。
这样有什么好处呢？ 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。
不过，要保持数据库和缓存中的数据的一致性。 如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p>
<p>高并发：
一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 redis 的情况，redis 集群的话会更高）。</p>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p>
<p>所以，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高的系统整体的并发。</p>
<h2 id="redis-常见数据结构以及使用场景分析">Redis 常见数据结构以及使用场景分析<a hidden class="anchor" aria-hidden="true" href="#redis-常见数据结构以及使用场景分析">#</a></h2>
<p>你可以自己本机安装 redis 或者通过 redis 官网提供的<a href="https://try.redis.io/">在线 redis 环境</a>。</p>
<h3 id="string">string<a hidden class="anchor" aria-hidden="true" href="#string">#</a></h3>
<p>string 是redis最简单的 key-value 类型。
常用命令: set、get、strlen、exists、dect、incr、setex等等。
应用场景 ：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</p>
<p>普通字符串的基本操作：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 设置 key-value 类型的值</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">set</span> key value 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 根据 key 获得对应的 value</span>
</span></span><span style="display:flex;"><span>get key
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 判断某个 key 是否存在</span>
</span></span><span style="display:flex;"><span>exists key
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 返回 key 所储存的字符串值的长度。</span>
</span></span><span style="display:flex;"><span>strlen key
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 删除某个 key 对应的值</span>
</span></span><span style="display:flex;"><span>del key 
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>get key
</span></span><span style="display:flex;"><span>(nil)
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="list">list<a hidden class="anchor" aria-hidden="true" href="#list">#</a></h3>
<p>list 即是 链表。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 LinkedList，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。
常用命令: rpush、lpop、lpush、rpop、lrange、llen 等。
应用场景: 发布与订阅或者说消息队列、慢查询。</p>
<p>list的简单使用</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 向 list 的头部（右边）添加元素</span>
</span></span><span style="display:flex;"><span>rpush myList value1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 向list的头部（最右边）添加多个元素</span>
</span></span><span style="display:flex;"><span>rpush myList value2 value3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 将 list的尾部(最左边)元素取出</span>
</span></span><span style="display:flex;"><span>lpop myList
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 查看对应下标的list列表， 0 为 start,1为 end</span>
</span></span><span style="display:flex;"><span>lrange myList <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 查看列表中的所有元素，-1表示倒数第一</span>
</span></span><span style="display:flex;"><span>lrange myList <span style="color:#ff0;font-weight:bold">0</span> -1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 通过 llen 查看链表长度：</span>
</span></span><span style="display:flex;"><span>llen myList
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="hash">hash<a hidden class="anchor" aria-hidden="true" href="#hash">#</a></h3>
<p>介绍 ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。
常用命令： hset、hmset、hexists、hget、hgetall、hkeys、hvals 等。
应用场景: 系统中对象数据的存储。</p>
<p>hash的简单使用</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>127.0.0.1:6379&gt; hmset userInfoKey name <span style="color:#0ff;font-weight:bold">&#34;guide&#34;</span> description <span style="color:#0ff;font-weight:bold">&#34;dev&#34;</span> age <span style="color:#0ff;font-weight:bold">&#34;24&#34;</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; hexists userInfoKey name <span style="color:#007f7f"># 查看 key 对应的 value中指定的字段是否存在。</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; hget userInfoKey name <span style="color:#007f7f"># 获取存储在哈希表中指定字段的值。</span>
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;guide&#34;</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; hget userInfoKey age
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;24&#34;</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; hgetall userInfoKey <span style="color:#007f7f"># 获取在哈希表中指定 key 的所有字段和值</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;guide&#34;</span>
</span></span><span style="display:flex;"><span>3) <span style="color:#0ff;font-weight:bold">&#34;description&#34;</span>
</span></span><span style="display:flex;"><span>4) <span style="color:#0ff;font-weight:bold">&#34;dev&#34;</span>
</span></span><span style="display:flex;"><span>5) <span style="color:#0ff;font-weight:bold">&#34;age&#34;</span>
</span></span><span style="display:flex;"><span>6) <span style="color:#0ff;font-weight:bold">&#34;24&#34;</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; hkeys userInfoKey <span style="color:#007f7f"># 获取 key 列表</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;description&#34;</span>
</span></span><span style="display:flex;"><span>3) <span style="color:#0ff;font-weight:bold">&#34;age&#34;</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; hvals userInfoKey <span style="color:#007f7f"># 获取 value 列表</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;guide&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;dev&#34;</span>
</span></span><span style="display:flex;"><span>3) <span style="color:#0ff;font-weight:bold">&#34;24&#34;</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; hset userInfoKey name <span style="color:#0ff;font-weight:bold">&#34;GuideGeGe&#34;</span> <span style="color:#007f7f"># 修改某个字段对应的值</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; hget userInfoKey name
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;GuideGeGe&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="set">set<a hidden class="anchor" aria-hidden="true" href="#set">#</a></h3>
<p>介绍 ： set 类似于 Java 中的 HashSet 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p>
<p>交集：给定两个集合A，B，即属于几个A，也属于集合B的集合，叫做集合A与集合B的交集。
并集：给定两个集合A，B，把他们所有的元素合并在一起组成的集合，叫做集合A与集合B的并集，记作A∪B，读作A并B。
差集：给定两个集合A和B，所有属于A且不属于B的元素的集合被称为A与B的差集。
示例：对于集合A = {a, b, c, d}和集合B = {b, c, w}，则A与B 的差集为{a, d}</p>
<p>常用命令： sadd、spop、smembers、sismember、scard、sinterstore、sunion 等。
应用场景: 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</p>
<p>set的简单使用</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>127.0.0.1:6379&gt; sadd mySet value1 value2 <span style="color:#007f7f"># 添加元素进去</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; sadd mySet value1 <span style="color:#007f7f"># 不允许有重复元素</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; smembers mySet <span style="color:#007f7f"># 查看 set 中所有的元素</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; scard mySet <span style="color:#007f7f"># 查看 set 的长度</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; sismember mySet value1 <span style="color:#007f7f"># 检查某个元素是否存在set 中，只能接收单个元素</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; sadd mySet2 value2 value3
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; sinterstore mySet3 mySet mySet2 <span style="color:#007f7f"># 获取 mySet 和 mySet2 的交集并存放在 mySet3 中</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; smembers mySet3
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="sorted-set">sorted set<a hidden class="anchor" aria-hidden="true" href="#sorted-set">#</a></h3>
<p>介绍： 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。
常用命令： zadd、zcard、zscore、zrange、zrevrange、zrem 等。
应用场景： 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</p>
<p>sorted set 的简单使用</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>127.0.0.1:6379&gt; zadd myZset 3.0 value1 <span style="color:#007f7f"># 添加元素到 sorted set 中 3.0 为权重</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; zadd myZset 2.0 value2 1.0 value3 <span style="color:#007f7f"># 一次添加多个元素</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; zcard myZset <span style="color:#007f7f"># 查看 sorted set 中的元素数量</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; zscore myZset value1 <span style="color:#007f7f"># 查看某个 value 的权重</span>
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;3&#34;</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; zrange  myZset <span style="color:#ff0;font-weight:bold">0</span> -1 <span style="color:#007f7f"># 顺序输出某个范围区间的元素，0 -1 表示输出所有元素</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value3&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>3) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; zrange  myZset <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">1</span> <span style="color:#007f7f"># 顺序输出某个范围区间的元素，0 为 start  1 为 stop</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value3&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; zrevrange  myZset <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">1</span> <span style="color:#007f7f"># 逆序输出某个范围区间的元素，0 为 start  1 为 stop</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="redis-单线程模型详解">Redis 单线程模型详解<a hidden class="anchor" aria-hidden="true" href="#redis-单线程模型详解">#</a></h2>
<p>Redis 基于 Reactor 模式来设计开发了自己的一套高效的事件处理模型 （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。
既然是单线程，那怎么监听大量的客户端连接呢？
Redis 通过IO 多路复用程序 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发生。
这样的好处非常明显： I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 Selector 组件很像）。</p>
<p>另外， Redis 服务器是一个事件驱动程序，服务器需要处理两类事件： 1. 文件事件; 2. 时间事件。
时间事件不需要多花时间了解，我们接触最多的还是 文件事件（客户端进行读取写入等操作，涉及一系列网络通信）。
《Redis 设计与实现》有一段话是如是介绍文件事件的，我觉得写得挺不错。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据 套接字目前执行的任务来为套接字关联不同的事件处理器。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="redis-没有使用多线程为什么不使用多线程">Redis 没有使用多线程？为什么不使用多线程？<a hidden class="anchor" aria-hidden="true" href="#redis-没有使用多线程为什么不使用多线程">#</a></h2>
<p>虽然说 Redis 是单线程模型，但是， 实际上，Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。
不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主处理之外的其他线程来“异步处理”。
大体上来说，Redis 6.0 之前主要还是单线程处理。
那，Redis6.0 之前 为什么不使用多线程？</p>
<p>我觉得主要原因有下面 3 个：</p>
<ul>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不是 CPU ，而是在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ul>
<h2 id="redis60-之后为何引入了多线程">Redis6.0 之后为何引入了多线程？<a hidden class="anchor" aria-hidden="true" href="#redis60-之后为何引入了多线程">#</a></h2>
<p>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。
虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了， 执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要修改 redis 配置文件 redis.conf ：
<code>io-threads-do-reads yes</code>
开启多线程后，还需要设置线程数，否则是不生效的。同样需要修改 redis 配置文件 redis.conf :
<code>io-threads 4 #官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</code></p>
<h2 id="redis-给缓存数据设置过期时间有啥用">Redis 给缓存数据设置过期时间有啥用？<a hidden class="anchor" aria-hidden="true" href="#redis-给缓存数据设置过期时间有啥用">#</a></h2>
<p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？
因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接Out of memory。
Redis 自带了给缓存数据设置过期时间的功能，比如：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>127.0.0.1:6379&gt; exp key  <span style="color:#ff0;font-weight:bold">60</span> <span style="color:#007f7f"># 数据在 60s 后过期</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; setex key <span style="color:#ff0;font-weight:bold">60</span> value <span style="color:#007f7f"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; ttl key <span style="color:#007f7f"># 查看数据还有多久过期</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">56</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：Redis中除了字符串类型有自己独有设置过期时间的命令 setex 外，其他方法都需要依靠 expire 命令来设置过期时间 。另外， persist 命令可以移除一个键的过期时间：</p>
<p>过期时间除了有助于缓解内存的消耗，还有什么其他用么？
很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在1分钟内有效，用户登录的 token 可能只在 1 天内有效。
如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h2 id="redis是如何判断数据是否过期的呢">Redis是如何判断数据是否过期的呢？<a hidden class="anchor" aria-hidden="true" href="#redis是如何判断数据是否过期的呢">#</a></h2>
<p>Redis 通过一个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向Redis数据库中的某个key(键)，过期字典的值是一个long long类型的整数，这个整数保存了key所指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。</p>
<h2 id="过期的数据的删除策略了解么">过期的数据的删除策略了解么？<a hidden class="anchor" aria-hidden="true" href="#过期的数据的删除策略了解么">#</a></h2>
<p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>
<ul>
<li>惰性删除 ：只会在取出key的时候才对数据进行过期检查。这样对CPU最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li>定期删除 ： 每隔一段时间抽取一批 key 执行删除过期key操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对CPU时间的影响。</li>
</ul>
<p>定期删除对内存更加友好，惰性删除对CPU更加友好。两者各有千秋，所以Redis 采用的是 定期删除+惰性/懒汉式删除 。
但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就Out of memory了。
怎么解决这个问题呢？答案就是： Redis 内存淘汰机制。</p>
<h2 id="redis-内存淘汰机制了解么">Redis 内存淘汰机制了解么？<a hidden class="anchor" aria-hidden="true" href="#redis-内存淘汰机制了解么">#</a></h2>
<p>Redis 提供 6 种数据淘汰策略：</p>
<ul>
<li>volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li>allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li>no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ul>
<p>4.0 版本后增加以下两种：</p>
<ul>
<li>volatile-lfu（least frequently used）：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li>allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ul>
<h2 id="redis-持久化机制怎么保证-redis-挂掉之后再重启数据可以进行恢复">Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进行恢复)<a hidden class="anchor" aria-hidden="true" href="#redis-持久化机制怎么保证-redis-挂掉之后再重启数据可以进行恢复">#</a></h2>
<p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p>
<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p>
<h3 id="快照snapshotting持久化rdb">快照（snapshotting）持久化（RDB）<a hidden class="anchor" aria-hidden="true" href="#快照snapshotting持久化rdb">#</a></h3>
<p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>#在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
</span></span><span style="display:flex;"><span>save 900 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
</span></span><span style="display:flex;"><span>save 300 10
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>#在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。
</span></span><span style="display:flex;"><span>save 60 10000
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="aofappend-only-file持久化">AOF（append-only file）持久化<a hidden class="anchor" aria-hidden="true" href="#aofappend-only-file持久化">#</a></h3>
<p>与快照持久化相比，AOF 持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：
<code>appendonly yes</code></p>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入硬盘中的 AOF 文件。AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
</span></span><span style="display:flex;"><span>appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
</span></span><span style="display:flex;"><span>appendfsync no        #让操作系统决定何时进行同步
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<h2 id="redis-事务">Redis 事务<a hidden class="anchor" aria-hidden="true" href="#redis-事务">#</a></h2>
<p>Redis 可以通过 MULTI，EXEC，DISCARD 和 WATCH 等命令来实现事务(transaction)功能。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; MULTI
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; INCR foo
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; INCR bar
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; EXEC
</span></span><span style="display:flex;"><span>1) (integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>2) (integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 MULTI命令后可以输入多个命令。Redis不会立即执行这些命令，而是将它们放到队列，当调用了EXEC命令将执行所有命令。</p>
<p>但是，Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： 1. 原子性，2. 隔离性，3. 持久性，4. 一致性。</p>
<ul>
<li>原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
<li>一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
</ul>
<p>Redis 是不支持 roll back 的，因而不满足原子性的（而且不满足持久性）。
Redis官网也解释了自己为啥不支持回滚。简单来说就是Redis开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。
你可以将Redis中的事务就理解为 ：Redis事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</p>
<h2 id="缓存穿透">缓存穿透<a hidden class="anchor" aria-hidden="true" href="#缓存穿透">#</a></h2>
<p>缓存穿透说简单点就是大量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上，根本没有经过缓存这一层。举个例子：某个黑客故意制造我们缓存中不存在的 key 发起大量请求，导致大量请求落到数据库。</p>
<h3 id="解决办法">解决办法：<a hidden class="anchor" aria-hidden="true" href="#解决办法">#</a></h3>
<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<h4 id="缓存无效-key">缓存无效 key<a hidden class="anchor" aria-hidden="true" href="#缓存无效-key">#</a></h4>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： SET key value EX 10086 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的： 表名:列名:主键名:主键值 。
如果用 Java 代码展示的话，差不多是下面这样的：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> Object getObjectInclNullById(Integer id) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 从缓存中获取数据</span>
</span></span><span style="display:flex;"><span>    Object cacheValue = cache.<span style="color:#007f7f">get</span>(id);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 缓存为空</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (cacheValue == <span style="color:#fff;font-weight:bold">null</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 从数据库中获取</span>
</span></span><span style="display:flex;"><span>        Object storageValue = storage.<span style="color:#007f7f">get</span>(key);
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 缓存空对象</span>
</span></span><span style="display:flex;"><span>        cache.<span style="color:#007f7f">set</span>(key, storageValue);
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 如果存储数据为空，需要设置一个过期时间(300秒)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (storageValue == <span style="color:#fff;font-weight:bold">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#007f7f">// 必须设置过期时间，否则有被攻击的风险</span>
</span></span><span style="display:flex;"><span>            cache.<span style="color:#007f7f">expire</span>(key, 60 * 5);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> storageValue;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> cacheValue;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="布隆过滤器">布隆过滤器<a hidden class="anchor" aria-hidden="true" href="#布隆过滤器">#</a></h4>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。
但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是： 布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</p>
<p>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！
我们先来看一下，当一个元素加入布隆过滤器中的时候，会进行哪些操作：
使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。根据得到的哈希值，在位数组中把对应下标的值置为 1。
我们再来看一下，当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</p>
<p>对给定元素再次进行相同的哈希计算；
得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。
然后，一定会出现这样一种情况：不同的字符串可能哈希出来的位置相同。 （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>
<h2 id="缓存雪崩">缓存雪崩<a hidden class="anchor" aria-hidden="true" href="#缓存雪崩">#</a></h2>
<p>缓存雪崩就是：缓存在同一时间大面积的失效，后面的请求都直接落到了数据库上，造成数据库短时间内承受大量请求。</p>
<p>还有一种缓存雪崩的场景是（缓存击穿）：是指一个key非常热点，在不停的扛着大并发，大并发集中对这一个点进行访问，当这个key在失效的瞬间，持续的大并发就穿破缓存，直接请求数据库，就像在一个屏障上凿开了一个洞。缓存击穿指并发查同一条数据。</p>
<p>举个例子 ：秒杀开始 12 个小时之前，我们统一存放了一批商品到 Redis 中，设置的缓存过期时间也是 12 个小时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就是，相应的请求直接就落到了数据库上，就像雪崩一样可怕。</p>
<p>针对 Redis 服务不可用的情况：</p>
<ul>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ul>
<p>针对热点缓存失效的情况：</p>
<ul>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效。</li>
</ul>
<h2 id="如何保证缓存和数据库数据的一致性">如何保证缓存和数据库数据的一致性？<a hidden class="anchor" aria-hidden="true" href="#如何保证缓存和数据库数据的一致性">#</a></h2>
<p>我们更新数据时，通常先更新数据库，然后更新缓存。
那么如果数据库更新成功了，而缓存没更新成功，那么就造成了数据库和缓存不一致的问题。</p>
<p>Cache Aside Pattern（旁路缓存模式）：
增加cache更新重试机制（常用）： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将 缓存中对应的 key 删除即可。</p>
<h1 id="mysql">MYSQL<a hidden class="anchor" aria-hidden="true" href="#mysql">#</a></h1>
<h2 id="什么是mysql">什么是mysql<a hidden class="anchor" aria-hidden="true" href="#什么是mysql">#</a></h2>
<p>MySQL 是一种关系型数据库，在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。阿里巴巴数据库系统也大量用到了 MySQL，因此它的稳定性是有保障的。MySQL是开放源代码的，因此任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL的默认端口号是3306。</p>
<h2 id="sql的执行顺序">SQL的执行顺序<a hidden class="anchor" aria-hidden="true" href="#sql的执行顺序">#</a></h2>
<h2 id="存储引擎">存储引擎<a hidden class="anchor" aria-hidden="true" href="#存储引擎">#</a></h2>
<ul>
<li>
<p>查看MySQL提供的所有存储引擎
<code>show engines;</code>
从上图我们可以查看出 MySQL 当前默认的存储引擎是InnoDB,并且在5.7版本所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。</p>
</li>
<li>
<p>查看MySQL当前默认的存储引擎
<code>show variables like '%storage_engine%';</code></p>
</li>
<li>
<p>查看表的存储引擎
<code>show table status like &quot;table_name&quot; ;</code></p>
</li>
</ul>
<h3 id="myisam和innodb区别">MyISAM和InnoDB区别<a hidden class="anchor" aria-hidden="true" href="#myisam和innodb区别">#</a></h3>
<p>MyISAM是MySQL的默认数据库引擎（5.5版之前）。虽然性能极佳，而且提供了大量的特性，包括全文索引、压缩、空间函数等，但MyISAM不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。不过，5.5版本之后，MySQL引入了InnoDB（事务性数据库引擎），MySQL 5.5版本后默认的存储引擎为InnoDB。</p>
<p>大多数时候我们使用的都是 InnoDB 存储引擎，但是在某些情况下使用 MyISAM 也是合适的比如读密集的情况下。（如果你不介意 MyISAM 崩溃恢复问题的话）。</p>
<p>两者的对比：</p>
<ul>
<li>是否支持行级锁 : MyISAM 只有表级锁(table-level locking)，而InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</li>
<li>是否支持事务和崩溃后的安全恢复： MyISAM 强调的是性能，每次查询具有原子性,其执行速度比InnoDB类型更快，但是不提供事务支持。但是InnoDB 提供事务支持事务，外部键等高级数据库功能。 具有事务(commit)、回滚(rollback)和崩溃修复能力(crash recovery capabilities)的事务安全(transaction-safe (ACID compliant))型表。</li>
<li>是否支持外键： MyISAM不支持，而InnoDB支持。</li>
<li>是否支持MVCC ：仅 InnoDB 支持。应对高并发事务, MVCC比单纯的加锁更高效;MVCC只在 READ COMMITTED 和 REPEATABLE READ 两个隔离级别下工作;MVCC可以使用 乐观(optimistic)锁 和 悲观(pessimistic)锁来实现;各数据库中MVCC实现并不统一。</li>
</ul>
<p>《MySQL高性能》上面有一句话这样写到:
不要轻易相信“MyISAM比InnoDB快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB的速度都可以让MyISAM望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p>
<h2 id="什么是回表查询如何避免">什么是回表查询？如何避免？<a hidden class="anchor" aria-hidden="true" href="#什么是回表查询如何避免">#</a></h2>
<p>对于mysql数据库的InnoDB引擎，它的非主键索引是非聚簇索引，索引文件和数据文件分开存储，索引文件B+树的叶节点只保存主键，在进行查询时，需要先去索引文件找到id，再根据id去数据文件查找具体数据，这种现象就叫回表查询。</p>
<p>解决方式：将查询sql中的字段添加到联合索引里面，只要保证查询语句里面的字段都在索引文件中，就无需进行回表查询。</p>
<h2 id="字符集及校对规则">字符集及校对规则<a hidden class="anchor" aria-hidden="true" href="#字符集及校对规则">#</a></h2>
<p>MySQL采用的是类似继承的方式指定字符集的默认值，每个数据库以及每张数据表都有自己的默认值，他们逐层继承。比如：某个库中所有表的默认字符集将是该数据库所指定的字符集（这些表在没有指定字符集的情况下，才会采用默认字符集）</p>
<h2 id="索引">索引<a hidden class="anchor" aria-hidden="true" href="#索引">#</a></h2>
<h3 id="什么是索引">什么是索引<a hidden class="anchor" aria-hidden="true" href="#什么是索引">#</a></h3>
<p>索引其实是一种数据结构，能够帮助我们快速的检索数据库中的数据。</p>
<h3 id="索引的种类">索引的种类<a hidden class="anchor" aria-hidden="true" href="#索引的种类">#</a></h3>
<p>普通索引：仅加速查询
唯一索引：加速查询 + 列值唯一（可以有null）
主键索引：加速查询 + 列值唯一（不可以有null）+ 表中只有一个
组合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并
全文索引：对文本的内容进行分词，进行搜索</p>
<h3 id="创建索引的时机">创建索引的时机<a hidden class="anchor" aria-hidden="true" href="#创建索引的时机">#</a></h3>
<p>一般来说，在WHERE和JOIN中出现的列需要建立索引，但也不完全如此，因为MySQL只对
&lt;，&lt;=，=，&gt;，&gt;=，BETWEEN，IN，以及某些时候的LIKE才会使用索引。
like有几种使用方式：
通配符在前：<code>%王靖尧</code>，这种情况，mysql不会使用索引。
通配符在后：<code>王靖尧%</code>，会使用索引
通配符在前后：<code>%王靖尧%</code>，会使用索引</p>
<p>例如：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SELECT</span> t.name <span style="color:#fff;font-weight:bold">FROM</span> mytable_t
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">LEFT</span> <span style="color:#fff;font-weight:bold">JOIN</span> mytable_m <span style="color:#fff;font-weight:bold">ON</span> t.name = m.username
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">WHERE</span> m.age=<span style="color:#ff0;font-weight:bold">20</span> 
</span></span><span style="display:flex;"><span>	<span style="color:#fff;font-weight:bold">AND</span> m.city = <span style="color:#0ff;font-weight:bold">&#39;北京&#39;</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时就需要对city和age建立索引，由于mytable_m表的userame也出现在了JOIN子句中，也有对它建立索引的必要。</p>
<h3 id="哪些情况索引会失效">哪些情况索引会失效？<a hidden class="anchor" aria-hidden="true" href="#哪些情况索引会失效">#</a></h3>
<ul>
<li>like通配符在前：<code>%王靖尧</code>，这种情况，索引会失效。</li>
<li>当 or 条件中有未建立索引的列才失效，要想使用or，又想让索引生效，只能将or条件中的每个列都加上索引。</li>
<li>存在索引列的数据类型隐形转换，则用不上索引，比如列类型是字符串，那一定要在条件中将数据使用引号引用起来，否则不使用索引。</li>
<li>where 子句里对索引列上有数学运算或者函数，会导致索引失效而转向全表扫描。</li>
<li>对于多列索引（复合索引），条件中没有索引的第一个字段，则不会使用索引。</li>
</ul>
<h3 id="索引采用的哪种数据结构呢">索引采用的哪种数据结构呢？<a hidden class="anchor" aria-hidden="true" href="#索引采用的哪种数据结构呢">#</a></h3>
<p>MySQL索引使用的数据结构主要有BTree索引和哈希索引 ，InnoDB引擎，默认的是B+树索引。</p>
<p>哈希索引，底层就是哈希表，哈希表是一种以key-value存储数据的结构，适合单条记录查询。
而B+ 树是一种多路平衡查询树，所以他的节点是天然有序的（左子节点小于父节点、父节点小于右子节点），所以对于范围查询的时候不需要做全表扫描。</p>
<ul>
<li>哈希索引适合等值查询，但是无法进行范围查询</li>
<li>哈希索引没办法利用索引完成排序</li>
<li>哈希索引不支持多列联合索引的最左匹配规则</li>
<li>如果有大量重复键值的情况下，哈希索引的效率会很低，因为存在哈希碰撞问题</li>
</ul>
<h3 id="刚刚我们聊到b-tree-那你知道b-tree的叶子节点都可以存哪些东西吗">刚刚我们聊到B+ Tree ，那你知道B+ Tree的叶子节点都可以存哪些东西吗？<a hidden class="anchor" aria-hidden="true" href="#刚刚我们聊到b-tree-那你知道b-tree的叶子节点都可以存哪些东西吗">#</a></h3>
<p>InnoDB的B+ Tree可能存储的是整行数据，也有可能是主键的值。
那这两者有什么区别吗？
B+ Tree的叶子节点存储了整行数据的是主键索引，也被称之为聚簇索引。
B+ Tree的叶子节点存储了主键的值的是非主键索引，也被称之为非聚簇索引。</p>
<p>聚簇索引和非聚簇索引，在查询数据的时候有区别吗？
聚簇索引查询会更快。
为什么呢？
因为主键索引树的叶子节点直接就是我们要查询的整行数据了。而非主键索引的叶子节点是主键的值，查到主键的值以后，还需要再通过主键的值再进行一次查询。</p>
<h3 id="非主键索引一定会查询多次吗">非主键索引一定会查询多次吗？<a hidden class="anchor" aria-hidden="true" href="#非主键索引一定会查询多次吗">#</a></h3>
<p>通过覆盖索引，非主键索引可以只查询一次。
覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。
当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。
如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。
当我们通过SQL语句：select key2 from covering_index_sample where key1 = &lsquo;keytest&rsquo;;的时候，就可以通过覆盖索引查询，无需回表。</p>
<h3 id="联合索引最左前缀匹配">联合索引、最左前缀匹配<a hidden class="anchor" aria-hidden="true" href="#联合索引最左前缀匹配">#</a></h3>
<p>创建索引的时候都会考虑哪些因素呢？
我们一般对于查询概率比较高，经常作为where条件的字段设置索引。</p>
<p>用过联合索引吗？
用过呀，我们有对一些表中创建过联合索引。</p>
<p>在创建联合索引的时候，需要做联合索引多个字段之间顺序你们是如何选择的呢？
我们把识别度最高的字段放到最前面。</p>
<p>为什么这么做呢？
因为最左前缀匹配。
因为MySQL索引查询会遵循最左前缀匹配的原则，即最左优先，在检索数据时从联合索引的最左边开始匹配。所以当我们创建一个联合索引的时候，如(key1,key2,key3)，相当于创建了（key1）、(key1,key2)和(key1,key2,key3)三个索引，这就是最左匹配原则。</p>
<h3 id="你们创建的那么多索引到底有没有生效或者说你们的sql语句有没有使用索引查询你们有统计过吗">你们创建的那么多索引，到底有没有生效，或者说你们的SQL语句有没有使用索引查询你们有统计过吗？<a hidden class="anchor" aria-hidden="true" href="#你们创建的那么多索引到底有没有生效或者说你们的sql语句有没有使用索引查询你们有统计过吗">#</a></h3>
<p>这个还没有统计过，除非遇到慢SQL的时候我们才会去排查</p>
<h3 id="那排查的时候有什么手段可以知道有没有走索引查询呢">那排查的时候，有什么手段可以知道有没有走索引查询呢？<a hidden class="anchor" aria-hidden="true" href="#那排查的时候有什么手段可以知道有没有走索引查询呢">#</a></h3>
<p>可以通过explain查看sql语句的执行计划，通过执行计划来分析索引使用情况。
explain的结果共包含12个字段，简单介绍几个重要的：</p>
<ul>
<li>id，执行顺序</li>
<li>select_type，查询中每个select的查询类型</li>
<li>type，重点关注的字段，该字段直接反映我们SQL的性能是否高效，这个字段值较多，只需关注重点几个：性能由好到差依次为：system-&gt;const-&gt;eq_ref-&gt;ref-&gt;range-&gt;index-&gt;all</li>
</ul>
<h3 id="那什么情况下会发生明明创建了索引但是执行的时候并没有通过索引呢">那什么情况下会发生明明创建了索引，但是执行的时候并没有通过索引呢？<a hidden class="anchor" aria-hidden="true" href="#那什么情况下会发生明明创建了索引但是执行的时候并没有通过索引呢">#</a></h3>
<p>查询优化器。
在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。</p>
<h2 id="查询缓存的使用">查询缓存的使用<a hidden class="anchor" aria-hidden="true" href="#查询缓存的使用">#</a></h2>
<p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用。
my.cnf加入以下配置，重启MySQL开启查询缓存</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>query_cache_type=1
</span></span><span style="display:flex;"><span>query_cache_size=600000
</span></span></code></pre></td></tr></table>
</div>
</div><p>MySQL执行以下命令也可以开启查询缓存</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>set global  query_cache_type=1;
</span></span><span style="display:flex;"><span>set global  query_cache_size=600000;
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上，开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。因此任何两个查询在任何字符上的不同都会导致缓存不命中。此外，如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL库中的系统表，其查询结果也不会被缓存。</p>
<p>缓存建立之后，MySQL的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</p>
<p>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。 因此，开启缓存查询要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十MB比较合适。此外，还可以通过sql_cache和sql_no_cache来控制某个查询语句是否需要缓存：
<code>select sql_no_cache count(*) from usr;</code></p>
<h2 id="什么是事务">什么是事务?<a hidden class="anchor" aria-hidden="true" href="#什么是事务">#</a></h2>
<p>事务是逻辑上的一组操作，要么都执行，要么都不执行。
事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：将小明的余额减少1000元，将小红的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小明余额减少而小红的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p>
<h2 id="事物的四大特性acid">事物的四大特性(ACID)<a hidden class="anchor" aria-hidden="true" href="#事物的四大特性acid">#</a></h2>
<ul>
<li>原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li>一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
<li>隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li>持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
</ul>
<h2 id="并发事务带来哪些问题">并发事务带来哪些问题?<a hidden class="anchor" aria-hidden="true" href="#并发事务带来哪些问题">#</a></h2>
<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ul>
<li>
<p>脏读（Dirty read）: 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</p>
</li>
<li>
<p>丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</p>
</li>
<li>
<p>不可重复读（Unrepeatableread）: 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>
</li>
<li>
<p>幻读（Phantom read）: 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
</li>
</ul>
<p>不可重复读和幻读区别：
不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。</p>
<h2 id="事务隔离级别有哪些mysql的默认隔离级别是">事务隔离级别有哪些?MySQL的默认隔离级别是?<a hidden class="anchor" aria-hidden="true" href="#事务隔离级别有哪些mysql的默认隔离级别是">#</a></h2>
<p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li>READ-UNCOMMITTED(读取未提交)： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li>REPEATABLE-READ(可重复读)： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<table>
<thead>
<tr>
<th>隔离级别</th>
<th>脏读</th>
<th>不可重复读</th>
<th>幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td>READ-UNCOMMITTED</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>READ-COMMITTED</td>
<td>×</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>REPEATABLE-READ</td>
<td>×</td>
<td>×</td>
<td>√</td>
</tr>
<tr>
<td>SERIALIZABLE</td>
<td>×</td>
<td>×</td>
<td>×</td>
</tr>
</tbody>
</table>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看。</p>
<p>这里需要注意的是：与 SQL 标准不同的地方在于 InnoDB 存储引擎在 REPEATABLE-READ（可重读） 事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server) 是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读） 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的 SERIALIZABLE(可串行化) 隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED(读取提交内容) ，但是你要知道的是InnoDB 存储引擎默认使用 REPEAaTABLE-READ（可重读） 并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在 分布式事务 的情况下一般会用到 SERIALIZABLE(可串行化) 隔离级别。</p>
<h2 id="锁机制与innodb锁算法">锁机制与InnoDB锁算法<a hidden class="anchor" aria-hidden="true" href="#锁机制与innodb锁算法">#</a></h2>
<p>MyISAM和InnoDB存储引擎使用的锁：</p>
<ul>
<li>MyISAM采用表级锁(table-level locking)。</li>
<li>InnoDB支持行级锁(row-level locking)和表级锁,默认为行级锁</li>
</ul>
<p>表级锁和行级锁对比：</p>
<ul>
<li>表级锁： MySQL中锁定 粒度最大 的一种锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。其锁定粒度最大，触发锁冲突的概率最高，并发度最低，MyISAM和 InnoDB引擎都支持表级锁。</li>
<li>行级锁： MySQL中锁定 粒度最小 的一种锁，只针对当前操作的行进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。</li>
</ul>
<p>InnoDB存储引擎的锁的算法有三种：</p>
<ul>
<li>Record lock：单个行记录上的锁</li>
<li>Gap lock：间隙锁，锁定一个范围，不包括记录本身</li>
<li>Next-key lock：record+gap 锁定一个范围，包含记录本身</li>
</ul>
<p>相关知识点：</p>
<ul>
<li>innodb对于行的查询使用next-key lock</li>
<li>Next-locking keying为了解决Phantom Problem幻读问题</li>
<li>当查询的索引含有唯一属性时，将next-key lock降级为record key</li>
<li>Gap锁设计的目的是为了阻止多个事务将记录插入到同一范围内，而这会导致幻读问题的产生</li>
<li>有两种方式显式关闭gap锁：（除了外键约束和唯一性检查外，其余情况仅使用record lock） A. 将事务隔离级别设置为RC B. 将参数innodb_locks_unsafe_for_binlog设置为1</li>
</ul>
<h2 id="大表优化">大表优化<a hidden class="anchor" aria-hidden="true" href="#大表优化">#</a></h2>
<p>当MySQL单表记录数过大时，数据库的CRUD性能会明显下降，一些常见的优化措施如下：</p>
<h3 id="限定数据的范围">限定数据的范围<a hidden class="anchor" aria-hidden="true" href="#限定数据的范围">#</a></h3>
<p>务必禁止不带任何限制数据范围条件的查询语句。比如：我们当用户在查询订单历史的时候，我们可以控制在一个月的范围内；</p>
<h3 id="读写分离">读/写分离<a hidden class="anchor" aria-hidden="true" href="#读写分离">#</a></h3>
<p>经典的数据库拆分方案，主库负责写，从库负责读；</p>
<h3 id="垂直拆分">垂直拆分<a hidden class="anchor" aria-hidden="true" href="#垂直拆分">#</a></h3>
<p>根据数据库里面数据表的相关性进行拆分。 例如，用户表中既有用户的登录信息又有用户的基本信息，可以将用户表拆分成两个单独的表，甚至放到单独的库做分库。
简单来说垂直拆分是指数据表列的拆分，把一张列比较多的表拆分为多张表。 如下图所示，这样来说大家应该就更容易理解了。</p>
<p>垂直拆分的优点： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；</p>
<h3 id="水平拆分">水平拆分<a hidden class="anchor" aria-hidden="true" href="#水平拆分">#</a></h3>
<p>保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达到了分布式的目的。 水平拆分可以支撑非常大的数据量。
水平拆分是指数据表行的拆分，表的行数超过200万行时，就会变慢，这时可以把一张的表的数据拆成多张表来存放。举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p>
<p>水平拆分可以支持非常大的数据量。需要注意的一点是：分表仅仅是解决了单一表数据过大的问题，但由于表的数据还是在同一台机器上，其实对于提升MySQL并发能力没有什么意义，所以 水平拆分最好分库 。</p>
<p>水平拆分能够支持非常大的数据量存储，应用端改造也少，但 分片事务难以解决 ，跨节点Join性能较差，逻辑复杂。《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的。如果实在要分片，尽量选择客户端分片架构，这样可以减少一次和中间件的网络I/O。</p>
<p>下面补充一下数据库分片的两种常见方案：</p>
<ul>
<li>客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。 当当网的 Sharding-JDBC 、阿里的TDDL是两种比较常用的实现。</li>
<li>中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。 我们现在谈的 Mycat 、360的Atlas、网易的DDB等等都是这种架构的实现。</li>
</ul>
<p>详细内容可以参考： MySQL大表优化方案: <a href="https://segmentfault.com/a/1190000006158186">https://segmentfault.com/a/1190000006158186</a></p>
<h2 id="解释一下什么是池化设计思想什么是数据库连接池为什么需要数据库连接池">解释一下什么是池化设计思想。什么是数据库连接池?为什么需要数据库连接池?<a hidden class="anchor" aria-hidden="true" href="#解释一下什么是池化设计思想什么是数据库连接池为什么需要数据库连接池">#</a></h2>
<p>池化设计应该不是一个新名词。我们常见的如java线程池、jdbc连接池、redis连接池等就是这类设计的代表实现。这种设计会初始预设资源，解决的问题就是抵消每次获取资源的消耗，如创建线程的开销，获取远程连接的开销等。就好比你去食堂打饭，打饭的大妈会先把饭盛好几份放那里，你来了就直接拿着饭盒加菜即可，不用再临时又盛饭又打菜，效率就高了。除了初始化资源，池化设计还包括如下这些特征：池子的初始值、池子的活跃值、池子的最大值等，这些特征可以直接映射到java线程池和数据库连接池的成员属性中。这篇文章对池化设计思想介绍的还不错，直接复制过来，避免重复造轮子了。</p>
<p>数据库连接本质就是一个 socket 的连接。数据库服务端还要维护一些缓存和用户权限信息之类的 所以占用了一些内存。我们可以把数据库连接池是看做是维护的数据库连接的缓存，以便将来需要对数据库的请求时可以重用这些连接。为每个用户打开和维护数据库连接，尤其是对动态数据库驱动的网站应用程序的请求，既昂贵又浪费资源。**在连接池中，创建连接后，将其放置在池中，并再次使用它，因此不必建立新的连接。如果使用了所有连接，则会建立一个新连接并将其添加到池中。 **连接池还减少了用户必须等待建立与数据库的连接的时间。</p>
<h2 id="分库分表之后id-主键如何处理">分库分表之后,id 主键如何处理？<a hidden class="anchor" aria-hidden="true" href="#分库分表之后id-主键如何处理">#</a></h2>
<p>因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。
生成全局 id 有下面这几种方式：</p>
<ul>
<li>UUID：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。</li>
<li>数据库自增 id : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。</li>
<li>利用 redis 生成 id : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。</li>
<li>Twitter的snowflake算法 ：Github 地址：https://github.com/twitter-archive/snowflake。</li>
<li>美团的Leaf分布式ID生成系统 ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。感觉还不错。美团技术团队的一篇文章：https://tech.meituan.com/2017/04/21/mt-leaf.html 。</li>
</ul>
<h2 id="一条sql语句在mysql中如何执行的">一条SQL语句在MySQL中如何执行的<a hidden class="anchor" aria-hidden="true" href="#一条sql语句在mysql中如何执行的">#</a></h2>
<h2 id="mysql高性能优化规范建议">MySQL高性能优化规范建议<a hidden class="anchor" aria-hidden="true" href="#mysql高性能优化规范建议">#</a></h2>
<p><a href="https://www.cnblogs.com/huchong/p/10219318.html">https://www.cnblogs.com/huchong/p/10219318.html</a></p>
<h2 id="一条sql语句执行得很慢的原因有哪些">一条SQL语句执行得很慢的原因有哪些？<a hidden class="anchor" aria-hidden="true" href="#一条sql语句执行得很慢的原因有哪些">#</a></h2>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247485185&idx=1&sn=66ef08b4ab6af5757792223a83fc0d45&chksm=cea248caf9d5c1dc72ec8a281ec16aa3ec3e8066dbb252e27362438a26c33fbe842b0e0adf47&token=79317275&lang=zh_CN#rd</a></p>
<h2 id="后端程序员必备书写高质量sql的30条建议">后端程序员必备：书写高质量SQL的30条建议<a hidden class="anchor" aria-hidden="true" href="#后端程序员必备书写高质量sql的30条建议">#</a></h2>
<p><a href="https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486461&idx=1&sn=60a22279196d084cc398936fe3b37772&chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&token=1987003517&lang=zh_CN#rd">https://mp.weixin.qq.com/s?__biz=Mzg2OTA0Njk0OA==&mid=2247486461&idx=1&sn=60a22279196d084cc398936fe3b37772&chksm=cea24436f9d5cd20a4fa0e907590f3e700d7378b3f608d7b33bb52cfb96f503b7ccb65a1deed&token=1987003517&lang=zh_CN#rd</a></p>
<h1 id="spring">Spring<a hidden class="anchor" aria-hidden="true" href="#spring">#</a></h1>
<h2 id="什么是-spring-框架">什么是 Spring 框架?<a hidden class="anchor" aria-hidden="true" href="#什么是-spring-框架">#</a></h2>
<p>Spring 是一种轻量级开发框架，旨在提高开发人员的开发效率以及系统的可维护性。Spring 官网：https://spring.io/。</p>
<p>我们一般说 Spring 框架指的都是 Spring Framework，它是很多模块的集合，使用这些模块可以很方便地协助我们进行开发。这些模块是：核心容器、数据访问/集成,、Web、AOP（面向切面编程）、工具、消息和测试模块。比如：Core Container 中的 Core 组件是Spring 所有组件的核心，Beans 组件和 Context 组件是实现IOC和依赖注入的基础，AOP组件用来实现面向切面编程。</p>
<h2 id="spring包含哪些模块">Spring包含哪些模块？<a hidden class="anchor" aria-hidden="true" href="#spring包含哪些模块">#</a></h2>
<p>Spring Core： 基础,可以说 Spring 其他所有的功能都需要依赖于该类库。主要提供 IoC 依赖注入功能。
Spring Aspects ： 该模块为与AspectJ的集成提供支持。
Spring AOP ：提供了面向切面的编程实现。
Spring JDBC : Java数据库连接。
Spring JMS ：Java消息服务。
Spring ORM : 用于支持Hibernate等ORM工具。
Spring Web : 为创建Web应用程序提供支持。
Spring Test : 提供了对 JUnit 和 TestNG 测试的支持。</p>
<h2 id="spring-ioc">Spring IOC<a hidden class="anchor" aria-hidden="true" href="#spring-ioc">#</a></h2>
<p>IoC（Inverse of Control:控制反转）是一种设计思想，就是 将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 IoC 在其他语言中也有应用，并非 Spring 特有。 IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个Map（key，value）,Map 中存放的是各种对象。</p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p>
<p>Spring 时代我们一般通过 XML 文件来配置 Bean，后来开发人员觉得 XML 文件来配置不太好，于是 SpringBoot 注解配置就慢慢开始流行起来。</p>
<p><a href="https://www.zhihu.com/question/23277575/answer/169698662">推荐阅读</a></p>
<h2 id="aop">AOP<a hidden class="anchor" aria-hidden="true" href="#aop">#</a></h2>
<p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>Spring AOP就是基于动态代理的，如果要代理的对象，实现了某个接口，那么Spring AOP会使用JDK Proxy，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候Spring AOP会使用Cglib ，这时候Spring AOP会使用 Cglib 生成一个被代理对象的子类来作为代理</p>
<p>当然你也可以使用 AspectJ ,Spring AOP 已经集成了AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p>
<p>使用 AOP 之后我们可以把一些通用功能抽象出来，在需要用到的地方直接使用即可，这样大大简化了代码量。我们需要增加新功能时也方便，这样也提高了系统扩展性。日志功能、事务管理等等场景都用到了 AOP 。</p>
<p>Spring AOP 和 AspectJ AOP 有什么区别？
Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。 Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。
Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，
如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比Spring AOP 快很多。</p>
<h2 id="spring-中的-bean-的作用域有哪些">Spring 中的 bean 的作用域有哪些?<a hidden class="anchor" aria-hidden="true" href="#spring-中的-bean-的作用域有哪些">#</a></h2>
<p>singleton : 唯一 bean 实例，Spring 中的 bean 默认都是单例的。
prototype : 每次请求都会创建一个新的 bean 实例。
request : 每一次HTTP请求都会产生一个新的bean，该bean仅在当前HTTP request内有效。
session : 每一次HTTP请求都会产生一个新的 bean，该bean仅在当前 HTTP session 内有效。</p>
<h2 id="spring-中的单例-bean-的线程安全问题了解吗">Spring 中的单例 bean 的线程安全问题了解吗？<a hidden class="anchor" aria-hidden="true" href="#spring-中的单例-bean-的线程安全问题了解吗">#</a></h2>
<p>大部分时候我们并没有在系统中使用多线程，所以很少有人会关注这个问题。单例 bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候，对这个对象的非静态成员变量的写操作会存在线程安全问题。</p>
<p>常见的有两种解决办法：</p>
<ul>
<li>在Bean对象中尽量避免定义可变的成员变量（不太现实）。</li>
<li>在类中定义一个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推荐的一种方式）。</li>
</ul>
<h2 id="component-和-bean-的区别是什么">@Component 和 @Bean 的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#component-和-bean-的区别是什么">#</a></h2>
<ul>
<li>作用对象不同: @Component 注解作用于类，而@Bean注解作用于方法。</li>
<li>@Component通常是通过类路径扫描来自动侦测以及自动装配到Spring容器中（我们可以使用 @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。@Bean 注解通常是我们在标有该注解的方法中定义产生这个 bean,@Bean告诉了Spring这是某个类的示例，当我需要用它的时候还给我。</li>
<li>@Bean 注解比 Component 注解的自定义性更强，而且很多地方我们只能通过 @Bean 注解来注册bean。比如当我们引用第三方库中的类需要装配到 Spring容器时，则只能通过 @Bean来实现。</li>
</ul>
<p>@Bean注解使用示例：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>@Configuration
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> AppConfig {
</span></span><span style="display:flex;"><span>    @Bean
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> TransferService transferService() {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> TransferServiceImpl();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>上面的代码相当于下面的 xml 配置</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-xml" data-lang="xml"><span style="display:flex;"><span><span style="font-weight:bold">&lt;beans&gt;</span>
</span></span><span style="display:flex;"><span>    <span style="font-weight:bold">&lt;bean</span> <span style="color:#007f7f">id=</span><span style="color:#0ff;font-weight:bold">&#34;transferService&#34;</span> <span style="color:#007f7f">class=</span><span style="color:#0ff;font-weight:bold">&#34;com.acme.TransferServiceImpl&#34;</span><span style="font-weight:bold">/&gt;</span>
</span></span><span style="display:flex;"><span><span style="font-weight:bold">&lt;/beans&gt;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>下面这个例子是通过 @Component 无法实现的。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>@Bean
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> OneService getService(status) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">case</span> (status)  {
</span></span><span style="display:flex;"><span>        when 1:
</span></span><span style="display:flex;"><span>                <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> serviceImpl1();
</span></span><span style="display:flex;"><span>        when 2:
</span></span><span style="display:flex;"><span>                <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> serviceImpl2();
</span></span><span style="display:flex;"><span>        when 3:
</span></span><span style="display:flex;"><span>                <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> serviceImpl3();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="将一个类声明为spring的-bean-的注解有哪些">将一个类声明为Spring的 bean 的注解有哪些?<a hidden class="anchor" aria-hidden="true" href="#将一个类声明为spring的-bean-的注解有哪些">#</a></h2>
<p>我们一般使用 @Autowired 注解自动装配 bean，要想把类标识成可用于 @Autowired 注解自动装配的 bean 的类,采用以下注解可实现：</p>
<ul>
<li>@Component ：通用的注解，可标注任意类为 Spring 组件。如果一个Bean不知道属于哪个层，可以使用@Component 注解标注。</li>
<li>@Repository : 对应持久层即 Dao 层，主要用于数据库相关操作。</li>
<li>@Service : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao层。</li>
<li>@Controller : 对应 Spring MVC 控制层，主要用户接受用户请求并调用 Service 层返回数据给前端页面。</li>
</ul>
<h2 id="spring-中的-bean-生命周期">Spring 中的 bean 生命周期?<a hidden class="anchor" aria-hidden="true" href="#spring-中的-bean-生命周期">#</a></h2>
<p>Bean 容器找到配置文件中 Spring Bean 的定义。
Bean 容器利用 Java Reflection API 创建一个Bean的实例。
如果涉及到一些属性值 利用 set()方法设置一些属性值。
如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。
如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。
与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。
如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法
如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。
如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。
如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法
当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。
当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</p>
<p>图示：
<img loading="lazy" src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/48376272.jpg"></p>
<p>中文图示：
<img loading="lazy" src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-17/5496407.jpg"></p>
<h2 id="说说自己对于-spring-mvc-了解">说说自己对于 Spring MVC 了解?<a hidden class="anchor" aria-hidden="true" href="#说说自己对于-spring-mvc-了解">#</a></h2>
<p>MVC 是一种设计模式,Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的Web层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service层（处理业务）、Dao层（数据库操作）、Entity层（实体类）、Controller层(控制层，返回数据给前台页面)。</p>
<h2 id="spring-mvc-的运行流程重要">Spring MVC 的运行流程（重要）：<a hidden class="anchor" aria-hidden="true" href="#spring-mvc-的运行流程重要">#</a></h2>
<ol>
<li>客户端（浏览器）发送请求，直接请求到 DispatcherServlet。</li>
<li>DispatcherServlet 根据请求信息调用 HandlerMapping，解析请求对应的 Handler。</li>
<li>解析到对应的 Handler（也就是我们平常说的 Controller 控制器）后，开始由 HandlerAdapter 适配器处理。</li>
<li>HandlerAdapter 会根据 Handler 来调用真正的处理器开处理请求，并处理相应的业务逻辑。</li>
<li>处理器处理完业务后，会返回一个 ModelAndView 对象，Model 是返回的数据对象，View 是个逻辑上的 View。</li>
<li>ViewResolver 会根据逻辑 View 查找实际的 View。</li>
<li>DispaterServlet 把返回的 Model 传给 View（视图渲染）。</li>
<li>把 View 返回给请求者（浏览器）</li>
</ol>
<h2 id="spring-框架中用到了哪些设计模式">Spring 框架中用到了哪些设计模式？<a hidden class="anchor" aria-hidden="true" href="#spring-框架中用到了哪些设计模式">#</a></h2>
<p>工厂设计模式 : Spring使用工厂模式通过 BeanFactory、ApplicationContext 创建 bean 对象。
代理设计模式 : Spring AOP 功能的实现。
单例设计模式 : Spring 中的 Bean 默认都是单例的。
包装器设计模式 : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。
观察者模式: Spring 事件驱动模型就是观察者模式很经典的一个应用。
适配器模式 :Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配Controller。</p>
<h2 id="spring-事务">Spring 事务<a hidden class="anchor" aria-hidden="true" href="#spring-事务">#</a></h2>
<p>Spring 管理事务的方式有几种？
编程式事务，在代码中硬编码。(不推荐使用)
声明式事务，在配置文件中配置（推荐使用）</p>
<p>声明式事务又分为两种：</p>
<ul>
<li>基于XML的声明式事务</li>
<li>基于注解的声明式事务</li>
</ul>
<h2 id="spring-事务中的隔离级别有哪几种">Spring 事务中的隔离级别有哪几种?<a hidden class="anchor" aria-hidden="true" href="#spring-事务中的隔离级别有哪几种">#</a></h2>
<p>TransactionDefinition 接口中定义了五个表示隔离级别的常量：</p>
<ul>
<li>TransactionDefinition.ISOLATION_DEFAULT: 使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别.</li>
<li>TransactionDefinition.ISOLATION_READ_UNCOMMITTED: 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</li>
<li>TransactionDefinition.ISOLATION_READ_COMMITTED: 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</li>
<li>TransactionDefinition.ISOLATION_REPEATABLE_READ: 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li>TransactionDefinition.ISOLATION_SERIALIZABLE: 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li>
</ul>
<h2 id="spring-事务传播行为有几种">Spring 事务传播行为有几种?<a hidden class="anchor" aria-hidden="true" href="#spring-事务传播行为有几种">#</a></h2>
<p>支持当前事务的情况：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRED： 如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。
TransactionDefinition.PROPAGATION_SUPPORTS： 如果当前存在事务，则加入该事务；- 如果当前没有事务，则以非事务的方式继续运行。</li>
<li>TransactionDefinition.PROPAGATION_MANDATORY： 如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</li>
</ul>
<p>不支持当前事务的情况：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_REQUIRES_NEW： 创建一个新的事务，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NOT_SUPPORTED： 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li>
<li>TransactionDefinition.PROPAGATION_NEVER： 以非事务方式运行，如果当前存在事务，则抛出异常。</li>
</ul>
<p>其他情况：</p>
<ul>
<li>TransactionDefinition.PROPAGATION_NESTED： 如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于TransactionDefinition.PROPAGATION_REQUIRED。</li>
</ul>
<h2 id="transactionalrollbackfor--exceptionclass注解了解吗">@Transactional(rollbackFor = Exception.class)注解了解吗？<a hidden class="anchor" aria-hidden="true" href="#transactionalrollbackfor--exceptionclass注解了解吗">#</a></h2>
<p>我们知道：Exception分为运行时异常RuntimeException和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以保证数据的一致性。</p>
<p>当@Transactional注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p>
<p>在@Transactional注解中如果不配置rollbackFor属性,那么事物只会在遇到RuntimeException的时候才会回滚,加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚。</p>
<h1 id="springboot">SpringBoot<a hidden class="anchor" aria-hidden="true" href="#springboot">#</a></h1>
<h2 id="springboot的优点">SpringBoot的优点<a hidden class="anchor" aria-hidden="true" href="#springboot的优点">#</a></h2>
<ul>
<li>独立运行
Spring Boot 而且内嵌了各种 servlet 容器，Tomcat、Jetty 等，现在不再需要打成war 包部署到容器中，Spring Boot 只要打成一个可执行的 jar 包就能独立运行，所有的依赖包都在一个 jar 包内。</li>
<li>无代码生成和XML配置
Spring Boot 配置过程中无代码生成，也无需 XML 配置文件就能完成所有配置工作，这一切都是借助于条件注解完成的，这也是 Spring4.x 的核心功能之一。</li>
</ul>
<h2 id="什么是spring-boot-starter">什么是Spring Boot Starter？<a hidden class="anchor" aria-hidden="true" href="#什么是spring-boot-starter">#</a></h2>
<p>Starter主要用来简化maven依赖配置，可以理解成pom配置了一堆jar组合的空maven项目。
例如spring-boot-starter-web包含以下依赖：
org.springframework.boot:spring-boot-starter
org.springframework.boot:spring-boot-starter-tomcat
org.springframework.boot:spring-boot-starter-validation
com.fasterxml.jackson.core:jackson-databind
org.springframework:spring-web
org.springframework:spring-webmvc</p>
<h2 id="springboot的启动流程">SpringBoot的启动流程<a hidden class="anchor" aria-hidden="true" href="#springboot的启动流程">#</a></h2>
<h1 id="dubbo">Dubbo<a hidden class="anchor" aria-hidden="true" href="#dubbo">#</a></h1>
<h2 id="dubbo里面有哪几种节点角色">Dubbo里面有哪几种节点角色？<a hidden class="anchor" aria-hidden="true" href="#dubbo里面有哪几种节点角色">#</a></h2>
<p>provider：服务提供者
consumer：消费者
registry：注册中心
Monitor：监控中心，统计服务调用次数和调用时间
container：服务运行容器</p>
<h2 id="服务注册与发现的流程图">服务注册与发现的流程图<a hidden class="anchor" aria-hidden="true" href="#服务注册与发现的流程图">#</a></h2>
<p><img loading="lazy" src="/posts/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/dubbo.png"></p>
<h2 id="dubbo默认使用什么注册中心还有别的选择吗">Dubbo默认使用什么注册中心，还有别的选择吗？<a hidden class="anchor" aria-hidden="true" href="#dubbo默认使用什么注册中心还有别的选择吗">#</a></h2>
<p>推荐使用 Zookeeper 作为注册中心，还有 Redis、Multicast、Simple 注册中心，但不推荐。</p>
<h2 id="dubbo-核心的配置有哪些">Dubbo 核心的配置有哪些？<a hidden class="anchor" aria-hidden="true" href="#dubbo-核心的配置有哪些">#</a></h2>
<p>dubbo:service 服务配置
dubbo:registry 注册中心配置
dubbo:provider 提供者配置
dubbo:consumer 消费者配置
dubbo:monitor 监控中心配置</p>
<h2 id="在-provider-上可以配置的-consumer-端的属性有哪些">在 Provider 上可以配置的 Consumer 端的属性有哪些？<a hidden class="anchor" aria-hidden="true" href="#在-provider-上可以配置的-consumer-端的属性有哪些">#</a></h2>
<p>1）timeout：方法调用超时
2）retries：失败重试次数，默认重试 2 次
3）loadbalance：负载均衡算法，默认随机
4）actives 消费者端，最大并发调用限制</p>
<h2 id="dubbo启动时如果依赖的服务不可用会怎样">Dubbo启动时如果依赖的服务不可用会怎样？<a hidden class="anchor" aria-hidden="true" href="#dubbo启动时如果依赖的服务不可用会怎样">#</a></h2>
<p>Dubbo 缺省会在启动时检查依赖的服务是否可用，不可用时会抛出异常，阻止 Spring 初始化完成，默认 check=&ldquo;true&rdquo;，可以通过 check=&ldquo;false&rdquo; 关闭检查。</p>
<h2 id="dubbo推荐使用什么序列化框架你知道的还有哪些">Dubbo推荐使用什么序列化框架，你知道的还有哪些？<a hidden class="anchor" aria-hidden="true" href="#dubbo推荐使用什么序列化框架你知道的还有哪些">#</a></h2>
<p>推荐使用Hessian序列化，还有Duddo、FastJson、Java自带序列化。</p>
<h2 id="dubbo默认使用的是什么通信框架">Dubbo默认使用的是什么通信框架<a hidden class="anchor" aria-hidden="true" href="#dubbo默认使用的是什么通信框架">#</a></h2>
<p>Dubbo 默认使用 Netty 框架</p>
<h2 id="dubbo有哪几种集群容错方案默认是哪种">Dubbo有哪几种集群容错方案，默认是哪种？<a hidden class="anchor" aria-hidden="true" href="#dubbo有哪几种集群容错方案默认是哪种">#</a></h2>
<p>Failover Cluster（默认），失败自动切换，当出现失败，重试其它服务器。通常用于读操作，但重试会带来更长延迟。
Failfast Cluster，快速失败，只发起一次调用，失败立即报错。通常用于非幂等性的写操作，比如新增记录。
Failsafe Cluster，失败安全，出现异常时，直接忽略。通常用于写入日志等。
Failback Cluster，失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知等。
Forking Cluster，并行调用多个服务器，只要一个成功即返回。通常用于实时性要求较高的读操作，但需要浪费更多服务资源。可通过 forks 来设置最大并行数。
Broadcast Cluster，广播调用所有提供者，逐个调用，任意一台报错则报错。通常用于通知所有提供者更新缓存本地资源信息。</p>
<h2 id="dubbo有哪几种负载均衡策略默认是哪种">Dubbo有哪几种负载均衡策略，默认是哪种？<a hidden class="anchor" aria-hidden="true" href="#dubbo有哪几种负载均衡策略默认是哪种">#</a></h2>
<p>Random LoadBalance：随机选取提供者策略，随机转发请求，可以加权
RoundRobin LoadBalance：轮循选取提供者策略，请求平均分布
LeastActive LoadBalance：最少活跃调用策略，可以让慢提供者接收更少的请求
ConstantHash LoadBalance：一致性 Hash 策略，相同参数请求总是发到同一提供者，一台机器宕机，可以基于虚拟节点，分摊至其他提供者</p>
<h2 id="当一个服务接口有多种实现时怎么做">当一个服务接口有多种实现时怎么做？<a hidden class="anchor" aria-hidden="true" href="#当一个服务接口有多种实现时怎么做">#</a></h2>
<p>当一个接口有多种实现时，可以用 group 属性来分组，服务提供方和消费方都指定同一个 group 即可。</p>
<h2 id="服务上线怎么兼容旧版本">服务上线怎么兼容旧版本？<a hidden class="anchor" aria-hidden="true" href="#服务上线怎么兼容旧版本">#</a></h2>
<p>可以用版本号（version）过渡，多个不同版本的服务注册到注册中心，版本号不同的服务相互间不引用。这个和服务分组的概念有一点类似。</p>
<h2 id="dubbo可以对结果进行缓存吗">Dubbo可以对结果进行缓存吗？<a hidden class="anchor" aria-hidden="true" href="#dubbo可以对结果进行缓存吗">#</a></h2>
<p>可以，Dubbo 提供了声明式缓存，用于加速热门数据的访问速度，以减少用户加缓存的工作量。</p>
<h2 id="dubbo服务之间的调用是阻塞的吗">Dubbo服务之间的调用是阻塞的吗？<a hidden class="anchor" aria-hidden="true" href="#dubbo服务之间的调用是阻塞的吗">#</a></h2>
<p>默认是同步等待结果阻塞的，支持异步调用。</p>
<h1 id="多线程">多线程<a hidden class="anchor" aria-hidden="true" href="#多线程">#</a></h1>
<h2 id="什么是线程和进程">什么是线程和进程?<a hidden class="anchor" aria-hidden="true" href="#什么是线程和进程">#</a></h2>
<p>进程：是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
<p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
<p>线程：与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈和本地方法栈，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</p>
<h2 id="并发与并行的区别">并发与并行的区别?<a hidden class="anchor" aria-hidden="true" href="#并发与并行的区别">#</a></h2>
<p>并行必须多核CPU才能办到，并发单核就可以做到（并发宏观并行，微观串行）。</p>
<p>你吃饭吃到一半，电话来了，你一直到吃完了以后才去接，这就说明你不支持并发也不支持并行。你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这说明你支持并发。你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这说明你支持并行。并发的关键是你有处理多个任务的能力，不一定要同时。并行的关键是你有同时处理多个任务的能力。所以我认为它们最关键的点就是：是否是『同时』。</p>
<h2 id="线程的状态">线程的状态<a hidden class="anchor" aria-hidden="true" href="#线程的状态">#</a></h2>
<p>线程共包括以下五种状态：</p>
<p>新建(new)：线程对象被创建后，进入新建状态。如：Thread thread = new Thread();
就绪(Runnable)：可执行状态。线程对象被创建后，其他线程调用了该对象的start方法，来启动该线程。如：thread.start()。处于就绪状态的线程，随时可能被CPU调度执行。
运行(Running)：线程获取CPU权限进行执行。注意：线程只能从就绪状态进入到运行状态。
阻塞(Blocked)：阻塞状态是线程因为某种原因放弃CPU使用权，暂时停止运行。直到线程进入就绪状态，才有机会继续运行。阻塞的情况分三种：
等待阻塞：通过调用线程的wait()方法，让线程等待某工作完成。
同步阻塞：线程获取synchronized同步锁失败(因为锁被其他线程占用)，它会进入同步阻塞状态。
其他阻塞：通过调用线程的sleep()或join()或发出I/O请求时，线程会进入到阻塞状态。当sleep()状态超时、join()等待线程终止或超时、I/O处理完毕，线程会重新进入就绪状态。
死亡(Dead)：线程执行完了或因异常退出了run()方法，该线程结束生命周期。</p>
<h2 id="线程之间如何通信">线程之间如何通信<a hidden class="anchor" aria-hidden="true" href="#线程之间如何通信">#</a></h2>
<p>1、基于synchronized+wait() 和 notify()
2、基于reentrantLock的Condition
3、基于volatile
4、基于CountDownLatch
<a href="https://blog.csdn.net/qq_33709582/article/details/113654386">demo</a></p>
<h2 id="什么是上下文切换">什么是上下文切换?<a hidden class="anchor" aria-hidden="true" href="#什么是上下文切换">#</a></h2>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。
概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换回这个任务时，可以再加载这个任务的状态。任务从保存到再加载的过程就是一次上下文切换。
上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。
Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<h2 id="什么是线程死锁如何避免死锁">什么是线程死锁?如何避免死锁?<a hidden class="anchor" aria-hidden="true" href="#什么是线程死锁如何避免死锁">#</a></h2>
<p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<h2 id="sleep-方法和-wait-方法区别">sleep() 方法和 wait() 方法区别<a hidden class="anchor" aria-hidden="true" href="#sleep-方法和-wait-方法区别">#</a></h2>
<ul>
<li>sleep是Thread的方法，wait是Object的方法。</li>
<li>sleep() 方法没有释放锁，而 wait() 方法释放了锁。</li>
<li>wait，notify和notifyAll只能在synchronized方法或者synchronized代码块里使用，而sleep可以在任何地方使用。</li>
<li>sleep必须捕获异常，而wait，notify和notifyAll不需要捕获异常。</li>
</ul>
<h2 id="调用-start-方法时会执行-run-方法为什么我们不能直接调用-run-方法">调用 start() 方法时会执行 run() 方法，为什么我们不能直接调用 run() 方法？<a hidden class="anchor" aria-hidden="true" href="#调用-start-方法时会执行-run-方法为什么我们不能直接调用-run-方法">#</a></h2>
<p>调用 start() 方法方可启动线程并使线程进入就绪状态，直接执行 run() 方法的话不会以多线程的方式执行。</p>
<h2 id="synchronized-关键字">synchronized 关键字<a hidden class="anchor" aria-hidden="true" href="#synchronized-关键字">#</a></h2>
<p>synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
即：保证原子性。</p>
<h2 id="如何使用-synchronized-关键字">如何使用 synchronized 关键字<a hidden class="anchor" aria-hidden="true" href="#如何使用-synchronized-关键字">#</a></h2>
<ul>
<li>修饰实例方法: 作用于当前对象实例加锁，进入同步代码前要获得 当前对象实例的锁</li>
<li>修饰静态方法: 也就是给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 当前 class 的锁。</li>
<li>修饰代码块 ：指定加锁对象，对给定对象/类加锁。</li>
</ul>
<h2 id="synchronized-关键字的底层原理">synchronized 关键字的底层原理<a hidden class="anchor" aria-hidden="true" href="#synchronized-关键字的底层原理">#</a></h2>
<p>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</p>
<p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。</p>
<p>不过两者的本质都是对对象监视器 monitor 的获取。</p>
<h2 id="synchronized-关键字和-volatile-关键字的区别">synchronized 关键字和 volatile 关键字的区别<a hidden class="anchor" aria-hidden="true" href="#synchronized-关键字和-volatile-关键字的区别">#</a></h2>
<p>synchronized 关键字和 volatile 关键字是两个互补的存在，而不是对立的存在。
volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized 关键字解决的是多个线程之间访问资源的同步性。</p>
<h2 id="threadlocal">ThreadLocal<a hidden class="anchor" aria-hidden="true" href="#threadlocal">#</a></h2>
<p>ThreadLocal类主要解决的就是让每个线程绑定自己的值，可以将ThreadLocal类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。
如果你创建了一个ThreadLocal变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是ThreadLocal变量名的由来。他们可以使用 get（） 和 set（） 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</p>
<p>最终的变量是放在了当前线程的 ThreadLocalMap 中，并不是存在 ThreadLocal 上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。 ThrealLocal 类中可以通过Thread.currentThread()获取到当前线程对象后，直接通过getMap(Thread t)可以访问到该线程的ThreadLocalMap对象。
每个Thread中都具备一个ThreadLocalMap，而ThreadLocalMap可以存储以ThreadLocal为 key ，Object 对象为 value 的键值对。</p>
<h2 id="threadlocal-内存泄露问题">ThreadLocal 内存泄露问题<a hidden class="anchor" aria-hidden="true" href="#threadlocal-内存泄露问题">#</a></h2>
<p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap 实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法。</p>
<h2 id="为什么要使用线程池">为什么要使用线程池？<a hidden class="anchor" aria-hidden="true" href="#为什么要使用线程池">#</a></h2>
<ul>
<li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统- 的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h2 id="实现-runnable-接口和-callable-接口的区别">实现 Runnable 接口和 Callable 接口的区别<a hidden class="anchor" aria-hidden="true" href="#实现-runnable-接口和-callable-接口的区别">#</a></h2>
<p>Runnable自 Java 1.0 以来一直存在，但Callable仅在 Java 1.5 中引入,目的就是为了来处理Runnable不支持的用例。**Runnable 接口不会返回结果或抛出检查异常，但是Callable 接口可以。所以，如果任务不需要返回结果或抛出异常推荐使用 **Runnable 接口，这样代码看起来会更加简洁。</p>
<h2 id="执行-execute方法和-submit方法的区别">执行 execute()方法和 submit()方法的区别<a hidden class="anchor" aria-hidden="true" href="#执行-execute方法和-submit方法的区别">#</a></h2>
<p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；
submit()方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h2 id="线程池threadpoolexecutor构造函数重要参数">线程池ThreadPoolExecutor构造函数重要参数<a hidden class="anchor" aria-hidden="true" href="#线程池threadpoolexecutor构造函数重要参数">#</a></h2>
<ul>
<li>corePoolSize : 核心线程数线程数</li>
<li>workQueue: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li>
<li>maximumPoolSize : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li>
<li>keepAliveTime:当线程池中的线程数量大于 corePoolSize 的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 keepAliveTime才会被回收销毁；</li>
<li>unit : keepAliveTime 参数的时间单位。</li>
<li>threadFactory : 创建线程的工厂</li>
<li>handler : 线程池满了之后的拒绝策略</li>
</ul>
<h2 id="介绍一下-atomic-原子类">介绍一下 Atomic 原子类<a hidden class="anchor" aria-hidden="true" href="#介绍一下-atomic-原子类">#</a></h2>
<p>原子性指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。
所谓原子类，就是具有原子/原子操作特征的类。</p>
<h2 id="aqs-了解么">AQS 了解么？<a hidden class="anchor" aria-hidden="true" href="#aqs-了解么">#</a></h2>
<p>AQS 的全称为（AbstractQueuedSynchronizer），这个类在java.util.concurrent.locks包下面。
AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>
<h1 id="网络">网络<a hidden class="anchor" aria-hidden="true" href="#网络">#</a></h1>
<h2 id="tcpip-网络模型有几层分别有什么用">TCP/IP 网络模型有几层？分别有什么用？<a hidden class="anchor" aria-hidden="true" href="#tcpip-网络模型有几层分别有什么用">#</a></h2>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>应用层-&gt;传输层-&gt;网络层-&gt;数据链路层-&gt;物理层
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><strong>1.应用层</strong>:我们能接触到的就是应用层了，手机，电脑这些这些设备都属于应用层。</li>
<li><strong>2.传输层</strong>:就是<strong>为应用层提供网络支持</strong>的，当设备作为接收⽅时，传输层则要负责把数据包传给应⽤，但是⼀台设备上可能会有很多应⽤在接收或者传输数据，因此需要⽤⼀个编号将应⽤区分开来，这个编号就是<strong>端⼝</strong>。所以 <strong>TCP 和 UDP 协议就是在这一层的</strong></li>
<li><strong>3.网络层</strong>:是<strong>负责传输数据的</strong>，最常使用的 ip 协议就在该层，⽹络层负责将数据从⼀个设备传输到另⼀个设备，世界上有很多设备，⽹络层需要有区分设备的编号。我们⼀般⽤ <strong>IP 地址</strong>给设备进⾏编号</li>
<li><strong>4.数据链路层</strong>:每⼀台设备的⽹卡都会有⼀个 MAC 地址，它就是⽤来唯⼀标识设备的。路由器计算出了下⼀个⽬的地 IP 地址，再通过 ARP 协议找到该⽬的地的 MAC 地址，这样就知道这个 IP 地址是哪个设备的了。路由器就是通过数据链路层来知道这个 ip 地址是属于哪个设备的，它主要<strong>为⽹络层提供链路级别传输的服务</strong>。</li>
<li><strong>5.物理层</strong>:当数据准备要从设备发送到⽹络的时候，需要把数据包转换成电信号，让其可以在物理介质中传输，它<strong>主要是为数据链路层提供⼆进制传输的服务</strong>。</li>
</ul>
<h2 id="简单介绍-http-协议">简单介绍 HTTP 协议<a hidden class="anchor" aria-hidden="true" href="#简单介绍-http-协议">#</a></h2>
<p>HTTP 协议是<strong>基于 TCP 协议</strong>实现的，它是一个<strong>超文本传输协议</strong>，其实就是一个简单的请求-响应协议，它<strong>指定了客户端可能发送给服务器什么样的消息以及得到什么样的响应</strong>。</p>
<p>它主要是<strong>负责点对点之间通信</strong>的。</p>
<p><strong>超文本</strong>就是用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本。比如说html，内部定义了很多图片视频的链接，放在浏览器上就呈现出了画面。</p>
<p><strong>协议</strong>就是约定俗称的东西，比如说 moon 要给读者送一本书，读者那里只接受顺丰快递，那么 moon 觉得可以，发快递的时候选择的顺丰，那么我们彼此之间共同约定好的就叫做协议。</p>
<p><strong>传输</strong>这个就很好理解了，比如刚才举的例子，将书发给读者，要通过骑车或者飞机的方式，传递的这个过程就是运输。</p>
<h2 id="get-和-post有什么区别">GET 和 POST有什么区别？<a hidden class="anchor" aria-hidden="true" href="#get-和-post有什么区别">#</a></h2>
<p>GET 和 POST 本质上就是 TCP 链接，并无差别。</p>
<p><strong>但是由于 HTTP 的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同。</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">区别</th>
<th style="text-align:center">GET</th>
<th style="text-align:right">POST</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">数据传输方式</td>
<td style="text-align:center">从服务器获取数据</td>
<td style="text-align:right">向服务器提交数据</td>
</tr>
<tr>
<td style="text-align:left">对数据长度的限制</td>
<td style="text-align:center">当发送数据时，GET 方法向 URL 添加数据；URL 的长度是受限制的（URL 的最大长度是 2048 个字符）</td>
<td style="text-align:right">无限制</td>
</tr>
<tr>
<td style="text-align:left">对数据类型的限制</td>
<td style="text-align:center">只允许 ASCII 字符</td>
<td style="text-align:right">无限制</td>
</tr>
<tr>
<td style="text-align:left">安全性</td>
<td style="text-align:center">较差，所发送的数据是 URL 的一部分，会显示在网页上</td>
<td style="text-align:right">较好 参数不会被保存在浏览器历史或 WEB 服务器日志中</td>
</tr>
<tr>
<td style="text-align:left">可见性</td>
<td style="text-align:center">显示在 URL 上</td>
<td style="text-align:right">不显示</td>
</tr>
<tr>
<td style="text-align:left">收藏为书签</td>
<td style="text-align:center">可以</td>
<td style="text-align:right">不可以</td>
</tr>
<tr>
<td style="text-align:left">历史记录</td>
<td style="text-align:center">可以被保留在历史记录当中</td>
<td style="text-align:right">不可以被保留</td>
</tr>
<tr>
<td style="text-align:left">缓存</td>
<td style="text-align:center">能被缓存</td>
<td style="text-align:right">不可以被缓存</td>
</tr>
</tbody>
</table>
<h2 id="ping-的作用">PING 的作用？<a hidden class="anchor" aria-hidden="true" href="#ping-的作用">#</a></h2>
<p>PING 主要的作用就是<strong>测试在两台主机之间能否建立连接</strong>，如果 PING 不通就无法建立连接。</p>
<p>它其实就是向目的主机发送多个 ICMP 回送请求报文</p>
<ul>
<li>如果没有响应则无法建立连接</li>
<li>如果有响应就可以根据目的主机返回的回送报文的时间和成功响应的次数估算出数据包<strong>往返时间及丢包率</strong></li>
</ul>
<h2 id="常见的-http-状态码有哪些">常见的 HTTP 状态码有哪些<a hidden class="anchor" aria-hidden="true" href="#常见的-http-状态码有哪些">#</a></h2>
<table>
<thead>
<tr>
<th style="text-align:left">1xx</th>
<th style="text-align:center">信息，服务器收到请求，需要请求者继续执行操作</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2xx</td>
<td style="text-align:center">成功，操作被成功接收并处理</td>
</tr>
<tr>
<td style="text-align:left">3xx</td>
<td style="text-align:center">重定向，需要进一步的操作以完成请求</td>
</tr>
<tr>
<td style="text-align:left">4xx</td>
<td style="text-align:center">客户端错误，请求包含语法错误或无法完成请求</td>
</tr>
<tr>
<td style="text-align:left">5xx</td>
<td style="text-align:center">服务器错误，服务器在处理请求的过程中发生了错误</td>
</tr>
</tbody>
</table>
<h2 id="http11-和-http10-的区别有哪些">HTTP1.1 和 HTTP1.0 的区别有哪些？<a hidden class="anchor" aria-hidden="true" href="#http11-和-http10-的区别有哪些">#</a></h2>
<ul>
<li>
<p>1.<strong>长链接</strong></p>
</li>
<li>
<ul>
<li>早期 HTTP1.0 的每一次请求都伴随着一次三次握手的过程，并且是<strong>串行的请求</strong>，增加了不必要的性能开销</li>
<li>HTTP1.1 <strong>新增了长链接</strong>的通讯方式，减少了性能损耗</li>
</ul>
</li>
<li>
<p>2.<strong>管道</strong></p>
</li>
<li>
<ul>
<li>HTTP1.0 只有串行发送，没有管道</li>
<li>HTTP1.1 增加了<strong>管道</strong>的概念，使得在同一个 TCP 链接当中可以同时发出多个请求</li>
</ul>
</li>
<li>
<p>3.<strong>断点续传</strong></p>
</li>
<li>
<ul>
<li>HTTP1.0 <strong>不支持断点续传</strong></li>
<li>HTTP1.1 新增了 <strong>range</strong> 字段，用来指定数据字节位置，开启了断点续传的时代</li>
</ul>
</li>
<li>
<p>4.<strong>Host头处理</strong></p>
</li>
<li>
<ul>
<li>HTTP1.0 任务主机只有一个节点，所以并<strong>没有传 HOST</strong></li>
<li>HTTP1.1 时代，虚拟机技术越来越发达，一台机器上也有可能有很多节点，故<strong>增加了 HOST 信息</strong></li>
</ul>
</li>
<li>
<p>5.<strong>缓存处理</strong></p>
</li>
<li>
<ul>
<li>在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准</li>
<li>HTTP1.1则<strong>引入了更多的缓存控制策略</strong>例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li>
</ul>
</li>
<li>
<p>6.<strong>错误状态响应码</strong></p>
</li>
<li>
<ul>
<li>在HTTP1.1中<strong>新增了24个错误状态响应码</strong>，如410（Gone）表示服务器上的某个资源被永久性的删除等。</li>
</ul>
</li>
</ul>
<h2 id="https-和-http-的区别是什么">HTTPS 和 HTTP 的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#https-和-http-的区别是什么">#</a></h2>
<ul>
<li>
<p>1.<strong>SSL安全协议</strong></p>
</li>
<li>
<ul>
<li>HTTP 是超⽂本传输协议，信息是<strong>明⽂传输</strong>，存在安全⻛险的问题。</li>
<li>HTTPS 则解决 HTTP 不安全的缺陷，在TCP 和 HTTP ⽹络层之间加⼊了 SSL/TLS 安全协议，使得报⽂能够<strong>加密传输</strong>。</li>
</ul>
</li>
<li>
<p>2.<strong>建立连接</strong></p>
</li>
<li>
<ul>
<li>HTTP 连接建⽴相对简单， TCP **三次握⼿**之后便可进⾏ HTTP 的报⽂传输。</li>
<li>HTTPS 在 TCP **三次握⼿<strong>之后，还需进⾏ <strong>SSL/TLS</strong> 的</strong>握⼿**过程，才可进⼊加密报⽂传输。</li>
</ul>
</li>
<li>
<p>3.<strong>端口号</strong></p>
</li>
<li>
<ul>
<li>HTTP 的端⼝号是 <strong>80</strong>。</li>
<li>HTTPS 的端⼝号是 <strong>443</strong>。</li>
</ul>
</li>
<li>
<p>4.<strong>CA证书</strong></p>
</li>
<li>
<ul>
<li><strong>HTTPS 协议需要向 CA（证书权威。机构）申请数字证书</strong>来保证服务器的身份是可信的。</li>
</ul>
</li>
</ul>
<h2 id="http2-和-http11-的区别是什么">HTTP2 和 HTTP1.1 的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#http2-和-http11-的区别是什么">#</a></h2>
<ul>
<li>
<p>1.<strong>头部压缩</strong></p>
</li>
<li>
<ul>
<li>在 HTTP2 当中，如果你发出了<strong>多个请求</strong>，并且它们的<strong>头部(header)是相同的</strong>，那么 HTTP2 协议会帮你<strong>消除同样的部分</strong>。(其实就是在客户端和服务端维护一张索引表来实现)</li>
</ul>
</li>
<li>
<p>2.<strong>二进制格式</strong></p>
</li>
<li>
<ul>
<li>HTTP1.1 采用<strong>明文</strong>的形式</li>
<li>HTTP/2 全⾯采⽤了**⼆进制格式**，头信息和数据体都是⼆进制</li>
</ul>
</li>
<li>
<p>3.<strong>数据流</strong></p>
</li>
<li>
<ul>
<li>HTTP/2 的数据包不是按顺序发送的，同⼀个连接⾥⾯连续的数据包，可能属于不同的回应。(对数据包做了标记，标志其属于哪一个请求，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。<strong>客户端还可以指定数据流的优先级</strong>，优先级⾼的请求，服务器就先响应该请求)</li>
</ul>
</li>
<li>
<p>4.<strong>IO多路复用</strong></p>
</li>
<li>
<ul>
<li>如:在⼀个连接中，服务器收到了客户端 A 和 B 的两个请求，但是发现在处理 A 的过程中⾮常耗时，索性就先回应 A 已经处理好的部分，再接着回应 B 请求，最后再回应 A 请求剩下的部分。</li>
<li>HTTP/2 可以<strong>在⼀个连接中并发多个请求或回应</strong>。</li>
</ul>
</li>
<li>
<p>5.<strong>服务器推送</strong></p>
</li>
<li>
<ul>
<li>服务器可以主动向客户端发送请求</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="http3-和-http2-的区别是什么">HTTP3 和 HTTP2 的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#http3-和-http2-的区别是什么">#</a></h2>
<ul>
<li>
<p>1.<strong>协议不同</strong></p>
</li>
<li>
<ul>
<li>HTTP2 是基于 <strong>TCP</strong> 协议实现的</li>
<li>HTTP3 是基于 <strong>UDP</strong> 协议实现的</li>
</ul>
</li>
<li>
<p>2.<strong>QUIC</strong></p>
</li>
<li>
<ul>
<li><strong>HTTP3 新增了 QUIC 协议</strong>来实现可靠性的传输</li>
</ul>
</li>
<li>
<p>3.<strong>握手次数</strong></p>
</li>
<li>
<ul>
<li>HTTP2 是基于 HTTPS 实现的，建立连接需要先进行 TCP 3次握手，然后再进行 TLS 3次握手，<strong>总共6次握手</strong></li>
<li>HTTP3 只需要 QUIC 的<strong>3次握手</strong></li>
</ul>
</li>
</ul>
<h2 id="tcp-建立连接的过程是怎样的">TCP 建立连接的过程是怎样的？<a hidden class="anchor" aria-hidden="true" href="#tcp-建立连接的过程是怎样的">#</a></h2>
<ul>
<li>第一次握手:A 的 TCP 进程创建一个 传输控制块 TCB ，然后向 B 发出连接请求报文段。之后将同步位 <strong>SYN 设置为 1</strong>，同时选择一个初始序列号 <strong>seq=x</strong>，这时客户端 A 进入到 <strong>SYN-SENT（同步已发送</strong>）状态。</li>
<li>第二次握手:B 收到连接请求报文段，如果同意建立连接，则向 A 发送确认。在确认报文段中 <strong>同步位 SYN=1、确认位 ACK=1、确认号 ack=x+1</strong>，同时也为自己选择一个初始序列号 <strong>seq=y</strong>，这时服务器 B 进入 SYN-RCVID 状态。</li>
<li>第三次握手:A 收到 B 的确认以后，再向 B 发出确认。确认报文 <strong>ACK=1、确认号ack=y+1</strong>。这时A进入到 ESTAB-LISHED 状态。<strong>当B接收到A的确认后，也进入 ESTAB-LISHED 状态。连接建立完成</strong></li>
</ul>
<h2 id="为什么是三次握手">为什么是三次握手？<a hidden class="anchor" aria-hidden="true" href="#为什么是三次握手">#</a></h2>
<ul>
<li>
<p>1.为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误</p>
</li>
<li>
<ul>
<li>如果客户端连续发送多次 SYN 建⽴连接的报⽂，如果出现了<strong>网络拥堵</strong>，可能会有<strong>旧连接先于新连接到达</strong>的情况，就可能会出现<strong>连接覆盖</strong>，要避免这种情况，最少需要三次握手</li>
</ul>
</li>
<li>
<p>2.三次握⼿正好避免资源浪费</p>
</li>
<li>
<ul>
<li>三次握⼿就已经是理论上<strong>建立可靠连接的最小次数</strong>了，所以不需要更多的连接</li>
</ul>
</li>
<li>
<p>3.同步双⽅初始序列号</p>
</li>
<li>
<ul>
<li>同步序列号(可以鉴别重复数序，按序接受等)其实并不要三次握手，只要一来一回两次就可以了</li>
</ul>
</li>
<li></li>
</ul>
<h2 id="tcp-断开连接的过程是怎样的">TCP 断开连接的过程是怎样的？<a hidden class="anchor" aria-hidden="true" href="#tcp-断开连接的过程是怎样的">#</a></h2>
<ul>
<li>
<p>第一次挥手:A 先发送连接释放报文段，段首部的终止控制位 <strong>FIN=1</strong>，序号<strong>seq=u</strong>（等于<strong>A前面发送数据的最后一个序号加1</strong>）；然后 A 进入 FIN-WAIT-1（终止等待1）状态，等待 B 的确认。</p>
</li>
<li>
<p>第二次挥手:B 收到 A 的连接释放报文段后，立刻发出确认报文段，确认号 <strong>ack=u+1</strong>，序号 <strong>seq=v</strong>（等于 <strong>B 前面发送数据的最后一个序号加1</strong>）；然后 B 进入 CLOSE-WAIT（关闭等待）状态。</p>
</li>
<li>
<p>第三次挥手:A 收到 B 的确认报文段后进入到 FIN-WAIT-2（终止等待2）状态，继续等待 B 发出连接释放报文段；</p>
</li>
<li>
<ul>
<li>若 B 已经没有数据要发送，B 就会向 A 发送连接释放报文段，段首部的终止控制位 <strong>FIN=1</strong>，序号 <strong>seq=w</strong>（半关闭状态可能又发送了一些数据），确认号 <strong>ack=u+1</strong>，这时B进入 <strong>LAST-ACK</strong>（最后确认）状态，等待A的确认。</li>
</ul>
</li>
<li>
<p>第四次挥手:A收到B的连接释放报文段并发出确认，确认段中 确认位 <strong>ACK=1</strong>，确认号 <strong>ack=w+1</strong>，序号 <strong>seq=u+1</strong>；然后 A 进入到<strong>TIME-WAIT</strong>（时间等待）状态。当 B 再接收到该确认段后，B 就进入 <strong>CLOSED</strong> 状态。</p>
</li>
</ul>
<h2 id="第四次挥手为什么要等待2msl60s">第四次挥手为什么要等待2MSL(60s)<a hidden class="anchor" aria-hidden="true" href="#第四次挥手为什么要等待2msl60s">#</a></h2>
<p>首先 2MSL 的时间是从客户端(A)接收到 <strong>FIN 后发送 ACK 开始计时</strong>的。如果<strong>在 TIME-WAIT 时间内</strong>，因为客户端(A)的 ACK <strong>没有传输</strong>到服务端(B)，客户端(A)又接收到了服务端(B)重发的 FIN 报文，那么 2MSL <strong>时间会被重置</strong>。等待 2MSL 原因如下</p>
<ul>
<li>
<p>1.<strong>得原来连接的数据包消失</strong></p>
</li>
<li>
<ul>
<li>1）如果B没有收到自己的ACK，会超时重传FiN那么A再次接到重传的FIN，会再次发送ACK</li>
<li>2）如果B收到自己的ACK，也不会再发任何消息，</li>
<li>在最后一次挥手后 A 并不知道 B 是否接到自己的 信息</li>
</ul>
</li>
</ul>
<p>包括 ACK 是以上哪两种情况，A 都需要等待，要取这两种情况等待时间的最大值，以应对最坏的情况发生，这个最坏情况是：去向ACK消息最大存活时间（MSL) + 来向FIN消息的最大存活时间(MSL)。这刚好是2MSL，这个时间，足以<strong>使得原来连接的数据包在网络中消失</strong>。</p>
<ul>
<li>
<p>2.<strong>保证 ACK 能被服务端接收到从而正确关闭链接</strong></p>
</li>
<li>
<ul>
<li>因为这个 ACK 是有可能丢失的，会导致服务器收不到对 FIN-ACK 确认报文。假设客户端不等待 2MSL ，而是在发送完 ACK 之后直接释放关闭，一但这个 ACK 丢失的话，服务器就<strong>无法正常的进入关闭连接状态</strong>。</li>
</ul>
</li>
</ul>
<h2 id="为什么是四次挥手">为什么是四次挥手？<a hidden class="anchor" aria-hidden="true" href="#为什么是四次挥手">#</a></h2>
<p>因为 tcp 可以在发送数据的同时也能接受数据，要实现可靠的连接关闭，A 发出结束报文 FIN，收到 B 确认后 A 知道自己没有数据需要发送了，B 知道 A 不再发送数据了，自己也不会接收数据了，<strong>但是此时 A 还是可以接收数据，B 也可以发送数据</strong>；当 B 发出 FIN 报文的时候此时两边才会真正的断开连接，读写分开。</p>
<h2 id="tcp-滑动窗是什么">TCP 滑动窗⼝是什么？<a hidden class="anchor" aria-hidden="true" href="#tcp-滑动窗是什么">#</a></h2>
<p>TCP 是<strong>每发送⼀个数据，都要进⾏⼀次确认应答</strong>。只有上一个收到了回应才发送下一个，这样<strong>效率会非常低</strong>，因此<strong>引进了滑动窗口</strong>的概念.</p>
<p>其实就是在发送方<strong>设立一个缓存区间</strong>，将已发送但未收到确认的消息<strong>缓存</strong>起来，<strong>假如一个窗口可以发送 5 个 TCP 段</strong>，那么发送方就可以连续发送 5 个 TCP 段，然后就会将这 5 个 TCP 段的数据缓存起来，这 5 个 TCP 段是有序的，只要后面的消息收到了 ACK ，那么不管前面的是否有收到 ACK,都代表成功，<strong>窗⼝⼤⼩是由接收方决定的</strong>。</p>
<p>窗⼝⼤⼩就是指<strong>不需要等待应答，还可以发送数据的大小</strong>。</p>
<h2 id="发送方一直发送数据但是接收方处理不过来怎么办流量控制">发送方一直发送数据，但是接收方处理不过来怎么办？（流量控制）<a hidden class="anchor" aria-hidden="true" href="#发送方一直发送数据但是接收方处理不过来怎么办流量控制">#</a></h2>
<p>如果接收方处理不过来，发送方就会触发重试机制再次发送数据，然而这个是有性能损耗的，为了解决这个问题，TCP 就提出了流量控制，为的就是<strong>让发送方知道接受方的处理能力</strong>。</p>
<p>也就是说，每次接收方接受到数据后会<strong>将剩余可处理数据的大小告诉发送方</strong>。</p>
<p>比如接受方滑动窗口可用大小为400字节，发送方发送过来100字节的数据，那么接收方剩余可用滑动窗口大小就为300字节，这是发送方就知道下次返送数据的大小范围了。</p>
<p>但是这里有一个问题，数据会存放在缓冲区，但是这个<strong>缓冲区是操作系统控制的，当系统繁忙的时候，会缩减缓冲区减小，可能就会造成丢包的问题</strong>。</p>
<p>如: 发送方接收方窗口大小各为200字节，发送方发送100字节的给接收方，此时双方各剩100字节，但是此时操作系统非常忙，将接收方的缓存区减少了50字节，这时接收方就会告诉发送方，我还有50字节可用，但是在接收方发送到达之前，发送方是不知道的，只会看到自己还有100字节可用，那么就继续发送数据，如果发送了80字节数据，那么接收方缓存区大小为50字节，就会丢失30字节的数据，也就是会发生丢包现象。</p>
<p>我们会发现，这个问题发生的原因就是减少了缓存，又收缩了窗口大小，所以 TCP 是**不允许同时减少缓存⼜收缩窗⼝**的。</p>
<h2 id="tcp-半连接队列和全连接队列是什么">TCP 半连接队列和全连接队列是什么？<a hidden class="anchor" aria-hidden="true" href="#tcp-半连接队列和全连接队列是什么">#</a></h2>
<p>服务端收到客户端发出的 SYN 请求后，会把这个连接信息存储到<strong>半链接队列(SYN 队列)</strong>。</p>
<p>服务端收到第三次握⼿的 ACK 后，内核会把连接从半连接队列移除，然后创建新的完全的连接，并将其添加到<strong>全连接队列</strong>(accept 队列)，等待进程调⽤ accept 函数时把连接取出来。</p>
<p>这两个队列都是有大小限制的，当超过容量后就会将链接丢弃，或者返回 RST 包。</p>
<h2 id="粘包拆包是怎么发生的怎么解决这个问题">粘包/拆包是怎么发生的？怎么解决这个问题？<a hidden class="anchor" aria-hidden="true" href="#粘包拆包是怎么发生的怎么解决这个问题">#</a></h2>
<p>TCP 发送数据时会根据 TCP 缓冲区的实际情况进行包的划分，一个完整的包<strong>可能会被 TCP 拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送</strong>，这就是 TCP 粘包和拆包问题。</p>
<p>发生 TCP <strong>粘包</strong>的<strong>原因</strong>:</p>
<ul>
<li>1.<strong>发送的数据小于 TCP 缓冲区大小</strong>，TCP将缓冲区中的数据(数据属于多条业务内容)一次发送出去可能就会发生粘包。</li>
<li>2.接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</li>
</ul>
<p>发生 TCP <strong>拆包</strong>的<strong>原因</strong>:</p>
<ul>
<li>1.<strong>待发送数据大于最大报文长度</strong>，TCP 在传输前将进行拆包。</li>
<li>2.<strong>发送的数据大于 TCP 发送缓冲区剩余空间大小</strong>，将会发生拆包。</li>
</ul>
<p><strong>解决方案</strong>:</p>
<ul>
<li>1.<strong>发送端给每个数据包添加包首部</strong>，首部中包含数据包的长度，这样接收端在接收到数据后，通过该字段就可以知道每个数据包的实际长度了。</li>
<li>2.发送端将每个数据包<strong>设置固定长度</strong>，这样接收端每次从读取固定长度的数据把每个数据包拆分开。</li>
<li>3.可以在数据包之间<strong>设置边界</strong>，如添加特殊符号，接收端可以通过这个特殊符号来拆分包。</li>
</ul>
<h2 id="浏览器地址栏输入网站按回车后发生了什么">浏览器地址栏输入网站按回车后发生了什么？<a hidden class="anchor" aria-hidden="true" href="#浏览器地址栏输入网站按回车后发生了什么">#</a></h2>
<ul>
<li>1:<strong>解析网址</strong>,生成 HTTP 请求信息</li>
<li>2:根据 DNS 服务器<strong>查询真实请求的 IP 地址</strong>，如果本地服务器有缓存则直接返回</li>
<li>3:得到了 IP 以后，向服务器<strong>发送 TCP 连接</strong>，TCP 连接经过三次握手。</li>
<li>4:接受 TCP 报文后，对<strong>连接进行处理</strong>，对 HTTP 协议解析</li>
<li>5:服务器<strong>返回响应</strong></li>
<li><strong>6:浏览器*<em>接受响应，显示页面，渲染页面*</em></strong></li>
</ul>
<h1 id="解决方案">解决方案<a hidden class="anchor" aria-hidden="true" href="#解决方案">#</a></h1>
<h2 id="分布式事务">分布式事务<a hidden class="anchor" aria-hidden="true" href="#分布式事务">#</a></h2>
<p><a href="https://blog.csdn.net/crazymakercircle/article/details/109459593">参考</a></p>
<h3 id="两阶段提交2pc">两阶段提交（2PC）<a hidden class="anchor" aria-hidden="true" href="#两阶段提交2pc">#</a></h3>
<p>两阶段提交（Two-phase Commit，2PC），通过引入协调者（Coordinator）来协调参与者的行为，并最终决定这些参与者是否要真正执行事务。</p>
<ol>
<li>准备阶段
协调者询问参与者事务是否执行成功，参与者发回事务执行结果。</li>
<li>提交阶段
如果事务在每个参与者上都执行成功，事务协调者发送通知让参与者提交事务；否则，协调者发送通知让参与者回滚事务。
需要注意的是，在准备阶段，参与者执行了事务，但是还未提交。只有在提交阶段接收到协调者发来的通知后，才进行提交或者回滚。</li>
</ol>
<p>存在的问题：</p>
<ul>
<li>同步阻塞：所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。</li>
<li>单点问题：协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。</li>
<li>数据不一致 在阶段二，如果协调者只发送了部分 Commit 消息，此时网络发生异常，那么只有部分参与者接收到 Commit 消息，也就是说只有部分参与者提交了事务，使得系统数据不一致。</li>
<li>太过保守 任意一个节点失败就会导致整个事务失败，没有完善的容错机制。</li>
</ul>
<p>三阶段提交（3PC）（略）</p>
<h3 id="补偿事务tcc">补偿事务（TCC）<a hidden class="anchor" aria-hidden="true" href="#补偿事务tcc">#</a></h3>
<p>TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p>
<ul>
<li>Try 阶段主要是对业务系统做检测及资源预留</li>
<li>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li>
<li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。</li>
</ul>
<p>举个例子，假入 张三 要向 李四 转账，思路大概是： 我们有一个本地方法，里面依次调用</p>
<ul>
<li>首先在 Try 阶段，要先调用远程接口把 Smith 和 Bob 的钱给冻结起来。</li>
<li>在 Confirm 阶段，执行远程调用的转账的操作，转账成功进行解冻。</li>
<li>如果第2步执行成功，那么转账成功，如果第二步执行失败，则调用远程冻结接口对应的解冻方法 (Cancel)。</li>
</ul>
<p>优点： 跟2PC比起来，实现以及流程相对简单了一些，但数据的一致性比2PC也要差一些
缺点： 缺点还是比较明显的，在2,3步中都有可能失败。TCC属于应用层的一种补偿方式，所以需要程序员在实现的时候多写很多补偿的代码，在一些场景中，一些业务流程可能用TCC不太好定义及处理。</p>
<h3 id="标准答案-如何解决分布式事务问题的">标准答案: 如何解决分布式事务问题的？<a hidden class="anchor" aria-hidden="true" href="#标准答案-如何解决分布式事务问题的">#</a></h3>
<p>使用的是阿里的Seata。Seata AT模式和Seata TCC是在生产中最常用。</p>
<h4 id="强一致性场景">强一致性场景<a hidden class="anchor" aria-hidden="true" href="#强一致性场景">#</a></h4>
<p>对于那些特别严格的场景，用的是Seata AT模式来保证强一致性，如电商交易交易中的库存和订单、优惠券。</p>
<h4 id="弱一致性场景">弱一致性场景<a hidden class="anchor" aria-hidden="true" href="#弱一致性场景">#</a></h4>
<p>对于数据一致性要求不严格、或者由不同系统执行子事务的场景，可以使用Seata TCC 保障弱一致性方案。如电商订单支付服务，发送成功支付成功消息。</p>
<h4 id="最终一致性场景">最终一致性场景<a hidden class="anchor" aria-hidden="true" href="#最终一致性场景">#</a></h4>
<p>基于可靠消息的最终一致性，各个子事务可以较长时间内异步，但数据绝对不能丢的场景。
可以使用基于MQ的<code>异步确保型事务</code>，比如电商平台的通知支付结果：</p>
<ul>
<li>积分服务：增加积分</li>
<li>消费服务：生成消费记录</li>
</ul>
<h2 id="秒杀系统设计包含如何防止超卖">秒杀系统设计（包含如何防止超卖）<a hidden class="anchor" aria-hidden="true" href="#秒杀系统设计包含如何防止超卖">#</a></h2>
<p>现在的电商系统功能繁多，除了最基本的购买商品功能，还有物流跟踪，订单管理，社区交互等功能。不过面试中关注的主要是购买商品功能，我们将其他次要功能归类为其他业务功能，购买商品流程如下：</p>
<ol>
<li>客户通过客户端下单</li>
<li>如果下单成功则进入支付阶段，否则返回购买失败</li>
<li>进入支付阶段后，如果在一定时间内支付成功则返回购买成功，否则返回购买失败</li>
</ol>
<h3 id="从-0-到-1000">从 0 到 1000<a hidden class="anchor" aria-hidden="true" href="#从-0-到-1000">#</a></h3>
<p>想象你自己从零搭建一个电商平台，一开始平台里的商品种类以及日订单量都较少，商品种类有 100 款，日订单量只有 1000 条。根据以上信息，我们可以设计出架构 1：</p>
<ul>
<li>客户端发送下单请求给服务端</li>
<li>服务端查询数据库
<ul>
<li>若该商品库存大于零，将库存减一并且返回下单成功</li>
<li>若该商品库存等于零的话，返回下单失败</li>
</ul>
</li>
</ul>
<p>架构 1 简单直观，它忽略了系统可用性以及可扩展性，但在日订单量少，不会出现多位客户对同一件商品同时下单的情况下，它很好地完成了我们需要的功能。</p>
<h3 id="从-1000-到-100万">从 1000 到 100万<a hidden class="anchor" aria-hidden="true" href="#从-1000-到-100万">#</a></h3>
<p>经过一段时间后，你的电商平台商品种类增加到 1 万款，日订单量飙升到 100 万条，而且在高峰期，例如晚饭后，睡觉前的订单量会特别多。这是一个好的消息，不过同时你发现了一个问题，某些商品的成功下单量要大于库存量，也就是说出现了商品超卖的情况。这可是个严重的问题，因为没办法及时交货给客户对电商平台的信誉有极大影响。仔细分析架构 1 后，我们发现了问题的根源：当商品库存只剩下 1 件而有多位客户同时下单的时候，每个下单请求在查询的时候都发现库存大于零，并且将库存减 1 返回下单成功。下图中，在库存只有 1 件的时候，两个请求却都返回下单成功。
<img loading="lazy" src="/posts/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/1.png"></p>
<p>幸运的是，我们知道大部分并发问题都可以通过锁机制或者队列服务来解决：</p>
<h4 id="悲观锁">悲观锁<a hidden class="anchor" aria-hidden="true" href="#悲观锁">#</a></h4>
<p>我们可以观察到，超卖问题的原因在于事务查询和更新库区期间，库存已经被其他事务修改了。在学习悲观锁之前，我们先了解下什么是两阶段加锁，两阶段加锁是一个典型的悲观锁策略：
我们的电商系统中可以应用两阶段加锁，由于下单请求涉及到修改库存，可以先使用排他锁锁定记录，防止被其他事务所修改。大部分关系型数据库都提供这种功能（在 MySQL 和 PostgresSQL 里面的语法是 SELECT … FOR 下UPDATE）。流程如下图：
<img loading="lazy" src="/posts/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/2.png"></p>
<ol>
<li>蓝色请求先获取排他锁，查询和更新库存，在此期间黑色请求等待获取排他锁。</li>
<li>蓝色请求更新库存后释放排他锁，返回下单成功</li>
<li>黑色请求获取排他锁，发现库存为 0，释放排他锁，返回下单失败</li>
</ol>
<p>我们可以看到悲观锁成功解决了商品超卖问题，不过它的缺点也比较明显：
1）处理性能不高，当一件商品有多位客户同时下单的时候，每个请求需要等待排他锁，也要较长才知道是否下单成功。
2）容易发生死锁：在实际工程中，下单操作不只涉及了库存修改，还可能涉及其他业务功能，由于悲观锁下每个请求都轮流持有锁，应用层的代码处理不好的话会更容易发生死锁。</p>
<h4 id="乐观锁">乐观锁<a hidden class="anchor" aria-hidden="true" href="#乐观锁">#</a></h4>
<p>和悲观锁不同，乐观锁策略下事务会记录下查询时的版本号，当事务准备更新库存的时候，如果此时的版本号与查询时的版本号不同，则代表库存被其他事务修改了，这时候就会回滚事务，流程如下图：
<img loading="lazy" src="/posts/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/3.png"></p>
<ol>
<li>蓝色请求与黑色请求查询库存，并记录库存版本号</li>
<li>蓝色请求先更新库存为 0，返回下单成功</li>
<li>黑色请求更新前发现版本与之前版本号不同，回归事务，返回下单失败</li>
</ol>
<h4 id="分布式锁">分布式锁<a hidden class="anchor" aria-hidden="true" href="#分布式锁">#</a></h4>
<p>分布式锁在服务端以及数据库之间加上分布式组件来保证请求的并发安全，国内较常使用 Redis 或者 ZooKeeper。和悲观锁类似，每个请求需要先从组件中获取分布式锁之后才可以继续执行。流程如下图：
<img loading="lazy" src="/posts/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/4.png"></p>
<ol>
<li>蓝色请求先获取分布式锁，查询和更新库存，在此期间黑色请求等待获取分布式锁</li>
<li>蓝色请求更新库存后释放分布式锁，返回下单成功</li>
<li>黑色请求获取分布式锁，查询库存，发现库存为 0，释放分布式锁，返回下单失败</li>
</ol>
<p>分布式锁的优点是将功能进行分离，分布式组件负责解决并发安全的问题，数据库负责数据存储。不过缺点在于</p>
<ul>
<li>分布式锁的正确实现并不简单，错误的实现方式容易引起其他一致性的问题。</li>
<li>分布式锁在高并发下也会产生锁竞争的问题，性能不佳。</li>
<li>由于引入了新的组件，要考虑分布式组件的可靠性，以及崩溃之后的恢复机制。</li>
</ul>
<h4 id="消息队列">消息队列<a hidden class="anchor" aria-hidden="true" href="#消息队列">#</a></h4>
<p>另一个直观的解决方法就是使用消息队列，确保每个商品每个时刻只有一个请求，流程如下图：
<img loading="lazy" src="/posts/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/5.png"></p>
<ol>
<li>蓝色请求进入队列，黑色请求进入队列，数据库订阅下单请求</li>
<li>数据库处理蓝色请求，蓝色请求查询和更新库存，返回下单成功</li>
<li>数据库处理黑色请求，查询库存，发现库存为 0，返回下单失败</li>
</ol>
<p>消息队列的优点对业务进行了解耦，除了数据库之外，其他对下单请求感兴趣的业务系统，例如数据分析，日志记录等都可以订阅下单请求的消息。缺点在于</p>
<ul>
<li>因为消息队列可能会崩溃，消息发送也可能失败，所以要考虑消息只消费一次，不会因为重复消费导致重复下单。</li>
<li>由于引入了新的组件，要考虑消息队列的可靠性，以及崩溃之后的恢复机制。</li>
</ul>
<h3 id="从电商系统到秒杀系统">从电商系统到秒杀系统<a hidden class="anchor" aria-hidden="true" href="#从电商系统到秒杀系统">#</a></h3>
<p>秒杀系统和电商系统有两个核心区别：</p>
<ul>
<li>双十一也有极大的流量，但是双十一的商品种类很多，所以流量会分布到不同的商品中。而秒杀系统中，商品的种类和库存都比较少，导致大部分流量集中在少量商品中。</li>
<li>秒杀系统由于商品稀缺，价值高。同一位客户可能会对同一商品多次提交下单请求，而且恶意刷单的请求比较多，所以系统接收到的无效请求及非法请求较多。</li>
</ul>
<p>针对这两个区别，我们发现上边的架构3个潜在问题：</p>
<ul>
<li>当一款商品库存只有 10 件却有 1 万名用户下单的时候，只有前 10 名客户可以下单成功，其他用户都浪费时间在队列等待以及无意义地查询库存，既牺牲了用户体验也增加了消息队列以及数据库的压力。</li>
<li>由于库存过少，有大量的请求（例如非法用户的请求，超过秒杀活动开始一定时间的请求）其实是没有机会抢到商品的，所以没有必要到达服务器，更不用说数据库了。</li>
<li>大量的客户端在下单前同时请求同一个商品的秒杀页面，导致服务器压力骤升。</li>
</ul>
<p>针对这三个问题我们可以考虑两个方案：流量控制和资源隔离。</p>
<h4 id="流量限制">流量限制<a hidden class="anchor" aria-hidden="true" href="#流量限制">#</a></h4>
<p>第三个问题相对简单，可以将秒杀页面使用 CDN 缓存起来，客户端就可以直接从 CDN 获取到秒杀页面，不需要重复请求服务器。另外两个问题可以通过流量限制来解决，如下三种方案。</p>
<h5 id="限流器分为前端限流与后端限流">限流器（分为前端限流与后端限流：）<a hidden class="anchor" aria-hidden="true" href="#限流器分为前端限流与后端限流">#</a></h5>
<ul>
<li>前端限流包括验证答题，防止重复点击按钮等常见机制。</li>
<li>后端限流使用限流算法进行流量限制，简单情况下可以使用固定限流算法，例如秒杀商品的库存是 10 件，只要限流器接收到 10 * k（k 可以根据业务进行调整）个请求之后，就停止接受该商品的所有请求。这样无论有多少个下单请求，最终到达服务器的单个商品请求数量都不超过 10 * k。实际工程中，因为有客户可能会出现支付超时导致释放库存的情况，系统需要通知限流器接受新的请求。</li>
</ul>
<h5 id="负载均衡">负载均衡<a hidden class="anchor" aria-hidden="true" href="#负载均衡">#</a></h5>
<p>负载均衡负责将下单请求通过负载均衡算法转发到最合适的服务器。</p>
<h5 id="安全验证组件分为前端安全验证以及后端安全验证">安全验证组件（分为前端安全验证以及后端安全验证：）<a hidden class="anchor" aria-hidden="true" href="#安全验证组件分为前端安全验证以及后端安全验证">#</a></h5>
<ul>
<li>后端安全验证包括黑名单校验，IP 地址校验等机制。</li>
<li>前端安全验证包括：客户端账户验证（确保客户有资格参考秒杀活动），客户端版本安全验证（防止反编译以及修改客户端代码），秒杀接口动态生成（防止使用刷单脚本）等机制。</li>
</ul>
<p>此时系统的整体架构如下：
客户端-&gt;限流器(或另外两种)-&gt;服务端-&gt;消息队列-&gt;数据库</p>
<h4 id="热门资源隔离">热门资源隔离<a hidden class="anchor" aria-hidden="true" href="#热门资源隔离">#</a></h4>
<p>大部分流量集中在少量商品中，我们可以针对这些商品进行特殊处理。
这样既可以防止秒杀活动影响其他业务功能，也可以针对热门商品进行资源分配。
首先我们需要识别出热门商品，这里有两种常见的方法：</p>
<ul>
<li>静态识别：包括京东在内的一些电商平台，客户在参加秒杀活动之前需要先进行预约，只有预约过的客户才能参考秒杀活动。这样系统可以提早识别热门商品以及进行流量预估。</li>
<li>动态识别：通过实时数据分析系统在秒杀活动前统计出现在较多客户浏览的热门商品，针对预估结果进行资源分配。</li>
</ul>
<p>识别出热门商品之后，我们可以将热门商品的资源进行隔离，并且设置独立的策略，例如：</p>
<ul>
<li>使用特殊的限流器，由于秒杀系统的库存很少，在下单请求开始阶段就可以随机丢弃大部分请求。</li>
<li>使用单独的数据库，在架构 2 中，下单请求的处理速度受限于消费者的处理速度，也就是数据库的处理速度。我们可以对热门商品进行分库分表，这样可以将请求处理的压力分摊到多个数据库中。下图中，我们将秒杀系统的一些组件独立开来：
<img loading="lazy" src="/posts/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/6.png"></li>
</ul>
<p>根据以上两个方案，我们可以设计出最后的架构 3：
<img loading="lazy" src="/posts/%E5%85%B6%E4%BB%96/%E9%9D%A2%E8%AF%95/7.png"></p>
<ol>
<li>客户端从 CDN 获取到秒杀页面</li>
<li>客户端发送下单请求给网关</li>
<li>在网关或者服务器前进行流量控制以及负载均衡等策略</li>
<li>服务端将请求发送到消息队列</li>
<li>数据库每次从消息队列取出请求</li>
<li>若该商品库存大于零，将库存减一</li>
<li>若该商品库存等于零的话，不做操作</li>
<li>服务端根据消息队列里的消息状态返回下单结果</li>
</ol>
<h3 id="面试中的回答方式">面试中的回答方式<a hidden class="anchor" aria-hidden="true" href="#面试中的回答方式">#</a></h3>
<p>国内的系统设计面试更多只需要讲述思路，这整个系统从头到尾说一遍的话肯定不够时间，面试官主要想考核的有三个方向：</p>
<ul>
<li>理解到系统设计问题的核心，使用合适的组件来解决问题</li>
<li>分析现有架构的瓶颈，从不同的方案中找到合适的解决方案</li>
<li>对于一些关键组件，了解里面的具体原理以及最佳实践</li>
</ul>
<p>面试回答来说，可以分成四个部分：</p>
<h4 id="描述系统特点">描述系统特点<a hidden class="anchor" aria-hidden="true" href="#描述系统特点">#</a></h4>
<p>“秒杀系统的特点是大流量以及流量倾斜，大量流量会集中在少量的几种商品中。”</p>
<h4 id="理解核心问题">理解核心问题<a hidden class="anchor" aria-hidden="true" href="#理解核心问题">#</a></h4>
<p>理解该系统的核心问题，基本所有系统都需要保证高可用，高扩展以及一致性，可以将其对应到具体问题：
“秒杀系统需要保证：
高可用：服务器不因为大流量而崩溃，同时秒杀业务不影响其他业务。
高扩展，架构适合水平扩展，在特殊活动前能够迅速扩容。
一致性：商品不出现超卖和少卖的问题。”</p>
<h4 id="提出主要方案">提出主要方案<a hidden class="anchor" aria-hidden="true" href="#提出主要方案">#</a></h4>
<p>从整个架构中，能够总结出主要方案：
“要保证上述三个性质，主要方案有三个：</p>
<p>合理使用消息队列，既可以解决并发安全问题，也可以进行业务解耦，方便水平扩展。
前后端的流量限制，将大部分的无效流量拦在服务器之前。
热门资源隔离，针对热门商品进行独立处理以及资源分配。”</p>
<h4 id="根据面试官反馈回答">根据面试官反馈回答<a hidden class="anchor" aria-hidden="true" href="#根据面试官反馈回答">#</a></h4>
<p>“应该在什么时候扣除库存，是下单后扣除库存还是支付后扣除库存呢？为什么？”
应该在下单的时候扣除库存，如果在支付成功再扣除库存的话会出现下单请求成功数量大于库存的情况。</p>
<p>“对秒杀商品进行分库分表之后可能导致某个分表库存为零，但其他分表还有库存，如何解决这个问题？”
“有三种解决方案：</p>
<p>如果当前分表没有库存的话，到其他分表进行重试，缺点是会放大流量。
通过路由组件记录每个分表的库存情况，将下单请求转发到有库存的分表中。
使用分布式缓存记录每个分表的库存情况，并且每次下单请求只更新缓存，缓存后续再更新到数据库中，缺点是可能出现缓存和数据库不一致的问题。”</p>
<p>“客户下单后可能支付超时并释放库存，这时候有哪些要注意的？”
“服务器能够通知限流器以及前端库存发生变化，限流器能够重新接收请求，前端页面显示可下单的页面，确保后续的用户能继续购买商品。”</p>
<p>“消息队列方案有什么潜在问题吗？”
“秒杀系统下，可能 80% 的流量都指向同一个热门商品，那么消息队列中的分区会特别大，影响了两个方面 1）消息队列本身的稳定性，吞吐量会受单个分区限制，也可能影响其他业务。2）下单请求受到消费者消费能力的限制，即使消息队列每秒可以处理大量消息，但是数据库每秒处理的数量有限。可以使用以下几种方案：
压力测试：在前期压力测试的时候，模拟流量极端分布的情况，确保现有架构能够支持服务。
资源隔离：对秒杀商品使用独立的消息队列，使用特殊的流量限流策略，配置更好的资源。
合并下单请求：将多个下单请求合并成一个请求，再交给数据库处理。不过在实际工程中，下单业务可能比较复杂，不只包含扣减库存。所以合并逻辑会影响后续业务的可扩展性。
合并事务：将多个事务合并成一个事务执行，这样能有效减少数据库压力，缺点是逻辑会比较复杂，而且一个事务执行失败会影响多个订单。</p>
<p>“消息队列怎么保证消息有且仅生效一次（Exactly Once）？”
为了保证最少一次生效, 消费者需要下单成功后才能返回确认 ACK，否则有可能会丢失消息。
为了防止消息重复消费的问题，需要使下单逻辑变为幂等操作，常见的解决方案是保证下单请求有全局唯一的 ID，并在消息队列中对 ID 进行持久化，在发送给消费者之前先检查 ID 是否已经消费过。要注意中间层的重试机制不要修改这个全局唯一的 ID，不然会导致消息队列误以为该消息没有消费过。</p>
<p>“如果电商系统流量过大，如何进行降级服务？”
暂停非核心业务：例如淘宝在双十一会暂时关闭退款功能。
拒绝服务：当系统压力到达一个阈值的的时候，随机丢弃部分秒杀请求。
减少重试：将重试次数降低甚至设置为0，否则容易造成雪崩效应，系统陷入负反馈循环，无法正常恢复。</p>
<p>“消息队列如何保证消息有序/分布式事务一致性/高可用？”
“如何正确地实现分布式锁？”
“分布式锁和数据库悲观锁相比有什么优势？有什么共同的缺点？”
“如何保证缓存和数据库的一致性？”</p>
<h2 id="如何保证缓存和数据库的一致性">如何保证缓存和数据库的一致性？<a hidden class="anchor" aria-hidden="true" href="#如何保证缓存和数据库的一致性">#</a></h2>
<p>使用缓存后，通常处理流程是这样的：</p>
<ol>
<li>如果用户请求的数据在缓存中就直接返回。</li>
<li>缓存中不存在的话就看数据库中是否存在。</li>
<li>数据库中存在的话就更新缓存中的数据。</li>
<li>数据库中不存在的话就返回空数据。</li>
</ol>
<p>当数据发生更新时，我们不仅要更新数据库，还要一并更新缓存。
但数据库和缓存都更新，又存在先后问题，那对应的方案就有 2 个：</p>
<ul>
<li>先更新缓存，后更新数据库</li>
<li>先更新数据库，后更新缓存</li>
</ul>
<p>并发情况下，我们来分析这两种情况。</p>
<ul>
<li>
<p>先更新缓存，后更新数据库
如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库中是「旧值」。
虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存「失效」，就会从数据库中读取到「旧值」，重建缓存也是这个旧值。
这时用户会发现自己之前修改的数据又「变回去」了，对业务造成影响。</p>
</li>
<li>
<p>先更新数据库，后更新缓存
如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是「旧值」。
之后的读请求读到的都是旧数据，只有当缓存「失效」后，才能从数据库中得到正确的值。
这时用户会发现，自己刚刚修改了数据，但却看不到变更，一段时间过后，数据才变更过来，对业务也会有影响。</p>
</li>
</ul>
<p>除了操作失败问题，还有什么情况会影响数据一致性？</p>
<h3 id="并发引发的一致性问题">并发引发的一致性问题<a hidden class="anchor" aria-hidden="true" href="#并发引发的一致性问题">#</a></h3>
<p>假设我们采用「先更新数据库，再更新缓存」的方案，并且两步都可以「成功执行」的前提下，如果存在并发，情况会是怎样的呢？</p>
<p>有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：</p>
<ol>
<li>线程 A 更新数据库（X = 1）</li>
<li>线程 B 更新数据库（X = 2）</li>
<li>线程 B 更新缓存（X = 2）</li>
<li>线程 A 更新缓存（X = 1）</li>
</ol>
<p>最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致。
也就是说，A 虽然先于 B 发生，但 B 操作数据库和缓存的时间，却要比 A 的时间短，执行时序发生「错乱」，最终这条数据结果是不符合预期的。
同样地，采用「先更新缓存，再更新数据库」的方案，也会有类似问题，这里不再详述。
除此之外，我们从「缓存利用率」的角度来评估这个方案，也是不太推荐的。
这是因为每次数据发生变更，都「无脑」更新缓存，但是缓存中的数据不一定会被「马上读取」，这就会导致缓存中可能存放了很多不常访问的数据，浪费缓存资源。
而且很多情况下，写到缓存中的值，并不是与数据库中的值一一对应的，很有可能是先查询数据库，再经过一系列「计算」得出一个值，才把这个值才写到缓存中。
由此可见，这种「更新数据库 + 更新缓存」的方案，不仅缓存利用率不高，还会造成机器性能的浪费。所以此时我们需要考虑另外一种方案：删除缓存。</p>
<h3 id="删除缓存可以保证一致性吗">删除缓存可以保证一致性吗？<a hidden class="anchor" aria-hidden="true" href="#删除缓存可以保证一致性吗">#</a></h3>
<p>删除缓存，只在写数据时删除缓存，分两种情况：</p>
<ul>
<li>先删缓存，后更新数据库</li>
<li>先更新数据库，后删缓存</li>
</ul>
<p>并发情况下，这两种方案会有什么问题呢？</p>
<h4 id="先删缓存后更新数据库">先删缓存，后更新数据库<a hidden class="anchor" aria-hidden="true" href="#先删缓存后更新数据库">#</a></h4>
<p>如果有 2 个线程要并发「读写」数据，可能会发生以下场景：</p>
<ol>
<li>线程 A 要更新 X = 2（原值 X = 1）</li>
<li>线程 A 先删除缓存</li>
<li>线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）</li>
<li>线程 A 将新值写入数据库（X = 2）</li>
<li>线程 B 将旧值写入缓存（X = 1）</li>
<li>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。
可见，先删除缓存，后更新数据库，当发生「读+写」并发时，还是存在数据不一致的情况。</li>
</ol>
<h4 id="先更新数据库后删缓存">先更新数据库，后删缓存<a hidden class="anchor" aria-hidden="true" href="#先更新数据库后删缓存">#</a></h4>
<p>依旧是 2 个线程并发「读写」数据：</p>
<ol>
<li>缓存中 X 不存在（数据库 X = 1）</li>
<li>线程 A 读取数据库，得到旧值（X = 1）</li>
<li>线程B 更新数据库（X = 2)</li>
<li>线程B 删除缓存</li>
<li>线程A 将旧值写入缓存（X = 1）</li>
</ol>
<p>最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），也发生不一致。
这种情况「理论」来说是可能发生的，但实际真的有可能发生吗？
其实概率「很低」，这是因为它必须满足 3 个条件：</p>
<ol>
<li>缓存刚好已失效</li>
<li>读请求 + 写请求并发</li>
<li>更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）</li>
</ol>
<p>仔细想一下，条件 3 发生的概率其实是非常低的。
因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。
这么来看，「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的。
所以，我们应该采用这种方案，来操作数据库和缓存。
好，解决了并发问题，我们继续来看前面遗留的，第二步执行「失败」导致数据不一致的问题。</p>
<h3 id="通过mq保证两步操作都执行成功">通过MQ保证两步操作都执行成功<a hidden class="anchor" aria-hidden="true" href="#通过mq保证两步操作都执行成功">#</a></h3>
<p>前面我们分析到，无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。保证第二步成功执行，就是解决问题的关键。</p>
<p>最简单的解决办法是什么？答案是：重试。
无论是先操作缓存，还是先操作数据库，但凡后者执行失败了，我们就可以发起重试，尽可能地去做「补偿」。
那这是不是意味着，只要执行失败，我们「无脑重试」就可以了呢？
答案是否定的。现实情况往往没有想的这么简单，失败后立即重试的问题在于：</p>
<ul>
<li>立即重试很大概率「还会失败」</li>
<li>「重试次数」设置多少才合理？</li>
<li>重试会一直「占用」这个线程资源，无法服务其它客户端请求</li>
</ul>
<p>看到了么，虽然我们想通过重试的方式解决问题，但这种「同步」重试的方案依旧不严谨。
那更好的方案应该怎么做？答案是：异步重试。什么是异步重试？
其实就是把重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功。
或者更直接的做法，为了避免第二步执行失败，我们可以把操作缓存这一步，直接放到消息队列中，由消费者来操作缓存。
到这里你可能会问，写消息队列也有可能会失败啊？而且，引入消息队列，这又增加了更多的维护成本，这样做值得吗？
这个问题很好，但我们思考这样一个问题：如果在执行失败的线程中一直重试，还没等执行成功，此时如果项目「重启」了，那这次重试请求也就「丢失」了，那这条数据就一直不一致了。
所以，这里我们必须把重试或第二步操作放到另一个「服务」中，这个服务用「消息队列」最为合适。这是因为消息队列的特性，正好符合我们的需求：</p>
<ul>
<li>消息队列保证可靠性：写到队列中的消息，成功消费之前不会丢失（重启项目也不担心）</li>
<li>消息队列保证消息成功投递：下游从队列拉取消息，成功消费后才会删除消息，否则还会继续投递消息给消费者（符合我们重试的场景）</li>
</ul>
<p>至于写队列失败和消息队列的维护成本问题：</p>
<ul>
<li>写队列失败：操作缓存和写消息队列，「同时失败」的概率其实是很小的</li>
<li>维护成本：我们项目中一般都会用到消息队列，维护成本并没有新增很多</li>
</ul>
<p>所以，引入消息队列来解决这个问题，是比较合适的。</p>
<h3 id="通过mysql-binlog">通过MYSQL binlog<a hidden class="anchor" aria-hidden="true" href="#通过mysql-binlog">#</a></h3>
<p>那如果你确实不想在应用中去写消息队列，是否有更简单的方案，同时又可以保证一致性呢？
方案还是有的，这就是近几年比较流行的解决方案：订阅数据库变更日志，再操作缓存。
具体来讲就是，我们的业务应用在修改数据时，「只需」修改数据库，无需操作缓存。
当一条数据发生修改时，MySQL 就会产生一条变更日志（Binlog），我们可以订阅这个日志，拿到具体操作的数据，然后再根据这条数据，去删除对应的缓存。</p>
<p>订阅变更日志，目前也有了比较成熟的开源中间件，例如阿里的 canal，使用这种方案的优点在于：</p>
<ul>
<li>无需考虑写消息队列失败情况：只要写 MySQL 成功，Binlog 肯定会有</li>
<li>自动投递到下游队列：canal 自动把数据库变更日志「投递」给下游的消息队列</li>
</ul>
<p>当然，与此同时，我们需要投入精力去维护 canal 的高可用和稳定性。</p>
<p>至此，我们可以得出结论，想要保证数据库和缓存一致性，推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做。</p>
<h1 id="反问面试官">反问面试官<a hidden class="anchor" aria-hidden="true" href="#反问面试官">#</a></h1>
<p><a href="https://github.com/yifeikong/reverse-interview-zh">本部分参考</a></p>
<h2 id="职责">职责<a hidden class="anchor" aria-hidden="true" href="#职责">#</a></h2>
<ul>
<li>如果我能入职，我的日常工作是什么？</li>
<li>团队有多少人，初级和高级工程师的比例是多少？</li>
<li>我入职的岗位是新增还是接替之前离职的同事？</li>
<li>一周的工作是怎样安排的？</li>
</ul>
<h2 id="技术">技术<a hidden class="anchor" aria-hidden="true" href="#技术">#</a></h2>
<ul>
<li>公司常用的技术栈是什么？</li>
<li>使用持续集成和持续部署吗 (CI/CD)？如jenkins</li>
<li>有标准的开发环境吗？是强制的吗？</li>
<li>你们的代码有开发文档吗？需要写开发文档么？</li>
<li>有没有技术分享交流活动？</li>
<li>你们的数据库是怎么进行版本控制的？</li>
</ul>
<h2 id="公司">公司<a hidden class="anchor" aria-hidden="true" href="#公司">#</a></h2>
<ul>
<li>公司是如何盈利的？</li>
<li>如果现在没有盈利，还需要多久才能盈利？</li>
<li>公司的资金来源是什么？</li>
<li>为什么在招人？（产品发展 / 新产品 / 波动&hellip;)</li>
<li>绩效评估流程是怎样的？</li>
<li>您在这工作了多久了？您觉得体验如何？</li>
<li>公司的调薪制度是如何的？</li>
</ul>
<h2 id="待遇">待遇<a hidden class="anchor" aria-hidden="true" href="#待遇">#</a></h2>
<ul>
<li>试用期多久?</li>
<li>试用期是否缴纳五险一金？</li>
<li>试用期工资是80%么？</li>
<li>五险一金是否全额缴纳？</li>
<li>有补充医疗么？</li>
</ul>
<h2 id="休假">休假<a hidden class="anchor" aria-hidden="true" href="#休假">#</a></h2>
<ul>
<li>加班能换成调休么？</li>
<li>年假？</li>
</ul>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://009965.xyz/tags/%E5%85%B6%E4%BB%96/">其他</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://009965.xyz/">Wjy&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
