<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>系统设计面试题 | Wjy&#39;s Blog</title>
<meta name="keywords" content="interview">
<meta name="description" content="RestFul API 简明教程 何为 API？ API（Application Programming Interface） 翻译过来是应用程序编程接口的意思。 我们在进行后端开发的时候，主要">
<meta name="author" content="">
<link rel="canonical" href="https://funny-toffee-4aa7c3.netlify.app/posts/interview/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.js" onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://funny-toffee-4aa7c3.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://funny-toffee-4aa7c3.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://funny-toffee-4aa7c3.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://funny-toffee-4aa7c3.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://funny-toffee-4aa7c3.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="系统设计面试题" />
<meta property="og:description" content="RestFul API 简明教程 何为 API？ API（Application Programming Interface） 翻译过来是应用程序编程接口的意思。 我们在进行后端开发的时候，主要" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://funny-toffee-4aa7c3.netlify.app/posts/interview/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-07-06T05:00:00+00:00" />
<meta property="article:modified_time" content="2023-07-06T05:00:00+00:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="系统设计面试题"/>
<meta name="twitter:description" content="RestFul API 简明教程 何为 API？ API（Application Programming Interface） 翻译过来是应用程序编程接口的意思。 我们在进行后端开发的时候，主要"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://funny-toffee-4aa7c3.netlify.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "系统设计面试题",
      "item": "https://funny-toffee-4aa7c3.netlify.app/posts/interview/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "系统设计面试题",
  "name": "系统设计面试题",
  "description": "RestFul API 简明教程 何为 API？ API（Application Programming Interface） 翻译过来是应用程序编程接口的意思。 我们在进行后端开发的时候，主要",
  "keywords": [
    "interview"
  ],
  "articleBody": "RestFul API 简明教程 何为 API？ API（Application Programming Interface） 翻译过来是应用程序编程接口的意思。\n我们在进行后端开发的时候，主要的工作就是为前端或者其他后端服务提供 API 比如查询用户数据的 API 。\n但是， API 不仅仅代表后端系统暴露的接口，像框架中提供的方法也属于 API 的范畴。\n为了方便大家理解，我再列举几个例子 🌰：\n你通过某电商网站搜索某某商品，电商网站的前端就调用了后端提供了搜索商品相关的 API。 你使用 JDK 开发 Java 程序，想要读取用户的输入的话，你就需要使用 JDK 提供的 IO 相关的 API。 …… 你可以把 API 理解为程序与程序之间通信的桥梁，其本质就是一个函数而已。另外，API 的使用也不是没有章法的，它的规则由（比如数据输入和输出的格式）API 提供方制定。\n何为 RESTful API？ RESTful API 经常也被叫做 REST API，它是基于 REST 构建的 API。这个 REST 到底是什么，我们后文在讲，涉及到的概念比较多。\n如果你看 RESTful API 相关的文章的话一般都比较晦涩难懂，主要是因为 REST 涉及到的一些概念比较难以理解。但是，实际上，我们平时开发用到的 RESTful API 的知识非常简单也很容易概括！\n举个例子，如果我给你下面两个 API 你是不是立马能知道它们是干什么用的！这就是 RESTful API 的强大之处！\n1 2 GET /classes：列出所有班级 POST /classes：新建一个班级 RESTful API 可以让你看到 URL+Http Method 就知道这个 URL 是干什么的，让你看到了 HTTP 状态码（status code）就知道请求结果如何。\n像咱们在开发过程中设计 API 的时候也应该至少要满足 RESTful API 的最基本的要求（比如接口中尽量使用名词，使用 POST 请求创建资源，DELETE 请求删除资源等等，示例：GET /notes/id：获取某个指定 id 的笔记的信息）。\n解读 REST REST 是 REpresentational State Transfer 的缩写。这个词组的翻译过来就是“表现层状态转化”。\n这样理解起来甚是晦涩，实际上 REST 的全称是 Resource Representational State Transfer ，直白地翻译过来就是 “资源”在网络传输中以某种“表现形式”进行“状态转移” 。如果还是不能继续理解，请继续往下看，相信下面的讲解一定能让你理解到底啥是 REST 。\n我们分别对上面涉及到的概念进行解读，以便加深理解，实际上你不需要搞懂下面这些概念，也能看懂我下一部分要介绍到的内容。不过，为了更好地能跟别人扯扯 “RESTful API”我建议你还是要好好理解一下！\n资源（Resource）：我们可以把真实的对象数据称为资源。一个资源既可以是一个集合，也可以是单个个体。比如我们的班级 classes 是代表一个集合形式的资源，而特定的 class 代表单个个体资源。每一种资源都有特定的 URI（统一资源标识符）与之对应，如果我们需要获取这个资源，访问这个 URI 就可以了，比如获取特定的班级：/class/12。另外，资源也可以包含子资源，比如 /classes/classId/teachers：列出某个指定班级的所有老师的信息 表现形式（Representational）：“资源\"是一种信息实体，它可以有多种外在表现形式。我们把\"资源\"具体呈现出来的形式比如 json，xml，image,txt 等等叫做它的\"表现层/表现形式”。 状态转移（State Transfer）：大家第一眼看到这个词语一定会很懵逼？内心 BB：这尼玛是啥啊？ 大白话来说 REST 中的状态转移更多地描述的服务器端资源的状态，比如你通过增删改查（通过 HTTP 动词实现）引起资源状态的改变。ps:互联网通信协议 HTTP 协议，是一个无状态协议，所有的资源状态都保存在服务器端。 综合上面的解释，我们总结一下什么是 RESTful 架构：\n每一个 URI 代表一种资源； 客户端和服务器之间，传递这种资源的某种表现形式比如 json，xml，image,txt 等等； 客户端通过特定的 HTTP 动词，对服务器端资源进行操作，实现\"表现层状态转化\"。 RESTful API 规范 动作 GET：请求从服务器获取特定资源。举个例子：GET /classes（获取所有班级） POST：在服务器上创建一个新的资源。举个例子：POST /classes（创建班级） PUT：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：PUT /classes/12（更新编号为 12 的班级） DELETE：从服务器删除特定的资源。举个例子：DELETE /classes/12（删除编号为 12 的班级） PATCH：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。 路径（接口命名） 路径又称\"终点\"（endpoint），表示 API 的具体网址。实际开发中常见的规范如下：\n网址中不能有动词，只能有名词，API 中的名词也应该使用复数。 因为 REST 中的资源往往和数据库中的表对应，而数据库中的表都是同种记录的\"集合\"（collection）。如果 API 调用并不涉及资源（如计算，翻译等操作）的话，可以用动词。比如：GET /calculate?param1=11\u0026param2=33 。 不用大写字母，建议用中杠 - 不用下杠 _ 。比如邀请码写成 invitation-code而不是 invitation_code 。 善用版本化 API。当我们的 API 发生了重大改变而不兼容前期版本的时候，我们可以通过 URL 来实现版本化，比如 http://api.example.com/v1、http://apiv1.example.com 。版本不必非要是数字，只是数字用的最多，日期、季节都可以作为版本标识符，项目团队达成共识就可。 接口尽量使用名词，避免使用动词。 RESTful API 操作（HTTP Method）的是资源（名词）而不是动作（动词）。 Talk is cheap！来举个实际的例子来说明一下吧！现在有这样一个 API 提供班级（class）的信息，还包括班级中的学生和教师的信息，则它的路径应该设计成下面这样。\n1 2 3 4 5 6 7 8 9 GET /classes：列出所有班级 POST /classes：新建一个班级 GET /classes/{classId}：获取某个指定班级的信息 PUT /classes/{classId}：更新某个指定班级的信息（一般倾向整体更新） PATCH /classes/{classId}：更新某个指定班级的信息（一般倾向部分更新） DELETE /classes/{classId}：删除某个班级 GET /classes/{classId}/teachers：列出某个指定班级的所有老师的信息 GET /classes/{classId}/students：列出某个指定班级的所有学生的信息 DELETE /classes/{classId}/teachers/{ID}：删除某个指定班级下的指定的老师的信息 反例：\n1 2 3 /getAllclasses /createNewclass /deleteAllActiveclasses 理清资源的层次结构，比如业务针对的范围是学校，那么学校会是一级资源:/schools，老师: /schools/teachers，学生: /schools/students 就是二级资源。\n过滤信息（Filtering） 如果我们在查询的时候需要添加特定条件的话，建议使用 url 参数的形式。比如我们要查询 state 状态为 active 并且 name 为 guidegege 的班级：\n1 GET /classes?state=active\u0026name=guidegege 比如我们要实现分页查询：\n1 GET /classes?page=1\u0026size=10 //指定第1页，每页10个数据 状态码（Status Codes） 状态码范围：\n2xx：成功 3xx：重定向 4xx：客户端错误 5xx：服务器错误 200 成功 301 永久重定向 400 参数错误 500 服务器错误 201 创建 304 资源未修改 401 未授权 502 网关错误 403 禁止访问 504 网关超时 404 未找到 405 请求方法不对 软件工程简明教程 何为软件工程？ 1968 年 NATO（北大西洋公约组织）提出了软件危机（Software crisis）一词。同年，为了解决软件危机问题，“软件工程”的概念诞生了。一门叫做软件工程的学科也就应运而生。\n随着时间的推移，软件工程这门学科也经历了一轮又一轮的完善，其中的一些核心内容比如软件开发模型越来越丰富实用！\n什么是软件危机呢？\n简单来说，软件危机描述了当时软件开发的一个痛点：我们很难高效地开发出质量高的软件。\nDijkstra（Dijkstra 算法的作者） 在 1972 年图灵奖获奖感言中也提高过软件危机，他是这样说的：“导致软件危机的主要原因是机器变得功能强大了几个数量级！坦率地说：只要没有机器，编程就完全没有问题。当我们有一些弱小的计算机时，编程成为一个温和的问题，而现在我们有了庞大的计算机，编程也同样成为一个巨大的问题”。\n说了这么多，到底什么是软件工程呢？\n工程是为了解决实际的问题将理论应用于实践。软件工程指的就是将工程思想应用于软件开发。\n上面是我对软件工程的定义，我们再来看看比较权威的定义。IEEE 软件工程汇刊给出的定义是这样的：　(1)将系统化的、规范的、可量化的方法应用到软件的开发、运行及维护中，即将工程化方法应用于软件。　(2)在(1)中所述方法的研究。\n总之，软件工程的终极目标就是：在更少资源消耗的情况下，创造出更好、更容易维护的软件。\n软件开发过程 维基百科是这样定义软件开发过程open in new window的：\n软件开发过程（英语：software development process），或软件过程（英语：software process），是软件开发的开发生命周期（software development life cycle），其各个阶段实现了软件的需求定义与分析、设计、实现、测试、交付和维护。软件过程是在开发与构建系统时应遵循的步骤，是软件开发的路线图。\n需求分析：分析用户的需求，建立逻辑模型。 软件设计：根据需求分析的结果对软件架构进行设计。 编码：编写程序运行的源代码。 测试 : 确定测试用例，编写测试报告。 交付：将做好的软件交付给客户。 维护：对软件进行维护比如解决 bug，完善功能。 软件开发过程只是比较笼统的层面上，一定义了一个软件开发可能涉及到的一些流程。\n软件开发模型更具体地定义了软件开发过程，对开发过程提供了强有力的理论支持。\n软件开发模型 软件开发模型有很多种，比如瀑布模型（Waterfall Model）、快速原型模型（Rapid Prototype Model）、V 模型（V-model）、W 模型（W-model）、敏捷开发模型。其中最具有代表性的还是 瀑布模型 和 敏捷开发 。\n瀑布模型 定义了一套完成的软件开发周期，完整地展示了一个软件的的生命周期。\n敏捷开发模型 是目前使用的最多的一种软件开发模型。MBA 智库百科对敏捷开发的描述open in new window是这样的:\n敏捷开发 是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。\n像现在比较常见的一些概念比如 持续集成、重构、小版本发布、低文档、站会、结对编程、测试驱动开发 都是敏捷开发的核心。\n软件开发的基本策略 软件复用 我们在构建一个新的软件的时候，不需要从零开始，通过复用已有的一些轮子（框架、第三方库等）、设计模式、设计原则等等现成的物料，我们可以更快地构建出一个满足要求的软件。\n像我们平时接触的开源项目就是最好的例子。我想，如果不是开源，我们构建出一个满足要求的软件，耗费的精力和时间要比现在多的多！\n分而治之 构建软件的过程中，我们会遇到很多问题。我们可以将一些比较复杂的问题拆解为一些小问题，然后，一一攻克。\n我结合现在比较火的软件设计方法—领域驱动设计（Domain Driven Design，简称 DDD）来说说。\n在领域驱动设计中，很重要的一个概念就是领域（Domain），它就是我们要解决的问题。在领域驱动设计中，我们要做的就是把比较大的领域（问题）拆解为若干的小领域（子域）。\n除此之外，分而治之也是一个比较常用的算法思想，对应的就是分治算法。如果你想了解分治算法的话，推荐你看一下北大的《算法设计与分析 Design and Analysis of Algorithms》open in new window。\n逐步演进 软件开发是一个逐步演进的过程，我们需要不断进行迭代式增量开发，最终交付符合客户价值的产品。\n这里补充一个在软件开发领域，非常重要的概念：MVP（Minimum Viable Product，最小可行产品）。\n这个最小可行产品，可以理解为刚好能够满足客户需求的产品。下面这张图片把这个思想展示的非常精髓。\n利用最小可行产品，我们可以也可以提早进行市场分析，这对于我们在探索产品不确定性的道路上非常有帮助。可以非常有效地指导我们下一步该往哪里走。\n优化折中 软件开发是一个不断优化改进的过程。任何软件都有很多可以优化的点，不可能完美。我们需要不断改进和提升软件的质量。\n但是，也不要陷入这个怪圈。要学会折中，在有限的投入内，以最有效的方式提高现有软件的质量。\n命名指南 常见命名规则以及适用场景 这里只介绍 3 种最常见的命名规范。\n驼峰命名法（CamelCase） 驼峰命名法应该我们最常见的一个，这种命名方式使用大小写混合的格式来区别各个单词，并且单词之间不使用空格隔开或者连接字符连接的命名方式\n驼峰命名法（UpperCamelCase） 类名需要使用大驼峰命名法（UpperCamelCase）\n正例：\n1 ServiceDiscovery、ServiceInstance、LruCacheFactory 反例：\n1 serviceDiscovery、Serviceinstance、LRUCacheFactory 驼峰命名法（lowerCamelCase） 方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。\n正例：\n1 2 3 4 getUserInfo() createCustomThreadPool() setNameFormat(String nameFormat) Uservice userService; 反例：\n1 2 GetUserInfo()、CreateCustomThreadPool()、setNameFormat(String NameFormat) Uservice user_service 蛇形命名法（snake_case） 测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）\n在蛇形命名法中，各个单词之间通过下划线“_”连接，比如should_get_200_status_code_when_request_is_valid、CLIENT_CONNECT_SERVER_FAILURE。\n蛇形命名法的优势是命名所需要的单词比较多的时候，比如我把上面的命名通过小驼峰命名法给大家看一下：“shouldGet200StatusCodeWhenRequestIsValid”。\n感觉如何？ 相比于使用蛇形命名法（snake_case）来说是不是不那么易读？\n正例：\n1 2 3 4 @Test void should_get_200_status_code_when_request_is_valid() { ...... } 反例：\n1 2 3 4 @Test void shouldGet200StatusCodeWhenRequestIsValid() { ...... } 串式命名法（kebab-case） 在串式命名法中，各个单词之间通过连接符“-”连接，比如dubbo-registry。\n建议项目文件夹名称使用串式命名法（kebab-case），比如 dubbo 项目的各个模块的命名是下面这样的。\n常见命名规范 Java 语言基本命名规范 1、类名需要使用大驼峰命名法（UpperCamelCase）风格。方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。\n2、测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case），比如should_get_200_status_code_when_request_is_valid、CLIENT_CONNECT_SERVER_FAILURE。并且，测试方法名称要求全部小写，常量以及枚举名称需要全部大写。\n3、项目文件夹名称使用串式命名法（kebab-case），比如dubbo-registry。\n4、包名统一使用小写，尽量使用单个名词作为包名，各个单词通过 “.” 分隔符连接，并且各个单词必须为单数。\n正例：org.apache.dubbo.common.threadlocal\n反例：org.apache_dubbo.Common.threadLocals\n5、抽象类命名使用 Abstract 开头。\n1 2 3 4 //为远程传输部分抽象出来的一个抽象类（出处：Dubbo源码） public abstract class AbstractClient extends AbstractEndpoint implements Client { } 6、异常类命名使用 Exception 结尾。\n1 2 3 4 5 6 7 8 9 10 11 12 //自定义的 NoSuchMethodException（出处：Dubbo源码） public class NoSuchMethodException extends RuntimeException { private static final long serialVersionUID = -2725364246023268766L; public NoSuchMethodException() { super(); } public NoSuchMethodException(String msg) { super(msg); } } 7、测试类命名以它要测试的类的名称开始，以 Test 结尾。\n1 2 3 4 //为 AnnotationUtils 类写的测试类（出处：Dubbo源码） public class AnnotationUtilsTest { ...... } POJO 类中布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。\n如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。\n命名易读性规范 1、为了能让命名更加易懂和易读，尽量不要缩写/简写单词，除非这些单词已经被公认可以被这样缩写/简写。比如 CustomThreadFactory 不可以被写成 ~~CustomTF 。\n2、命名不像函数一样要尽量追求短，可读性强的名字优先于简短的名字，虽然可读性强的名字会比较长一点。 这个对应我们上面说的第 1 点。\n3、避免无意义的命名，你起的每一个名字都要能表明意思。\n正例：UserService userService; int userCount;\n反例: UserService service int count\n4、避免命名过长（50 个字符以内最好），过长的命名难以阅读并且丑陋。\n5、不要使用拼音，更不要使用中文。 不过像 alibaba、wuhan、taobao 这种国际通用名词可以当做英文来看待。\n正例：discount\n反例：dazhe\n代码重构 学习重构必看的一本神书《重构：改善代码既有设计》从两个角度给出了重构的定义：\n重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。 重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。 用更贴近工程师的语言来说：重构就是利用设计模式(如组合模式、策略模式、责任链模式)、软件设计原则（如 SOLID 原则、YAGNI 原则、KISS 原则）和重构手段（如封装、继承、构建测试体系）来让代码更容易理解，更易于修改。\n软件设计原则指导着我们组织和规范代码，同时，重构也是为了能够尽量设计出尽量满足软件设计原则的软件。\n正确重构的核心在于 步子一定要小，每一步的重构都不会影响软件的正常运行，可以随时停止重构。\n为什么要重构？ 在上面介绍重构定义的时候，我从比较抽象的角度介绍了重构的好处：重构的主要目的主要是提升代码\u0026架构的灵活性/可扩展性以及复用性。\n如果对应到一个真实的项目，重构具体能为我们带来什么好处呢？\n让代码更容易理解：通过添加注释、命名规范、逻辑优化等手段可以让我们的代码更容易被理解； 避免代码腐化：通过重构干掉坏味道代码； 加深对代码的理解：重构代码的过程会加深你对某部分代码的理解； 发现潜在 bug：是这样的，很多潜在的 bug ，都是我们在重构的过程中发现的； …… 看了上面介绍的关于重构带来的好处之后，你会发现重构的最终目标是 提高软件开发速度和质量 。\n重构并不会减慢软件开发速度，相反，如果代码质量和软件设计较差，当我们想要添加新功能的话，开发速度会越来越慢。到了最后，甚至都有想要重写整个系统的冲动。\n《重构：改善代码既有设计》这本书中这样说：\n重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。\n何时进行重构？ 重构在是开发过程中随时可以进行的，见机行事即可，并不需要单独分配一两天的时间专门用来重构。\n提交代码之前 《重构：改善代码既有设计》这本书介绍了一个 营地法则 的概念:\n编程时，需要遵循营地法则：保证你离开时的代码库一定比来时更健康。\n这个概念表达的核心思想其实很简单：在你提交代码的之前，花一会时间想一想，我这次的提交是让项目代码变得更健康了，还是更腐化了，或者说没什么变化？\n项目团队的每一个人只有保证自己的提交没有让项目代码变得更腐化，项目代码才会朝着健康的方向发展。\n当我们离开营地（项目代码）的时候，请不要留下垃圾！尽量确保营地变得更干净了！\n开发一个新功能之后\u0026之前 在开发一个新功能之后，我们应该回过头看看是不是有可以改进的地方。在添加一个新功能之前，我们可以思考一下自己是否可以重构代码以让新功能的开发更容易。\n一个新功能的开发不应该仅仅只有功能验证通过那么简单，我们还应该尽量保证代码质量。\n有一个两顶帽子的比喻：在我开发新功能之前，我发现重构可以让新功能的开发更容易，于是我戴上了重构的帽子。重构之后，我换回原来的帽子，继续开发新能功能。新功能开发完成之后，我又发现自己的代码难以理解，于是我又戴上了重构帽子。比较好的开发状态就是就是这样在重构和开发新功能之间来回切换。\nCode Review 之后 Code Review 可以非常有效提高代码的整体质量，它会帮助我们发现代码中的坏味道以及可能存在问题的地方。并且， Code Review 可以帮助项目团队其他程序员理解你负责的业务模块，有效避免人员方面的单点风险。\n经历一次 Code Review ，你的代码可能会收到很多改进建议。\n捡垃圾式重构 当我们发现垃圾代码的时候，如果我们不想停下手头自己正在做的工作，但又不想放着垃圾不管，我们可以这样做：\n如果这个垃圾很容易重构的话，我们可以立即重构它。 如果这个垃圾不太容易重构的话，我们可以先记录下来，当完成当下的任务再回来重构它。 捡垃圾式重构 当我们发现坏味道代码（垃圾）的时候，如果我们不想停下手头自己正在做的工作，但又不想放着垃圾不管，我们可以这样做：\n如果这个垃圾很容易重构的话，我们可以立即重构它。 如果这个垃圾不太容易重构的话，我们可以先记录下来，当完成当下的任务再回来重构它。 重构有哪些注意事项？ 单元测试是重构的保护网 单元测试可以为重构提供信心，降低重构的成本。我们要像重视生产代码那样，重视单元测试。\n另外，多提一句：持续集成也要依赖单元测试，当持续集成服务自动构建新代码之后，会自动运行单元测试来发现代码错误。\n怎样才能算单元测试呢？ 网上的定义很多，很抽象，很容易把人给看迷糊了。我觉得对于单元测试的定义主要取决于你的项目，一个函数甚至是一个类都可以看作是一个单元。就比如说我们写了一个计算个人股票收益率的方法，我们为了验证它的正确性专门为它写了一个单元测试。再比如说我们代码有一个类专门负责数据脱敏，我们为了验证脱敏是否符合预期专门为这个类写了一个单元测试。\n单元测试也是需要重构或者修改的。 《代码整洁之道:敏捷软件开发手册》open in new window这本书这样写到：\n测试代码需要随着生产代码的演进而修改，如果测试不能保持整洁，只会越来越难修改。\n不要为了重构而重构 重构一定是要为项目带来价值的！ 某些情况下我们不应该进行重构：\n学习了某个设计模式/工程实践之后，不顾项目实际情况，刻意使用在项目上（避免货物崇拜编程）； 项目进展比较急的时候，重构项目调用的某个 API 的底层代码（重构之后对项目调用这个 API 并没有带来什么价值）； 重写比重构更容易更省事； …… 遵循方法 《重构：改善代码既有设计》这本书中列举除了代码常见的一些坏味道（比如重复代码、过长函数）和重构手段（如提炼函数、提炼变量、提炼类）。我们应该花时间去学习这些重构相关的理论知识，并在代码中去实践这些重构理论。\n如何练习重构？ 除了可以在重构项目代码的过程中练习精进重构之外，你还可以有下面这些手段：\n重构实战练习open in new window：通过几个小案例一步一步带你学习重构！ 设计模式+重构学习网站open in new window：免费在线学习代码重构、 设计模式、 SOLID 原则 （单一职责、 开闭原则、 里氏替换、 接口隔离以及依赖反转） 。 IDEA 官方文档的代码重构教程open in new window：教你如何使用 IDEA 进行重构。 单元测试指南 何谓单元测试？ 维基百科是这样介绍单元测试的：\n在计算机编程中，单元测试（Unit Testing）是针对程序模块（软件设计的最小单位）进行的正确性检验测试工作。\n程序单元是应用的 最小可测试部件 。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。\n由于每个单元有独立的逻辑，在做单元测试时，为了隔离外部依赖，确保这些依赖不影响验证逻辑，我们经常会用到 Fake、Stub 与 Mock 。\n关于 Fake、Mock 与 Stub 这几个概念的解读，可以看看这篇文章：测试中 Fakes、Mocks 以及 Stubs 概念明晰 - 王下邀月熊 - 2018open in new window 。\n为什么需要单元测试？ 为重构保驾护航 单元测试可以为重构提供信心，降低重构的成本。我们要像重视生产代码那样，重视单元测试。\n每个开发者都会经历重构，重构后把代码改坏了的情况并不少见，很可能你只是修改了一个很简单的方法就导致系统出现了一个比较严重的错误。\n如果有了单元测试的话，就不会存在这个隐患了。写完一个类，把单元测试写了，确保这个类逻辑正确；写第二个类，单元测试…..写 100 个类，道理一样，每个类做到第一点“保证逻辑正确性”，100 个类拼在一起肯定不出问题。你大可以放心一边重构，一边运行 APP；而不是整体重构完，提心吊胆地 run。\n提高代码质量 由于每个单元有独立的逻辑，做单元测试时需要隔离外部依赖，确保这些依赖不影响验证逻辑。因为要把各种依赖分离，单元测试会促进工程进行组件拆分，整理工程依赖关系，更大程度减少代码耦合。这样写出来的代码，更好维护，更好扩展，从而提高代码质量。\n减少 bug 一个机器，由各种细小的零件组成，如果其中某件零件坏了，机器运行故障。必须保证每个零件都按设计图要求的规格，机器才能正常运行。\n一个可单元测试的工程，会把业务、功能分割成规模更小、有独立的逻辑部件，称为单元。单元测试的目标，就是保证各个单元的逻辑正确性。单元测试保障工程各个“零件”按“规格”（需求）执行，从而保证整个“机器”（项目）运行正确，最大限度减少 bug。\n快速定位 bug 如果程序有 bug，我们运行一次全部单元测试，找到不通过的测试，可以很快地定位对应的执行代码。修复代码后，运行对应的单元测试；如还不通过，继续修改，运行测试…..直到测试通过。\n持续集成依赖单元测试 持续集成需要依赖单元测试，当持续集成服务自动构建新代码之后，会自动运行单元测试来发现代码错误。\n谁逼你写单元测试？ 领导要求 有些经验丰富的领导，或多或少都会要求团队写单元测试。对于有一定工作经验的队友，这要求挺合理；对于经验尚浅的、毕业生，恐怕要死要活了，连代码都写不好，还要写单元测试，are you kidding me？\n培训新人单元测试用法，是一项艰巨的任务。新人代码风格未形成，也不知道单元测试多重要，强制单元测试会让他们感到困惑，没办法按自己思路写代码。\n大牛都写单元测试 国外很多家喻户晓的开源项目，都有大量单元测试。例如，retrofitopen in new window、okhttpopen in new window、butterknifeopen in new window…. 国外大牛都写单元测试，我们也写吧！\n很多读者都有这种想法，一开始满腔热血。当真要对自己项目单元测试时，便困难重重，很大原因是项目对单元测试不友好。最后只能对一些不痛不痒的工具类做单元测试，久而久之，当初美好愿望也不了了之。\n保住面子 都是有些许年经验的老鸟，还天天被测试同学追 bug，好意思么？花多一点时间写单元测试，确保没低级 bug，还能彰显大牛风范，何乐而不为？\n心虚 笔者也是个不太相信自己代码的人，总觉得哪里会突然冒出莫名其妙的 bug，也怕别人不小心改了自己的代码（被害妄想症），新版本上线提心吊胆……花点时间写单元测试，有事没事跑一下测试，确保原逻辑没问题，至少能睡安稳一点。\nTDD 测试驱动开发 何谓 TDD？ TDD 即 Test-Driven Development（ 测试驱动开发），这是敏捷开发的一项核心实践和技术，也是一种设计方法论。\nTDD 原理是开发功能代码之前，先编写测试用例代码，然后针对测试用例编写功能代码，使其能够通过。\nTDD 的节奏：“红 - 绿 - 重构”。\n由于 TDD 对开发人员要求非常高，跟传统开发思维不一样，因此实施起来相当困难。\nTDD 在很多人眼中是不实用的，一来他们并不理解测试“驱动”开发的含义，但更重要的是，他们很少会做任务分解。而任务分解是做好 TDD 的关键点。只有把任务分解到可以测试的地步，才能够有针对性地写测试。\nTDD 优缺点分析 测试驱动开发有好处也有坏处。因为每个测试用例都是根据需求来的，或者说把一个大需求分解成若干小需求编写测试用例，所以测试用例写出来后，开发者写的执行代码，必须满足测试用例。如果测试不通过，则修改执行代码，直到测试用例通过。\n优点：\n帮你整理需求，梳理思路； 帮你设计出更合理的接口（空想的话很容易设计出屎）； 减小代码出现 bug 的概率； 提高开发效率（前提是正确且熟练使用 TDD）。 缺点：\n能用好 TDD 的人非常少，看似简单，实则门槛很高； 投入开发资源（时间和精力）通常会更多； 由于测试用例在未进行代码设计前写；很有可能限制开发者对代码整体设计； 可能引起开发人员不满情绪，我觉得这点很严重，毕竟不是人人都喜欢单元测试，尽管单元测试会带给我们相当多的好处。 相关阅读：如何用正确的姿势打开 TDD？ - 陈天 - 2017open in new window\n单测框架如何选择？ 对于单测来说，目前常用的单测框架有：JUnit、Mockito、Spock、PowerMock、JMockit、TestableMock 等等。\nJUnit 几乎是默认选择，但是其不支持 Mock，因此我们还需要选择一个 Mock 工具。Mockito 和 Spock 是最主流的两款 Mock 工具，一般都是在这两者中选择。\n究竟是选择 Mockito 还是 Spock 呢？我这里做了一些简单的对比分析：\nSpock 没办法 Mock 静态方法和私有方法 ，Mockito 3.4.0 以后，支持静态方法的 Mock，具体可以看这个 issue：https://github.com/mockito/mockito/issues/1013，具体教程可以看这篇文章：https://www.baeldung.com/mockito-mock-static-methods。open in new window Spock 基于 Groovy，写出来的测试代码更清晰易读，比较规范(自带 given-when-then 的常用测试结构规范)。Mockito 没有具体的结构规范，需要项目组自己约定一个或者遵守比较好的测试代码实践。通常来说，同样的测试用例，Spock 的代码要更简洁。 Mockito 使用的人群更广泛，稳定可靠。并且，Mockito 是 SpringBoot Test 默认集成的 Mock 工具。 Mockito 和 Spock 都是非常不错的 Mock 工具，相对来说，Mockito 的适用性更强一些。\n总结 单元测试确实会带给你相当多的好处，但不是立刻体验出来。正如买重疾保险，交了很多保费，没病没痛，十几年甚至几十年都用不上，最好就是一辈子用不上理赔，身体健康最重要。单元测试也一样，写了可以买个放心，对代码的一种保障，有 bug 尽快测出来，没 bug 就最好，总不能说“写那么多单元测试，结果测不出 bug，浪费时间”吧？\n以下是个人对单元测试一些建议：\n越重要的代码，越要写单元测试； 代码做不到单元测试，多思考如何改进，而不是放弃； 边写业务代码，边写单元测试，而不是完成整个新功能后再写； 多思考如何改进、简化测试代码。 测试代码需要随着生产代码的演进而重构或者修改，如果测试不能保持整洁，只会越来越难修改。 作为一名经验丰富的程序员，写单元测试更多的是对自己的代码负责。有测试用例的代码，别人更容易看懂，以后别人接手你的代码时，也可能放心做改动。\n多敲代码实践，多跟有单元测试经验的工程师交流，你会发现写单元测试获得的收益会更多。\n",
  "wordCount" : "12404",
  "inLanguage": "en",
  "datePublished": "2023-07-06T05:00:00Z",
  "dateModified": "2023-07-06T05:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://funny-toffee-4aa7c3.netlify.app/posts/interview/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E9%9D%A2%E8%AF%95%E9%A2%98/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Wjy's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://funny-toffee-4aa7c3.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://funny-toffee-4aa7c3.netlify.app/" accesskey="h" title="Wjy&#39;s Blog (Alt + H)">Wjy&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/about" title="🙋🏻‍♂️关于">
                    <span>🙋🏻‍♂️关于</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/links" title="🤝友链">
                    <span>🤝友链</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://funny-toffee-4aa7c3.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://funny-toffee-4aa7c3.netlify.app/posts/">Posts</a></div>
    <h1 class="post-title">
      系统设计面试题
    </h1>
    <div class="post-meta"><span title='2023-07-06 05:00:00 +0000 UTC'>2023-07-06</span>

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#restful-api-%e7%ae%80%e6%98%8e%e6%95%99%e7%a8%8b" aria-label="RestFul API 简明教程">RestFul API 简明教程</a><ul>
                        
                <li>
                    <a href="#%e4%bd%95%e4%b8%ba-api" aria-label="何为 API？">何为 API？</a></li>
                <li>
                    <a href="#%e4%bd%95%e4%b8%ba-restful-api" aria-label="何为 RESTful API？">何为 RESTful API？</a></li>
                <li>
                    <a href="#%e8%a7%a3%e8%af%bb-rest" aria-label="解读 REST">解读 REST</a></li>
                <li>
                    <a href="#restful-api-%e8%a7%84%e8%8c%83" aria-label="RESTful API 规范">RESTful API 规范</a><ul>
                        
                <li>
                    <a href="#%e5%8a%a8%e4%bd%9c" aria-label="动作">动作</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%b7%af%e5%be%84%e6%8e%a5%e5%8f%a3%e5%91%bd%e5%90%8d" aria-label="路径（接口命名）">路径（接口命名）</a></li>
                <li>
                    <a href="#%e8%bf%87%e6%bb%a4%e4%bf%a1%e6%81%affiltering" aria-label="过滤信息（Filtering）">过滤信息（Filtering）</a></li>
                <li>
                    <a href="#%e7%8a%b6%e6%80%81%e7%a0%81status-codes" aria-label="状态码（Status Codes）">状态码（Status Codes）</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b%e7%ae%80%e6%98%8e%e6%95%99%e7%a8%8b" aria-label="软件工程简明教程">软件工程简明教程</a><ul>
                        
                <li>
                    <a href="#%e4%bd%95%e4%b8%ba%e8%bd%af%e4%bb%b6%e5%b7%a5%e7%a8%8b" aria-label="何为软件工程？">何为软件工程？</a></li>
                <li>
                    <a href="#%e8%bd%af%e4%bb%b6%e5%bc%80%e5%8f%91%e8%bf%87%e7%a8%8b" aria-label="软件开发过程">软件开发过程</a></li>
                <li>
                    <a href="#%e8%bd%af%e4%bb%b6%e5%bc%80%e5%8f%91%e6%a8%a1%e5%9e%8b" aria-label="软件开发模型">软件开发模型</a></li>
                <li>
                    <a href="#%e8%bd%af%e4%bb%b6%e5%bc%80%e5%8f%91%e7%9a%84%e5%9f%ba%e6%9c%ac%e7%ad%96%e7%95%a5" aria-label="软件开发的基本策略">软件开发的基本策略</a><ul>
                        
                <li>
                    <a href="#%e8%bd%af%e4%bb%b6%e5%a4%8d%e7%94%a8" aria-label="软件复用">软件复用</a></li>
                <li>
                    <a href="#%e5%88%86%e8%80%8c%e6%b2%bb%e4%b9%8b" aria-label="分而治之">分而治之</a></li>
                <li>
                    <a href="#%e9%80%90%e6%ad%a5%e6%bc%94%e8%bf%9b" aria-label="逐步演进">逐步演进</a></li>
                <li>
                    <a href="#%e4%bc%98%e5%8c%96%e6%8a%98%e4%b8%ad" aria-label="优化折中">优化折中</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%91%bd%e5%90%8d%e6%8c%87%e5%8d%97" aria-label="命名指南">命名指南</a><ul>
                        
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e5%91%bd%e5%90%8d%e8%a7%84%e5%88%99%e4%bb%a5%e5%8f%8a%e9%80%82%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="常见命名规则以及适用场景">常见命名规则以及适用场景</a><ul>
                        
                <li>
                    <a href="#%e9%a9%bc%e5%b3%b0%e5%91%bd%e5%90%8d%e6%b3%95camelcase" aria-label="驼峰命名法（CamelCase）">驼峰命名法（CamelCase）</a><ul>
                        
                <li>
                    <a href="#%e9%a9%bc%e5%b3%b0%e5%91%bd%e5%90%8d%e6%b3%95uppercamelcase" aria-label="驼峰命名法（UpperCamelCase）">驼峰命名法（UpperCamelCase）</a></li>
                <li>
                    <a href="#%e9%a9%bc%e5%b3%b0%e5%91%bd%e5%90%8d%e6%b3%95lowercamelcase" aria-label="驼峰命名法（lowerCamelCase）">驼峰命名法（lowerCamelCase）</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%9b%87%e5%bd%a2%e5%91%bd%e5%90%8d%e6%b3%95snake_case" aria-label="蛇形命名法（snake_case）">蛇形命名法（snake_case）</a></li>
                <li>
                    <a href="#%e4%b8%b2%e5%bc%8f%e5%91%bd%e5%90%8d%e6%b3%95kebab-case" aria-label="串式命名法（kebab-case）">串式命名法（kebab-case）</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e5%91%bd%e5%90%8d%e8%a7%84%e8%8c%83" aria-label="常见命名规范">常见命名规范</a><ul>
                        
                <li>
                    <a href="#java-%e8%af%ad%e8%a8%80%e5%9f%ba%e6%9c%ac%e5%91%bd%e5%90%8d%e8%a7%84%e8%8c%83" aria-label="Java 语言基本命名规范">Java 语言基本命名规范</a></li>
                <li>
                    <a href="#%e5%91%bd%e5%90%8d%e6%98%93%e8%af%bb%e6%80%a7%e8%a7%84%e8%8c%83" aria-label="命名易读性规范">命名易读性规范</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e4%bb%a3%e7%a0%81%e9%87%8d%e6%9e%84" aria-label="代码重构">代码重构</a><ul>
                        
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e9%87%8d%e6%9e%84" aria-label="为什么要重构？">为什么要重构？</a></li>
                <li>
                    <a href="#%e4%bd%95%e6%97%b6%e8%bf%9b%e8%a1%8c%e9%87%8d%e6%9e%84" aria-label="何时进行重构？">何时进行重构？</a><ul>
                        
                <li>
                    <a href="#%e6%8f%90%e4%ba%a4%e4%bb%a3%e7%a0%81%e4%b9%8b%e5%89%8d" aria-label="提交代码之前">提交代码之前</a></li>
                <li>
                    <a href="#%e5%bc%80%e5%8f%91%e4%b8%80%e4%b8%aa%e6%96%b0%e5%8a%9f%e8%83%bd%e4%b9%8b%e5%90%8e%e4%b9%8b%e5%89%8d" aria-label="开发一个新功能之后&amp;amp;之前">开发一个新功能之后&amp;之前</a></li>
                <li>
                    <a href="#code-review-%e4%b9%8b%e5%90%8e" aria-label="Code Review 之后">Code Review 之后</a></li>
                <li>
                    <a href="#%e6%8d%a1%e5%9e%83%e5%9c%be%e5%bc%8f%e9%87%8d%e6%9e%84" aria-label="捡垃圾式重构">捡垃圾式重构</a></li>
                <li>
                    <a href="#%e6%8d%a1%e5%9e%83%e5%9c%be%e5%bc%8f%e9%87%8d%e6%9e%84-1" aria-label="捡垃圾式重构">捡垃圾式重构</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%87%8d%e6%9e%84%e6%9c%89%e5%93%aa%e4%ba%9b%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" aria-label="重构有哪些注意事项？">重构有哪些注意事项？</a><ul>
                        
                <li>
                    <a href="#%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95%e6%98%af%e9%87%8d%e6%9e%84%e7%9a%84%e4%bf%9d%e6%8a%a4%e7%bd%91" aria-label="单元测试是重构的保护网">单元测试是重构的保护网</a></li>
                <li>
                    <a href="#%e4%b8%8d%e8%a6%81%e4%b8%ba%e4%ba%86%e9%87%8d%e6%9e%84%e8%80%8c%e9%87%8d%e6%9e%84" aria-label="不要为了重构而重构">不要为了重构而重构</a></li>
                <li>
                    <a href="#%e9%81%b5%e5%be%aa%e6%96%b9%e6%b3%95" aria-label="遵循方法">遵循方法</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e7%bb%83%e4%b9%a0%e9%87%8d%e6%9e%84" aria-label="如何练习重构？">如何练习重构？</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95%e6%8c%87%e5%8d%97" aria-label="单元测试指南">单元测试指南</a><ul>
                        
                <li>
                    <a href="#%e4%bd%95%e8%b0%93%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95" aria-label="何谓单元测试？">何谓单元测试？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e9%9c%80%e8%a6%81%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95" aria-label="为什么需要单元测试？">为什么需要单元测试？</a><ul>
                        
                <li>
                    <a href="#%e4%b8%ba%e9%87%8d%e6%9e%84%e4%bf%9d%e9%a9%be%e6%8a%a4%e8%88%aa" aria-label="为重构保驾护航">为重构保驾护航</a></li>
                <li>
                    <a href="#%e6%8f%90%e9%ab%98%e4%bb%a3%e7%a0%81%e8%b4%a8%e9%87%8f" aria-label="提高代码质量">提高代码质量</a></li>
                <li>
                    <a href="#%e5%87%8f%e5%b0%91-bug" aria-label="减少 bug">减少 bug</a></li>
                <li>
                    <a href="#%e5%bf%ab%e9%80%9f%e5%ae%9a%e4%bd%8d-bug" aria-label="快速定位 bug">快速定位 bug</a></li>
                <li>
                    <a href="#%e6%8c%81%e7%bb%ad%e9%9b%86%e6%88%90%e4%be%9d%e8%b5%96%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95" aria-label="持续集成依赖单元测试">持续集成依赖单元测试</a></li></ul>
                </li>
                <li>
                    <a href="#%e8%b0%81%e9%80%bc%e4%bd%a0%e5%86%99%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95" aria-label="谁逼你写单元测试？">谁逼你写单元测试？</a><ul>
                        
                <li>
                    <a href="#%e9%a2%86%e5%af%bc%e8%a6%81%e6%b1%82" aria-label="领导要求">领导要求</a></li>
                <li>
                    <a href="#%e5%a4%a7%e7%89%9b%e9%83%bd%e5%86%99%e5%8d%95%e5%85%83%e6%b5%8b%e8%af%95" aria-label="大牛都写单元测试">大牛都写单元测试</a></li>
                <li>
                    <a href="#%e4%bf%9d%e4%bd%8f%e9%9d%a2%e5%ad%90" aria-label="保住面子">保住面子</a></li>
                <li>
                    <a href="#%e5%bf%83%e8%99%9a" aria-label="心虚">心虚</a></li></ul>
                </li>
                <li>
                    <a href="#tdd-%e6%b5%8b%e8%af%95%e9%a9%b1%e5%8a%a8%e5%bc%80%e5%8f%91" aria-label="TDD 测试驱动开发">TDD 测试驱动开发</a><ul>
                        
                <li>
                    <a href="#%e4%bd%95%e8%b0%93-tdd" aria-label="何谓 TDD？">何谓 TDD？</a></li>
                <li>
                    <a href="#tdd-%e4%bc%98%e7%bc%ba%e7%82%b9%e5%88%86%e6%9e%90" aria-label="TDD 优缺点分析">TDD 优缺点分析</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%8d%95%e6%b5%8b%e6%a1%86%e6%9e%b6%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9" aria-label="单测框架如何选择？">单测框架如何选择？</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="restful-api-简明教程">RestFul API 简明教程<a hidden class="anchor" aria-hidden="true" href="#restful-api-简明教程">#</a></h1>
<h2 id="何为-api">何为 API？<a hidden class="anchor" aria-hidden="true" href="#何为-api">#</a></h2>
<p><strong>API（Application Programming Interface）</strong> 翻译过来是应用程序编程接口的意思。</p>
<p>我们在进行后端开发的时候，主要的工作就是为前端或者其他后端服务提供 API 比如查询用户数据的 API 。</p>
<p>但是， API 不仅仅代表后端系统暴露的接口，像框架中提供的方法也属于 API 的范畴。</p>
<p>为了方便大家理解，我再列举几个例子 🌰：</p>
<ol>
<li>你通过某电商网站搜索某某商品，电商网站的前端就调用了后端提供了搜索商品相关的 API。</li>
<li>你使用 JDK 开发 Java 程序，想要读取用户的输入的话，你就需要使用 JDK 提供的 IO 相关的 API。</li>
<li>&hellip;&hellip;</li>
</ol>
<p>你可以把 API 理解为程序与程序之间通信的桥梁，其本质就是一个函数而已。另外，API 的使用也不是没有章法的，它的规则由（比如数据输入和输出的格式）API 提供方制定。</p>
<h2 id="何为-restful-api">何为 RESTful API？<a hidden class="anchor" aria-hidden="true" href="#何为-restful-api">#</a></h2>
<p><strong>RESTful API</strong> 经常也被叫做 <strong>REST API</strong>，它是基于 REST 构建的 API。这个 REST 到底是什么，我们后文在讲，涉及到的概念比较多。</p>
<p>如果你看 RESTful API 相关的文章的话一般都比较晦涩难懂，主要是因为 REST 涉及到的一些概念比较难以理解。但是，实际上，我们平时开发用到的 RESTful API 的知识非常简单也很容易概括！</p>
<p>举个例子，如果我给你下面两个 API 你是不是立马能知道它们是干什么用的！这就是 RESTful API 的强大之处！</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>GET    /classes：列出所有班级
</span></span><span style="display:flex;"><span>POST   /classes：新建一个班级
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>RESTful API 可以让你看到 URL+Http Method 就知道这个 URL 是干什么的，让你看到了 HTTP 状态码（status code）就知道请求结果如何。</strong></p>
<p>像咱们在开发过程中设计 API 的时候也应该至少要满足 RESTful API 的最基本的要求（比如接口中尽量使用名词，使用 <code>POST</code> 请求创建资源，<code>DELETE</code> 请求删除资源等等，示例：<code>GET /notes/id</code>：获取某个指定 id 的笔记的信息）。</p>
<h2 id="解读-rest">解读 REST<a hidden class="anchor" aria-hidden="true" href="#解读-rest">#</a></h2>
<p><strong>REST</strong> 是 <code>REpresentational State Transfer</code> 的缩写。这个词组的翻译过来就是“<strong>表现层状态转化</strong>”。</p>
<p>这样理解起来甚是晦涩，实际上 REST 的全称是 <strong>Resource Representational State Transfer</strong> ，直白地翻译过来就是 <strong>“资源”在网络传输中以某种“表现形式”进行“状态转移”</strong> 。如果还是不能继续理解，请继续往下看，相信下面的讲解一定能让你理解到底啥是 REST 。</p>
<p>我们分别对上面涉及到的概念进行解读，以便加深理解，实际上你不需要搞懂下面这些概念，也能看懂我下一部分要介绍到的内容。不过，为了更好地能跟别人扯扯 “RESTful API”我建议你还是要好好理解一下！</p>
<ul>
<li><strong>资源（Resource）</strong>：我们可以把真实的对象数据称为资源。一个资源既可以是一个集合，也可以是单个个体。比如我们的班级 classes 是代表一个集合形式的资源，而特定的 class 代表单个个体资源。每一种资源都有特定的 URI（统一资源标识符）与之对应，如果我们需要获取这个资源，访问这个 URI 就可以了，比如获取特定的班级：<code>/class/12</code>。另外，资源也可以包含子资源，比如 <code>/classes/classId/teachers</code>：列出某个指定班级的所有老师的信息</li>
<li><strong>表现形式（Representational）</strong>：&ldquo;资源&quot;是一种信息实体，它可以有多种外在表现形式。我们把&quot;资源&quot;具体呈现出来的形式比如 <code>json</code>，<code>xml</code>，<code>image</code>,<code>txt</code> 等等叫做它的&quot;表现层/表现形式&rdquo;。</li>
<li><strong>状态转移（State Transfer）</strong>：大家第一眼看到这个词语一定会很懵逼？内心 BB：这尼玛是啥啊？ 大白话来说 REST 中的状态转移更多地描述的服务器端资源的状态，比如你通过增删改查（通过 HTTP 动词实现）引起资源状态的改变。ps:互联网通信协议 HTTP 协议，是一个无状态协议，所有的资源状态都保存在服务器端。</li>
</ul>
<p>综合上面的解释，我们总结一下什么是 RESTful 架构：</p>
<ol>
<li>每一个 URI 代表一种资源；</li>
<li>客户端和服务器之间，传递这种资源的某种表现形式比如 <code>json</code>，<code>xml</code>，<code>image</code>,<code>txt</code> 等等；</li>
<li>客户端通过特定的 HTTP 动词，对服务器端资源进行操作，实现&quot;表现层状态转化&quot;。</li>
</ol>
<h2 id="restful-api-规范">RESTful API 规范<a hidden class="anchor" aria-hidden="true" href="#restful-api-规范">#</a></h2>
<h3 id="动作">动作<a hidden class="anchor" aria-hidden="true" href="#动作">#</a></h3>
<ul>
<li><code>GET</code>：请求从服务器获取特定资源。举个例子：<code>GET /classes</code>（获取所有班级）</li>
<li><code>POST</code>：在服务器上创建一个新的资源。举个例子：<code>POST /classes</code>（创建班级）</li>
<li><code>PUT</code>：更新服务器上的资源（客户端提供更新后的整个资源）。举个例子：<code>PUT /classes/12</code>（更新编号为 12 的班级）</li>
<li><code>DELETE</code>：从服务器删除特定的资源。举个例子：<code>DELETE /classes/12</code>（删除编号为 12 的班级）</li>
<li><code>PATCH</code>：更新服务器上的资源（客户端提供更改的属性，可以看做作是部分更新），使用的比较少，这里就不举例子了。</li>
</ul>
<h2 id="路径接口命名">路径（接口命名）<a hidden class="anchor" aria-hidden="true" href="#路径接口命名">#</a></h2>
<p>路径又称&quot;终点&quot;（endpoint），表示 API 的具体网址。实际开发中常见的规范如下：</p>
<ol>
<li><strong>网址中不能有动词，只能有名词，API 中的名词也应该使用复数。</strong> 因为 REST 中的资源往往和数据库中的表对应，而数据库中的表都是同种记录的&quot;集合&quot;（collection）。如果 API 调用并不涉及资源（如计算，翻译等操作）的话，可以用动词。比如：<code>GET /calculate?param1=11&amp;param2=33</code> 。</li>
<li><strong>不用大写字母，建议用中杠 - 不用下杠 _</strong> 。比如邀请码写成 <code>invitation-code</code>而不是 invitation_code 。</li>
<li><strong>善用版本化 API</strong>。当我们的 API 发生了重大改变而不兼容前期版本的时候，我们可以通过 URL 来实现版本化，比如 <code>http://api.example.com/v1</code>、<code>http://apiv1.example.com</code> 。版本不必非要是数字，只是数字用的最多，日期、季节都可以作为版本标识符，项目团队达成共识就可。</li>
<li><strong>接口尽量使用名词，避免使用动词。</strong> RESTful API 操作（HTTP Method）的是资源（名词）而不是动作（动词）。</li>
</ol>
<p>Talk is cheap！来举个实际的例子来说明一下吧！现在有这样一个 API 提供班级（class）的信息，还包括班级中的学生和教师的信息，则它的路径应该设计成下面这样。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>GET    /classes：列出所有班级
</span></span><span style="display:flex;"><span>POST   /classes：新建一个班级
</span></span><span style="display:flex;"><span>GET    /classes/{classId}：获取某个指定班级的信息
</span></span><span style="display:flex;"><span>PUT    /classes/{classId}：更新某个指定班级的信息（一般倾向整体更新）
</span></span><span style="display:flex;"><span>PATCH  /classes/{classId}：更新某个指定班级的信息（一般倾向部分更新）
</span></span><span style="display:flex;"><span>DELETE /classes/{classId}：删除某个班级
</span></span><span style="display:flex;"><span>GET    /classes/{classId}/teachers：列出某个指定班级的所有老师的信息
</span></span><span style="display:flex;"><span>GET    /classes/{classId}/students：列出某个指定班级的所有学生的信息
</span></span><span style="display:flex;"><span>DELETE /classes/{classId}/teachers/{ID}：删除某个指定班级下的指定的老师的信息
</span></span></code></pre></td></tr></table>
</div>
</div><p>反例：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>/getAllclasses
</span></span><span style="display:flex;"><span>/createNewclass
</span></span><span style="display:flex;"><span>/deleteAllActiveclasses
</span></span></code></pre></td></tr></table>
</div>
</div><p>理清资源的层次结构，比如业务针对的范围是学校，那么学校会是一级资源:<code>/schools</code>，老师: <code>/schools/teachers</code>，学生: <code>/schools/students</code> 就是二级资源。</p>
<h2 id="过滤信息filtering">过滤信息（Filtering）<a hidden class="anchor" aria-hidden="true" href="#过滤信息filtering">#</a></h2>
<p>如果我们在查询的时候需要添加特定条件的话，建议使用 url 参数的形式。比如我们要查询 state 状态为 active 并且 name 为 guidegege 的班级：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>GET    /classes?state=active&amp;name=guidegege
</span></span></code></pre></td></tr></table>
</div>
</div><p>比如我们要实现分页查询：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>GET    /classes?page=1&amp;size=10 //指定第1页，每页10个数据
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="状态码status-codes">状态码（Status Codes）<a hidden class="anchor" aria-hidden="true" href="#状态码status-codes">#</a></h2>
<p><strong>状态码范围：</strong></p>
<table>
<thead>
<tr>
<th>2xx：成功</th>
<th>3xx：重定向</th>
<th>4xx：客户端错误</th>
<th>5xx：服务器错误</th>
</tr>
</thead>
<tbody>
<tr>
<td>200 成功</td>
<td>301 永久重定向</td>
<td>400 参数错误</td>
<td>500 服务器错误</td>
</tr>
<tr>
<td>201 创建</td>
<td>304 资源未修改</td>
<td>401 未授权</td>
<td>502 网关错误</td>
</tr>
<tr>
<td></td>
<td></td>
<td>403 禁止访问</td>
<td>504 网关超时</td>
</tr>
<tr>
<td></td>
<td></td>
<td>404 未找到</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>405 请求方法不对</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="软件工程简明教程">软件工程简明教程<a hidden class="anchor" aria-hidden="true" href="#软件工程简明教程">#</a></h1>
<h2 id="何为软件工程">何为软件工程？<a hidden class="anchor" aria-hidden="true" href="#何为软件工程">#</a></h2>
<p>1968 年 NATO（北大西洋公约组织）提出了<strong>软件危机</strong>（<strong>Software crisis</strong>）一词。同年，为了解决软件危机问题，“<strong>软件工程</strong>”的概念诞生了。一门叫做软件工程的学科也就应运而生。</p>
<p>随着时间的推移，软件工程这门学科也经历了一轮又一轮的完善，其中的一些核心内容比如软件开发模型越来越丰富实用！</p>
<p><strong>什么是软件危机呢？</strong></p>
<p>简单来说，软件危机描述了当时软件开发的一个痛点：我们很难高效地开发出质量高的软件。</p>
<p>Dijkstra（Dijkstra 算法的作者） 在 1972 年图灵奖获奖感言中也提高过软件危机，他是这样说的：“导致软件危机的主要原因是机器变得功能强大了几个数量级！坦率地说：只要没有机器，编程就完全没有问题。当我们有一些弱小的计算机时，编程成为一个温和的问题，而现在我们有了庞大的计算机，编程也同样成为一个巨大的问题”。</p>
<p><strong>说了这么多，到底什么是软件工程呢？</strong></p>
<p>工程是为了解决实际的问题将理论应用于实践。软件工程指的就是将工程思想应用于软件开发。</p>
<p>上面是我对软件工程的定义，我们再来看看比较权威的定义。IEEE 软件工程汇刊给出的定义是这样的：　(1)将系统化的、规范的、可量化的方法应用到软件的开发、运行及维护中，即将工程化方法应用于软件。　(2)在(1)中所述方法的研究。</p>
<p>总之，软件工程的终极目标就是：<strong>在更少资源消耗的情况下，创造出更好、更容易维护的软件。</strong></p>
<h2 id="软件开发过程">软件开发过程<a hidden class="anchor" aria-hidden="true" href="#软件开发过程">#</a></h2>
<p><a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B">维基百科是这样定义软件开发过程open in new window</a>的：</p>
<blockquote>
<p>软件开发过程（英语：software development process），或软件过程（英语：software process），是软件开发的开发生命周期（software development life cycle），其各个阶段实现了软件的需求定义与分析、设计、实现、测试、交付和维护。软件过程是在开发与构建系统时应遵循的步骤，是软件开发的路线图。</p>
</blockquote>
<ul>
<li>需求分析：分析用户的需求，建立逻辑模型。</li>
<li>软件设计：根据需求分析的结果对软件架构进行设计。</li>
<li>编码：编写程序运行的源代码。</li>
<li>测试 : 确定测试用例，编写测试报告。</li>
<li>交付：将做好的软件交付给客户。</li>
<li>维护：对软件进行维护比如解决 bug，完善功能。</li>
</ul>
<p>软件开发过程只是比较笼统的层面上，一定义了一个软件开发可能涉及到的一些流程。</p>
<p>软件开发模型更具体地定义了软件开发过程，对开发过程提供了强有力的理论支持。</p>
<h2 id="软件开发模型">软件开发模型<a hidden class="anchor" aria-hidden="true" href="#软件开发模型">#</a></h2>
<p>软件开发模型有很多种，比如瀑布模型（Waterfall Model）、快速原型模型（Rapid Prototype Model）、V 模型（V-model）、W 模型（W-model）、敏捷开发模型。其中最具有代表性的还是 <strong>瀑布模型</strong> 和 <strong>敏捷开发</strong> 。</p>
<p><strong>瀑布模型</strong> 定义了一套完成的软件开发周期，完整地展示了一个软件的的生命周期。</p>
<p><img loading="lazy" src="up-264f2750a3d30366e36c375ec3a30ec2775.png" alt=""  />
</p>
<p><strong>敏捷开发模型</strong> 是目前使用的最多的一种软件开发模型。<a href="https://wiki.mbalib.com/wiki/%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91">MBA 智库百科对敏捷开发的描述open in new window</a>是这样的:</p>
<blockquote>
<p><strong>敏捷开发</strong> 是一种以人为核心、迭代、循序渐进的开发方法。在敏捷开发中，软件项目的构建被切分成多个子项目，各个子项目的成果都经过测试，具备集成和可运行的特征。换言之，就是把一个大项目分为多个相互联系，但也可独立运行的小项目，并分别完成，在此过程中软件一直处于可使用状态。</p>
</blockquote>
<p>像现在比较常见的一些概念比如 <strong>持续集成</strong>、<strong>重构</strong>、<strong>小版本发布</strong>、<strong>低文档</strong>、<strong>站会</strong>、<strong>结对编程</strong>、<strong>测试驱动开发</strong> 都是敏捷开发的核心。</p>
<h2 id="软件开发的基本策略">软件开发的基本策略<a hidden class="anchor" aria-hidden="true" href="#软件开发的基本策略">#</a></h2>
<h3 id="软件复用">软件复用<a hidden class="anchor" aria-hidden="true" href="#软件复用">#</a></h3>
<p>我们在构建一个新的软件的时候，不需要从零开始，通过复用已有的一些轮子（框架、第三方库等）、设计模式、设计原则等等现成的物料，我们可以更快地构建出一个满足要求的软件。</p>
<p>像我们平时接触的开源项目就是最好的例子。我想，如果不是开源，我们构建出一个满足要求的软件，耗费的精力和时间要比现在多的多！</p>
<h3 id="分而治之">分而治之<a hidden class="anchor" aria-hidden="true" href="#分而治之">#</a></h3>
<p>构建软件的过程中，我们会遇到很多问题。我们可以将一些比较复杂的问题拆解为一些小问题，然后，一一攻克。</p>
<p>我结合现在比较火的软件设计方法—领域驱动设计（Domain Driven Design，简称 DDD）来说说。</p>
<p>在领域驱动设计中，很重要的一个概念就是<strong>领域（Domain）</strong>，它就是我们要解决的问题。在领域驱动设计中，我们要做的就是把比较大的领域（问题）拆解为若干的小领域（子域）。</p>
<p>除此之外，分而治之也是一个比较常用的算法思想，对应的就是分治算法。如果你想了解分治算法的话，推荐你看一下北大的<a href="https://www.coursera.org/learn/algorithms">《算法设计与分析 Design and Analysis of Algorithms》open in new window</a>。</p>
<h3 id="逐步演进">逐步演进<a hidden class="anchor" aria-hidden="true" href="#逐步演进">#</a></h3>
<p>软件开发是一个逐步演进的过程，我们需要不断进行迭代式增量开发，最终交付符合客户价值的产品。</p>
<p>这里补充一个在软件开发领域，非常重要的概念：<strong>MVP（Minimum Viable Product，最小可行产品</strong>）。</p>
<p>这个最小可行产品，可以理解为刚好能够满足客户需求的产品。下面这张图片把这个思想展示的非常精髓。</p>
<p><img loading="lazy" src="up-a99961ff7725106c0592abca845d555568a.png" alt=""  />
</p>
<p>利用最小可行产品，我们可以也可以提早进行市场分析，这对于我们在探索产品不确定性的道路上非常有帮助。可以非常有效地指导我们下一步该往哪里走。</p>
<h3 id="优化折中">优化折中<a hidden class="anchor" aria-hidden="true" href="#优化折中">#</a></h3>
<p>软件开发是一个不断优化改进的过程。任何软件都有很多可以优化的点，不可能完美。我们需要不断改进和提升软件的质量。</p>
<p>但是，也不要陷入这个怪圈。要学会折中，在有限的投入内，以最有效的方式提高现有软件的质量。</p>
<h1 id="命名指南">命名指南<a hidden class="anchor" aria-hidden="true" href="#命名指南">#</a></h1>
<h2 id="常见命名规则以及适用场景">常见命名规则以及适用场景<a hidden class="anchor" aria-hidden="true" href="#常见命名规则以及适用场景">#</a></h2>
<p>这里只介绍 3 种最常见的命名规范。</p>
<h3 id="驼峰命名法camelcase">驼峰命名法（CamelCase）<a hidden class="anchor" aria-hidden="true" href="#驼峰命名法camelcase">#</a></h3>
<p>驼峰命名法应该我们最常见的一个，这种命名方式使用大小写混合的格式来区别各个单词，并且单词之间不使用空格隔开或者连接字符连接的命名方式</p>
<h4 id="驼峰命名法uppercamelcase">驼峰命名法（UpperCamelCase）<a hidden class="anchor" aria-hidden="true" href="#驼峰命名法uppercamelcase">#</a></h4>
<p><strong>类名需要使用大驼峰命名法（UpperCamelCase）</strong></p>
<p>正例：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>ServiceDiscovery<span style="color:#f00">、</span>ServiceInstance<span style="color:#f00">、</span>LruCacheFactory
</span></span></code></pre></td></tr></table>
</div>
</div><p>反例：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>serviceDiscovery<span style="color:#f00">、</span>Serviceinstance<span style="color:#f00">、</span>LRUCacheFactory
</span></span></code></pre></td></tr></table>
</div>
</div><h4 id="驼峰命名法lowercamelcase">驼峰命名法（lowerCamelCase）<a hidden class="anchor" aria-hidden="true" href="#驼峰命名法lowercamelcase">#</a></h4>
<p><strong>方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。</strong></p>
<p>正例：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>getUserInfo()
</span></span><span style="display:flex;"><span>createCustomThreadPool()
</span></span><span style="display:flex;"><span>setNameFormat(String nameFormat)
</span></span><span style="display:flex;"><span>Uservice userService;
</span></span></code></pre></td></tr></table>
</div>
</div><p>反例：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>GetUserInfo()<span style="color:#f00">、</span>CreateCustomThreadPool()<span style="color:#f00">、</span>setNameFormat(String NameFormat)
</span></span><span style="display:flex;"><span>Uservice user_service
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="蛇形命名法snake_case">蛇形命名法（snake_case）<a hidden class="anchor" aria-hidden="true" href="#蛇形命名法snake_case">#</a></h3>
<p><strong>测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）</strong></p>
<p>在蛇形命名法中，各个单词之间通过下划线“_”连接，比如<code>should_get_200_status_code_when_request_is_valid</code>、<code>CLIENT_CONNECT_SERVER_FAILURE</code>。</p>
<p>蛇形命名法的优势是命名所需要的单词比较多的时候，比如我把上面的命名通过小驼峰命名法给大家看一下：“shouldGet200StatusCodeWhenRequestIsValid”。</p>
<p>感觉如何？ 相比于使用蛇形命名法（snake_case）来说是不是不那么易读？</p>
<p>正例：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>@Test
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> should_get_200_status_code_when_request_is_valid() {
</span></span><span style="display:flex;"><span>  ......
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>反例：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>@Test
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> shouldGet200StatusCodeWhenRequestIsValid() {
</span></span><span style="display:flex;"><span>  ......
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="串式命名法kebab-case">串式命名法（kebab-case）<a hidden class="anchor" aria-hidden="true" href="#串式命名法kebab-case">#</a></h3>
<p>在串式命名法中，各个单词之间通过连接符“-”连接，比如<code>dubbo-registry</code>。</p>
<p>建议项目文件夹名称使用串式命名法（kebab-case），比如 dubbo 项目的各个模块的命名是下面这样的。</p>
<p><img loading="lazy" src="dubbo-naming.png" alt=""  />
</p>
<h2 id="常见命名规范">常见命名规范<a hidden class="anchor" aria-hidden="true" href="#常见命名规范">#</a></h2>
<h3 id="java-语言基本命名规范">Java 语言基本命名规范<a hidden class="anchor" aria-hidden="true" href="#java-语言基本命名规范">#</a></h3>
<p><strong>1、类名需要使用大驼峰命名法（UpperCamelCase）风格。方法名、参数名、成员变量、局部变量需要使用小驼峰命名法（lowerCamelCase）。</strong></p>
<p><strong>2、测试方法名、常量、枚举名称需要使用蛇形命名法（snake_case）</strong>，比如<code>should_get_200_status_code_when_request_is_valid</code>、<code>CLIENT_CONNECT_SERVER_FAILURE</code>。并且，<strong>测试方法名称要求全部小写，常量以及枚举名称需要全部大写。</strong></p>
<p><strong>3、项目文件夹名称使用串式命名法（kebab-case），比如<code>dubbo-registry</code>。</strong></p>
<p><strong>4、包名统一使用小写，尽量使用单个名词作为包名，各个单词通过 &ldquo;.&rdquo; 分隔符连接，并且各个单词必须为单数。</strong></p>
<p>正例：<code>org.apache.dubbo.common.threadlocal</code></p>
<p>反例：<code>org.apache_dubbo.Common.threadLocals</code></p>
<p><strong>5、抽象类命名使用 Abstract 开头</strong>。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">//为远程传输部分抽象出来的一个抽象类（出处：Dubbo源码）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">abstract</span> <span style="color:#fff;font-weight:bold">class</span> AbstractClient <span style="color:#fff;font-weight:bold">extends</span> AbstractEndpoint <span style="color:#fff;font-weight:bold">implements</span> Client {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>6、异常类命名使用 Exception 结尾。</strong></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">//自定义的 NoSuchMethodException（出处：Dubbo源码）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> NoSuchMethodException <span style="color:#fff;font-weight:bold">extends</span> RuntimeException {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> <span style="color:#fff;font-weight:bold">long</span> serialVersionUID = -<span style="color:#ff0;font-weight:bold">2725364246023268766L</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> NoSuchMethodException() {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">super</span>();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> NoSuchMethodException(String msg) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">super</span>(msg);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>7、测试类命名以它要测试的类的名称开始，以 Test 结尾。</strong></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">//为 AnnotationUtils 类写的测试类（出处：Dubbo源码）
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">class</span> AnnotationUtilsTest {
</span></span><span style="display:flex;"><span>  ......
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>POJO 类中布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。</p>
<p>如果模块、接口、类、方法使用了设计模式，在命名时需体现出具体模式。</p>
<h3 id="命名易读性规范">命名易读性规范<a hidden class="anchor" aria-hidden="true" href="#命名易读性规范">#</a></h3>
<p><strong>1、为了能让命名更加易懂和易读，尽量不要缩写/简写单词，除非这些单词已经被公认可以被这样缩写/简写。比如 <code>CustomThreadFactory</code> 不可以被写成 ~~<code>CustomTF</code> 。</strong></p>
<p><strong>2、命名不像函数一样要尽量追求短，可读性强的名字优先于简短的名字，虽然可读性强的名字会比较长一点。</strong> 这个对应我们上面说的第 1 点。</p>
<p><strong>3、避免无意义的命名，你起的每一个名字都要能表明意思。</strong></p>
<p>正例：<code>UserService userService;</code> <code>int userCount</code>;</p>
<p>反例: <code>UserService service</code> <code>int count</code></p>
<p><strong>4、避免命名过长（50 个字符以内最好），过长的命名难以阅读并且丑陋。</strong></p>
<p><strong>5、不要使用拼音，更不要使用中文。</strong> 不过像 alibaba、wuhan、taobao 这种国际通用名词可以当做英文来看待。</p>
<p>正例：discount</p>
<p>反例：dazhe</p>
<h1 id="代码重构">代码重构<a hidden class="anchor" aria-hidden="true" href="#代码重构">#</a></h1>
<p>学习重构必看的一本神书《重构：改善代码既有设计》从两个角度给出了重构的定义：</p>
<blockquote>
<ul>
<li>重构（名词）：对软件内部结构的一种调整，目的是在不改变软件可观察行为的前提下，提高其可理解性，降低其修改成本。</li>
<li>重构（动词）：使用一系列重构手法，在不改变软件可观察行为的前提下，调整其结构。</li>
</ul>
</blockquote>
<p>用更贴近工程师的语言来说：<strong>重构就是利用设计模式(如组合模式、策略模式、责任链模式)、软件设计原则（如 SOLID 原则、YAGNI 原则、KISS 原则）和重构手段（如封装、继承、构建测试体系）来让代码更容易理解，更易于修改。</strong></p>
<p>软件设计原则指导着我们组织和规范代码，同时，重构也是为了能够尽量设计出尽量满足软件设计原则的软件。</p>
<p>正确重构的核心在于 <strong>步子一定要小，每一步的重构都不会影响软件的正常运行，可以随时停止重构。</strong></p>
<h2 id="为什么要重构">为什么要重构？<a hidden class="anchor" aria-hidden="true" href="#为什么要重构">#</a></h2>
<p>在上面介绍重构定义的时候，我从比较抽象的角度介绍了重构的好处：重构的主要目的主要是提升代码&amp;架构的灵活性/可扩展性以及复用性。</p>
<p>如果对应到一个真实的项目，重构具体能为我们带来什么好处呢？</p>
<ol>
<li><strong>让代码更容易理解</strong>：通过添加注释、命名规范、逻辑优化等手段可以让我们的代码更容易被理解；</li>
<li><strong>避免代码腐化</strong>：通过重构干掉坏味道代码；</li>
<li><strong>加深对代码的理解</strong>：重构代码的过程会加深你对某部分代码的理解；</li>
<li><strong>发现潜在 bug</strong>：是这样的，很多潜在的 bug ，都是我们在重构的过程中发现的；</li>
<li>&hellip;&hellip;</li>
</ol>
<p>看了上面介绍的关于重构带来的好处之后，你会发现重构的最终目标是 <strong>提高软件开发速度和质量</strong> 。</p>
<p>重构并不会减慢软件开发速度，相反，如果代码质量和软件设计较差，当我们想要添加新功能的话，开发速度会越来越慢。到了最后，甚至都有想要重写整个系统的冲动。</p>
<p><img loading="lazy" src="bad&amp;good-design.png" alt=""  />
</p>
<p>《重构：改善代码既有设计》这本书中这样说：</p>
<blockquote>
<p>重构的唯一目的就是让我们开发更快，用更少的工作量创造更大的价值。</p>
</blockquote>
<h2 id="何时进行重构">何时进行重构？<a hidden class="anchor" aria-hidden="true" href="#何时进行重构">#</a></h2>
<p>重构在是开发过程中随时可以进行的，见机行事即可，并不需要单独分配一两天的时间专门用来重构。</p>
<h3 id="提交代码之前">提交代码之前<a hidden class="anchor" aria-hidden="true" href="#提交代码之前">#</a></h3>
<p>《重构：改善代码既有设计》这本书介绍了一个 <strong>营地法则</strong> 的概念:</p>
<blockquote>
<p>编程时，需要遵循营地法则：保证你离开时的代码库一定比来时更健康。</p>
</blockquote>
<p>这个概念表达的核心思想其实很简单：在你提交代码的之前，花一会时间想一想，我这次的提交是让项目代码变得更健康了，还是更腐化了，或者说没什么变化？</p>
<p>项目团队的每一个人只有保证自己的提交没有让项目代码变得更腐化，项目代码才会朝着健康的方向发展。</p>
<p><strong>当我们离开营地（项目代码）的时候，请不要留下垃圾！尽量确保营地变得更干净了！</strong></p>
<h3 id="开发一个新功能之后之前">开发一个新功能之后&amp;之前<a hidden class="anchor" aria-hidden="true" href="#开发一个新功能之后之前">#</a></h3>
<p>在开发一个新功能之后，我们应该回过头看看是不是有可以改进的地方。在添加一个新功能之前，我们可以思考一下自己是否可以重构代码以让新功能的开发更容易。</p>
<p>一个新功能的开发不应该仅仅只有功能验证通过那么简单，我们还应该尽量保证代码质量。</p>
<p>有一个两顶帽子的比喻：在我开发新功能之前，我发现重构可以让新功能的开发更容易，于是我戴上了重构的帽子。重构之后，我换回原来的帽子，继续开发新能功能。新功能开发完成之后，我又发现自己的代码难以理解，于是我又戴上了重构帽子。比较好的开发状态就是就是这样在重构和开发新功能之间来回切换。</p>
<h3 id="code-review-之后">Code Review 之后<a hidden class="anchor" aria-hidden="true" href="#code-review-之后">#</a></h3>
<p>Code Review 可以非常有效提高代码的整体质量，它会帮助我们发现代码中的坏味道以及可能存在问题的地方。并且， Code Review 可以帮助项目团队其他程序员理解你负责的业务模块，有效避免人员方面的单点风险。</p>
<p>经历一次 Code Review ，你的代码可能会收到很多改进建议。</p>
<h3 id="捡垃圾式重构">捡垃圾式重构<a hidden class="anchor" aria-hidden="true" href="#捡垃圾式重构">#</a></h3>
<p>当我们发现垃圾代码的时候，如果我们不想停下手头自己正在做的工作，但又不想放着垃圾不管，我们可以这样做：</p>
<ul>
<li>如果这个垃圾很容易重构的话，我们可以立即重构它。</li>
<li>如果这个垃圾不太容易重构的话，我们可以先记录下来，当完成当下的任务再回来重构它。</li>
</ul>
<h3 id="捡垃圾式重构-1">捡垃圾式重构<a hidden class="anchor" aria-hidden="true" href="#捡垃圾式重构-1">#</a></h3>
<p>当我们发现坏味道代码（垃圾）的时候，如果我们不想停下手头自己正在做的工作，但又不想放着垃圾不管，我们可以这样做：</p>
<ul>
<li>如果这个垃圾很容易重构的话，我们可以立即重构它。</li>
<li>如果这个垃圾不太容易重构的话，我们可以先记录下来，当完成当下的任务再回来重构它。</li>
</ul>
<h2 id="重构有哪些注意事项">重构有哪些注意事项？<a hidden class="anchor" aria-hidden="true" href="#重构有哪些注意事项">#</a></h2>
<h3 id="单元测试是重构的保护网">单元测试是重构的保护网<a hidden class="anchor" aria-hidden="true" href="#单元测试是重构的保护网">#</a></h3>
<p><strong>单元测试可以为重构提供信心，降低重构的成本。我们要像重视生产代码那样，重视单元测试。</strong></p>
<p>另外，多提一句：持续集成也要依赖单元测试，当持续集成服务自动构建新代码之后，会自动运行单元测试来发现代码错误。</p>
<p><strong>怎样才能算单元测试呢？</strong> 网上的定义很多，很抽象，很容易把人给看迷糊了。我觉得对于单元测试的定义主要取决于你的项目，一个函数甚至是一个类都可以看作是一个单元。就比如说我们写了一个计算个人股票收益率的方法，我们为了验证它的正确性专门为它写了一个单元测试。再比如说我们代码有一个类专门负责数据脱敏，我们为了验证脱敏是否符合预期专门为这个类写了一个单元测试。</p>
<p><strong>单元测试也是需要重构或者修改的。</strong> <a href="https://book.douban.com/subject/4199741/">《代码整洁之道:敏捷软件开发手册》open in new window</a>这本书这样写到：</p>
<blockquote>
<p>测试代码需要随着生产代码的演进而修改，如果测试不能保持整洁，只会越来越难修改。</p>
</blockquote>
<h3 id="不要为了重构而重构">不要为了重构而重构<a hidden class="anchor" aria-hidden="true" href="#不要为了重构而重构">#</a></h3>
<p><strong>重构一定是要为项目带来价值的！</strong> 某些情况下我们不应该进行重构：</p>
<ul>
<li>学习了某个设计模式/工程实践之后，不顾项目实际情况，刻意使用在项目上（避免货物崇拜编程）；</li>
<li>项目进展比较急的时候，重构项目调用的某个 API 的底层代码（重构之后对项目调用这个 API 并没有带来什么价值）；</li>
<li>重写比重构更容易更省事；</li>
<li>&hellip;&hellip;</li>
</ul>
<h3 id="遵循方法">遵循方法<a hidden class="anchor" aria-hidden="true" href="#遵循方法">#</a></h3>
<p>《重构：改善代码既有设计》这本书中列举除了代码常见的一些坏味道（比如重复代码、过长函数）和重构手段（如提炼函数、提炼变量、提炼类）。我们应该花时间去学习这些重构相关的理论知识，并在代码中去实践这些重构理论。</p>
<h2 id="如何练习重构">如何练习重构？<a hidden class="anchor" aria-hidden="true" href="#如何练习重构">#</a></h2>
<p>除了可以在重构项目代码的过程中练习精进重构之外，你还可以有下面这些手段：</p>
<ul>
<li><a href="https://linesh.gitbook.io/refactoring/">重构实战练习open in new window</a>：通过几个小案例一步一步带你学习重构！</li>
<li><a href="https://refactoringguru.cn/">设计模式+重构学习网站open in new window</a>：免费在线学习代码重构、 设计模式、 SOLID 原则 （单一职责、 开闭原则、 里氏替换、 接口隔离以及依赖反转） 。</li>
<li><a href="https://www.jetbrains.com/help/idea/refactoring-source-code.html#popular-refactorings">IDEA 官方文档的代码重构教程open in new window</a>：教你如何使用 IDEA 进行重构。</li>
</ul>
<h1 id="单元测试指南">单元测试指南<a hidden class="anchor" aria-hidden="true" href="#单元测试指南">#</a></h1>
<h2 id="何谓单元测试">何谓单元测试？<a hidden class="anchor" aria-hidden="true" href="#何谓单元测试">#</a></h2>
<p>维基百科是这样介绍单元测试的：</p>
<blockquote>
<p>在计算机编程中，单元测试（Unit Testing）是针对程序模块（软件设计的最小单位）进行的正确性检验测试工作。</p>
<p>程序单元是应用的 <strong>最小可测试部件</strong> 。在过程化编程中，一个单元就是单个程序、函数、过程等；对于面向对象编程，最小单元就是方法，包括基类（超类）、抽象类、或者派生类（子类）中的方法。</p>
</blockquote>
<p>由于每个单元有独立的逻辑，在做单元测试时，为了隔离外部依赖，确保这些依赖不影响验证逻辑，我们经常会用到 Fake、Stub 与 Mock 。</p>
<p>关于 Fake、Mock 与 Stub 这几个概念的解读，可以看看这篇文章：<a href="https://zhuanlan.zhihu.com/p/26942686">测试中 Fakes、Mocks 以及 Stubs 概念明晰 - 王下邀月熊 - 2018open in new window</a> 。</p>
<h2 id="为什么需要单元测试">为什么需要单元测试？<a hidden class="anchor" aria-hidden="true" href="#为什么需要单元测试">#</a></h2>
<h3 id="为重构保驾护航">为重构保驾护航<a hidden class="anchor" aria-hidden="true" href="#为重构保驾护航">#</a></h3>
<blockquote>
<p>单元测试可以为重构提供信心，降低重构的成本。我们要像重视生产代码那样，重视单元测试。</p>
</blockquote>
<p>每个开发者都会经历重构，重构后把代码改坏了的情况并不少见，很可能你只是修改了一个很简单的方法就导致系统出现了一个比较严重的错误。</p>
<p>如果有了单元测试的话，就不会存在这个隐患了。写完一个类，把单元测试写了，确保这个类逻辑正确；写第二个类，单元测试&hellip;..写 100 个类，道理一样，每个类做到第一点“保证逻辑正确性”，100 个类拼在一起肯定不出问题。你大可以放心一边重构，一边运行 APP；而不是整体重构完，提心吊胆地 run。</p>
<h3 id="提高代码质量">提高代码质量<a hidden class="anchor" aria-hidden="true" href="#提高代码质量">#</a></h3>
<p>由于每个单元有独立的逻辑，做单元测试时需要隔离外部依赖，确保这些依赖不影响验证逻辑。因为要把各种依赖分离，单元测试会促进工程进行组件拆分，整理工程依赖关系，更大程度减少代码耦合。这样写出来的代码，更好维护，更好扩展，从而提高代码质量。</p>
<h3 id="减少-bug">减少 bug<a hidden class="anchor" aria-hidden="true" href="#减少-bug">#</a></h3>
<p>一个机器，由各种细小的零件组成，如果其中某件零件坏了，机器运行故障。必须保证每个零件都按设计图要求的规格，机器才能正常运行。</p>
<p>一个可单元测试的工程，会把业务、功能分割成规模更小、有独立的逻辑部件，称为单元。单元测试的目标，就是保证各个单元的逻辑正确性。单元测试保障工程各个“零件”按“规格”（需求）执行，从而保证整个“机器”（项目）运行正确，最大限度减少 bug。</p>
<h3 id="快速定位-bug">快速定位 bug<a hidden class="anchor" aria-hidden="true" href="#快速定位-bug">#</a></h3>
<p>如果程序有 bug，我们运行一次全部单元测试，找到不通过的测试，可以很快地定位对应的执行代码。修复代码后，运行对应的单元测试；如还不通过，继续修改，运行测试&hellip;..直到<strong>测试通过</strong>。</p>
<h3 id="持续集成依赖单元测试">持续集成依赖单元测试<a hidden class="anchor" aria-hidden="true" href="#持续集成依赖单元测试">#</a></h3>
<p>持续集成需要依赖单元测试，当持续集成服务自动构建新代码之后，会自动运行单元测试来发现代码错误。</p>
<h2 id="谁逼你写单元测试">谁逼你写单元测试？<a hidden class="anchor" aria-hidden="true" href="#谁逼你写单元测试">#</a></h2>
<h3 id="领导要求">领导要求<a hidden class="anchor" aria-hidden="true" href="#领导要求">#</a></h3>
<p>有些经验丰富的领导，或多或少都会要求团队写单元测试。对于有一定工作经验的队友，这要求挺合理；对于经验尚浅的、毕业生，恐怕要死要活了，连代码都写不好，还要写单元测试，are you kidding me？</p>
<p>培训新人单元测试用法，是一项艰巨的任务。新人代码风格未形成，也不知道单元测试多重要，强制单元测试会让他们感到困惑，没办法按自己思路写代码。</p>
<h3 id="大牛都写单元测试">大牛都写单元测试<a hidden class="anchor" aria-hidden="true" href="#大牛都写单元测试">#</a></h3>
<p>国外很多家喻户晓的开源项目，都有大量单元测试。例如，<a href="https://link.jianshu.com?t=https://github.com/square/retrofit/tree/master/retrofit/src/test/java/retrofit2">retrofitopen in new window</a>、<a href="https://link.jianshu.com?t=https://github.com/square/okhttp/tree/master/okhttp-tests/src/test/java/okhttp3">okhttpopen in new window</a>、<a href="https://link.jianshu.com?t=https://github.com/JakeWharton/butterknife/tree/master/butterknife-compiler/src/test/java/butterknife">butterknifeopen in new window</a>&hellip;. 国外大牛都写单元测试，我们也写吧！</p>
<p>很多读者都有这种想法，一开始满腔热血。当真要对自己项目单元测试时，便困难重重，很大原因是项目对单元测试不友好。最后只能对一些不痛不痒的工具类做单元测试，久而久之，当初美好愿望也不了了之。</p>
<h3 id="保住面子">保住面子<a hidden class="anchor" aria-hidden="true" href="#保住面子">#</a></h3>
<p>都是有些许年经验的老鸟，还天天被测试同学追 bug，好意思么？花多一点时间写单元测试，确保没低级 bug，还能彰显大牛风范，何乐而不为？</p>
<h3 id="心虚">心虚<a hidden class="anchor" aria-hidden="true" href="#心虚">#</a></h3>
<p>笔者也是个不太相信自己代码的人，总觉得哪里会突然冒出莫名其妙的 bug，也怕别人不小心改了自己的代码（被害妄想症），新版本上线提心吊胆&hellip;&hellip;花点时间写单元测试，有事没事跑一下测试，确保原逻辑没问题，至少能睡安稳一点。</p>
<h2 id="tdd-测试驱动开发">TDD 测试驱动开发<a hidden class="anchor" aria-hidden="true" href="#tdd-测试驱动开发">#</a></h2>
<h3 id="何谓-tdd">何谓 TDD？<a hidden class="anchor" aria-hidden="true" href="#何谓-tdd">#</a></h3>
<p>TDD 即 Test-Driven Development（ 测试驱动开发），这是敏捷开发的一项核心实践和技术，也是一种设计方法论。</p>
<p>TDD 原理是开发功能代码之前，先编写测试用例代码，然后针对测试用例编写功能代码，使其能够通过。</p>
<p>TDD 的节奏：“红 - 绿 - 重构”。</p>
<p><img loading="lazy" src="090e1fc6aff08b4aa66376f776c2337f.png" alt="img"  />
</p>
<p>由于 TDD 对开发人员要求非常高，跟传统开发思维不一样，因此实施起来相当困难。</p>
<p>TDD 在很多人眼中是不实用的，一来他们并不理解测试“驱动”开发的含义，但更重要的是，他们很少会做任务分解。而任务分解是做好 TDD 的关键点。只有把任务分解到可以测试的地步，才能够有针对性地写测试。</p>
<h3 id="tdd-优缺点分析">TDD 优缺点分析<a hidden class="anchor" aria-hidden="true" href="#tdd-优缺点分析">#</a></h3>
<p>测试驱动开发有好处也有坏处。因为每个测试用例都是根据需求来的，或者说把一个大需求分解成若干小需求编写测试用例，所以测试用例写出来后，开发者写的执行代码，必须满足测试用例。如果测试不通过，则修改执行代码，直到测试用例通过。</p>
<p><strong>优点</strong>：</p>
<ol>
<li>帮你整理需求，梳理思路；</li>
<li>帮你设计出更合理的接口（空想的话很容易设计出屎）；</li>
<li>减小代码出现 bug 的概率；</li>
<li>提高开发效率（前提是正确且熟练使用 TDD）。</li>
</ol>
<p><strong>缺点</strong>：</p>
<ol>
<li>能用好 TDD 的人非常少，看似简单，实则门槛很高；</li>
<li>投入开发资源（时间和精力）通常会更多；</li>
<li>由于测试用例在未进行代码设计前写；很有可能限制开发者对代码整体设计；</li>
<li>可能引起开发人员不满情绪，我觉得这点很严重，毕竟不是人人都喜欢单元测试，尽管单元测试会带给我们相当多的好处。</li>
</ol>
<p>相关阅读：<a href="https://zhuanlan.zhihu.com/p/24997923">如何用正确的姿势打开 TDD？ - 陈天 - 2017open in new window</a></p>
<h2 id="单测框架如何选择">单测框架如何选择？<a hidden class="anchor" aria-hidden="true" href="#单测框架如何选择">#</a></h2>
<p>对于单测来说，目前常用的单测框架有：JUnit、Mockito、Spock、PowerMock、JMockit、TestableMock 等等。</p>
<p>JUnit 几乎是默认选择，但是其不支持 Mock，因此我们还需要选择一个 Mock 工具。Mockito 和 Spock 是最主流的两款 Mock 工具，一般都是在这两者中选择。</p>
<p>究竟是选择 Mockito 还是 Spock 呢？我这里做了一些简单的对比分析：</p>
<ul>
<li>Spock 没办法 Mock 静态方法和私有方法 ，Mockito 3.4.0 以后，支持静态方法的 Mock，具体可以看这个 issue：<a href="https://github.com/mockito/mockito/issues/1013%EF%BC%8C%E5%85%B7%E4%BD%93%E6%95%99%E7%A8%8B%E5%8F%AF%E4%BB%A5%E7%9C%8B%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%EF%BC%9Ahttps://www.baeldung.com/mockito-mock-static-methods%E3%80%82">https://github.com/mockito/mockito/issues/1013，具体教程可以看这篇文章：https://www.baeldung.com/mockito-mock-static-methods。open in new window</a></li>
<li>Spock 基于 Groovy，写出来的测试代码更清晰易读，比较规范(自带 given-when-then 的常用测试结构规范)。Mockito 没有具体的结构规范，需要项目组自己约定一个或者遵守比较好的测试代码实践。通常来说，同样的测试用例，Spock 的代码要更简洁。</li>
<li>Mockito 使用的人群更广泛，稳定可靠。并且，Mockito 是 SpringBoot Test 默认集成的 Mock 工具。</li>
</ul>
<p>Mockito 和 Spock 都是非常不错的 Mock 工具，相对来说，Mockito 的适用性更强一些。</p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<p>单元测试确实会带给你相当多的好处，但不是立刻体验出来。正如买重疾保险，交了很多保费，没病没痛，十几年甚至几十年都用不上，最好就是一辈子用不上理赔，身体健康最重要。单元测试也一样，写了可以买个放心，对代码的一种保障，有 bug 尽快测出来，没 bug 就最好，总不能说“写那么多单元测试，结果测不出 bug，浪费时间”吧？</p>
<p>以下是个人对单元测试一些建议：</p>
<blockquote>
<ul>
<li>越重要的代码，越要写单元测试；</li>
<li>代码做不到单元测试，多思考如何改进，而不是放弃；</li>
<li>边写业务代码，边写单元测试，而不是完成整个新功能后再写；</li>
<li>多思考如何改进、简化测试代码。</li>
<li>测试代码需要随着生产代码的演进而重构或者修改，如果测试不能保持整洁，只会越来越难修改。</li>
</ul>
</blockquote>
<p>作为一名经验丰富的程序员，写单元测试更多的是<strong>对自己的代码负责</strong>。有测试用例的代码，别人更容易看懂，以后别人接手你的代码时，也可能放心做改动。</p>
<p><strong>多敲代码实践，多跟有单元测试经验的工程师交流</strong>，你会发现写单元测试获得的收益会更多。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://funny-toffee-4aa7c3.netlify.app/tags/interview/">interview</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://funny-toffee-4aa7c3.netlify.app/">Wjy&#39;s Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
