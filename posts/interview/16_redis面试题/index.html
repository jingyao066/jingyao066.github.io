<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>16_Redis面试题 | Wjy&#39;s Blog</title>
<meta name="keywords" content="interview, redis">
<meta name="description" content="概述 Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于">
<meta name="author" content="Wjy">
<link rel="canonical" href="https://wjy6.netlify.app/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://wjy6.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://wjy6.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://wjy6.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://wjy6.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://wjy6.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://wjy6.netlify.app/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="https://wjy6.netlify.app/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/">
  <meta property="og:site_name" content="Wjy&#39;s Blog">
  <meta property="og:title" content="16_Redis面试题">
  <meta property="og:description" content="概述 Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-28T05:00:00+00:00">
    <meta property="article:modified_time" content="2023-07-28T05:00:00+00:00">
    <meta property="article:tag" content="Interview">
    <meta property="article:tag" content="Redis">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="16_Redis面试题">
<meta name="twitter:description" content="概述 Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://wjy6.netlify.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "16_Redis面试题",
      "item": "https://wjy6.netlify.app/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "16_Redis面试题",
  "name": "16_Redis面试题",
  "description": "概述 Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于",
  "keywords": [
    "interview", "redis"
  ],
  "articleBody": "概述 Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。\n为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。\nRedis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。\n个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的在线 Redis 环境（少部分命令无法使用）来实际体验 Redis。\nRedis 为什么这么快？ Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：\nRedis 基于内存，内存的访问速度是磁盘的上千倍； Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用； Redis 内置了多种优化过后的数据结构实现，性能非常高。 为什么要用 Redis/为什么要用缓存？ 下面我们主要从“高性能”和“高并发”这两点来回答这个问题。\n1、高性能\n假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。\n这样有什么好处呢？ 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。\n2、高并发\n一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。\nQPS（Query Per Second）：服务器每秒可以执行的查询次数；\n由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。\nRedis 应用场景 缓存：Redis 最常用的场景是作为缓存层，以减少数据库的负载，提高数据读取速度。 分布式锁：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。 实时系统：网站点击统计、实时排行榜（sorted set）。 计数器：- Redis 的原子性操作非常适合用作计数器。例如，可以使用 Redis 来统计页面访问量、点赞数、评论数等。通过 INCR 命令可以轻松实现高效的计数。 限流：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》。 其他（不常用）：\n消息队列：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。 延时队列：Redisson 内置了延时队列（基于 sorted set 实现的）。 分布式 Session ：利用 string 或者 hash 保存 Session 数据，所有的服务器都可以访问。 复杂业务场景：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。 Redis 可以做消息队列么？ 实际项目中也没见谁使用 Redis 来做消息队列，对于这部分知识点大家了解就好了。\n先说结论：可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。\nRedis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现。\n通过 RPUSH/LPOP 或者 LPUSH/RPOP即可实现简易版消息队列：\n1 2 3 4 5 6 7 8 # 生产者生产消息 \u003e RPUSH myList msg1 msg2 (integer) 2 \u003e RPUSH myList msg3 (integer) 3 # 消费者消费消息 \u003e LPOP myList \"msg1\" 不过，通过 RPUSH/LPOP 或者 LPUSH/RPOP这样的方式存在性能问题，我们需要不断轮询去调用 RPOP 或 LPOP 来消费消息。当 List 为空时，大部分的轮询的请求都是无效请求，这种方式大量浪费了系统资源。\n因此，Redis 还提供了 BLPOP、BRPOP 这种阻塞式读取的命令（带 B-Bloking 的都是阻塞式），并且还支持一个超时参数。如果 List 为空，Redis 服务端不会立刻返回结果，它会等待 List 中有新数据后在返回或者是等待最多一个超时时间后返回空。如果将超时时间设置为 0 时，即可无限等待，直到弹出消息\n1 2 3 4 # 超时时间为 10s # 如果有数据立刻返回，否则最多等待10秒 \u003e BRPOP myList 10 null List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。\nRedis 2.0 引入了发布订阅 (pub/sub) 功能，解决了 List 实现消息队列没有广播机制的问题。\npub/sub 中引入了一个概念叫 channel（频道），发布订阅机制的实现就是基于这个 channel 来做的。\npub/sub 涉及发布者（Publisher）和订阅者（Subscriber，也叫消费者）两个角色：\n发布者通过 PUBLISH 投递消息给指定 channel。 订阅者通过SUBSCRIBE订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。 我们这里启动 3 个 Redis 客户端来简单演示一下：\npub/sub 既能单播又能广播，还支持 channel 的简单正则匹配。不过，消息丢失（客户端断开连接或者 Redis 宕机都会导致消息丢失）、消息堆积（发布者发布消息的时候不会管消费者的具体消费能力如何）等问题依然没有一个比较好的解决办法。\n为此，Redis 5.0 新增加的一个数据结构 Stream 来做消息队列。Stream 支持：\n发布 / 订阅模式 按照消费者组进行消费 消息持久化（ RDB 和 AOF） Stream 使用起来相对要麻烦一些，这里就不演示了。而且，Stream 在实际使用中依然会有一些小问题不太好解决比如在 Redis 发生故障恢复后不能保证消息至少被消费一次。\n综上，和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议不要使用 Redis 来做消息队列，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。\n相关阅读：Redis 消息队列发展历程 - 阿里开发者 - 2022。\nRedis 数据结构 关于 Redis 5 种基础数据结构和 3 种特殊数据结构的详细介绍请看下面这两篇文章：\nRedis 5 种基本数据结构详解 Redis 3 种特殊数据结构详解 Redis 常用的数据结构有哪些？ 5 种基础数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。 3 种特殊数据结构：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。 String 的应用场景有哪些？ String 是 Redis 中最简单同时也是最常用的一个数据结构。String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。\nString 的常见应用场景如下：\n常规数据（比如 session、token、序列化后的对象、图片的路径）的缓存； 计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数； 分布式锁(利用 SETNX key value 命令可以实现一个最简易的分布式锁)； …… 关于 String 的详细介绍请看这篇文章：Redis 5 种基本数据结构详解。\nString 还是 Hash 存储对象数据更好呢？ String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。 String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。 在绝大部分情况，我们建议使用 String 来存储对象数据即可！\nString 的底层实现是什么？ Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 \\0 结尾的字符数组），而是自己编写了 SDS（Simple Dynamic String，简单动态字符串） 来作为底层实现。\nSDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。\nRedis7.0 的 SDS 的部分源码如下（https://github.com/redis/redis/blob/7.0/src/sds.h）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; 通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。\n类型 字节 位 sdshdr5 \u003c 1 \u003c8 sdshdr8 1 8 sdshdr16 2 16 sdshdr32 4 32 sdshdr64 8 64 对于后四种实现都包含了下面这 4 个属性：\nlen：字符串的长度也就是已经使用的字节数 alloc：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小 buf[]：实际存储字符串的数组 flags：低三位保存类型标志 SDS 相比于 C 语言中的字符串有如下提升：\n可以避免缓冲区溢出：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。 获取字符串长度的复杂度较低：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。 减少内存分配次数：为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。 二进制安全：C 语言中的字符串以空字符 \\0 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。 🤐 多提一嘴，很多文章里 SDS 的定义是下面这样的：\n1 2 3 4 5 struct sdshdr { unsigned int len; unsigned int free; char buf[]; }; 这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，len 和 free 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。\n购物车信息用 String 还是 Hash 存储更好呢? 由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：\n用户 id 为 key 商品 id 为 field，商品数量为 value 那用户购物车信息的维护具体应该怎么操作呢？\n用户添加商品就是往 Hash 里面增加新的 field 与 value； 查询购物车信息就是遍历对应的 Hash； 更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）； 删除商品就是删除 Hash 中对应的 field； 清空购物车直接删除对应的 key 即可。 这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。\n使用 Redis 实现一个排行榜怎么做？ Redis 中有一个叫做 sorted set 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。\n相关的一些 Redis 命令: ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。\nSet 的应用场景是什么？ Redis 中 Set 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。\nSet 的常见应用场景如下：\n存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 HyperLogLog更适合一些）、文章点赞、动态点赞等等。 需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。 需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。 使用 Set 实现抽奖系统怎么做？ 如果想要使用 Set 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：\nSADD key member1 member2 ...：向指定集合添加一个或多个元素。 SPOP key count：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。 SRANDMEMBER key count : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。 使用 Bitmap 统计活跃用户怎么做？ Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。\n你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。\n如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。\n初始化数据：\n1 2 3 4 5 6 \u003e SETBIT 20210308 1 1 (integer) 0 \u003e SETBIT 20210308 2 1 (integer) 0 \u003e SETBIT 20210309 1 1 (integer) 0 统计 20210308~20210309 总活跃用户数:\n1 2 3 4 \u003e BITOP and desk1 20210308 20210309 (integer) 1 \u003e BITCOUNT desk1 (integer) 1 统计 20210308~20210309 在线活跃用户数:\n1 2 3 4 \u003e BITOP or desk2 20210308 20210309 (integer) 1 \u003e BITCOUNT desk2 (integer) 2 使用 HyperLogLog 统计页面 UV 怎么做？ 使用 HyperLogLog 统计页面 UV 主要需要用到下面这两个命令：\nPFADD key element1 element2 ...：添加一个或多个元素到 HyperLogLog 中。 PFCOUNT key1 key2：获取一个或者多个 HyperLogLog 的唯一计数。 1、将访问指定页面的每个用户 ID 添加到 HyperLogLog 中。\n1 PFADD PAGE_1:UV USER1 USER2 ...... USERn 2、统计指定页面的 UV。\n1 PFCOUNT PAGE_1:UV Redis 线程模型（重要） 对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。\nRedis 单线程模型了解吗？ Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型 （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。\n《Redis 设计与实现》有一段话是如是介绍文件事件处理器的，我觉得写得挺不错。\nRedis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。\n文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。 虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。\n既然是单线程，那怎么监听大量的客户端连接呢？\nRedis 通过 IO 多路复用程序 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。\n这样的好处非常明显：I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 Selector 组件很像）。\n文件事件处理器（file event handler）主要是包含 4 个部分：\n多个 socket（客户端连接） IO 多路复用程序（支持多个客户端连接的关键） 文件事件分派器（将 socket 关联到相应的事件处理器） 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器） Redis6.0 之前为什么不使用多线程？ 虽然说 Redis 是单线程模型，但是，实际上，Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。\n不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。\n为此，Redis 4.0 之后新增了UNLINK（可以看作是 DEL 的异步版本）、FLUSHALL ASYNC（清空所有数据库的所有 key，不仅仅是当前 SELECT 的数据库）、FLUSHDB ASYNC（清空当前 SELECT 数据库中的所有 key）等异步命令。\n大体上来说，Redis 6.0 之前主要还是单线程处理。\n那 Redis6.0 之前为什么不使用多线程？ 我觉得主要原因有 3 点：\n单线程编程容易并且更容易维护； Redis 的性能瓶颈不在 CPU ，主要在内存和网络； 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。 Redis6.0 之后为何引入了多线程？ Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。\n虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。\nRedis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置 IO 线程数 \u003e 1，需要修改 redis 配置文件 redis.conf：\n1 io-threads 4 #设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程 另外：\nio-threads 的个数一旦设置，不能通过 config 动态设置。 当设置 ssl 后，io-threads 将不工作。 开启多线程后，默认只会使用多线程进行 IO 写入 writes，即发送数据给客户端，如果需要开启多线程 IO 读取 reads，同样需要修改 redis 配置文件 redis.conf :\n1 io-threads-do-reads yes 但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启\nRedis 后台线程了解吗？ 我们虽然经常说 Redis 是单线程模型（主要逻辑是单线程完成的），但实际还有一些后台线程用于执行一些比较耗时的操作：\n通过 bio_close_file 后台线程来释放 AOF / RDB 等过程中产生的临时文件资源。 通过 bio_aof_fsync 后台线程调用 fsync 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。 通过 bio_lazy_free后台线程释放大对象（已删除）占用的内存空间. 在bio.h 文件中有定义（Redis 6.0 版本，源码地址：https://github.com/redis/redis/blob/6.0/src/bio.h）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #ifndef __BIO_H #define __BIO_H /* Exported API */ void bioInit(void); void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3); unsigned long long bioPendingJobsOfType(int type); unsigned long long bioWaitStepOfType(int type); time_t bioOlderJobOfType(int type); void bioKillThreads(void); /* Background job opcodes */ #define BIO_CLOSE_FILE 0 /* Deferred close(2) syscall. */ #define BIO_AOF_FSYNC 1 /* Deferred AOF fsync. */ #define BIO_LAZY_FREE 2 /* Deferred objects freeing. */ #define BIO_NUM_OPS 3 #endif Redis 内存管理 Redis 给缓存数据设置过期时间有啥用？ 一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？\n因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。\nRedis 自带了给缓存数据设置过期时间的功能，比如：\n1 2 3 4 5 6 127.0.0.1:6379\u003e expire key 60 # 数据在 60s 后过期 (integer) 1 127.0.0.1:6379\u003e setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire) OK 127.0.0.1:6379\u003e ttl key # 查看数据还有多久过期 (integer) 56 注意：Redis 中除了字符串类型有自己独有设置过期时间的命令 setex 外，其他方法都需要依靠 expire 命令来设置过期时间 。另外， persist 命令可以移除一个键的过期时间。\n过期时间除了有助于缓解内存的消耗，还有什么其他用么？\n很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。\n如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。\nRedis 是如何判断数据是否过期的呢？ Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。\n过期字典是存储在 redisDb 这个结构里的：\n1 2 3 4 5 6 7 typedef struct redisDb { ... dict *dict; //数据库键空间,保存着数据库中所有键值对 dict *expires // 过期字典,保存着键的过期时间 ... } redisDb; 过期的数据的删除策略了解么？ 如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？\n常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：\n惰性删除：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。 定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。 定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 定期删除+惰性/懒汉式删除 。\n但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。\n怎么解决这个问题呢？答案就是：Redis 内存淘汰机制。\nRedis 内存淘汰机制了解么？ 相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?\nRedis 提供 6 种数据淘汰策略：\nvolatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。 allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰。 no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！ 4.0 版本后增加以下两种：\nvolatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰。 allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。 Redis 事务 什么是 Redis 事务？ 你可以将 Redis 中的事务理解为：Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。\nRedis 事务实际开发中使用的非常少，功能比较鸡肋，不要将其和我们平时理解的关系型数据库的事务混淆了。\n除了不满足原子性和持久性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。\n因此，Redis 事务是不建议在日常开发中使用的。\n如何使用 Redis 事务？ Redis 可以通过 MULTI，EXEC，DISCARD 和 WATCH 等命令来实现事务(Transaction)功能。\n1 2 3 4 5 6 7 8 9 \u003e MULTI OK \u003e SET PROJECT \"JavaGuide\" QUEUED \u003e GET PROJECT QUEUED \u003e EXEC 1) OK 2) \"JavaGuide\" MULTI 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 EXEC 命令后，再执行所有的命令。\n这个过程是这样的：\n开始事务（MULTI）； 命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)； 执行事务(EXEC)。 你也可以通过 DISCARD 命令取消一个事务，它会清空事务队列中保存的所有命令。\n1 2 3 4 5 6 7 8 \u003e MULTI OK \u003e SET PROJECT \"JavaGuide\" QUEUED \u003e GET PROJECT QUEUED \u003e DISCARD OK 你可以通过WATCH 命令监听指定的 Key，当调用 EXEC 命令执行事务时，如果一个被 WATCH 命令监视的 Key 被 其他客户端/Session 修改的话，整个事务都不会被执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 客户端 1 \u003e SET PROJECT \"RustGuide\" OK \u003e WATCH PROJECT OK \u003e MULTI OK \u003e SET PROJECT \"JavaGuide\" QUEUED # 客户端 2 # 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值 \u003e SET PROJECT \"GoGuide\" # 客户端 1 # 修改失败，因为 PROJECT 的值被客户端2修改了 \u003e EXEC (nil) \u003e GET PROJECT \"GoGuide\" 不过，如果 WATCH 与 事务 在同一个 Session 里，并且被 WATCH 监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的（相关 issue：WATCH 命令碰到 MULTI 命令时的不同效果）。\n事务内部修改 WATCH 监视的 Key：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u003e SET PROJECT \"JavaGuide\" OK \u003e WATCH PROJECT OK \u003e MULTI OK \u003e SET PROJECT \"JavaGuide1\" QUEUED \u003e SET PROJECT \"JavaGuide2\" QUEUED \u003e SET PROJECT \"JavaGuide3\" QUEUED \u003e EXEC 1) OK 2) OK 3) OK 127.0.0.1:6379\u003e GET PROJECT \"JavaGuide3\" 事务外部修改 WATCH 监视的 Key：\n1 2 3 4 5 6 7 8 9 10 11 12 \u003e SET PROJECT \"JavaGuide\" OK \u003e WATCH PROJECT OK \u003e SET PROJECT \"JavaGuide2\" OK \u003e MULTI OK \u003e GET USER QUEUED \u003e EXEC (nil) Redis 官网相关介绍 https://redis.io/topics/transactions\nRedis 事务支持原子性吗？ Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性：1. 原子性，2. 隔离性，3. 持久性，4. 一致性。\n原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的； Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的。\nRedis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。\nRedis 事务支持持久性吗？ Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:\n快照（snapshotting，RDB） 只追加文件（append-only file, AOF） RDB 和 AOF 的混合持久化(Redis 4.0 新增) 与 RDB 持久化相比，AOF 持久化的实时性更好。在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ fsync策略），它们分别是：\n1 2 3 appendfsync always #每次有数据修改发生时都会调用fsync函数同步AOF文件,fsync完成后线程返回,这样会严重降低Redis的速度 appendfsync everysec #每秒钟调用fsync函数同步一次AOF文件 appendfsync no #让操作系统决定何时进行同步，一般为30秒一次 AOF 持久化的fsync策略为 no、everysec 时都会存在数据丢失的情况 。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。\n因此，Redis 事务的持久性也是没办法保证的。\n如何解决 Redis 事务的缺陷？ Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。\n一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。\n不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， 严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。\n如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。\n另外，Redis 7.0 新增了 Redis functions 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。\nRedis 性能优化（重要） 除了下面介绍的内容之外，再推荐两篇不错的文章：\n你的 Redis 真的变慢了吗？性能优化如何做 - 阿里开发者 Redis 常见阻塞原因总结 - JavaGuide 使用批量操作减少网络传输 一个 Redis 命令的执行可以简化为以下 4 步：\n发送命令 命令排队 命令执行 返回结果 其中，第 1 步和第 4 步耗费时间之和称为 Round Trip Time (RTT,往返时间) ，也就是数据在网络上传输的时间。\n使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。\n另外，除了能减少 RTT 之外，发送一次命令的 socket I/O 成本也比较高（涉及上下文切换，存在read()和write()系统调用），批量操作还可以减少 socket I/O 成本。这个在官方对 pipeline 的介绍中有提到：https://redis.io/docs/manual/pipelining/ 。\n原生批量操作命令 Redis 中有一些原生支持批量操作的命令，比如：\nMGET(获取一个或多个指定 key 的值)、MSET(设置一个或多个指定 key 的值)、 HMGET(获取指定哈希表中一个或者多个指定字段的值)、HMSET(同时将一个或多个 field-value 对设置到指定哈希表中)、 SADD（向指定集合添加一个或多个元素） …… 不过，在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，使用这些原生批量操作命令可能会存在一些小问题需要解决。就比如说 MGET 无法保证所有的 key 都在同一个 hash slot（哈希槽）上，MGET可能还是需要多次网络传输，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。\n整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：\n找到 key 对应的所有 hash slot； 分别向对应的 Redis 节点发起 MGET 请求获取数据； 等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。 如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。\nRedis Cluster 并没有使用一致性哈希，采用的是 哈希槽分区 ，每一个键值对都属于一个 hash slot（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。\n我在 Redis 集群详解（付费） 这篇文章中详细介绍了 Redis Cluster 这部分的内容，感兴趣地可以看看。\npipeline 对于不支持批量操作的命令，我们可以利用 pipeline（流水线) 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。不过，需要注意控制一次批量操作的 元素个数(例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。\n与MGET、MSET等原生批量操作命令一样，pipeline 同样在 Redis Cluster 上使用会存在一些小问题。原因类似，无法保证所有的 key 都在同一个 hash slot（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。\n原生批量操作命令和 pipeline 的是有区别的，使用的时候需要注意：\n原生批量操作命令是原子操作，pipeline 是非原子操作。 pipeline 可以打包不同的命令，原生批量操作命令不可以。 原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。 顺带补充一下 pipeline 和 Redis 事务的对比：\n事务是原子操作，pipeline 是非原子操作。两个不同的事务不会同时运行，而 pipeline 可以同时以交错方式执行。 Redis 事务中每个命令都需要发送到服务端，而 Pipeline 只需要发送一次，请求次数更少。 事务可以看作是一个原子操作，但其实并不满足原子性。当我们提到 Redis 中的原子操作时，主要指的是这个操作（比如事务、Lua 脚本）不会被其他操作（比如其他事务、Lua 脚本）打扰，并不能完全保证这个操作中的所有写命令要么都执行要么都不执行。这主要也是因为 Redis 是不支持回滚操作。\n另外，pipeline 不适用于执行顺序有依赖关系的一批命令。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 Lua 脚本 。\nLua 脚本 Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是 原子操作 。也就是说，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。\n并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。\n不过， Lua 脚本依然存在下面这些缺陷：\n如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。 Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 hash slot（哈希槽）上。 大量 key 集中过期问题 对于过期 key，Redis 采用的是 定期删除+惰性/懒汉式删除 策略。\n定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。\n如何解决呢？ 下面是两种常见的方法：\n给 key 设置随机过期时间。 开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。 个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。\n慢查询命令 为什么会有慢查询命令？ 我们知道一个 Redis 命令的执行可以简化为以下 4 步：\n发送命令 命令排队 命令执行 返回结果 Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。\nRedis 为什么会有慢查询命令呢？\nRedis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：\nKEYS *：会返回所有符合规则的 key。 HGETALL：会返回一个 Hash 中所有的键值对。 LRANGE：会返回 List 中指定范围内的元素。 SMEMBERS：返回 Set 中的所有元素。 SINTER/SUNION/SDIFF：计算多个 Set 的交集/并集/差集。 …… 由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 HSCAN、SSCAN、ZSCAN 代替。\n除了这些 O(n)时间复杂度的命令可能会导致慢查询之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：\nZRANGE/ZREVRANGE：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。 ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。 …… 如何找到慢查询命令？ 在 redis.conf 文件中，我们可以使用 slowlog-log-slower-than 参数设置耗时命令的阈值，并使用 slowlog-max-len 参数设置耗时命令的最大记录条数。\n当 Redis 服务器检测到执行时间超过 slowlog-log-slower-than阈值的命令时，就会将该命令记录在慢查询日志(slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。\n⚠️注意：由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。\nslowlog-log-slower-than和slowlog-max-len的默认配置如下(可以自行修改)：\n1 2 3 4 5 6 7 8 # The following time is expressed in microseconds, so 1000000 is equivalent # to one second. Note that a negative number disables the slow log, while # a value of zero forces the logging of every command. slowlog-log-slower-than 10000 # There is no limit to this length. Just be aware that it will consume memory. # You can reclaim memory used by the slow log with SLOWLOG RESET. slowlog-max-len 128 除了修改配置文件之外，你也可以直接通过 CONFIG 命令直接设置：\n1 2 3 4 # 命令执行耗时超过 10000 微妙（即10毫秒）就会被记录 CONFIG SET slowlog-log-slower-than 10000 # 只保留最近 128 条耗时命令 CONFIG SET slowlog-max-len 128 获取慢查询日志的内容很简单，直接使用SLOWLOG GET 命令即可。\n1 2 3 4 5 6 7 8 9 127.0.0.1:6379\u003e SLOWLOG GET #慢日志查询 1) 1) (integer) 5 2) (integer) 1684326682 3) (integer) 12000 4) 1) \"KEYS\" 2) \"*\" 5) \"172.17.0.1:61152\" 6) \"\" // ... 慢查询日志中的每个条目都由以下六个值组成：\n唯一渐进的日志标识符。 处理记录命令的 Unix 时间戳。 执行所需的时间量，以微秒为单位。 组成命令参数的数组。 客户端 IP 地址和端口。 客户端名称。 SLOWLOG GET 命令默认返回最近 10 条的的慢查询命令，你也自己可以指定返回的慢查询命令的数量 SLOWLOG GET N。\n下面是其他比较常用的慢查询相关的命令：\n1 2 3 4 5 6 # 返回慢查询命令的数量 127.0.0.1:6379\u003e SLOWLOG LEN (integer) 128 # 清空慢查询命令 127.0.0.1:6379\u003e SLOWLOG RESET OK 缓存穿透 指查询一个不存在的数据，缓存中没有相应的记录，每次请求都会去数据库查询，造成数据库负担加重。\n举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。\n解决方案：\n使用布隆过滤器，过滤掉不存在的请求，避免直接访问数据库。 对查询结果进行缓存，即使是不存在的数据，也可以缓存一个标识，以减少对数据库的请求。 缓存击穿 指某个热点数据在缓存中失效，导致大量请求直接访问数据库。此时，由于瞬间的高并发，可能导致数据库崩溃。\n举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。\n解决方案：\n设置热点数据永不过期或者过期时间比较长。 针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。 请求数据库写数据到缓存之前，先获取分布式锁，保证只有一个请求会落到数据库上，减少数据库的压力。 缓存雪崩 指多个缓存数据在同一时间过期，导致大量请求同时访问数据库，从而造成数据库瞬间负载激增。\n举个例子：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。\n解决方案：\n随机设置缓存失效时间 双缓存 Redis主从 下图就是一个 Redis 主从架构图：\n主从架构可以实现读写分离。写操作可以请求主节点，而读操作只请求从节点，这样就能减轻主节点的压力。\n整个主从集群仅主节点可以写入，其它从节点都通过复制来同步数据，这样就能保证数据的一致性。并且对读请求分散到多个节点，提高了 Redis 的吞吐量，从一定程度上也提高了 Redis 的可用性。\nRedis 主从复制的实现原理 Redis 的主从复制是指一个 Redis 实例（主节点）可以将数据复制到一个或多个从节点（从节点），从节点从主节点获取数据并保持同步。\n复制流程：\n开始同步：从节点通过向主节点发送 PSYNC 命令发起同步。 全量复制：如果是第一次连接或之前的连接失效，从节点会请求全量复制，主节点将当前数据快照（RDB文件）发送给从节点。 增量复制：全量复制完毕后，主从之间会保持一个长连接，主节点会通过这个连接将后续的写操作传递给从节点执行，来保证数据的一致。 Redis哨兵 Redis 的哨兵机制（Sentinel） 是一种高可用性解决方案，用于监控 Redis 主从集群，自动完成主从切换，以实现故障自动恢复和通知。\n主要功能包括：\n监控：哨兵不断监控 Redis 主节点和从节点的运行状态，定期发送 PING 请求检查节点是否正常。 自动故障转移：当主节点发生故障时，哨兵会选举一个从节点提升为新的主节点，并通知客户端更新主节点的地址，从而实现高可用。 通知：哨兵可以向系统管理员或其他服务发送通知，以便快速处理 Redis 实例的状态变化。 哨兵机制的由来 主从架构中，如果采用读写分离的模式，即主节点负责写请求，从节点负责读请求。假设这个时候主节点宕机了，没有新的主节点顶替上来的话，就会出现很长一段时间写请求没响应的情况。\n针对这个情况，便出现了哨兵这个机制。它主要进行监控作用，如果主节点挂了，将从节点切换成主节点，从而最大限度地减少停机时间和数据丢失。\n哨兵机制对应的架构图如下所示：\n哨兵节点（Sentinel）: 主要作用是对 Redis 的主从服务节点进行监控，当主节点发生故障的时候，哨兵节点会选择一个合适的从节点升级为主节点，并通知其他从节点和客户端进行更新操作。 Redis 节点：主要包括 master 以及 slave 节点，就是 Redis 提供服务的实例。 一般哨兵需要集群部署，至少三台哨兵组成哨兵集群。\n主观下线和客观下线 哨兵是如何判断 Redis 中主节点挂了的呢？主要涉及到了两个机制：主观下线以及客观下线。\n1）主观下线\nSentinel 每隔 1s 会发送 ping 命令给所有的节点。如果 Sentinel 超过一段时间还未收到对应节点的 pong 回复，就会认为这个节点主观下线。\n“一段时间”是配置项 down-after-milliseconds 设定的。\n2）客观下线\n注意，只有主节点才有客观下线，从节点没有。\n假设目前有个主节点被一个 sentinel 的判断主观下线了，但可能主节点并没问题，只是因为网络抖动导致了一台哨兵的误判。所以此时哨兵需要问问它的队友，来确定这个主节点是不是真的出了问题！\n因此，它会向其他哨兵发起投票，其他哨兵会判断主节点的状态进行投票，可以投赞成或反对。\n如果认为下线的总投票数大于 quorum（一般为集群总数/2 + 1，假设哨兵集群有 3 台实例，那么 3 / 2 + 1 = 2），则判定该主节点客观下线，此时就需要进行主从切换，而只有哨兵的 leader 才能操作主从切换。\nSentinel leader 是如何选举出来的？ Sentinel leader 节点的选举实际上涉及到分布式算法 raft，感兴趣的同学可以深入去了解一下，这里主要简单说一下哨兵集群选择 leader 的方式：\n判断主节点主观下线的 sentinel 就是候选者，此时它想成为 leader。如果同时有两个 sentinel 判断主观下线，那么它们都是候选人，一起竞争成为 leader。\n候选者们会先投自己一票，然后向其他 sentinel 发送命令让它们给自己投票。每个哨兵手里只有一票，投了一个之后就不能投别人了。\n最后，如果某个候选者拿到哨兵集群半数及以上的赞成票，就会成为 leader。这里有一个注意的点，为了保证 sentinel 选举的时候尽量避免出现平票的情况，sentinel 的节点个数一般都会是奇数，比如 3,5,7 这样。\nRedis 主节点选举 选出哨兵 leader 之后，需要选出 Redis 主从集群中的新 master 节点。\n首先需要把一些已经下线的节点全部剔除，然后从正常的从节点中选择主节点，其主要经过以下三个流程:\n根据从节点的优先级进行选择，优先选择优先级的值比较小的节点（优先级的值越小优先级越高，优先级可通过 slave-priority 配置）。 如果节点的优先级相同，则查看进行主从复制的 offset 的值，即复制的偏移量，偏移量越大则表示其同步的数据越多，优先级越高。 如果 offset 也相同了，那只能比较 ID 号，选择 ID 号比较小的那个作为主节点（每个实例 ID 不同）。 选好主节点之后，哨兵 leader 会让其他从节点全部成为新 master 节点的 slave 节点。\n最后利用 redis 的发布/订阅机制，把新主节点的 IP 和端口信息推送给客户端，此时主从切换就结束了。\n可能还有同学关心旧主节点恢复了怎么办？实际上哨兵会继续监视旧的主节点，如果它上线了，哨兵集群会向它发送 slaveof 命令，让它成为新主节点的从节点。\nRedis 集群 Redis 集群的实现原理 注意：​​Redis 集群模式：​​ ​​不需要 Sentinel（哨兵）​​。集群自身通过内置的分布式协议（Gossip + Raft选举）实现了节点故障检测、主从自动切换和高可用性，是一个自包含的解决方案。\n作用：\n集群中有多个 master，每个 master 保存不同数据（海量数据） 每个 master 都可以有多个 slave 节点（高并发读） master 之间通过 ping 检测彼此健康状态 客户端请求可以访问集群任意节点，最终都会被转发到正确节点（路由规则） 怎么存储和读取的：\n分片集群引入了哈希槽的概率，有 16384 个哈希槽。 将 16384 个哈希槽分配到不同的实例。 读写数据：根据有效部分计算哈希值，对 16384 进行取余（有效部分 set {aaa}name tiantian ），余数作为插槽，寻找插槽所在的实例。 Redis 使用规范 实际使用 Redis 的过程中，我们尽量要准守一些常见的规范，比如：\n使用连接池：避免频繁创建关闭客户端连接。 尽量不使用 O(n)指令，使用 O(n) 命令时要关注 n 的数量：像 KEYS *、HGETALL、LRANGE、SMEMBERS、SINTER/SUNION/SDIFF等 O(n) 命令并非不能使用，但是需要明确 n 的值。另外，有遍历的需求可以使用 HSCAN、SSCAN、ZSCAN 代替。 使用批量操作减少网络传输：原生批量操作命令（比如 MGET、MSET等等）、pipeline、Lua 脚本。 尽量不使用 Redis 事务：Redis 事务实现的功能比较鸡肋，可以使用 Lua 脚本代替。 禁止长时间开启 monitor：对性能影响比较大。 控制 key 的生命周期：避免 Redis 中存放了太多不经常被访问的数据。 …… 相关文章推荐：阿里云 Redis 开发规范 。\n3种常用的缓存读写策略详解 Cache Aside Pattern（旁路缓存模式） Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。\nCache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。\n下面我们来看一下这个策略模式下的缓存读写步骤。\n写：\n先更新 db 然后直接删除 cache 。 读 :\n从 cache 中读取数据，读取到就直接返回 cache 中读取不到的话，就从 db 中读取数据返回 再把数据放到 cache 中。 简单画了一张图帮助大家理解读的步骤。\n你仅仅了解了上面这些内容的话是远远不够的，我们还要搞懂其中的原理。\n比如说面试官很可能会追问：“在写数据的过程中，可以先删除 cache ，后更新 db 么？”\n答案： 那肯定是不行的！因为这样可能会造成 数据库（db）和缓存（Cache）数据不一致的问题。\n举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。\n这个过程可以简单描述为：\n请求 1 先把 cache 中的 A 数据删除 -\u003e 请求 2 从 db 中读取数据-\u003e请求 1 再把 db 中的 A 数据更新\n当你这样回答之后，面试官可能会紧接着就追问：“在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？”\n答案： 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。\n举例：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。\n这个过程可以简单描述为：\n请求 1 从 db 读数据 A-\u003e 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -\u003e 请求 1 将数据 A 写入 cache\n现在我们再来分析一下 Cache Aside Pattern 的缺陷。\n缺陷 1：首次请求数据一定不在 cache 的问题\n解决办法：可以将热点数据可以提前放入 cache 中。\n缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。\n解决办法：\n数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。 可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。 Read/Write Through Pattern（读写穿透） Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。\n这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入 db 的功能。\n写（Write Through）：\n先查 cache，cache 中不存在，直接更新 db。 cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（同步更新 cache 和 db）。 简单画了一张图帮助大家理解写的步骤。\n读(Read Through)：\n从 cache 中读取数据，读取到就直接返回 。 读取不到的话，先从 db 加载，写入到 cache 后返回响应。 简单画了一张图帮助大家理解读的步骤。\nRead-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。\n和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。\nWrite Behind Pattern（异步缓存写入） Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。\n但是，两个又有很大的不同：Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。\n很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。\n这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。\nWrite Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。\nRedis 5 种基本数据结构详解 Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。\n这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。\nRedis 基本数据结构的底层数据结构实现如下：\nString List Hash Set Zset SDS LinkedList/ZipList/QuickList Hash Table、ZipList ZipList、Intset ZipList、SkipList Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。\n你可以在 Redis 官网上找到 Redis 数据结构非常详细的介绍：\nRedis Data Structures Redis Data types tutorial 未来随着 Redis 新版本的发布，可能会有新的数据结构出现，通过查阅 Redis 官网对应的介绍，你总能获取到最靠谱的信息。\nString（字符串） 介绍 String 是 Redis 中最简单同时也是最常用的一个数据结构。\nString 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。\n虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 简单动态字符串（Simple Dynamic String，SDS）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。\n常用命令 命令 介绍 SET key value 设置指定 key 的值 SETNX key value 只有在 key 不存在时设置 key 的值 GET key 获取指定 key 的值 MSET key1 value1 key2 value2 … 设置一个或多个指定 key 的值 MGET key1 key2 … 获取一个或多个指定 key 的值 STRLEN key 返回 key 所储存的字符串值的长度 INCR key 将 key 中储存的数字值增一 DECR key 将 key 中储存的数字值减一 EXISTS key 判断指定 key 是否存在 DEL key（通用） 删除指定的 key EXPIRE key seconds（通用） 给指定 key 设置过期时间 更多 Redis String 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=string 。\n基本操作：\n1 2 3 4 5 6 7 8 9 10 11 12 \u003e SET key value OK \u003e GET key \"value\" \u003e EXISTS key (integer) 1 \u003e STRLEN key (integer) 5 \u003e DEL key (integer) 1 \u003e GET key (nil) 批量设置：\n1 2 3 4 5 \u003e MSET key1 value1 key2 value2 OK \u003e MGET key1 key2 # 批量获取多个 key 对应的 value 1) \"value1\" 2) \"value2\" 计数器（字符串的内容为整数的时候可以使用）：\n1 2 3 4 5 6 7 8 9 10 \u003e SET number 1 OK \u003e INCR number # 将 key 中储存的数字值增一 (integer) 2 \u003e GET number \"2\" \u003e DECR number # 将 key 中储存的数字值减一 (integer) 1 \u003e GET number \"1\" 设置过期时间（默认为永不过期）：\n1 2 3 4 5 6 \u003e EXPIRE key 60 (integer) 1 \u003e SETEX key 60 value # 设置值并设置过期时间 OK \u003e TTL key (integer) 56 应用场景 需要存储常规数据的场景\n举例：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。 相关命令：SET、GET。 需要计数的场景\n举例：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。 相关命令：SET、GET、 INCR、DECR 。 分布式锁\n利用 SETNX key value 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。\nList（列表） 介绍 Redis 中的 List 其实就是链表数据结构的实现。我在 线性数据结构 :数组、链表、栈、队列 这篇文章中详细介绍了链表这种数据结构，我这里就不多做介绍了。\n许多高级编程语言都内置了链表的实现比如 Java 中的 LinkedList，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 List 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。\n常用命令 命令 介绍 RPUSH key value1 value2 … 在指定列表的尾部（右边）添加一个或多个元素 LPUSH key value1 value2 … 在指定列表的头部（左边）添加一个或多个元素 LSET key index value 将指定列表索引 index 位置的值设置为 value LPOP key 移除并获取指定列表的第一个元素(最左边) RPOP key 移除并获取指定列表的最后一个元素(最右边) LLEN key 获取列表元素数量 LRANGE key start end 获取列表 start 和 end 之间 的元素 更多 Redis List 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=list 。\n通过 RPUSH/LPOP 或者 LPUSH/RPOP实现队列：\n1 2 3 4 5 6 7 8 9 10 11 12 \u003e RPUSH myList value1 (integer) 1 \u003e RPUSH myList value2 value3 (integer) 3 \u003e LPOP myList \"value1\" \u003e LRANGE myList 0 1 1) \"value2\" 2) \"value3\" \u003e LRANGE myList 0 -1 1) \"value2\" 2) \"value3\" 通过 RPUSH/RPOP或者LPUSH/LPOP 实现栈：\n1 2 3 4 \u003e RPUSH myList2 value1 value2 value3 (integer) 3 \u003e RPOP myList2 # 将 list的最右边的元素取出 \"value3\" 我专门画了一个图方便大家理解 RPUSH , LPOP , lpush , RPOP 命令：\n通过 LRANGE 查看对应下标范围的列表元素：\n1 2 3 4 5 6 7 8 9 \u003e RPUSH myList value1 value2 value3 (integer) 3 \u003e LRANGE myList 0 1 1) \"value1\" 2) \"value2\" \u003e LRANGE myList 0 -1 1) \"value1\" 2) \"value2\" 3) \"value3\" 通过 LRANGE 命令，你可以基于 List 实现分页查询，性能非常高！\n通过 LLEN 查看链表长度：\n1 2 \u003e LLEN myList (integer) 3 应用场景 信息流展示\n举例：最新文章、最新动态。 相关命令：LPUSH、LRANGE。 消息队列\nRedis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。\n相对来说，Redis 5.0 新增加的一个数据结构 Stream 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。\nHash（哈希） 介绍 Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。\nHash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。\n常用命令 命令 介绍 HSET key field value 设置指定哈希表中指定字段的值 HSETNX key field value 只有指定字段不存在时设置指定字段的值 HMSET key field1 value1 field2 value2 … 同时将一个或多个 field-value (域-值)对设置到指定哈希表中 HGET key field 获取指定哈希表中指定字段的值 HMGET key field1 field2 … 获取指定哈希表中一个或者多个指定字段的值 HGETALL key 获取指定哈希表中所有的键值对 HEXISTS key field 查看指定哈希表中指定的字段是否存在 HDEL key field1 field2 … 删除一个或多个哈希表字段 HLEN key 获取指定哈希表中字段的数量 HINCRBY key field increment 对指定哈希中的指定字段做运算操作（正数为加，负数为减） 更多 Redis Hash 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=hash 。\n模拟对象数据存储：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u003e HMSET userInfoKey name \"guide\" description \"dev\" age 24 OK \u003e HEXISTS userInfoKey name # 查看 key 对应的 value中指定的字段是否存在。 (integer) 1 \u003e HGET userInfoKey name # 获取存储在哈希表中指定字段的值。 \"guide\" \u003e HGET userInfoKey age \"24\" \u003e HGETALL userInfoKey # 获取在哈希表中指定 key 的所有字段和值 1) \"name\" 2) \"guide\" 3) \"description\" 4) \"dev\" 5) \"age\" 6) \"24\" \u003e HSET userInfoKey name \"GuideGeGe\" \u003e HGET userInfoKey name \"GuideGeGe\" \u003e HINCRBY userInfoKey age 2 (integer) 26 应用场景 对象数据存储场景\n举例：用户信息、商品信息、文章信息、购物车信息。 相关命令：HSET （设置单个字段的值）、HMSET（设置多个字段的值）、HGET（获取单个字段的值）、HMGET（获取多个字段的值）。 Set（集合） 介绍 Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。\n你可以基于 Set 轻易实现交集、并集、差集的操作，比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。\n常用命令 命令 介绍 SADD key member1 member2 … 向指定集合添加一个或多个元素 SMEMBERS key 获取指定集合中的所有元素 SCARD key 获取指定集合的元素数量 SISMEMBER key member 判断指定元素是否在指定集合中 SINTER key1 key2 … 获取给定所有集合的交集 SINTERSTORE destination key1 key2 … 将给定所有集合的交集存储在 destination 中 SUNION key1 key2 … 获取给定所有集合的并集 SUNIONSTORE destination key1 key2 … 将给定所有集合的并集存储在 destination 中 SDIFF key1 key2 … 获取给定所有集合的差集 SDIFFSTORE destination key1 key2 … 将给定所有集合的差集存储在 destination 中 SPOP key count 随机移除并获取指定集合中一个或多个元素 SRANDMEMBER key count 随机获取指定集合中指定数量的元素 更多 Redis Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=set 。\n基本操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u003e SADD mySet value1 value2 (integer) 2 \u003e SADD mySet value1 # 不允许有重复元素，因此添加失败 (integer) 0 \u003e SMEMBERS mySet 1) \"value1\" 2) \"value2\" \u003e SCARD mySet (integer) 2 \u003e SISMEMBER mySet value1 (integer) 1 \u003e SADD mySet2 value2 value3 (integer) 2 mySet : value1、value2 。 mySet2：value2、value3 。 求交集：\n1 2 3 4 \u003e SINTERSTORE mySet3 mySet mySet2 (integer) 1 \u003e SMEMBERS mySet3 1) \"value2\" 求并集：\n1 2 3 4 \u003e SUNION mySet mySet2 1) \"value3\" 2) \"value2\" 3) \"value1\" 求差集：\n1 2 \u003e SDIFF mySet mySet2 # 差集是由所有属于 mySet 但不属于 A 的元素组成的集合 1) \"value1\" 应用场景 需要存放的数据不能重复的场景\n举例：网站 UV 统计（数据量巨大的场景还是 HyperLogLog更适合一些）、文章点赞、动态点赞等场景。 相关命令：SCARD（获取集合数量） 。 需要获取多个数据源交集、并集和差集的场景\n举例：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等场景。 相关命令：SINTER（交集）、SINTERSTORE （交集）、SUNION （并集）、SUNIONSTORE（并集）、SDIFF（差集）、SDIFFSTORE （差集）。 需要随机获取数据源中的元素的场景\n举例：抽奖系统、随机点名等场景。 相关命令：SPOP（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、SRANDMEMBER（随机获取集合中的元素，适合允许重复中奖的场景）。 Sorted Set（有序集合） 介绍 Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。\n常用命令 命令 介绍 ZADD key score1 member1 score2 member2 … 向指定有序集合添加一个或多个元素 ZCARD KEY 获取指定有序集合的元素数量 ZSCORE key member 获取指定有序集合中指定元素的 score 值 ZINTERSTORE destination numkeys key1 key2 … 将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量 ZUNIONSTORE destination numkeys key1 key2 … 求并集，其它和 ZINTERSTORE 类似 ZDIFFSTORE destination numkeys key1 key2 … 求差集，其它和 ZINTERSTORE 类似 ZRANGE key start end 获取指定有序集合 start 和 end 之间的元素（score 从低到高） ZREVRANGE key start end 获取指定有序集合 start 和 end 之间的元素（score 从高到底） ZREVRANK key member 获取指定有序集合中指定元素的排名(score 从大到小排序) 更多 Redis Sorted Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=sorted-set 。\n基本操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u003e ZADD myZset 2.0 value1 1.0 value2 (integer) 2 \u003e ZCARD myZset 2 \u003e ZSCORE myZset value1 2.0 \u003e ZRANGE myZset 0 1 1) \"value2\" 2) \"value1\" \u003e ZREVRANGE myZset 0 1 1) \"value1\" 2) \"value2\" \u003e ZADD myZset2 4.0 value2 3.0 value3 (integer) 2 myZset : value1(2.0)、value2(1.0) 。 myZset2：value2 （4.0）、value3(3.0) 。 获取指定元素的排名：\n1 2 3 4 \u003e ZREVRANK myZset value1 0 \u003e ZREVRANK myZset value2 1 求交集：\n1 2 3 4 5 \u003e ZINTERSTORE myZset3 2 myZset myZset2 1 \u003e ZRANGE myZset3 0 1 WITHSCORES value2 5 求并集：\n1 2 3 4 5 6 7 8 9 \u003e ZUNIONSTORE myZset4 2 myZset myZset2 3 \u003e ZRANGE myZset4 0 2 WITHSCORES value1 2 value3 3 value2 5 求差集：\n1 2 3 \u003e ZDIFF 2 myZset myZset2 WITHSCORES value1 2 应用场景 需要随机获取数据源中的元素根据某个权重进行排序的场景\n举例：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。 相关命令：ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。 需要存储的数据有优先级或者重要程度的场景 比如优先级任务队列。\n举例：优先级任务队列。 相关命令：ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。 总结 数据类型 说明 String 一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。 List Redis 的 List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。 Hash 一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。 Set 无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。 Zset 和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。 Redis 3 种特殊数据结构详解 除了 5 种基本的数据结构之外，Redis 还支持 3 种特殊的数据结构：Bitmap、HyperLogLog、GEO。\nBitmap 介绍 Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。\n你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。\n常用命令 命令 介绍 SETBIT key offset value 设置指定 offset 位置的值 GETBIT key offset 获取指定 offset 位置的值 BITCOUNT key start end 获取 start 和 end 之前值为 1 的元素个数 BITOP operation destkey key1 key2 … 对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT Bitmap 基本操作演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # SETBIT 会返回之前位的值（默认是 0）这里会生成 7 个位 \u003e SETBIT mykey 7 1 (integer) 0 \u003e SETBIT mykey 7 0 (integer) 1 \u003e GETBIT mykey 7 (integer) 0 \u003e SETBIT mykey 6 1 (integer) 0 \u003e SETBIT mykey 8 1 (integer) 0 # 通过 bitcount 统计被被设置为 1 的位的数量。 \u003e BITCOUNT mykey (integer) 2 应用场景 需要保存状态信息（0/1 即可表示）的场景\n举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。 相关命令：SETBIT、GETBIT、BITCOUNT、BITOP。 HyperLogLog 介绍 HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。\nRedis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近2^64个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：\n稀疏矩阵：计数较少的时候，占用空间很小。 稠密矩阵：计数达到某个阈值的时候，占用 12k 的空间。 Redis 官方文档中有对应的详细说明：\n基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 0.81% ）。\nHyperLogLog 的使用非常简单，但原理非常复杂。HyperLogLog 的原理以及在 Redis 中的实现可以看这篇文章：HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的 。\n再推荐一个可以帮助理解 HyperLogLog 原理的工具：Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure 。\n常用命令 HyperLogLog 相关的命令非常少，最常用的也就 3 个。\n命令 介绍 PFADD key element1 element2 … 添加一个或多个元素到 HyperLogLog 中 PFCOUNT key1 key2 获取一个或者多个 HyperLogLog 的唯一计数。 PFMERGE destkey sourcekey1 sourcekey2 … 将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。 HyperLogLog 基本操作演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003e PFADD hll foo bar zap (integer) 1 \u003e PFADD hll zap zap zap (integer) 0 \u003e PFADD hll foo bar (integer) 0 \u003e PFCOUNT hll (integer) 3 \u003e PFADD some-other-hll 1 2 3 (integer) 1 \u003e PFCOUNT hll some-other-hll (integer) 6 \u003e PFMERGE desthll hll some-other-hll \"OK\" \u003e PFCOUNT desthll (integer) 6 应用场景 数量量巨大（百万、千万级别以上）的计数场景\n举例：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、 相关命令：PFADD、PFCOUNT 。 Geospatial index 介绍 Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。\n通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。\n常用命令 命令 介绍 GEOADD key longitude1 latitude1 member1 … 添加一个或多个元素对应的经纬度信息到 GEO 中 GEOPOS key member1 member2 … 返回给定元素的经纬度信息 GEODIST key member1 member2 M/KM/FT/MI 返回两个给定元素之间的距离 GEORADIUS key longitude latitude radius distance 获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数 GEORADIUSBYMEMBER key member radius distance 类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素 基本操作：\n1 2 3 4 5 6 7 \u003e GEOADD personLocation 116.33 39.89 user1 116.34 39.90 user2 116.35 39.88 user3 3 \u003e GEOPOS personLocation user1 116.3299986720085144 39.89000061669732844 \u003e GEODIST personLocation user1 user2 km 1.4018 通过 Redis 可视化工具查看 personLocation ，果不其然，底层就是 Sorted Set。\nGEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。\n获取指定位置范围内的其他元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u003e GEORADIUS personLocation 116.33 39.87 3 km user3 user1 \u003e GEORADIUS personLocation 116.33 39.87 2 km \u003e GEORADIUS personLocation 116.33 39.87 5 km user3 user1 user2 \u003e GEORADIUSBYMEMBER personLocation user1 5 km user3 user1 user2 \u003e GEORADIUSBYMEMBER personLocation user1 2 km user1 user2 GEORADIUS 命令的底层原理解析可以看看阿里的这篇文章：Redis 到底是怎么实现“附近的人”这个功能的呢？ 。\n移除元素：\nGEO 底层是 Sorted Set ，你可以对 GEO 使用 Sorted Set 相关的命令。\n1 2 3 4 5 6 7 \u003e ZREM personLocation user1 1 \u003e ZRANGE personLocation 0 -1 user3 user2 \u003e ZSCORE personLocation user2 4069879562983946 应用场景 需要管理使用地理空间数据的场景\n举例：附近的人。 相关命令: GEOADD、GEORADIUS、GEORADIUSBYMEMBER 。 总结 数据类型 说明 Bitmap 你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。 HyperLogLog Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近2^64个不同元素。不过，HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 0.81% ）。 Geospatial index Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。 Redis持久化机制详解 使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。\nRedis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:\n快照（snapshotting，RDB） 只追加文件（append-only file, AOF） RDB 和 AOF 的混合持久化(Redis 4.0 新增) 官方文档地址：https://redis.io/topics/persistence 。\nRDB 持久化 什么是 RDB 持久化？ Redis 可以通过创建快照来获得存储在内存里面的数据在 某个时间点 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。\n快照持久化是 Redis 默认采用的持久化方式，在 redis.conf 配置文件中默认有此下配置：\n1 2 3 4 5 save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。 save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。 save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。 RDB 创建快照时会阻塞主线程吗？ Redis 提供了两个命令来生成 RDB 快照文件：\nsave : 同步保存操作，会阻塞 Redis 主线程； bgsave : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。 这里说 Redis 主线程而不是主进程的主要是因为 Redis 启动之后主要是通过单线程的方式完成主要的工作。如果你想将其描述为 Redis 主进程，也没毛病。\nAOF 持久化 什么是 AOF 持久化？ 与快照持久化相比，AOF 持久化的实时性更好。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了），可以通过 appendonly 参数开启：\n1 appendonly yes 开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 server.aof_buf 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ fsync策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。\n只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了。\nAOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。\nAOF 工作基本流程是怎样的？ AOF 持久化功能的实现可以简单分为 5 步：\n命令追加（append）：所有的写命令会追加到 AOF 缓冲区中。 文件写入（write）：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用write函数（系统调用），write将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。 文件同步（fsync）：AOF 缓冲区根据对应的持久化方式（ fsync 策略）向硬盘做同步操作。这一步需要调用 fsync 函数（系统调用）， fsync 针对单个文件操作，对其进行强制硬盘同步，fsync 将阻塞直到写入磁盘完成后返回，保证了数据持久化。 文件重写（rewrite）：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。 重启加载（load）：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。 Linux 系统直接提供了一些函数用于对文件和设备进行访问和控制，这些函数被称为 系统调用（syscall）。\n这里对上面提到的一些 Linux 系统调用再做一遍解释：\nwrite：写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘。虽然提高了效率，但也带来了数据丢失的风险。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I/O 缓冲区的状态。 fsync：fsync用于强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。 AOF 工作流程图如下：\nAOF 持久化方式有哪些？ 在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ fsync策略），它们分别是：\nappendfsync always：主线程调用 write 执行写操作后，后台线程（ aof_fsync 线程）立即会调用 fsync 函数同步 AOF 文件（刷盘），fsync 完成后线程返回，这样会严重降低 Redis 的性能（write + fsync）。 appendfsync everysec：主线程调用 write 执行写操作后立即返回，由后台线程（ aof_fsync 线程）每秒钟调用 fsync 函数（系统调用）同步一次 AOF 文件（write+fsync，fsync间隔为 1 秒） appendfsync no：主线程调用 write 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（write但不fsync，fsync 的时机由操作系统决定）。 可以看出：这 3 种持久化方式的主要区别在于 fsync 同步 AOF 文件的时机（刷盘）。\n为了兼顾数据和写入性能，可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能受到的影响较小。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。\n从 Redis 7.0.0 开始，Redis 使用了 Multi Part AOF 机制。顾名思义，Multi Part AOF 就是将原来的单个 AOF 文件拆分成多个 AOF 文件。在 Multi Part AOF 中，AOF 文件被分为三种类型，分别为：\nBASE：表示基础 AOF 文件，它一般由子进程通过重写产生，该文件最多只有一个。 INCR：表示增量 AOF 文件，它一般会在 AOFRW 开始执行时被创建，该文件可能存在多个。 HISTORY：表示历史 AOF 文件，它由 BASE 和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis 自动删除。 Multi Part AOF 不是重点，了解即可，详细介绍可以看看阿里开发者的Redis 7.0 Multi Part AOF 的设计和实现 这篇文章。\n相关 issue：Redis 的 AOF 方式 #783。\nAOF 为什么是在执行完命令之后记录日志？ 关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。\n为什么是在执行完命令之后记录日志呢？\n避免额外的检查开销，AOF 记录日志不会对命令进行语法检查； 在命令执行完之后再记录，不会阻塞当前的命令执行。 这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：\n如果刚执行完命令 Redis 就宕机会导致对应的修改丢失； 可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。 AOF 重写了解吗？ 当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。\nAOF 重写（rewrite） 是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。\n由于 AOF 重写会进行大量的写入操作，为了避免对 Redis 正常处理命令请求造成影响，Redis 将 AOF 重写程序放到子进程里执行。\nAOF 文件重写期间，Redis 还会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。\n开启 AOF 重写功能，可以调用 BGREWRITEAOF 命令手动执行，也可以设置下面两个配置项，让程序自动决定触发时机：\nauto-aof-rewrite-min-size：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB; auto-aof-rewrite-percentage：执行 AOF 重写时，当前 AOF 大小（aof_current_size）和上一次重写时 AOF 大小（aof_base_size）的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。 Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。\nRedis 7.0 版本之后，AOF 重写机制得到了优化改进。下面这段内容摘自阿里开发者的从 Redis7.0 发布看 Redis 的过去与未来 这篇文章。\nAOF 重写期间的增量数据如何处理一直是个问题，在过去写期间的增量数据需要在内存中保留，写结束后再把这部分增量数据写入新的 AOF 文件中以保证数据完整性。可以看出来 AOF 写会额外消耗内存和磁盘 IO，这也是 Redis AOF 写的痛点，虽然之前也进行过多次改进但是资源消耗的本质问题一直没有解决。\n阿里云的 Redis 企业版在最初也遇到了这个问题，在内部经过多次迭代开发，实现了 Multi-part AOF 机制来解决，同时也贡献给了社区并随此次 7.0 发布。具体方法是采用 base（全量数据）+inc（增量数据）独立文件存储的方式，彻底解决内存和 IO 资源的浪费，同时也支持对历史 AOF 文件的保存管理，结合 AOF 文件中的时间信息还可以实现 PITR 按时间点恢复（阿里云企业版 Tair 已支持），这进一步增强了 Redis 的数据可靠性，满足用户数据回档等需求。\n相关 issue：Redis AOF 重写描述不准确 #1439。\nAOF 校验机制了解吗？ AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 校验和（checksum） 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。\n类似地，RDB 文件也有类似的校验机制来保证 RDB 文件的正确性，这里就不重复进行介绍了。\nRedis 4.0 对于持久化机制做了什么优化？ 由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。\n如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。\n官方文档地址：https://redis.io/topics/persistence\n如何选择 RDB 和 AOF？ 关于 RDB 和 AOF 的优缺点，官网上面也给了比较详细的说明Redis persistence，这里结合自己的理解简单总结一下。\nRDB 比 AOF 优秀的地方：\nRDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。 使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。 AOF 比 RDB 优秀的地方：\nRDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。 RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。 AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行FLUSHALL命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。 综上：\nRedis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。 不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。 如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。 Redis内存碎片详解 什么是内存碎片? 你可以将内存碎片简单地理解为那些不可用的空闲内存。\n举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。\nRedis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。\n为什么会有 Redis 内存碎片? Redis 内存碎片产生比较常见的 2 个原因：\n1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。\n以下是这段 Redis 官方的原话：\nTo store user keys, Redis allocates at most as much memory as the maxmemory setting enables (however there are small extra allocations possible).\nRedis 使用 zmalloc 方法(Redis 自己实现的内存分配方法)进行内存分配的时候，除了要分配 size 大小的内存之外，还会多分配 PREFIX_SIZE 大小的内存。\nzmalloc 方法源码如下（源码地址：https://github.com/antirez/redis-tools/blob/master/zmalloc.c）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void *zmalloc(size_t size) { // 分配指定大小的内存 void *ptr = malloc(size+PREFIX_SIZE); if (!ptr) zmalloc_oom_handler(size); #ifdef HAVE_MALLOC_SIZE update_zmalloc_stat_alloc(zmalloc_size(ptr)); return ptr; #else *((size_t*)ptr) = size; update_zmalloc_stat_alloc(size+PREFIX_SIZE); return (char*)ptr+PREFIX_SIZE; #endif } 另外，Redis 可以使用多种内存分配器来分配内存（ libc、jemalloc、tcmalloc），默认使用 jemalloc，而 jemalloc 按照一系列固定的大小（8 字节、16 字节、32 字节……）来分配内存的。jemalloc 划分的内存单元如下图所示：\n当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间，就比如说程序需要申请 17 字节的内存，jemalloc 会直接给它分配 32 字节的内存，这样会导致有 15 字节内存的浪费。不过，jemalloc 专门针对内存碎片问题做了优化，一般不会存在过度碎片化的问题。\n2、频繁修改 Redis 中的数据也会产生内存碎片。\n当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。\n这个在 Redis 官方文档中也有对应的原话:\n文档地址：https://redis.io/topics/memory-optimization 。\n如何查看 Redis 内存碎片的信息？ 使用 info memory 命令即可查看 Redis 内存相关的信息。下图中每个参数具体的含义，Redis 官方文档有详细的介绍：https://redis.io/commands/INFO 。\nRedis 内存碎片率的计算公式：mem_fragmentation_ratio （内存碎片率）= used_memory_rss (操作系统实际分配给 Redis 的物理内存空间大小)/ used_memory(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)\n也就是说，mem_fragmentation_ratio （内存碎片率）的值越大代表内存碎片率越严重。\n一定不要误认为used_memory_rss 减去 used_memory值就是内存碎片的大小！！！这不仅包括内存碎片，还包括其他进程开销，以及共享库、堆栈等的开销。\n很多小伙伴可能要问了：“多大的内存碎片率才是需要清理呢？”。\n通常情况下，我们认为 mem_fragmentation_ratio \u003e 1.5 的话才需要清理内存碎片。 mem_fragmentation_ratio \u003e 1.5 意味着你使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存。\n如果想要快速查看内存碎片率的话，你还可以通过下面这个命令：\n1 \u003e redis-cli -p 6379 info | grep mem_fragmentation_ratio 另外，内存碎片率可能存在小于 1 的情况。这种情况我在日常使用中还没有遇到过，感兴趣的小伙伴可以看看这篇文章 故障分析 | Redis 内存碎片率太低该怎么办？- 爱可生开源社区 。\n如何清理 Redis 内存碎片？ Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。\n直接通过 config set 命令将 activedefrag 配置项设置为 yes 即可。\n1 config set activedefrag yes 具体什么时候清理需要通过下面两个参数控制：\n1 2 3 4 # 内存碎片占用空间达到 500mb 的时候开始清理 config set active-defrag-ignore-bytes 500mb # 内存碎片率大于 1.5 的时候开始清理 config set active-defrag-threshold-lower 50 通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，我们可以通过下面两个参数来减少对 Redis 性能的影响：\n1 2 3 4 # 内存碎片清理所占用 CPU 时间的比例不低于 20% config set active-defrag-cycle-min 20 # 内存碎片清理所占用 CPU 时间的比例不高于 50% config set active-defrag-cycle-max 50 另外，重启节点可以做到内存碎片重新整理。如果你采用的是高可用架构的 Redis 集群的话，你可以将碎片率过高的主节点转换为从节点，以便进行安全重启。\nRedis常见阻塞原因总结 O(n) 命令 Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：\nKEYS *：会返回所有符合规则的 key。 HGETALL：会返回一个 Hash 中所有的键值对。 LRANGE：会返回 List 中指定范围内的元素。 SMEMBERS：返回 Set 中的所有元素。 SINTER/SUNION/SDIFF：计算多个 Set 的交集/并集/差集。 …… 由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长，从而导致客户端阻塞。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 HSCAN、SSCAN、ZSCAN 代替。\n除了这些 O(n)时间复杂度的命令可能会导致阻塞之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：\nZRANGE/ZREVRANGE：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。 ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。 …… SAVE 创建 RDB 快照 Redis 提供了两个命令来生成 RDB 快照文件：\nsave : 同步保存操作，会阻塞 Redis 主线程； bgsave : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。 默认情况下，Redis 默认配置会使用 bgsave 命令。如果手动使用 save 命令生成 RDB 快照文件的话，就会阻塞主线程。\nAOF AOF 日志记录阻塞 Redis AOF 持久化机制是在执行完命令之后再记录日志，这和关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复）不同。\n为什么是在执行完命令之后记录日志呢？\n避免额外的检查开销，AOF 记录日志不会对命令进行语法检查； 在命令执行完之后再记录，不会阻塞当前的命令执行。 这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：\n如果刚执行完命令 Redis 就宕机会导致对应的修改丢失； 可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。 AOF 刷盘阻塞 开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 server.aof_buf 中，然后再根据 appendfsync 配置来决定何时将其同步到硬盘中的 AOF 文件。\n在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ fsync策略），它们分别是：\nappendfsync always：主线程调用 write 执行写操作后，后台线程（ aof_fsync 线程）立即会调用 fsync 函数同步 AOF 文件（刷盘），fsync 完成后线程返回，这样会严重降低 Redis 的性能（write + fsync）。 appendfsync everysec：主线程调用 write 执行写操作后立即返回，由后台线程（ aof_fsync 线程）每秒钟调用 fsync 函数（系统调用）同步一次 AOF 文件（write+fsync，fsync间隔为 1 秒） appendfsync no：主线程调用 write 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（write但不fsync，fsync 的时机由操作系统决定）。 当后台线程（ aof_fsync 线程）调用 fsync 函数同步 AOF 文件时，需要等待，直到写入完成。当磁盘压力太大的时候，会导致 fsync 操作发生阻塞，主线程调用 write 函数时也会被阻塞。fsync 完成后，主线程执行 write 才能成功返回。\n关于 AOF 工作流程的详细介绍可以查看：Redis 持久化机制详解，有助于理解 AOF 刷盘阻塞。\nAOF 重写阻塞 fork 出一条子线程来将文件重写，在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子线程创建新 AOF 文件期间，记录服务器执行的所有写命令。 当子线程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。 最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。 阻塞就是出现在第 2 步的过程中，将缓冲区中新数据写到新文件的过程中会产生阻塞。\n相关阅读：Redis AOF 重写阻塞问题分析。\n大 Key 如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。\n大 key 造成的阻塞问题如下：\n客户端超时阻塞：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。 引发网络阻塞：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。 阻塞工作线程：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。 查找大 key 当我们在使用 Redis 自带的 --bigkeys 参数查找大 key 时，最好选择在从节点上执行该命令，因为主节点上执行时，会阻塞主节点。\n我们还可以使用 SCAN 命令来查找大 key； 通过分析 RDB 文件来找出 big key，这种方案的前提是 Redis 采用的是 RDB 持久化。网上有现成的工具： redis-rdb-tools：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具 rdb_bigkeys：Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。 删除大 key 删除操作的本质是要释放键值对占用的内存空间。\n释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。\n所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。\n删除大 key 时建议采用分批次删除和异步删除的方式进行。\n清空数据库 清空数据库和上面 bigkey 删除也是同样道理，flushdb、flushall 也涉及到删除和释放所有的键值对，也是 Redis 的阻塞点。\n集群扩容 Redis 集群可以进行节点的动态扩容缩容，这一过程目前还处于半自动状态，需要人工介入。\n在扩缩容的时候，需要进行数据迁移。而 Redis 为了保证迁移的一致性，迁移所有操作都是同步操作。\n执行迁移时，两端的 Redis 均会进入时长不等的阻塞状态，对于小 Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，严重的时候会触发集群内的故障转移，造成不必要的切换。\nSwap（内存交换） 什么是 Swap？ Swap 直译过来是交换的意思，Linux 中的 Swap 常被称为内存交换或者交换分区。类似于 Windows 中的虚拟内存，就是当内存不足的时候，把一部分硬盘空间虚拟成内存使用，从而解决内存容量不足的情况。因此，Swap 分区的作用就是牺牲硬盘，增加内存，解决 VPS 内存不够用或者爆满的问题。\nSwap 对于 Redis 来说是非常致命的，Redis 保证高性能的一个重要前提是所有的数据在内存中。如果操作系统把 Redis 使用的部分内存换出硬盘，由于内存与硬盘读写的速度并几个数量级，会导致发生交换后的 Redis 性能急剧下降。\n识别 Redis 发生 Swap 的检查方法如下：\n1、查询 Redis 进程号\n1 2 reids-cli -p 6383 info server | grep process_id process_id: 4476 2、根据进程号查询内存交换信息\n1 2 3 4 5 6 7 cat /proc/4476/smaps | grep Swap Swap: 0kB Swap: 0kB Swap: 4kB Swap: 0kB Swap: 0kB ..... 如果交换量都是 0KB 或者个别的是 4KB，则正常。\n预防内存交换的方法：\n保证机器充足的可用内存 确保所有 Redis 实例设置最大可用内存(maxmemory)，防止极端情况 Redis 内存不可控的增长 降低系统使用 swap 优先级，如echo 10 \u003e /proc/sys/vm/swappiness CPU 竞争 Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。\n可以通过reids-cli --stat获取当前 Redis 使用情况。通过top命令获取进程对 CPU 的利用率等信息 通过info commandstats统计信息分析出命令不合理开销时间，查看是否是因为高算法复杂度或者过度的内存优化问题。\n网络问题 连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。\nredis大key处理 怎么才算大key 大key 并不是指 key 的值很大，而是 key 对应的 value 很大（非常占内存）。一个key对应的value所占用的内存比较大，那么这个key就可以看作是 bigkey 。\n单个String类型的Key大小达到20KB并且OPS高 key本身的数据过大。例如，一个string类型的key，value为5MB。 key中的元素过多。例如，一个zset类型的key，元素超过10000个。 key中元素的数据过大。例如，一个Hash类型的key，元素只有500个，但是这些元素的value的总大小为100MB。 大KEY的影响 知道了大key的定义，那么我们也得知道大key的带来的影响：\n客户端超时阻塞： Redis 执行命令是单线程处理，然后在大 key处理时会比较耗时，那么就会发生阻塞 ，期间就会各种业务超时出现。 引发网络阻塞： 每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于服务器来说是灾难性的。 阻塞工作线程： 如果使用 del 删除大 key 时，会阻塞工作线程，无法处理后续的命令。 内存分布不均： 集群各分片内存使用不均。某个分片占用内存较高或OOM，发送缓存区增大等，导致该分片其他Key被逐出，同时也会造成其他分片的资源浪费。 如何发现大key 使用redis提供的命令 第一种：这个命令会扫描redis的所有key，对性能有影响，而且只能找出每种数据类型内存占用最大的key。\n1 redis-cli -p 6379 --bigkeys 第二种：查看置顶key的内存占用\n1 memory usage key名字 使用第三方工具 https://github.com/sripathikrishnan/redis-rdb-tools https://github.com/weiyanwei412/rdb_bigkeys 云服务内提供的可视化分析工具 bash脚本 1 2 3 4 5 6 7 # 遍历所有 Key，并筛选出内存占用超过 1MB 的 Key redis-cli --scan | while read key; do size=$(redis-cli MEMORY USAGE $key) if [ \"$size\" -gt 1048576 ]; then echo \"Big Key: $key, Size: $size bytes\" fi done 如何解决大key问题 设计阶段避免 Big Key 设计原则 示例 拆分大数据 将单个大 JSON 拆分为多个小字段存储 合理选择数据类型 使用 Hash 替代大字符串，便于分片和访问 限制 Key 的大小 通过业务逻辑限制 Key 的数据量，例如限制 List 元素数量 优化 Big Key 的操作 操作 优化措施 删除 Big Key 1. 分批次删除: hscan、ltrim、sscan指令分批次进行删除 2. 异步删除: 使用 UNLINK 替代 DEL，异步删除减少阻塞：UNLINK bigkey； 逐步迁移 对大数据结构（如 List、Set）分批迁移或处理： LRANGE + LTRIM 监控访问/内存 1. 避免对大对象使用全量操作（如 HGETALL、SMEMBERS），改用局部操作：HSCAN、SSCAN 2. 可通过监控系统设置合理 Redis 内存报警阈值，如内存使用率超 70%、1 小时内内存增长率超 20%等进行提醒。 开启 lazy-free 惰性删除/延迟释放 值得是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程 历史key未使用 针对这种key场景，其实存在着历史原因，可能是伴随着某个业务下线或者不使用，往往对应实现的缓存操作代码会删除，但是对于缓存数据往往不会做任何处理，久而久之，这种脏数据会一直堆积，占用着资源。那么如果确定已经无使用，并且可以确认有持久化数据（如mysql、es等）备份的话，可以直接将对应key删除。\n元素数过多 针对于Set、Hash这种场景，如果元素数量超过5000就视为大的key。如果对应value值不大，我们可以采取平铺的形式，\n比如系统内历史的设计是存储下每个品牌对应的名称，那么就设置了统一的key，然后不同的品牌id作为fild，操作了hSet和hGet来存储获取数据，降低查询外围服务的频率。但是随着品牌数量的增长，导致元素逐步增多，元素个数就超过了大key的预设值了。这种根据场景，我们其实存储本身只有一个品牌名称，那么我们就针对于品牌id对应加上一个统一前缀作为唯一key，采用平铺方式缓存对应数据即可。针对这种数据的替换，我这里也总结了下具体要实现的步骤：\n第一步：修改代码查询和赋值逻辑：\n把原始的hGet的逻辑修改为get获取； 把原始hSet的逻辑修改为set赋值。 第二步：历史数据刷新到新缓存key：\n为了避免上线之后出现缓存雪崩，因为替换了新的key，我们需要通过现有的HASH的数据刷新到新的缓存中，所以需要历史数据处理。\n通过hGetAll获取所以元素数据，循环缓存元素数据操作存储新的缓存key和value。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public String refreshHistoryData(){ try { String key = \"historyKey\"; Map redisInfoMap= redisUtils.hGetAll(key); if (redisInfoMap.isEmpty()){ return \"查询缓存无数据\"; } for (Map.Entry entry : redisInfoMap.entrySet()) { String redisVal = entry.getValue(); String filedKey = entry.getKey(); String newDataRedisKey = \"newDataKey\"+filedKey; redisUtils.set(newDataRedisKey,redisVal); } return \"success\"; }catch (Exception e){ LOG.error(\"refreshHistoryData 异常:\",e); } return \"failed\"; } 注意：这里一定要先刷历史数据，再上线代码业务逻辑的修改。防止引发缓存雪崩。\n大对象转换存储形式 复杂的大对象可以尝试将对象分拆成几个key-value， 使用mGet和mSet操作对应值或者pipeline的形式，最后拼装成需要返回的大对象。这样意义在于可以分散单次操作的压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响。\n这里以系统内订单对象为例：订单对象Order基础属性有几十个，如订单号、金额、时间、类型等，除此之外还要包含订单下的商品OrderSub、预售信息PresaleOrder、发票信息OrderInvoice、订单时效OrderPremiseInfo、订单轨迹OrderTrackInfo、订单详细费用OrderFee等信息。\n那么对于每个订单相关信息，我们可以设置为单独的key，把订单信息和几个相关的关联数据每个按照单独key存储，接着通过mGet方式获取每个信息之后，最后封装成整体Order对象。下面仅展示关键伪代码以mSet和mGet实现。\n缓存定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 public enum CacheKeyConstant { /** * 订单基础缓存key */ REDIS_ORDER_BASE_INFO(\"ORDER_BASE_INFO\"), /** * 订单商品缓存key */ ORDER_SUB_INFO(\"ORDER_SUB_INFO\"), /** * 订单预售信息缓存key */ ORDER_PRESALE_INFO(\"ORDER_PRESALE_INFO\"), /** * 订单履约信息缓存key */ ORDER_PREMISE_INFO(\"ORDER_PREMISE_INFO\"), /** * 订单发票信息缓存key */ ORDER_INVOICE_INFO(\"ORDER_INVOICE_INFO\"), /** * 订单轨迹信息缓存key */ ORDER_TRACK_INFO(\"ORDER_TRACK_INFO\"), /** * 订单详细费用信息缓存key */ ORDER_FEE_INFO(\"ORDER_FEE_INFO\"), ; /** * 前缀 */ private String prefix; /** * 项目统一前缀 */ public static final String COMMON_PREFIX = \"XXX\"; CacheKeyConstant(String prefix){ this.prefix = prefix; } public String getPrefix(String subKey) { if(StringUtil.isNotEmpty(subKey)){ return COMMON_PREFIX + prefix + \"_\" + subKey; } return COMMON_PREFIX + prefix; } public String getPrefix() { return COMMON_PREFIX + prefix; } } 缓存存储：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 /** * @description 刷新订单到缓存 * @param order 订单信息 */ public boolean refreshOrderToCache(Order order){ if(order == null || order.getOrderId() == null){ return ; } String orderId = order.getOrderId().toString(); //设置存储缓存数据 Map cacheOrderMap = new HashMap\u003c\u003e(16); cacheOrderMap.put(CacheKeyConstant.ORDER_BASE_INFO.getPrefix(orderId), JSON.toJSONString(buildBaseOrderVo(order))); cacheOrderMap.put(CacheKeyConstant.ORDER_SUB_INFO.getPrefix(orderId), JSON.toJSONString(order.getCustomerOrderSubs())); cacheOrderMap.put(CacheKeyConstant.ORDER_PRESALE_INFO.getPrefix(orderId), JSON.toJSONString(order.getPresaleOrderData())); cacheOrderMap.put(CacheKeyConstant.ORDER_INVOICE_INFO.getPrefix(orderId), JSON.toJSONString(order.getOrderInvoice())); cacheOrderMap.put(CacheKeyConstant.ORDER_TRACK_INFO.getPrefix(orderId), JSON.toJSONString(order.getOrderTrackInfo())); cacheOrderMap.put(CacheKeyConstant.ORDER_PREMISE_INFO.getPrefix(orderId), JSON.toJSONString( order.getPresaleOrderData())); cacheOrderMap.put(CacheKeyConstant.ORDER_FEE_INFO.getPrefix(orderId), JSON.toJSONString(order.getOrderFeeVo())); superRedisUtils.mSetString(cacheOrderMap); } 缓存获取：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 /** * @description 通过订单号获取缓存数据 * @param orderId 订单号 * @return Order 订单实体信息 */ public Order getOrderFromCache(String orderId){ if(StringUtils.isBlank(orderId)){ return null; } //定义查询缓存集合key List queryOrderKey = Arrays.asList(CacheKeyConstant.ORDER_BASE_INFO.getPrefix(orderId),CacheKeyConstant.ORDER_SUB_INFO.getPrefix(orderId), CacheKeyConstant.ORDER_PRESALE_INFO.getPrefix(orderId),CacheKeyConstant.ORDER_INVOICE_INFO.getPrefix(orderId),CacheKeyConstant.ORDER_TRACK_INFO.getPrefix(orderId), CacheKeyConstant.ORDER_PREMISE_INFO.getPrefix(orderId),CacheKeyConstant.ORDER_FEE_INFO.getPrefix(orderId)); //查询结果 List result = redisUtils.mGet(queryOrderKey); //基础信息 if(CollectionUtils.isEmpty(result)){ return null; } String[] resultInfo = result.toArray(new String[0]); //基础信息 if(StringUtils.isBlank(resultInfo[0])){ return null; } BaseOrderVo baseOrderVo = JSON.parseObject(resultInfo[0],BaseOrderVo.class); Order order = coverBaseOrderVoToOrder(baseOrderVo); //订单商品 if(StringUtils.isNotBlank(resultInfo[1])){ List orderSubs =JSON.parseObject(result.get(1), new TypeReference",
  "wordCount" : "46192",
  "inLanguage": "en",
  "datePublished": "2023-07-28T05:00:00Z",
  "dateModified": "2023-07-28T05:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Wjy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://wjy6.netlify.app/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Wjy's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://wjy6.netlify.app/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://wjy6.netlify.app/" accesskey="h" title="Wjy&#39;s Blog (Alt + H)">Wjy&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://wjy6.netlify.app/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://wjy6.netlify.app/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://wjy6.netlify.app/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://wjy6.netlify.app/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://wjy6.netlify.app/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://wjy6.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://wjy6.netlify.app/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      16_Redis面试题
    </h1>
    <div class="post-meta"><span title='2023-07-28 05:00:00 +0000 UTC'>2023-07-28</span>&nbsp;·&nbsp;Wjy

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e6%a6%82%e8%bf%b0" aria-label="概述">概述</a><ul>
                        
                <li>
                    <a href="#redis-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%99%e4%b9%88%e5%bf%ab" aria-label="Redis 为什么这么快？">Redis 为什么这么快？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-redis%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e7%bc%93%e5%ad%98" aria-label="为什么要用 Redis/为什么要用缓存？">为什么要用 Redis/为什么要用缓存？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="Redis 应用场景">Redis 应用场景</a><ul>
                        
                <li>
                    <a href="#redis-%e5%8f%af%e4%bb%a5%e5%81%9a%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e4%b9%88" aria-label="Redis 可以做消息队列么？">Redis 可以做消息队列么？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="Redis 数据结构">Redis 数据结构</a><ul>
                        
                <li>
                    <a href="#redis-%e5%b8%b8%e7%94%a8%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="Redis 常用的数据结构有哪些？">Redis 常用的数据结构有哪些？</a></li>
                <li>
                    <a href="#string-%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="String 的应用场景有哪些？">String 的应用场景有哪些？</a></li>
                <li>
                    <a href="#string-%e8%bf%98%e6%98%af-hash-%e5%ad%98%e5%82%a8%e5%af%b9%e8%b1%a1%e6%95%b0%e6%8d%ae%e6%9b%b4%e5%a5%bd%e5%91%a2" aria-label="String 还是 Hash 存储对象数据更好呢？">String 还是 Hash 存储对象数据更好呢？</a></li>
                <li>
                    <a href="#string-%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0%e6%98%af%e4%bb%80%e4%b9%88" aria-label="String 的底层实现是什么？">String 的底层实现是什么？</a></li>
                <li>
                    <a href="#%e8%b4%ad%e7%89%a9%e8%bd%a6%e4%bf%a1%e6%81%af%e7%94%a8-string-%e8%bf%98%e6%98%af-hash-%e5%ad%98%e5%82%a8%e6%9b%b4%e5%a5%bd%e5%91%a2" aria-label="购物车信息用 String 还是 Hash 存储更好呢?">购物车信息用 String 还是 Hash 存储更好呢?</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-redis-%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e6%8e%92%e8%a1%8c%e6%a6%9c%e6%80%8e%e4%b9%88%e5%81%9a" aria-label="使用 Redis 实现一个排行榜怎么做？">使用 Redis 实现一个排行榜怎么做？</a></li>
                <li>
                    <a href="#set-%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e6%98%af%e4%bb%80%e4%b9%88" aria-label="Set 的应用场景是什么？">Set 的应用场景是什么？</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-set-%e5%ae%9e%e7%8e%b0%e6%8a%bd%e5%a5%96%e7%b3%bb%e7%bb%9f%e6%80%8e%e4%b9%88%e5%81%9a" aria-label="使用 Set 实现抽奖系统怎么做？">使用 Set 实现抽奖系统怎么做？</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-bitmap-%e7%bb%9f%e8%ae%a1%e6%b4%bb%e8%b7%83%e7%94%a8%e6%88%b7%e6%80%8e%e4%b9%88%e5%81%9a" aria-label="使用 Bitmap 统计活跃用户怎么做？">使用 Bitmap 统计活跃用户怎么做？</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-hyperloglog-%e7%bb%9f%e8%ae%a1%e9%a1%b5%e9%9d%a2-uv-%e6%80%8e%e4%b9%88%e5%81%9a" aria-label="使用 HyperLogLog 统计页面 UV 怎么做？">使用 HyperLogLog 统计页面 UV 怎么做？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b%e9%87%8d%e8%a6%81" aria-label="Redis 线程模型（重要）">Redis 线程模型（重要）</a><ul>
                        
                <li>
                    <a href="#redis-%e5%8d%95%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="Redis 单线程模型了解吗？">Redis 单线程模型了解吗？</a></li>
                <li>
                    <a href="#redis60-%e4%b9%8b%e5%89%8d%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e4%bd%bf%e7%94%a8%e5%a4%9a%e7%ba%bf%e7%a8%8b" aria-label="Redis6.0 之前为什么不使用多线程？">Redis6.0 之前为什么不使用多线程？</a></li>
                <li>
                    <a href="#redis60-%e4%b9%8b%e5%90%8e%e4%b8%ba%e4%bd%95%e5%bc%95%e5%85%a5%e4%ba%86%e5%a4%9a%e7%ba%bf%e7%a8%8b" aria-label="Redis6.0 之后为何引入了多线程？">Redis6.0 之后为何引入了多线程？</a></li>
                <li>
                    <a href="#redis-%e5%90%8e%e5%8f%b0%e7%ba%bf%e7%a8%8b%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="Redis 后台线程了解吗？">Redis 后台线程了解吗？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" aria-label="Redis 内存管理">Redis 内存管理</a><ul>
                        
                <li>
                    <a href="#redis-%e7%bb%99%e7%bc%93%e5%ad%98%e6%95%b0%e6%8d%ae%e8%ae%be%e7%bd%ae%e8%bf%87%e6%9c%9f%e6%97%b6%e9%97%b4%e6%9c%89%e5%95%a5%e7%94%a8" aria-label="Redis 给缓存数据设置过期时间有啥用？">Redis 给缓存数据设置过期时间有啥用？</a></li>
                <li>
                    <a href="#redis-%e6%98%af%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e6%95%b0%e6%8d%ae%e6%98%af%e5%90%a6%e8%bf%87%e6%9c%9f%e7%9a%84%e5%91%a2" aria-label="Redis 是如何判断数据是否过期的呢？">Redis 是如何判断数据是否过期的呢？</a></li>
                <li>
                    <a href="#%e8%bf%87%e6%9c%9f%e7%9a%84%e6%95%b0%e6%8d%ae%e7%9a%84%e5%88%a0%e9%99%a4%e7%ad%96%e7%95%a5%e4%ba%86%e8%a7%a3%e4%b9%88" aria-label="过期的数据的删除策略了解么？">过期的数据的删除策略了解么？</a></li>
                <li>
                    <a href="#redis-%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e6%9c%ba%e5%88%b6%e4%ba%86%e8%a7%a3%e4%b9%88" aria-label="Redis 内存淘汰机制了解么？">Redis 内存淘汰机制了解么？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e4%ba%8b%e5%8a%a1" aria-label="Redis 事务">Redis 事务</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-redis-%e4%ba%8b%e5%8a%a1" aria-label="什么是 Redis 事务？">什么是 Redis 事务？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-redis-%e4%ba%8b%e5%8a%a1" aria-label="如何使用 Redis 事务？">如何使用 Redis 事务？</a></li>
                <li>
                    <a href="#redis-%e4%ba%8b%e5%8a%a1%e6%94%af%e6%8c%81%e5%8e%9f%e5%ad%90%e6%80%a7%e5%90%97" aria-label="Redis 事务支持原子性吗？">Redis 事务支持原子性吗？</a></li>
                <li>
                    <a href="#redis-%e4%ba%8b%e5%8a%a1%e6%94%af%e6%8c%81%e6%8c%81%e4%b9%85%e6%80%a7%e5%90%97" aria-label="Redis 事务支持持久性吗？">Redis 事务支持持久性吗？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3-redis-%e4%ba%8b%e5%8a%a1%e7%9a%84%e7%bc%ba%e9%99%b7" aria-label="如何解决 Redis 事务的缺陷？">如何解决 Redis 事务的缺陷？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e9%87%8d%e8%a6%81" aria-label="Redis 性能优化（重要）">Redis 性能优化（重要）</a><ul>
                        
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e6%89%b9%e9%87%8f%e6%93%8d%e4%bd%9c%e5%87%8f%e5%b0%91%e7%bd%91%e7%bb%9c%e4%bc%a0%e8%be%93" aria-label="使用批量操作减少网络传输">使用批量操作减少网络传输</a><ul>
                        
                <li>
                    <a href="#%e5%8e%9f%e7%94%9f%e6%89%b9%e9%87%8f%e6%93%8d%e4%bd%9c%e5%91%bd%e4%bb%a4" aria-label="原生批量操作命令">原生批量操作命令</a></li>
                <li>
                    <a href="#pipeline" aria-label="pipeline">pipeline</a></li>
                <li>
                    <a href="#lua-%e8%84%9a%e6%9c%ac" aria-label="Lua 脚本">Lua 脚本</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a4%a7%e9%87%8f-key-%e9%9b%86%e4%b8%ad%e8%bf%87%e6%9c%9f%e9%97%ae%e9%a2%98" aria-label="大量 key 集中过期问题">大量 key 集中过期问题</a></li>
                <li>
                    <a href="#%e6%85%a2%e6%9f%a5%e8%af%a2%e5%91%bd%e4%bb%a4" aria-label="慢查询命令">慢查询命令</a><ul>
                        
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e6%9c%89%e6%85%a2%e6%9f%a5%e8%af%a2%e5%91%bd%e4%bb%a4" aria-label="为什么会有慢查询命令？">为什么会有慢查询命令？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e6%89%be%e5%88%b0%e6%85%a2%e6%9f%a5%e8%af%a2%e5%91%bd%e4%bb%a4" aria-label="如何找到慢查询命令？">如何找到慢查询命令？</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f" aria-label="缓存穿透">缓存穿透</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf" aria-label="缓存击穿">缓存击穿</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9" aria-label="缓存雪崩">缓存雪崩</a></li>
                <li>
                    <a href="#redis%e4%b8%bb%e4%bb%8e" aria-label="Redis主从">Redis主从</a><ul>
                        
                <li>
                    <a href="#redis-%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86" aria-label="Redis 主从复制的实现原理">Redis 主从复制的实现原理</a></li></ul>
                </li>
                <li>
                    <a href="#redis%e5%93%a8%e5%85%b5" aria-label="Redis哨兵">Redis哨兵</a><ul>
                        
                <li>
                    <a href="#%e5%93%a8%e5%85%b5%e6%9c%ba%e5%88%b6%e7%9a%84%e7%94%b1%e6%9d%a5" aria-label="哨兵机制的由来">哨兵机制的由来</a></li>
                <li>
                    <a href="#%e4%b8%bb%e8%a7%82%e4%b8%8b%e7%ba%bf%e5%92%8c%e5%ae%a2%e8%a7%82%e4%b8%8b%e7%ba%bf" aria-label="主观下线和客观下线">主观下线和客观下线</a></li>
                <li>
                    <a href="#sentinel-leader-%e6%98%af%e5%a6%82%e4%bd%95%e9%80%89%e4%b8%be%e5%87%ba%e6%9d%a5%e7%9a%84" aria-label="Sentinel leader 是如何选举出来的？">Sentinel leader 是如何选举出来的？</a></li>
                <li>
                    <a href="#redis-%e4%b8%bb%e8%8a%82%e7%82%b9%e9%80%89%e4%b8%be" aria-label="Redis 主节点选举">Redis 主节点选举</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e9%9b%86%e7%be%a4" aria-label="Redis 集群">Redis 集群</a><ul>
                        
                <li>
                    <a href="#redis-%e9%9b%86%e7%be%a4%e7%9a%84%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86" aria-label="Redis 集群的实现原理">Redis 集群的实现原理</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e4%bd%bf%e7%94%a8%e8%a7%84%e8%8c%83" aria-label="Redis 使用规范">Redis 使用规范</a></li>
                <li>
                    <a href="#3%e7%a7%8d%e5%b8%b8%e7%94%a8%e7%9a%84%e7%bc%93%e5%ad%98%e8%af%bb%e5%86%99%e7%ad%96%e7%95%a5%e8%af%a6%e8%a7%a3" aria-label="3种常用的缓存读写策略详解">3种常用的缓存读写策略详解</a><ul>
                        
                <li>
                    <a href="#cache-aside-pattern%e6%97%81%e8%b7%af%e7%bc%93%e5%ad%98%e6%a8%a1%e5%bc%8f" aria-label="Cache Aside Pattern（旁路缓存模式）">Cache Aside Pattern（旁路缓存模式）</a></li>
                <li>
                    <a href="#readwrite-through-pattern%e8%af%bb%e5%86%99%e7%a9%bf%e9%80%8f" aria-label="Read/Write Through Pattern（读写穿透）">Read/Write Through Pattern（读写穿透）</a></li>
                <li>
                    <a href="#write-behind-pattern%e5%bc%82%e6%ad%a5%e7%bc%93%e5%ad%98%e5%86%99%e5%85%a5" aria-label="Write Behind Pattern（异步缓存写入）">Write Behind Pattern（异步缓存写入）</a></li></ul>
                </li>
                <li>
                    <a href="#redis-5-%e7%a7%8d%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e8%af%a6%e8%a7%a3" aria-label="Redis 5 种基本数据结构详解">Redis 5 种基本数据结构详解</a><ul>
                        
                <li>
                    <a href="#string%e5%ad%97%e7%ac%a6%e4%b8%b2" aria-label="String（字符串）">String（字符串）</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#list%e5%88%97%e8%a1%a8" aria-label="List（列表）">List（列表）</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d-1" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-1" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-1" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#hash%e5%93%88%e5%b8%8c" aria-label="Hash（哈希）">Hash（哈希）</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d-2" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-2" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-2" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#set%e9%9b%86%e5%90%88" aria-label="Set（集合）">Set（集合）</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d-3" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-3" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-3" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#sorted-set%e6%9c%89%e5%ba%8f%e9%9b%86%e5%90%88" aria-label="Sorted Set（有序集合）">Sorted Set（有序集合）</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d-4" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-4" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-4" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#redis-3-%e7%a7%8d%e7%89%b9%e6%ae%8a%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e8%af%a6%e8%a7%a3" aria-label="Redis 3 种特殊数据结构详解">Redis 3 种特殊数据结构详解</a><ul>
                        
                <li>
                    <a href="#bitmap" aria-label="Bitmap">Bitmap</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d-5" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-5" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-5" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#hyperloglog" aria-label="HyperLogLog">HyperLogLog</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d-6" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-6" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-6" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#geospatial-index" aria-label="Geospatial index">Geospatial index</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d-7" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-7" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-7" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93-1" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#redis%e6%8c%81%e4%b9%85%e5%8c%96%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3" aria-label="Redis持久化机制详解">Redis持久化机制详解</a><ul>
                        
                <li>
                    <a href="#rdb-%e6%8c%81%e4%b9%85%e5%8c%96" aria-label="RDB 持久化">RDB 持久化</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-rdb-%e6%8c%81%e4%b9%85%e5%8c%96" aria-label="什么是 RDB 持久化？">什么是 RDB 持久化？</a></li>
                <li>
                    <a href="#rdb-%e5%88%9b%e5%bb%ba%e5%bf%ab%e7%85%a7%e6%97%b6%e4%bc%9a%e9%98%bb%e5%a1%9e%e4%b8%bb%e7%ba%bf%e7%a8%8b%e5%90%97" aria-label="RDB 创建快照时会阻塞主线程吗？">RDB 创建快照时会阻塞主线程吗？</a></li></ul>
                </li>
                <li>
                    <a href="#aof-%e6%8c%81%e4%b9%85%e5%8c%96" aria-label="AOF 持久化">AOF 持久化</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-aof-%e6%8c%81%e4%b9%85%e5%8c%96" aria-label="什么是 AOF 持久化？">什么是 AOF 持久化？</a></li>
                <li>
                    <a href="#aof-%e5%b7%a5%e4%bd%9c%e5%9f%ba%e6%9c%ac%e6%b5%81%e7%a8%8b%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84" aria-label="AOF 工作基本流程是怎样的？">AOF 工作基本流程是怎样的？</a></li>
                <li>
                    <a href="#aof-%e6%8c%81%e4%b9%85%e5%8c%96%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="AOF 持久化方式有哪些？">AOF 持久化方式有哪些？</a></li>
                <li>
                    <a href="#aof-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e5%9c%a8%e6%89%a7%e8%a1%8c%e5%ae%8c%e5%91%bd%e4%bb%a4%e4%b9%8b%e5%90%8e%e8%ae%b0%e5%bd%95%e6%97%a5%e5%bf%97" aria-label="AOF 为什么是在执行完命令之后记录日志？">AOF 为什么是在执行完命令之后记录日志？</a></li>
                <li>
                    <a href="#aof-%e9%87%8d%e5%86%99%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="AOF 重写了解吗？">AOF 重写了解吗？</a></li>
                <li>
                    <a href="#aof-%e6%a0%a1%e9%aa%8c%e6%9c%ba%e5%88%b6%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="AOF 校验机制了解吗？">AOF 校验机制了解吗？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-40-%e5%af%b9%e4%ba%8e%e6%8c%81%e4%b9%85%e5%8c%96%e6%9c%ba%e5%88%b6%e5%81%9a%e4%ba%86%e4%bb%80%e4%b9%88%e4%bc%98%e5%8c%96" aria-label="Redis 4.0 对于持久化机制做了什么优化？">Redis 4.0 对于持久化机制做了什么优化？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9-rdb-%e5%92%8c-aof" aria-label="如何选择 RDB 和 AOF？">如何选择 RDB 和 AOF？</a></li></ul>
                </li>
                <li>
                    <a href="#redis%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87%e8%af%a6%e8%a7%a3" aria-label="Redis内存碎片详解">Redis内存碎片详解</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87" aria-label="什么是内存碎片?">什么是内存碎片?</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e6%9c%89-redis-%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87" aria-label="为什么会有 Redis 内存碎片?">为什么会有 Redis 内存碎片?</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e6%9f%a5%e7%9c%8b-redis-%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87%e7%9a%84%e4%bf%a1%e6%81%af" aria-label="如何查看 Redis 内存碎片的信息？">如何查看 Redis 内存碎片的信息？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e6%b8%85%e7%90%86-redis-%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87" aria-label="如何清理 Redis 内存碎片？">如何清理 Redis 内存碎片？</a></li></ul>
                </li>
                <li>
                    <a href="#redis%e5%b8%b8%e8%a7%81%e9%98%bb%e5%a1%9e%e5%8e%9f%e5%9b%a0%e6%80%bb%e7%bb%93" aria-label="Redis常见阻塞原因总结">Redis常见阻塞原因总结</a><ul>
                        
                <li>
                    <a href="#on-%e5%91%bd%e4%bb%a4" aria-label="O(n) 命令">O(n) 命令</a></li>
                <li>
                    <a href="#save-%e5%88%9b%e5%bb%ba-rdb-%e5%bf%ab%e7%85%a7" aria-label="SAVE 创建 RDB 快照">SAVE 创建 RDB 快照</a></li>
                <li>
                    <a href="#aof" aria-label="AOF">AOF</a><ul>
                        
                <li>
                    <a href="#aof-%e6%97%a5%e5%bf%97%e8%ae%b0%e5%bd%95%e9%98%bb%e5%a1%9e" aria-label="AOF 日志记录阻塞">AOF 日志记录阻塞</a></li>
                <li>
                    <a href="#aof-%e5%88%b7%e7%9b%98%e9%98%bb%e5%a1%9e" aria-label="AOF 刷盘阻塞">AOF 刷盘阻塞</a></li>
                <li>
                    <a href="#aof-%e9%87%8d%e5%86%99%e9%98%bb%e5%a1%9e" aria-label="AOF 重写阻塞">AOF 重写阻塞</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a4%a7-key" aria-label="大 Key">大 Key</a><ul>
                        
                <li>
                    <a href="#%e6%9f%a5%e6%89%be%e5%a4%a7-key" aria-label="查找大 key">查找大 key</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e5%a4%a7-key" aria-label="删除大 key">删除大 key</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%b8%85%e7%a9%ba%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="清空数据库">清空数据库</a></li>
                <li>
                    <a href="#%e9%9b%86%e7%be%a4%e6%89%a9%e5%ae%b9" aria-label="集群扩容">集群扩容</a></li>
                <li>
                    <a href="#swap%e5%86%85%e5%ad%98%e4%ba%a4%e6%8d%a2" aria-label="Swap（内存交换）">Swap（内存交换）</a></li>
                <li>
                    <a href="#cpu-%e7%ab%9e%e4%ba%89" aria-label="CPU 竞争">CPU 竞争</a></li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c%e9%97%ae%e9%a2%98" aria-label="网络问题">网络问题</a></li></ul>
                </li>
                <li>
                    <a href="#redis%e5%a4%a7key%e5%a4%84%e7%90%86" aria-label="redis大key处理">redis大key处理</a><ul>
                        
                <li>
                    <a href="#%e6%80%8e%e4%b9%88%e6%89%8d%e7%ae%97%e5%a4%a7key" aria-label="怎么才算大key">怎么才算大key</a></li>
                <li>
                    <a href="#%e5%a4%a7key%e7%9a%84%e5%bd%b1%e5%93%8d" aria-label="大KEY的影响">大KEY的影响</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%8f%91%e7%8e%b0%e5%a4%a7key" aria-label="如何发现大key">如何发现大key</a><ul>
                        
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8redis%e6%8f%90%e4%be%9b%e7%9a%84%e5%91%bd%e4%bb%a4" aria-label="使用redis提供的命令">使用redis提供的命令</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e7%ac%ac%e4%b8%89%e6%96%b9%e5%b7%a5%e5%85%b7" aria-label="使用第三方工具">使用第三方工具</a></li>
                <li>
                    <a href="#bash%e8%84%9a%e6%9c%ac" aria-label="bash脚本">bash脚本</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e5%a4%a7key%e9%97%ae%e9%a2%98" aria-label="如何解决大key问题">如何解决大key问题</a><ul>
                        
                <li>
                    <a href="#%e8%ae%be%e8%ae%a1%e9%98%b6%e6%ae%b5%e9%81%bf%e5%85%8d-big-key" aria-label="设计阶段避免 Big Key">设计阶段避免 Big Key</a></li>
                <li>
                    <a href="#%e4%bc%98%e5%8c%96-big-key-%e7%9a%84%e6%93%8d%e4%bd%9c" aria-label="优化 Big Key 的操作">优化 Big Key 的操作</a></li>
                <li>
                    <a href="#%e5%8e%86%e5%8f%b2key%e6%9c%aa%e4%bd%bf%e7%94%a8" aria-label="历史key未使用">历史key未使用</a></li>
                <li>
                    <a href="#%e5%85%83%e7%b4%a0%e6%95%b0%e8%bf%87%e5%a4%9a" aria-label="元素数过多">元素数过多</a></li>
                <li>
                    <a href="#%e5%a4%a7%e5%af%b9%e8%b1%a1%e8%bd%ac%e6%8d%a2%e5%ad%98%e5%82%a8%e5%bd%a2%e5%bc%8f" aria-label="大对象转换存储形式">大对象转换存储形式</a></li>
                <li>
                    <a href="#%e5%8e%8b%e7%bc%a9%e5%ad%98%e5%82%a8%e6%95%b0%e6%8d%ae" aria-label="压缩存储数据">压缩存储数据</a></li>
                <li>
                    <a href="#%e6%9b%bf%e6%8d%a2%e5%ad%98%e5%82%a8%e6%96%b9%e6%a1%88" aria-label="替换存储方案">替换存储方案</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93-2" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#redis-hotkey%e7%83%ad-key" aria-label="Redis hotkey（热 Key）">Redis hotkey（热 Key）</a><ul>
                        
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%ae%9a%e4%b9%89%e7%83%adkey" aria-label="如何定义热key">如何定义热key</a></li>
                <li>
                    <a href="#hotkey-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8d%b1%e5%ae%b3" aria-label="hotkey 有什么危害？">hotkey 有什么危害？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%8f%91%e7%8e%b0-hotkey" aria-label="如何发现 hotkey？">如何发现 hotkey？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3%e7%83%adkey" aria-label="如何解决热key">如何解决热key</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e4%b8%ad%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e7%bc%93%e5%ad%98%e4%b8%8e%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e6%95%b0%e6%8d%ae%e4%b8%80%e8%87%b4%e6%80%a7" aria-label="Redis 中如何保证缓存与数据库的数据一致性？">Redis 中如何保证缓存与数据库的数据一致性？</a></li>
                <li>
                    <a href="#redis%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81" aria-label="redis分布式锁">redis分布式锁</a><ul>
                        
                <li>
                    <a href="#redis%e5%ae%9e%e7%8e%b0%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e5%8f%af%e8%83%bd%e9%81%87%e5%88%b0%e7%9a%84%e9%97%ae%e9%a2%98" aria-label="redis实现分布式锁可能遇到的问题">redis实现分布式锁可能遇到的问题</a><ul>
                        
                <li>
                    <a href="#%e4%b8%9a%e5%8a%a1%e6%9c%aa%e6%89%a7%e8%a1%8c%e5%ae%8c%e9%94%81%e5%b7%b2%e5%88%b0%e6%9c%9f%e7%9c%8b%e9%97%a8%e7%8b%97%e8%87%aa%e5%8a%a8%e7%bb%ad%e6%9c%9f" aria-label="业务未执行完，锁已到期（看门狗自动续期）">业务未执行完，锁已到期（看门狗自动续期）</a></li>
                <li>
                    <a href="#%e8%a2%ab%e5%85%b6%e4%bb%96%e5%ae%a2%e6%88%b7%e7%ab%af%e8%a7%a3%e9%94%81%e5%bf%85%e9%a1%bb%e4%bd%bf%e7%94%a8%e5%94%af%e4%b8%80%e9%9a%8f%e6%9c%ba%e5%80%bc%e4%bd%9c%e4%b8%ba%e9%94%81%e7%9a%84%e5%80%bc%e5%bf%85%e9%a1%bb%e4%bd%bf%e7%94%a8lua%e8%84%9a%e6%9c%ac%e6%af%94%e8%be%83%e9%94%81%e7%9a%84%e5%80%bc%e5%90%8e%e5%86%8d%e5%88%a0%e9%99%a4%e8%a7%a3%e9%94%81" aria-label="被其他客户端解锁（必须使用唯一随机值作为锁的值，必须使用Lua脚本比较锁的值后再删除（解锁））">被其他客户端解锁（必须使用唯一随机值作为锁的值，必须使用Lua脚本比较锁的值后再删除（解锁））</a></li>
                <li>
                    <a href="#%e5%8d%95%e7%82%b9%e6%95%85%e9%9a%9c%e9%97%ae%e9%a2%98" aria-label="单点故障问题">单点故障问题</a></li>
                <li>
                    <a href="#%e9%9d%9e%e5%8e%9f%e5%ad%90%e6%80%a7%e7%9a%84%e5%8a%a0%e9%94%81%e6%93%8d%e4%bd%9c%e5%bf%85%e9%a1%bb%e4%bd%bf%e7%94%a8%e5%b8%a6%e8%bf%87%e6%9c%9f%e6%97%b6%e9%97%b4px%e7%9a%84%e5%8e%9f%e5%ad%90set-nx%e5%91%bd%e4%bb%a4%e8%bf%9b%e8%a1%8c%e5%8a%a0%e9%94%81" aria-label="非原子性的加锁操作（必须使用带过期时间(PX)的原子SET NX命令进行加锁​）">非原子性的加锁操作（必须使用带过期时间(PX)的原子SET NX命令进行加锁​）</a></li>
                <li>
                    <a href="#%e4%b8%bb%e4%bb%8e%e9%97%ae%e9%a2%98" aria-label="主从问题">主从问题</a></li>
                <li>
                    <a href="#%e9%94%81%e7%9a%84%e7%ab%9e%e4%ba%89%e4%b8%8e%e5%ae%a2%e6%88%b7%e7%ab%af%e7%ad%89%e5%be%85" aria-label="锁的竞争与客户端等待">锁的竞争与客户端等待</a></li>
                <li>
                    <a href="#%e9%94%81%e7%9a%84%e9%87%8d%e5%85%a5%e6%80%a7reentrancy" aria-label="锁的重入性（Reentrancy）">锁的重入性（Reentrancy）</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e9%94%81%e5%9c%a8%e6%9c%aa%e5%ae%8c%e6%88%90%e9%80%bb%e8%be%91%e5%89%8d%e8%bf%87%e6%9c%9f%e6%80%8e%e4%b9%88%e5%8a%9e" aria-label="分布式锁在未完成逻辑前过期怎么办？">分布式锁在未完成逻辑前过期怎么办？</a><ul>
                        
                <li>
                    <a href="#%e5%a6%82%e6%9e%9c%e8%8e%b7%e5%8f%96%e9%94%81%e7%9a%84%e5%ae%a2%e6%88%b7%e7%ab%af%e6%8c%82%e4%ba%86%e6%80%8e%e4%b9%88%e5%8a%9e" aria-label="如果获取锁的客户端挂了怎么办？">如果获取锁的客户端挂了怎么办？</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-redis-%e5%bf%ab%e9%80%9f%e5%ae%9e%e7%8e%b0%e6%8e%92%e8%a1%8c%e6%a6%9c" aria-label="如何使用 Redis 快速实现排行榜？">如何使用 Redis 快速实现排行榜？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-redis-%e7%bb%9f%e8%ae%a1%e5%a4%a7%e9%87%8f%e7%94%a8%e6%88%b7%e5%94%af%e4%b8%80%e8%ae%bf%e9%97%ae%e9%87%8fuv" aria-label="如何使用 Redis 统计大量用户唯一访问量（UV）？">如何使用 Redis 统计大量用户唯一访问量（UV）？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%9c%a8-redis-%e4%b8%ad%e5%ae%9e%e7%8e%b0%e9%98%9f%e5%88%97%e5%92%8c%e6%a0%88%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="如何在 Redis 中实现队列和栈数据结构？">如何在 Redis 中实现队列和栈数据结构？</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="概述">概述<a hidden class="anchor" aria-hidden="true" href="#概述">#</a></h1>
<p><a href="https://redis.io/">Redis</a> 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。</p>
<p>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</p>
<p>Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。</p>
<p>个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的<a href="https://try.redis.io/">在线 Redis 环境</a>（少部分命令无法使用）来实际体验 Redis。</p>
<h2 id="redis-为什么这么快">Redis 为什么这么快？<a hidden class="anchor" aria-hidden="true" href="#redis-为什么这么快">#</a></h2>
<p>Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：</p>
<ol>
<li>Redis 基于内存，内存的访问速度是磁盘的上千倍；</li>
<li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用；</li>
<li>Redis 内置了多种优化过后的数据结构实现，性能非常高。</li>
</ol>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/why-redis-so-fast-d3507ae8.png"></p>
<h2 id="为什么要用-redis为什么要用缓存">为什么要用 Redis/为什么要用缓存？<a hidden class="anchor" aria-hidden="true" href="#为什么要用-redis为什么要用缓存">#</a></h2>
<p>下面我们主要从“高性能”和“高并发”这两点来回答这个问题。</p>
<p><strong>1、高性能</strong></p>
<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p>
<p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p>
<p><strong>2、高并发</strong></p>
<p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p>
<blockquote>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p>
</blockquote>
<p>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p>
<h1 id="redis-应用场景">Redis 应用场景<a hidden class="anchor" aria-hidden="true" href="#redis-应用场景">#</a></h1>
<ul>
<li><strong>缓存</strong>：Redis 最常用的场景是作为缓存层，以减少数据库的负载，提高数据读取速度。</li>
<li><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</li>
<li><strong>实时系统</strong>：网站点击统计、实时排行榜（sorted set）。</li>
<li><strong>计数器</strong>：- Redis 的原子性操作非常适合用作计数器。例如，可以使用 Redis 来统计页面访问量、点赞数、评论数等。通过 INCR 命令可以轻松实现高效的计数。</li>
<li><strong>限流</strong>：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：<a href="https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA">《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》</a>。</li>
</ul>
<p>其他（不常用）：</p>
<ul>
<li><strong>消息队列</strong>：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>
<li><strong>延时队列</strong>：Redisson 内置了延时队列（基于 sorted set 实现的）。</li>
<li><strong>分布式 Session</strong> ：利用 string 或者 hash 保存 Session 数据，所有的服务器都可以访问。</li>
<li><strong>复杂业务场景</strong>：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li>
</ul>
<h2 id="redis-可以做消息队列么">Redis 可以做消息队列么？<a hidden class="anchor" aria-hidden="true" href="#redis-可以做消息队列么">#</a></h2>
<blockquote>
<p>实际项目中也没见谁使用 Redis 来做消息队列，对于这部分知识点大家了解就好了。</p>
</blockquote>
<p>先说结论：可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。</p>
<p><strong>Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现。</strong></p>
<p>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>即可实现简易版消息队列：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 生产者生产消息</span>
</span></span><span style="display:flex;"><span>&gt; RPUSH myList msg1 msg2
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>&gt; RPUSH myList msg3
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 消费者消费消息</span>
</span></span><span style="display:flex;"><span>&gt; LPOP myList
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;msg1&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过，通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>这样的方式存在性能问题，我们需要不断轮询去调用 <code>RPOP</code> 或 <code>LPOP</code> 来消费消息。当 List 为空时，大部分的轮询的请求都是无效请求，这种方式大量浪费了系统资源。</p>
<p>因此，Redis 还提供了 <code>BLPOP</code>、<code>BRPOP</code> 这种阻塞式读取的命令（带 B-Bloking 的都是阻塞式），并且还支持一个超时参数。如果 List 为空，Redis 服务端不会立刻返回结果，它会等待 List 中有新数据后在返回或者是等待最多一个超时时间后返回空。如果将超时时间设置为 0 时，即可无限等待，直到弹出消息</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 超时时间为 10s</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 如果有数据立刻返回，否则最多等待10秒</span>
</span></span><span style="display:flex;"><span>&gt; BRPOP myList <span style="color:#ff0;font-weight:bold">10</span>
</span></span><span style="display:flex;"><span>null
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。</strong></p>
<p><strong>Redis 2.0 引入了发布订阅 (pub/sub) 功能，解决了 List 实现消息队列没有广播机制的问题。</strong></p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-pub-sub.png"></p>
<p>pub/sub 中引入了一个概念叫 <strong>channel（频道）</strong>，发布订阅机制的实现就是基于这个 channel 来做的。</p>
<p>pub/sub 涉及发布者（Publisher）和订阅者（Subscriber，也叫消费者）两个角色：</p>
<ul>
<li>发布者通过 <code>PUBLISH</code> 投递消息给指定 channel。</li>
<li>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。</li>
</ul>
<p>我们这里启动 3 个 Redis 客户端来简单演示一下：</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-pubsub-message-queue.png"></p>
<p>pub/sub 既能单播又能广播，还支持 channel 的简单正则匹配。不过，消息丢失（客户端断开连接或者 Redis 宕机都会导致消息丢失）、消息堆积（发布者发布消息的时候不会管消费者的具体消费能力如何）等问题依然没有一个比较好的解决办法。</p>
<p>为此，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 来做消息队列。<code>Stream</code> 支持：</p>
<ul>
<li>发布 / 订阅模式</li>
<li>按照消费者组进行消费</li>
<li>消息持久化（ RDB 和 AOF）</li>
</ul>
<p><code>Stream</code> 使用起来相对要麻烦一些，这里就不演示了。而且，<code>Stream</code> 在实际使用中依然会有一些小问题不太好解决比如在 Redis 发生故障恢复后不能保证消息至少被消费一次。</p>
<p>综上，和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议不要使用 Redis 来做消息队列，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p>
<p>相关阅读：<a href="https://mp.weixin.qq.com/s/gCUT5TcCQRAxYkTJfTRjJw">Redis 消息队列发展历程 - 阿里开发者 - 2022</a>。</p>
<h1 id="redis-数据结构">Redis 数据结构<a hidden class="anchor" aria-hidden="true" href="#redis-数据结构">#</a></h1>
<blockquote>
<p>关于 Redis 5 种基础数据结构和 3 种特殊数据结构的详细介绍请看下面这两篇文章：</p>
<ul>
<li><a href="https://javaguide.cn/database/redis/redis-data-structures-01.html">Redis 5 种基本数据结构详解</a></li>
<li><a href="https://javaguide.cn/database/redis/redis-data-structures-02.html">Redis 3 种特殊数据结构详解</a></li>
</ul>
</blockquote>
<h2 id="redis-常用的数据结构有哪些">Redis 常用的数据结构有哪些？<a hidden class="anchor" aria-hidden="true" href="#redis-常用的数据结构有哪些">#</a></h2>
<ul>
<li><strong>5 种基础数据结构</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>
<li><strong>3 种特殊数据结构</strong>：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li>
</ul>
<h2 id="string-的应用场景有哪些">String 的应用场景有哪些？<a hidden class="anchor" aria-hidden="true" href="#string-的应用场景有哪些">#</a></h2>
<p>String 是 Redis 中最简单同时也是最常用的一个数据结构。String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>
<p>String 的常见应用场景如下：</p>
<ul>
<li>常规数据（比如 session、token、序列化后的对象、图片的路径）的缓存；</li>
<li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li>
<li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li>
<li>&hellip;&hellip;</li>
</ul>
<p>关于 String 的详细介绍请看这篇文章：<a href="https://javaguide.cn/database/redis/redis-data-structures-01.html">Redis 5 种基本数据结构详解</a>。</p>
<h2 id="string-还是-hash-存储对象数据更好呢">String 还是 Hash 存储对象数据更好呢？<a hidden class="anchor" aria-hidden="true" href="#string-还是-hash-存储对象数据更好呢">#</a></h2>
<ul>
<li>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li>
<li>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li>
</ul>
<p>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</p>
<h2 id="string-的底层实现是什么">String 的底层实现是什么？<a hidden class="anchor" aria-hidden="true" href="#string-的底层实现是什么">#</a></h2>
<p>Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 <code>\0</code> 结尾的字符数组），而是自己编写了 <a href="https://github.com/antirez/sds">SDS</a>（Simple Dynamic String，简单动态字符串） 来作为底层实现。</p>
<p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。</p>
<p>Redis7.0 的 SDS 的部分源码如下（https://github.com/redis/redis/blob/7.0/src/sds.h）：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#007f7f">/* Note: sdshdr5 is never used, we just access the flags byte directly.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * However is here to document the layout of type 5 SDS strings. */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> __attribute__ ((__packed__)) sdshdr5 {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> flags; <span style="color:#007f7f">/* 3 lsb of type, and 5 msb of string length */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> __attribute__ ((__packed__)) sdshdr8 {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint8_t</span> len; <span style="color:#007f7f">/* used */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint8_t</span> alloc; <span style="color:#007f7f">/* excluding the header and null terminator */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> flags; <span style="color:#007f7f">/* 3 lsb of type, 5 unused bits */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> __attribute__ ((__packed__)) sdshdr16 {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint16_t</span> len; <span style="color:#007f7f">/* used */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint16_t</span> alloc; <span style="color:#007f7f">/* excluding the header and null terminator */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> flags; <span style="color:#007f7f">/* 3 lsb of type, 5 unused bits */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> __attribute__ ((__packed__)) sdshdr32 {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint32_t</span> len; <span style="color:#007f7f">/* used */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint32_t</span> alloc; <span style="color:#007f7f">/* excluding the header and null terminator */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> flags; <span style="color:#007f7f">/* 3 lsb of type, 5 unused bits */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> __attribute__ ((__packed__)) sdshdr64 {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint64_t</span> len; <span style="color:#007f7f">/* used */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint64_t</span> alloc; <span style="color:#007f7f">/* excluding the header and null terminator */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> flags; <span style="color:#007f7f">/* 3 lsb of type, 5 unused bits */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>位</th>
</tr>
</thead>
<tbody>
<tr>
<td>sdshdr5</td>
<td>&lt; 1</td>
<td>&lt;8</td>
</tr>
<tr>
<td>sdshdr8</td>
<td>1</td>
<td>8</td>
</tr>
<tr>
<td>sdshdr16</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>sdshdr32</td>
<td>4</td>
<td>32</td>
</tr>
<tr>
<td>sdshdr64</td>
<td>8</td>
<td>64</td>
</tr>
</tbody>
</table>
<p>对于后四种实现都包含了下面这 4 个属性：</p>
<ul>
<li><code>len</code>：字符串的长度也就是已经使用的字节数</li>
<li><code>alloc</code>：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小</li>
<li><code>buf[]</code>：实际存储字符串的数组</li>
<li><code>flags</code>：低三位保存类型标志</li>
</ul>
<p>SDS 相比于 C 语言中的字符串有如下提升：</p>
<ol>
<li><strong>可以避免缓冲区溢出</strong>：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li>
<li><strong>获取字符串长度的复杂度较低</strong>：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li>
<li><strong>减少内存分配次数</strong>：为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li>
<li><strong>二进制安全</strong>：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li>
</ol>
<p>🤐 多提一嘴，很多文章里 SDS 的定义是下面这样的：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> sdshdr {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> len;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> free;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，<code>len</code> 和 <code>free</code> 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。</p>
<h2 id="购物车信息用-string-还是-hash-存储更好呢">购物车信息用 String 还是 Hash 存储更好呢?<a hidden class="anchor" aria-hidden="true" href="#购物车信息用-string-还是-hash-存储更好呢">#</a></h2>
<p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p>
<ul>
<li>用户 id 为 key</li>
<li>商品 id 为 field，商品数量为 value</li>
</ul>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/hash-shopping-cart.png"></p>
<p>那用户购物车信息的维护具体应该怎么操作呢？</p>
<ul>
<li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li>
<li>查询购物车信息就是遍历对应的 Hash；</li>
<li>更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li>
<li>删除商品就是删除 Hash 中对应的 field；</li>
<li>清空购物车直接删除对应的 key 即可。</li>
</ul>
<p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p>
<h2 id="使用-redis-实现一个排行榜怎么做">使用 Redis 实现一个排行榜怎么做？<a hidden class="anchor" aria-hidden="true" href="#使用-redis-实现一个排行榜怎么做">#</a></h2>
<p>Redis 中有一个叫做 <code>sorted set</code> 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p>
<p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p>
<h2 id="set-的应用场景是什么">Set 的应用场景是什么？<a hidden class="anchor" aria-hidden="true" href="#set-的应用场景是什么">#</a></h2>
<p>Redis 中 <code>Set</code> 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。</p>
<p>Set 的常见应用场景如下：</p>
<ul>
<li>存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等等。</li>
<li>需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。</li>
<li>需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。</li>
</ul>
<h2 id="使用-set-实现抽奖系统怎么做">使用 Set 实现抽奖系统怎么做？<a hidden class="anchor" aria-hidden="true" href="#使用-set-实现抽奖系统怎么做">#</a></h2>
<p>如果想要使用 Set 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：</p>
<ul>
<li><code>SADD key member1 member2 ...</code>：向指定集合添加一个或多个元素。</li>
<li><code>SPOP key count</code>：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li>
<li><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li>
</ul>
<h2 id="使用-bitmap-统计活跃用户怎么做">使用 Bitmap 统计活跃用户怎么做？<a hidden class="anchor" aria-hidden="true" href="#使用-bitmap-统计活跃用户怎么做">#</a></h2>
<p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p>
<p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p>
<p>如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</p>
<p>初始化数据：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SETBIT <span style="color:#ff0;font-weight:bold">20210308</span> <span style="color:#ff0;font-weight:bold">1</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; SETBIT <span style="color:#ff0;font-weight:bold">20210308</span> <span style="color:#ff0;font-weight:bold">2</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; SETBIT <span style="color:#ff0;font-weight:bold">20210309</span> <span style="color:#ff0;font-weight:bold">1</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>统计 20210308~20210309 总活跃用户数:</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; BITOP and desk1 <span style="color:#ff0;font-weight:bold">20210308</span> <span style="color:#ff0;font-weight:bold">20210309</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; BITCOUNT desk1
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>统计 20210308~20210309 在线活跃用户数:</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; BITOP or desk2 <span style="color:#ff0;font-weight:bold">20210308</span> <span style="color:#ff0;font-weight:bold">20210309</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; BITCOUNT desk2
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="使用-hyperloglog-统计页面-uv-怎么做">使用 HyperLogLog 统计页面 UV 怎么做？<a hidden class="anchor" aria-hidden="true" href="#使用-hyperloglog-统计页面-uv-怎么做">#</a></h2>
<p>使用 HyperLogLog 统计页面 UV 主要需要用到下面这两个命令：</p>
<ul>
<li><code>PFADD key element1 element2 ...</code>：添加一个或多个元素到 HyperLogLog 中。</li>
<li><code>PFCOUNT key1 key2</code>：获取一个或者多个 HyperLogLog 的唯一计数。</li>
</ul>
<p>1、将访问指定页面的每个用户 ID 添加到 <code>HyperLogLog</code> 中。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>PFADD PAGE_1:UV USER1 USER2 ...... USERn
</span></span></code></pre></td></tr></table>
</div>
</div><p>2、统计指定页面的 UV。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>PFCOUNT PAGE_1:UV
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="redis-线程模型重要">Redis 线程模型（重要）<a hidden class="anchor" aria-hidden="true" href="#redis-线程模型重要">#</a></h1>
<p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p>
<h2 id="redis-单线程模型了解吗">Redis 单线程模型了解吗？<a hidden class="anchor" aria-hidden="true" href="#redis-单线程模型了解吗">#</a></h2>
<p><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p>
<p>《Redis 设计与实现》有一段话是如是介绍文件事件处理器的，我觉得写得挺不错。</p>
<blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
</blockquote>
<p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>
<p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p>
<p>这样的好处非常明显：<strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p>
<p>文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<h2 id="redis60-之前为什么不使用多线程">Redis6.0 之前为什么不使用多线程？<a hidden class="anchor" aria-hidden="true" href="#redis60-之前为什么不使用多线程">#</a></h2>
<p>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p>
<p>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。</p>
<p>为此，Redis 4.0 之后新增了<code>UNLINK</code>（可以看作是 <code>DEL</code> 的异步版本）、<code>FLUSHALL ASYNC</code>（清空所有数据库的所有 key，不仅仅是当前 <code>SELECT</code> 的数据库）、<code>FLUSHDB ASYNC</code>（清空当前 <code>SELECT</code> 数据库中的所有 key）等异步命令。</p>
<p>大体上来说，Redis 6.0 之前主要还是单线程处理。</p>
<p><strong>那 Redis6.0 之前为什么不使用多线程？</strong> 我觉得主要原因有 3 点：</p>
<ul>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ul>
<h2 id="redis60-之后为何引入了多线程">Redis6.0 之后为何引入了多线程？<a hidden class="anchor" aria-hidden="true" href="#redis60-之后为何引入了多线程">#</a></h2>
<p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>
<p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置 IO 线程数 &gt; 1，需要修改 redis 配置文件 <code>redis.conf</code>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>io-threads <span style="color:#ff0;font-weight:bold">4</span> <span style="color:#007f7f">#设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外：</p>
<ul>
<li>io-threads 的个数一旦设置，不能通过 config 动态设置。</li>
<li>当设置 ssl 后，io-threads 将不工作。</li>
</ul>
<p>开启多线程后，默认只会使用多线程进行 IO 写入 writes，即发送数据给客户端，如果需要开启多线程 IO 读取 reads，同样需要修改 redis 配置文件 <code>redis.conf</code> :</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>io-threads-do-reads yes
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启</p>
<h2 id="redis-后台线程了解吗">Redis 后台线程了解吗？<a hidden class="anchor" aria-hidden="true" href="#redis-后台线程了解吗">#</a></h2>
<p>我们虽然经常说 Redis 是单线程模型（主要逻辑是单线程完成的），但实际还有一些后台线程用于执行一些比较耗时的操作：</p>
<ul>
<li>通过 <code>bio_close_file</code> 后台线程来释放 AOF / RDB 等过程中产生的临时文件资源。</li>
<li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。</li>
<li>通过 <code>bio_lazy_free</code>后台线程释放大对象（已删除）占用的内存空间.</li>
</ul>
<p>在<code>bio.h</code> 文件中有定义（Redis 6.0 版本，源码地址：https://github.com/redis/redis/blob/6.0/src/bio.h）：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f00">#</span>ifndef __BIO_H
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>define __BIO_H
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* Exported API */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> bioInit(<span style="color:#fff;font-weight:bold">void</span>);
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> bioCreateBackgroundJob(<span style="color:#fff;font-weight:bold">int</span> type, <span style="color:#fff;font-weight:bold">void</span> *arg1, <span style="color:#fff;font-weight:bold">void</span> *arg2, <span style="color:#fff;font-weight:bold">void</span> *arg3);
</span></span><span style="display:flex;"><span>unsigned <span style="color:#fff;font-weight:bold">long</span> <span style="color:#fff;font-weight:bold">long</span> bioPendingJobsOfType(<span style="color:#fff;font-weight:bold">int</span> type);
</span></span><span style="display:flex;"><span>unsigned <span style="color:#fff;font-weight:bold">long</span> <span style="color:#fff;font-weight:bold">long</span> bioWaitStepOfType(<span style="color:#fff;font-weight:bold">int</span> type);
</span></span><span style="display:flex;"><span>time_t bioOlderJobOfType(<span style="color:#fff;font-weight:bold">int</span> type);
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> bioKillThreads(<span style="color:#fff;font-weight:bold">void</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* Background job opcodes */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>define BIO_CLOSE_FILE    0 <span style="color:#007f7f">/* Deferred close(2) syscall. */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>define BIO_AOF_FSYNC     1 <span style="color:#007f7f">/* Deferred AOF fsync. */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>define BIO_LAZY_FREE     2 <span style="color:#007f7f">/* Deferred objects freeing. */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>define BIO_NUM_OPS       3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>endif
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="redis-内存管理">Redis 内存管理<a hidden class="anchor" aria-hidden="true" href="#redis-内存管理">#</a></h1>
<h2 id="redis-给缓存数据设置过期时间有啥用">Redis 给缓存数据设置过期时间有啥用？<a hidden class="anchor" aria-hidden="true" href="#redis-给缓存数据设置过期时间有啥用">#</a></h2>
<p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p>
<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p>
<p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>127.0.0.1:6379&gt; expire key <span style="color:#ff0;font-weight:bold">60</span> <span style="color:#007f7f"># 数据在 60s 后过期</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; setex key <span style="color:#ff0;font-weight:bold">60</span> value <span style="color:#007f7f"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; ttl key <span style="color:#007f7f"># 查看数据还有多久过期</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">56</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：<strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h2 id="redis-是如何判断数据是否过期的呢">Redis 是如何判断数据是否过期的呢？<a hidden class="anchor" aria-hidden="true" href="#redis-是如何判断数据是否过期的呢">#</a></h2>
<p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-expired-dictionary.png"></p>
<p>过期字典是存储在 redisDb 这个结构里的：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span> redisDb {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    dict *dict;     <span style="color:#007f7f">//数据库键空间,保存着数据库中所有键值对
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    dict *expires   <span style="color:#007f7f">// 过期字典,保存着键的过期时间
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    ...
</span></span><span style="display:flex;"><span>} redisDb;
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="过期的数据的删除策略了解么">过期的数据的删除策略了解么？<a hidden class="anchor" aria-hidden="true" href="#过期的数据的删除策略了解么">#</a></h2>
<p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p>
<p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>
<ol>
<li><strong>惰性删除</strong>：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong>：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p>
<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>
<p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p>
<h2 id="redis-内存淘汰机制了解么">Redis 内存淘汰机制了解么？<a hidden class="anchor" aria-hidden="true" href="#redis-内存淘汰机制了解么">#</a></h2>
<blockquote>
<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p>
</blockquote>
<p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰。</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中任意选择数据淘汰。</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</li>
<li><strong>allkeys-random</strong>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li>
</ol>
<h1 id="redis-事务">Redis 事务<a hidden class="anchor" aria-hidden="true" href="#redis-事务">#</a></h1>
<h2 id="什么是-redis-事务">什么是 Redis 事务？<a hidden class="anchor" aria-hidden="true" href="#什么是-redis-事务">#</a></h2>
<p>你可以将 Redis 中的事务理解为：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<p>Redis 事务实际开发中使用的非常少，功能比较鸡肋，不要将其和我们平时理解的关系型数据库的事务混淆了。</p>
<p>除了不满足原子性和持久性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。</p>
<p>因此，Redis 事务是不建议在日常开发中使用的。</p>
<h2 id="如何使用-redis-事务">如何使用 Redis 事务？<a hidden class="anchor" aria-hidden="true" href="#如何使用-redis-事务">#</a></h2>
<p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(Transaction)功能。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; MULTI
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide&#34;</span>
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; GET PROJECT
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; EXEC
</span></span><span style="display:flex;"><span>1) OK
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;JavaGuide&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://redis.io/commands/multi"><code>MULTI</code></a> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href="https://redis.io/commands/exec"><code>EXEC</code></a> 命令后，再执行所有的命令。</p>
<p>这个过程是这样的：</p>
<ol>
<li>开始事务（<code>MULTI</code>）；</li>
<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</li>
<li>执行事务(<code>EXEC</code>)。</li>
</ol>
<p>你也可以通过 <a href="https://redis.io/commands/discard"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; MULTI
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide&#34;</span>
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; GET PROJECT
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; DISCARD
</span></span><span style="display:flex;"><span>OK
</span></span></code></pre></td></tr></table>
</div>
</div><p>你可以通过<a href="https://redis.io/commands/watch"><code>WATCH</code></a> 命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 <strong>其他客户端/Session</strong> 修改的话，整个事务都不会被执行。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 客户端 1</span>
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;RustGuide&#34;</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; WATCH PROJECT
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; MULTI
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide&#34;</span>
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 客户端 2</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值</span>
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;GoGuide&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 客户端 1</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 修改失败，因为 PROJECT 的值被客户端2修改了</span>
</span></span><span style="display:flex;"><span>&gt; EXEC
</span></span><span style="display:flex;"><span>(nil)
</span></span><span style="display:flex;"><span>&gt; GET PROJECT
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;GoGuide&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过，如果 <strong>WATCH</strong> 与 <strong>事务</strong> 在同一个 Session 里，并且被 <strong>WATCH</strong> 监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的（相关 issue：<a href="https://github.com/Snailclimb/JavaGuide/issues/1714">WATCH 命令碰到 MULTI 命令时的不同效果</a>）。</p>
<p>事务内部修改 WATCH 监视的 Key：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide&#34;</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; WATCH PROJECT
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; MULTI
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide1&#34;</span>
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide2&#34;</span>
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide3&#34;</span>
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; EXEC
</span></span><span style="display:flex;"><span>1) OK
</span></span><span style="display:flex;"><span>2) OK
</span></span><span style="display:flex;"><span>3) OK
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; GET PROJECT
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;JavaGuide3&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>事务外部修改 WATCH 监视的 Key：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide&#34;</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; WATCH PROJECT
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide2&#34;</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; MULTI
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; GET USER
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; EXEC
</span></span><span style="display:flex;"><span>(nil)
</span></span></code></pre></td></tr></table>
</div>
</div><p>Redis 官网相关介绍 <a href="https://redis.io/topics/transactions">https://redis.io/topics/transactions</a></p>
<h2 id="redis-事务支持原子性吗">Redis 事务支持原子性吗？<a hidden class="anchor" aria-hidden="true" href="#redis-事务支持原子性吗">#</a></h2>
<p>Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性：<strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p>
<ol>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
</ol>
<p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的。</p>
<p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-rollback.png"></p>
<h2 id="redis-事务支持持久性吗">Redis 事务支持持久性吗？<a hidden class="anchor" aria-hidden="true" href="#redis-事务支持持久性吗">#</a></h2>
<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p>
<ul>
<li>快照（snapshotting，RDB）</li>
<li>只追加文件（append-only file, AOF）</li>
<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>
</ul>
<p>与 RDB 持久化相比，AOF 持久化的实时性更好。在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>appendfsync always    <span style="color:#007f7f">#每次有数据修改发生时都会调用fsync函数同步AOF文件,fsync完成后线程返回,这样会严重降低Redis的速度</span>
</span></span><span style="display:flex;"><span>appendfsync everysec  <span style="color:#007f7f">#每秒钟调用fsync函数同步一次AOF文件</span>
</span></span><span style="display:flex;"><span>appendfsync no        <span style="color:#007f7f">#让操作系统决定何时进行同步，一般为30秒一次</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>AOF 持久化的<code>fsync</code>策略为 no、everysec 时都会存在数据丢失的情况 。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。</p>
<p>因此，Redis 事务的持久性也是没办法保证的。</p>
<h2 id="如何解决-redis-事务的缺陷">如何解决 Redis 事务的缺陷？<a hidden class="anchor" aria-hidden="true" href="#如何解决-redis-事务的缺陷">#</a></h2>
<p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</p>
<p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</p>
<p>不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， <strong>严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</strong></p>
<p>如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。</p>
<p>另外，Redis 7.0 新增了 <a href="https://redis.io/docs/manual/programmability/functions-intro/">Redis functions</a> 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。</p>
<h1 id="redis-性能优化重要">Redis 性能优化（重要）<a hidden class="anchor" aria-hidden="true" href="#redis-性能优化重要">#</a></h1>
<p>除了下面介绍的内容之外，再推荐两篇不错的文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/nNEuYw0NlYGhuKKKKoWfcQ">你的 Redis 真的变慢了吗？性能优化如何做 - 阿里开发者</a></li>
<li><a href="https://javaguide.cn/database/redis/redis-common-blocking-problems-summary.html">Redis 常见阻塞原因总结 - JavaGuide</a></li>
</ul>
<h2 id="使用批量操作减少网络传输">使用批量操作减少网络传输<a hidden class="anchor" aria-hidden="true" href="#使用批量操作减少网络传输">#</a></h2>
<p>一个 Redis 命令的执行可以简化为以下 4 步：</p>
<ol>
<li>发送命令</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ol>
<p>其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是数据在网络上传输的时间。</p>
<p>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。</p>
<p>另外，除了能减少 RTT 之外，发送一次命令的 socket I/O 成本也比较高（涉及上下文切换，存在<code>read()</code>和<code>write()</code>系统调用），批量操作还可以减少 socket I/O 成本。这个在官方对 pipeline 的介绍中有提到：https://redis.io/docs/manual/pipelining/ 。</p>
<h3 id="原生批量操作命令">原生批量操作命令<a hidden class="anchor" aria-hidden="true" href="#原生批量操作命令">#</a></h3>
<p>Redis 中有一些原生支持批量操作的命令，比如：</p>
<ul>
<li><code>MGET</code>(获取一个或多个指定 key 的值)、<code>MSET</code>(设置一个或多个指定 key 的值)、</li>
<li><code>HMGET</code>(获取指定哈希表中一个或者多个指定字段的值)、<code>HMSET</code>(同时将一个或多个 field-value 对设置到指定哈希表中)、</li>
<li><code>SADD</code>（向指定集合添加一个或多个元素）</li>
<li>&hellip;&hellip;</li>
</ul>
<p>不过，在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，使用这些原生批量操作命令可能会存在一些小问题需要解决。就比如说 <code>MGET</code> 无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上，<code>MGET</code>可能还是需要多次网络传输，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。</p>
<p>整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：</p>
<ol>
<li>找到 key 对应的所有 hash slot；</li>
<li>分别向对应的 Redis 节点发起 <code>MGET</code> 请求获取数据；</li>
<li>等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。</li>
</ol>
<p>如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。</p>
<blockquote>
<p>Redis Cluster 并没有使用一致性哈希，采用的是 <strong>哈希槽分区</strong> ，每一个键值对都属于一个 <strong>hash slot</strong>（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。</p>
<p>我在 <a href="https://javaguide.cn/database/redis/redis-cluster.html">Redis 集群详解（付费）</a> 这篇文章中详细介绍了 Redis Cluster 这部分的内容，感兴趣地可以看看。</p>
</blockquote>
<h3 id="pipeline">pipeline<a hidden class="anchor" aria-hidden="true" href="#pipeline">#</a></h3>
<p>对于不支持批量操作的命令，我们可以利用 <strong>pipeline（流水线)</strong> 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。不过，需要注意控制一次批量操作的 <strong>元素个数</strong>(例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。</p>
<p>与<code>MGET</code>、<code>MSET</code>等原生批量操作命令一样，pipeline 同样在 Redis Cluster 上使用会存在一些小问题。原因类似，无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。</p>
<p>原生批量操作命令和 pipeline 的是有区别的，使用的时候需要注意：</p>
<ul>
<li>原生批量操作命令是原子操作，pipeline 是非原子操作。</li>
<li>pipeline 可以打包不同的命令，原生批量操作命令不可以。</li>
<li>原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。</li>
</ul>
<p>顺带补充一下 pipeline 和 Redis 事务的对比：</p>
<ul>
<li>事务是原子操作，pipeline 是非原子操作。两个不同的事务不会同时运行，而 pipeline 可以同时以交错方式执行。</li>
<li>Redis 事务中每个命令都需要发送到服务端，而 Pipeline 只需要发送一次，请求次数更少。</li>
</ul>
<blockquote>
<p>事务可以看作是一个原子操作，但其实并不满足原子性。当我们提到 Redis 中的原子操作时，主要指的是这个操作（比如事务、Lua 脚本）不会被其他操作（比如其他事务、Lua 脚本）打扰，并不能完全保证这个操作中的所有写命令要么都执行要么都不执行。这主要也是因为 Redis 是不支持回滚操作。</p>
</blockquote>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-pipeline-vs-transaction.png"></p>
<p>另外，pipeline 不适用于执行顺序有依赖关系的一批命令。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 <strong>Lua 脚本</strong> 。</p>
<h3 id="lua-脚本">Lua 脚本<a hidden class="anchor" aria-hidden="true" href="#lua-脚本">#</a></h3>
<p>Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是 <strong>原子操作</strong> 。也就是说，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。</p>
<p>并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。</p>
<p>不过， Lua 脚本依然存在下面这些缺陷：</p>
<ul>
<li>如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。</li>
<li>Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。</li>
</ul>
<h2 id="大量-key-集中过期问题">大量 key 集中过期问题<a hidden class="anchor" aria-hidden="true" href="#大量-key-集中过期问题">#</a></h2>
<p>对于过期 key，Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 策略。</p>
<p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p>
<p><strong>如何解决呢？</strong> 下面是两种常见的方法：</p>
<ol>
<li>给 key 设置随机过期时间。</li>
<li>开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>
</ol>
<p>个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</p>
<h2 id="慢查询命令">慢查询命令<a hidden class="anchor" aria-hidden="true" href="#慢查询命令">#</a></h2>
<h3 id="为什么会有慢查询命令">为什么会有慢查询命令？<a hidden class="anchor" aria-hidden="true" href="#为什么会有慢查询命令">#</a></h3>
<p>我们知道一个 Redis 命令的执行可以简化为以下 4 步：</p>
<ol>
<li>发送命令</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ol>
<p>Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。</p>
<p>Redis 为什么会有慢查询命令呢？</p>
<p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：</p>
<ul>
<li><code>KEYS *</code>：会返回所有符合规则的 key。</li>
<li><code>HGETALL</code>：会返回一个 Hash 中所有的键值对。</li>
<li><code>LRANGE</code>：会返回 List 中指定范围内的元素。</li>
<li><code>SMEMBERS</code>：返回 Set 中的所有元素。</li>
<li><code>SINTER</code>/<code>SUNION</code>/<code>SDIFF</code>：计算多个 Set 的交集/并集/差集。</li>
<li>&hellip;&hellip;</li>
</ul>
<p>由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</p>
<p>除了这些 O(n)时间复杂度的命令可能会导致慢查询之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：</p>
<ul>
<li><code>ZRANGE</code>/<code>ZREVRANGE</code>：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>
<li><code>ZREMRANGEBYRANK</code>/<code>ZREMRANGEBYSCORE</code>：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>
<li>&hellip;&hellip;</li>
</ul>
<h3 id="如何找到慢查询命令">如何找到慢查询命令？<a hidden class="anchor" aria-hidden="true" href="#如何找到慢查询命令">#</a></h3>
<p>在 <code>redis.conf</code> 文件中，我们可以使用 <code>slowlog-log-slower-than</code> 参数设置耗时命令的阈值，并使用 <code>slowlog-max-len</code> 参数设置耗时命令的最大记录条数。</p>
<p>当 Redis 服务器检测到执行时间超过 <code>slowlog-log-slower-than</code>阈值的命令时，就会将该命令记录在慢查询日志(slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。</p>
<p>⚠️注意：由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。</p>
<p><code>slowlog-log-slower-than</code>和<code>slowlog-max-len</code>的默认配置如下(可以自行修改)：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nginx" data-lang="nginx"><span style="display:flex;"><span><span style="color:#007f7f"># The following time is expressed in microseconds, so 1000000 is equivalent
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"># to one second. Note that a negative number disables the slow log, while
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"># a value of zero forces the logging of every command.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">slowlog-log-slower-than</span> <span style="color:#ff0;font-weight:bold">10000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># There is no limit to this length. Just be aware that it will consume memory.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"># You can reclaim memory used by the slow log with SLOWLOG RESET.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#0ff;font-weight:bold">slowlog-max-len</span> <span style="color:#ff0;font-weight:bold">128</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>除了修改配置文件之外，你也可以直接通过 <code>CONFIG</code> 命令直接设置：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 命令执行耗时超过 10000 微妙（即10毫秒）就会被记录</span>
</span></span><span style="display:flex;"><span>CONFIG SET slowlog-log-slower-than <span style="color:#ff0;font-weight:bold">10000</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 只保留最近 128 条耗时命令</span>
</span></span><span style="display:flex;"><span>CONFIG SET slowlog-max-len <span style="color:#ff0;font-weight:bold">128</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>获取慢查询日志的内容很简单，直接使用<code>SLOWLOG GET</code> 命令即可。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>127.<span style="color:#007f7f">0</span>.<span style="color:#007f7f">0</span>.<span style="color:#007f7f">1</span>:6379&gt; SLOWLOG GET <span style="color:#f00">#</span>慢日志查询
</span></span><span style="display:flex;"><span> 1) 1) (integer) 5
</span></span><span style="display:flex;"><span>   2) (integer) 1684326682
</span></span><span style="display:flex;"><span>   3) (integer) 12000
</span></span><span style="display:flex;"><span>   4) 1) <span style="color:#0ff;font-weight:bold">&#34;KEYS&#34;</span>
</span></span><span style="display:flex;"><span>      2) <span style="color:#0ff;font-weight:bold">&#34;*&#34;</span>
</span></span><span style="display:flex;"><span>   5) <span style="color:#0ff;font-weight:bold">&#34;172.17.0.1:61152&#34;</span>
</span></span><span style="display:flex;"><span>   6) <span style="color:#0ff;font-weight:bold">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// ...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>慢查询日志中的每个条目都由以下六个值组成：</p>
<ol>
<li>唯一渐进的日志标识符。</li>
<li>处理记录命令的 Unix 时间戳。</li>
<li>执行所需的时间量，以微秒为单位。</li>
<li>组成命令参数的数组。</li>
<li>客户端 IP 地址和端口。</li>
<li>客户端名称。</li>
</ol>
<p><code>SLOWLOG GET</code> 命令默认返回最近 10 条的的慢查询命令，你也自己可以指定返回的慢查询命令的数量 <code>SLOWLOG GET N</code>。</p>
<p>下面是其他比较常用的慢查询相关的命令：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 返回慢查询命令的数量</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; SLOWLOG LEN
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">128</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 清空慢查询命令</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; SLOWLOG RESET
</span></span><span style="display:flex;"><span>OK
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="缓存穿透">缓存穿透<a hidden class="anchor" aria-hidden="true" href="#缓存穿透">#</a></h1>
<p>指查询一个不存在的数据，缓存中没有相应的记录，每次请求都会去数据库查询，造成数据库负担加重。</p>
<p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p>
<p>解决方案：</p>
<ul>
<li>使用布隆过滤器，过滤掉不存在的请求，避免直接访问数据库。</li>
<li>对查询结果进行缓存，即使是不存在的数据，也可以缓存一个标识，以减少对数据库的请求。</li>
</ul>
<h1 id="缓存击穿">缓存击穿<a hidden class="anchor" aria-hidden="true" href="#缓存击穿">#</a></h1>
<p>指某个热点数据在缓存中失效，导致大量请求直接访问数据库。此时，由于瞬间的高并发，可能导致数据库崩溃。</p>
<p>举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
<p>解决方案：</p>
<ul>
<li>设置热点数据永不过期或者过期时间比较长。</li>
<li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li>请求数据库写数据到缓存之前，先获取分布式锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li>
</ul>
<h1 id="缓存雪崩">缓存雪崩<a hidden class="anchor" aria-hidden="true" href="#缓存雪崩">#</a></h1>
<p>指多个缓存数据在同一时间过期，导致大量请求同时访问数据库，从而造成数据库瞬间负载激增。</p>
<p>举个例子：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
<p>解决方案：</p>
<ul>
<li>随机设置缓存失效时间</li>
<li>双缓存</li>
</ul>
<h1 id="redis主从">Redis主从<a hidden class="anchor" aria-hidden="true" href="#redis主从">#</a></h1>
<p>下图就是一个 Redis 主从架构图：</p>
<p><img alt="image.png" loading="lazy" src="https://pic.code-nav.cn/mianshiya/question_picture/1772087337535152129/Ry6PqUac_image_mianshiya.png"></p>
<p>主从架构可以实现读写分离。写操作可以请求主节点，而读操作只请求从节点，这样就能减轻主节点的压力。</p>
<p><img alt="image.png" loading="lazy" src="https://pic.code-nav.cn/mianshiya/question_picture/1772087337535152129/jJA9JNgt_image_mianshiya.png"></p>
<p>整个主从集群仅主节点可以写入，其它从节点都通过复制来同步数据，这样就能保证数据的一致性。并且对读请求分散到多个节点，提高了 Redis 的吞吐量，从一定程度上也提高了 Redis 的可用性。</p>
<h2 id="redis-主从复制的实现原理">Redis 主从复制的实现原理<a hidden class="anchor" aria-hidden="true" href="#redis-主从复制的实现原理">#</a></h2>
<p>Redis 的主从复制是指一个 Redis 实例（主节点）可以将数据复制到一个或多个从节点（从节点），从节点从主节点获取数据并保持同步。</p>
<p><strong>复制流程</strong>：</p>
<ul>
<li><strong>开始同步</strong>：从节点通过向主节点发送 <code>PSYNC</code> 命令发起同步。</li>
<li><strong>全量复制</strong>：如果是第一次连接或之前的连接失效，从节点会请求全量复制，主节点将当前数据快照（RDB文件）发送给从节点。</li>
<li><strong>增量复制</strong>：全量复制完毕后，主从之间会保持一个长连接，主节点会通过这个连接将后续的写操作传递给从节点执行，来保证数据的一致。</li>
</ul>
<h1 id="redis哨兵">Redis哨兵<a hidden class="anchor" aria-hidden="true" href="#redis哨兵">#</a></h1>
<p><strong>Redis 的哨兵机制（Sentinel）</strong> 是一种高可用性解决方案，用于监控 Redis 主从集群，自动完成主从切换，以实现故障自动恢复和通知。</p>
<p>主要功能包括：</p>
<ul>
<li><strong>监控</strong>：哨兵不断监控 Redis 主节点和从节点的运行状态，定期发送 PING 请求检查节点是否正常。</li>
<li><strong>自动故障转移</strong>：当主节点发生故障时，哨兵会选举一个从节点提升为新的主节点，并通知客户端更新主节点的地址，从而实现高可用。</li>
<li><strong>通知</strong>：哨兵可以向系统管理员或其他服务发送通知，以便快速处理 Redis 实例的状态变化。</li>
</ul>
<h2 id="哨兵机制的由来">哨兵机制的由来<a hidden class="anchor" aria-hidden="true" href="#哨兵机制的由来">#</a></h2>
<p>主从架构中，如果采用读写分离的模式，即主节点负责写请求，从节点负责读请求。假设这个时候主节点宕机了，没有新的主节点顶替上来的话，就会出现很长一段时间写请求没响应的情况。</p>
<p>针对这个情况，便出现了哨兵这个机制。它主要进行监控作用，如果主节点挂了，将从节点切换成主节点，从而最大限度地减少停机时间和数据丢失。</p>
<p>哨兵机制对应的架构图如下所示：</p>
<p><img loading="lazy" src="https://pic.code-nav.cn/mianshiya/question_picture/1783397053004488705/Snipaste_2024-05-17_17-20-19_mianshiya.jpg"></p>
<ul>
<li>哨兵节点（Sentinel）: 主要作用是对 Redis 的主从服务节点进行监控，当主节点发生故障的时候，哨兵节点会选择一个合适的从节点升级为主节点，并通知其他从节点和客户端进行更新操作。</li>
<li>Redis 节点：主要包括 master 以及 slave 节点，就是 Redis 提供服务的实例。</li>
</ul>
<p>一般哨兵需要集群部署，至少三台哨兵组成哨兵集群。</p>
<h2 id="主观下线和客观下线">主观下线和客观下线<a hidden class="anchor" aria-hidden="true" href="#主观下线和客观下线">#</a></h2>
<p>哨兵是如何判断 Redis 中主节点挂了的呢？主要涉及到了两个机制：<strong>主观下线</strong>以及<strong>客观下线</strong>。</p>
<p><strong>1）主观下线</strong></p>
<p>Sentinel 每隔 1s 会发送 ping 命令给所有的节点。如果 Sentinel 超过一段时间还未收到对应节点的 pong 回复，就会认为这个节点主观下线。</p>
<p><img loading="lazy" src="https://pic.code-nav.cn/mianshiya/question_picture/1772087337535152129/Eqx6tHT9_image_mianshiya.png"></p>
<p>“一段时间”是配置项 <code>down-after-milliseconds</code> 设定的。</p>
<p><strong>2）客观下线</strong></p>
<p>注意，<strong>只有主节点才有客观下线，从节点没有</strong>。</p>
<p>假设目前有个主节点被一个 sentinel 的判断主观下线了，但可能主节点并没问题，只是因为网络抖动导致了一台哨兵的误判。所以此时哨兵需要问问它的队友，来确定这个主节点是不是真的出了问题！</p>
<p>因此，它会向其他哨兵发起投票，其他哨兵会判断主节点的状态进行投票，可以投赞成或反对。</p>
<p><img loading="lazy" src="https://pic.code-nav.cn/mianshiya/question_picture/1772087337535152129/lB8i9I6c_image_mianshiya.png"></p>
<p>如果认为下线的总投票数大于 quorum（一般为集群总数/2 + 1，假设哨兵集群有 3 台实例，那么 3 / 2 + 1 = 2），则判定该主节点客观下线，此时就需要进行主从切换，而<strong>只有哨兵的 leader 才能操作主从切换</strong>。</p>
<h2 id="sentinel-leader-是如何选举出来的">Sentinel leader 是如何选举出来的？<a hidden class="anchor" aria-hidden="true" href="#sentinel-leader-是如何选举出来的">#</a></h2>
<p>Sentinel leader 节点的选举实际上涉及到分布式算法 raft，感兴趣的同学可以深入去了解一下，这里主要简单说一下哨兵集群选择 leader 的方式：</p>
<p>判断主节点主观下线的 sentinel 就是候选者，此时它想成为 leader。如果同时有两个 sentinel 判断主观下线，那么它们都是候选人，一起竞争成为 leader。</p>
<p>候选者们会先投自己一票，然后向其他 sentinel 发送命令让它们给自己投票。<strong>每个哨兵手里只有一票，投了一个之后就不能投别人了</strong>。</p>
<p>最后，如果某个候选者拿到哨兵集群半数及以上的赞成票，就会成为 leader。这里有一个注意的点，为了保证 sentinel 选举的时候尽量避免出现平票的情况，sentinel 的节点个数一般都会是奇数，比如 3,5,7 这样。</p>
<h2 id="redis-主节点选举">Redis 主节点选举<a hidden class="anchor" aria-hidden="true" href="#redis-主节点选举">#</a></h2>
<p>选出哨兵 leader 之后，需要选出 Redis 主从集群中的新 master 节点。</p>
<p>首先需要把一些已经下线的节点全部剔除，然后从正常的从节点中选择主节点，其主要经过以下三个流程:</p>
<ol>
<li>根据从节点的优先级进行选择，优先选择优先级的值比较小的节点（优先级的值越小优先级越高，优先级可通过 <code>slave-priority</code> 配置）。</li>
<li>如果节点的优先级相同，则查看进行主从复制的 offset 的值，即复制的偏移量，偏移量越大则表示其同步的数据越多，优先级越高。</li>
<li>如果 offset 也相同了，那只能比较 ID 号，选择 ID 号比较小的那个作为主节点（每个实例 ID 不同）。</li>
</ol>
<p>选好主节点之后，哨兵 leader 会让其他从节点全部成为新 master 节点的 slave 节点。</p>
<p>最后利用 redis 的发布/订阅机制，把新主节点的 IP 和端口信息推送给客户端，此时主从切换就结束了。</p>
<p>可能还有同学关心旧主节点恢复了怎么办？实际上哨兵会继续监视旧的主节点，如果它上线了，哨兵集群会向它发送 slaveof 命令，让它成为新主节点的从节点。</p>
<h1 id="redis-集群">Redis 集群<a hidden class="anchor" aria-hidden="true" href="#redis-集群">#</a></h1>
<h2 id="redis-集群的实现原理">Redis 集群的实现原理<a hidden class="anchor" aria-hidden="true" href="#redis-集群的实现原理">#</a></h2>
<p>注意：​<strong>​Redis 集群模式：​</strong>​ ​<strong>​不需要 Sentinel（哨兵）​</strong>​。集群自身通过内置的分布式协议（Gossip + Raft选举）实现了节点故障检测、主从自动切换和高可用性，是一个自包含的解决方案。</p>
<p><strong>作用</strong>：</p>
<ul>
<li>集群中有多个 master，每个 master 保存不同数据（海量数据）</li>
<li>每个 master 都可以有多个 slave 节点（高并发读）</li>
<li>master 之间通过 ping 检测彼此健康状态</li>
<li>客户端请求可以访问集群任意节点，最终都会被转发到正确节点（路由规则）</li>
</ul>
<p><strong>怎么存储和读取的</strong>：</p>
<ul>
<li>分片集群引入了哈希槽的概率，有 16384 个哈希槽。</li>
<li>将 16384 个哈希槽分配到不同的实例。</li>
<li>读写数据：根据有效部分计算哈希值，对 16384 进行取余（有效部分 set {aaa}name tiantian ），余数作为插槽，寻找插槽所在的实例。</li>
</ul>
<h1 id="redis-使用规范">Redis 使用规范<a hidden class="anchor" aria-hidden="true" href="#redis-使用规范">#</a></h1>
<p>实际使用 Redis 的过程中，我们尽量要准守一些常见的规范，比如：</p>
<ol>
<li>使用连接池：避免频繁创建关闭客户端连接。</li>
<li>尽量不使用 O(n)指令，使用 O(n) 命令时要关注 n 的数量：像 <code>KEYS *</code>、<code>HGETALL</code>、<code>LRANGE</code>、<code>SMEMBERS</code>、<code>SINTER</code>/<code>SUNION</code>/<code>SDIFF</code>等 O(n) 命令并非不能使用，但是需要明确 n 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</li>
<li>使用批量操作减少网络传输：原生批量操作命令（比如 <code>MGET</code>、<code>MSET</code>等等）、pipeline、Lua 脚本。</li>
<li>尽量不使用 Redis 事务：Redis 事务实现的功能比较鸡肋，可以使用 Lua 脚本代替。</li>
<li>禁止长时间开启 monitor：对性能影响比较大。</li>
<li>控制 key 的生命周期：避免 Redis 中存放了太多不经常被访问的数据。</li>
<li>&hellip;&hellip;</li>
</ol>
<p>相关文章推荐：<a href="https://developer.aliyun.com/article/531067">阿里云 Redis 开发规范</a> 。</p>
<h1 id="3种常用的缓存读写策略详解">3种常用的缓存读写策略详解<a hidden class="anchor" aria-hidden="true" href="#3种常用的缓存读写策略详解">#</a></h1>
<h2 id="cache-aside-pattern旁路缓存模式">Cache Aside Pattern（旁路缓存模式）<a hidden class="anchor" aria-hidden="true" href="#cache-aside-pattern旁路缓存模式">#</a></h2>
<p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p>
<p>Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。</p>
<p>下面我们来看一下这个策略模式下的缓存读写步骤。</p>
<p><strong>写</strong>：</p>
<ul>
<li>先更新 db</li>
<li>然后直接删除 cache 。</li>
</ul>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/cache-aside-write.png"></p>
<p><strong>读</strong> :</p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache 中读取不到的话，就从 db 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/cache-aside-read.png"></p>
<p>你仅仅了解了上面这些内容的话是远远不够的，我们还要搞懂其中的原理。</p>
<p>比如说面试官很可能会追问：“<strong>在写数据的过程中，可以先删除 cache ，后更新 db 么？</strong>”</p>
<p><strong>答案：</strong> 那肯定是不行的！因为这样可能会造成 <strong>数据库（db）和缓存（Cache）数据不一致</strong>的问题。</p>
<p>举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。</p>
<p>这个过程可以简单描述为：</p>
<blockquote>
<p>请求 1 先把 cache 中的 A 数据删除 -&gt; 请求 2 从 db 中读取数据-&gt;请求 1 再把 db 中的 A 数据更新</p>
</blockquote>
<p>当你这样回答之后，面试官可能会紧接着就追问：“<strong>在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？</strong>”</p>
<p><strong>答案：</strong> 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。</p>
<p>举例：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。</p>
<p>这个过程可以简单描述为：</p>
<blockquote>
<p>请求 1 从 db 读数据 A-&gt; 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -&gt; 请求 1 将数据 A 写入 cache</p>
</blockquote>
<p>现在我们再来分析一下 <strong>Cache Aside Pattern 的缺陷</strong>。</p>
<p><strong>缺陷 1：首次请求数据一定不在 cache 的问题</strong></p>
<p>解决办法：可以将热点数据可以提前放入 cache 中。</p>
<p><strong>缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p>
<p>解决办法：</p>
<ul>
<li>数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
<h2 id="readwrite-through-pattern读写穿透">Read/Write Through Pattern（读写穿透）<a hidden class="anchor" aria-hidden="true" href="#readwrite-through-pattern读写穿透">#</a></h2>
<p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</p>
<p>这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入 db 的功能。</p>
<p><strong>写（Write Through）：</strong></p>
<ul>
<li>先查 cache，cache 中不存在，直接更新 db。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）。</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/write-through.png"></p>
<p><strong>读(Read Through)：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 db 加载，写入到 cache 后返回响应。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/read-through.png"></p>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>
<h2 id="write-behind-pattern异步缓存写入">Write Behind Pattern（异步缓存写入）<a hidden class="anchor" aria-hidden="true" href="#write-behind-pattern异步缓存写入">#</a></h2>
<p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。</p>
<p>但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</strong></p>
<p>很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。</p>
<p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。</p>
<p>Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>
<h1 id="redis-5-种基本数据结构详解">Redis 5 种基本数据结构详解<a hidden class="anchor" aria-hidden="true" href="#redis-5-种基本数据结构详解">#</a></h1>
<p>Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p>
<p>这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。</p>
<p>Redis 基本数据结构的底层数据结构实现如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">String</th>
<th style="text-align:left">List</th>
<th style="text-align:left">Hash</th>
<th style="text-align:left">Set</th>
<th style="text-align:left">Zset</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SDS</td>
<td style="text-align:left">LinkedList/ZipList/QuickList</td>
<td style="text-align:left">Hash Table、ZipList</td>
<td style="text-align:left">ZipList、Intset</td>
<td style="text-align:left">ZipList、SkipList</td>
</tr>
</tbody>
</table>
<p>Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。</p>
<p>你可以在 Redis 官网上找到 Redis 数据结构非常详细的介绍：</p>
<ul>
<li><a href="https://redis.com/redis-enterprise/data-structures/">Redis Data Structures</a></li>
<li><a href="https://redis.io/docs/manual/data-types/data-types-tutorial/">Redis Data types tutorial</a></li>
</ul>
<p>未来随着 Redis 新版本的发布，可能会有新的数据结构出现，通过查阅 Redis 官网对应的介绍，你总能获取到最靠谱的信息。</p>
<h2 id="string字符串">String（字符串）<a hidden class="anchor" aria-hidden="true" href="#string字符串">#</a></h2>
<h3 id="介绍">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍">#</a></h3>
<p>String 是 Redis 中最简单同时也是最常用的一个数据结构。</p>
<p>String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220719124403897.png"></p>
<p>虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（Simple Dynamic String，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>
<h3 id="常用命令">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令">#</a></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET key value</td>
<td>设置指定 key 的值</td>
</tr>
<tr>
<td>SETNX key value</td>
<td>只有在 key 不存在时设置 key 的值</td>
</tr>
<tr>
<td>GET key</td>
<td>获取指定 key 的值</td>
</tr>
<tr>
<td>MSET key1 value1 key2 value2 …</td>
<td>设置一个或多个指定 key 的值</td>
</tr>
<tr>
<td>MGET key1 key2 &hellip;</td>
<td>获取一个或多个指定 key 的值</td>
</tr>
<tr>
<td>STRLEN key</td>
<td>返回 key 所储存的字符串值的长度</td>
</tr>
<tr>
<td>INCR key</td>
<td>将 key 中储存的数字值增一</td>
</tr>
<tr>
<td>DECR key</td>
<td>将 key 中储存的数字值减一</td>
</tr>
<tr>
<td>EXISTS key</td>
<td>判断指定 key 是否存在</td>
</tr>
<tr>
<td>DEL key（通用）</td>
<td>删除指定的 key</td>
</tr>
<tr>
<td>EXPIRE key seconds（通用）</td>
<td>给指定 key 设置过期时间</td>
</tr>
</tbody>
</table>
<p>更多 Redis String 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href="https://redis.io/commands/?group=string">https://redis.io/commands/?group=string</a> 。</p>
<p><strong>基本操作</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SET key value
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; GET key
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;value&#34;</span>
</span></span><span style="display:flex;"><span>&gt; EXISTS key
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; STRLEN key
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">5</span>
</span></span><span style="display:flex;"><span>&gt; DEL key
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; GET key
</span></span><span style="display:flex;"><span>(nil)
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>批量设置</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; MSET key1 value1 key2 value2
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; MGET key1 key2 <span style="color:#007f7f"># 批量获取多个 key 对应的 value</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SET number <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; INCR number <span style="color:#007f7f"># 将 key 中储存的数字值增一</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>&gt; GET number
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;2&#34;</span>
</span></span><span style="display:flex;"><span>&gt; DECR number <span style="color:#007f7f"># 将 key 中储存的数字值减一</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; GET number
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;1&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>设置过期时间（默认为永不过期）</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; EXPIRE key <span style="color:#ff0;font-weight:bold">60</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; SETEX key <span style="color:#ff0;font-weight:bold">60</span> value <span style="color:#007f7f"># 设置值并设置过期时间</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; TTL key
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">56</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景">#</a></h3>
<p><strong>需要存储常规数据的场景</strong></p>
<ul>
<li>举例：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。</li>
<li>相关命令：<code>SET</code>、<code>GET</code>。</li>
</ul>
<p><strong>需要计数的场景</strong></p>
<ul>
<li>举例：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li>
<li>相关命令：<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> 。</li>
</ul>
<p><strong>分布式锁</strong></p>
<p>利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。</p>
<h2 id="list列表">List（列表）<a hidden class="anchor" aria-hidden="true" href="#list列表">#</a></h2>
<h3 id="介绍-1">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍-1">#</a></h3>
<p>Redis 中的 List 其实就是链表数据结构的实现。我在 <a href="https://javaguide.cn/cs-basics/data-structure/linear-data-structure.html">线性数据结构 :数组、链表、栈、队列</a> 这篇文章中详细介绍了链表这种数据结构，我这里就不多做介绍了。</p>
<p>许多高级编程语言都内置了链表的实现比如 Java 中的 <code>LinkedList</code>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 List 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220719124413287.png"></p>
<h3 id="常用命令-1">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令-1">#</a></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>RPUSH key value1 value2 &hellip;</td>
<td>在指定列表的尾部（右边）添加一个或多个元素</td>
</tr>
<tr>
<td>LPUSH key value1 value2 &hellip;</td>
<td>在指定列表的头部（左边）添加一个或多个元素</td>
</tr>
<tr>
<td>LSET key index value</td>
<td>将指定列表索引 index 位置的值设置为 value</td>
</tr>
<tr>
<td>LPOP key</td>
<td>移除并获取指定列表的第一个元素(最左边)</td>
</tr>
<tr>
<td>RPOP key</td>
<td>移除并获取指定列表的最后一个元素(最右边)</td>
</tr>
<tr>
<td>LLEN key</td>
<td>获取列表元素数量</td>
</tr>
<tr>
<td>LRANGE key start end</td>
<td>获取列表 start 和 end 之间 的元素</td>
</tr>
</tbody>
</table>
<p>更多 Redis List 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href="https://redis.io/commands/?group=list">https://redis.io/commands/?group=list</a> 。</p>
<p><strong>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>实现队列</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; RPUSH myList value1
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; RPUSH myList value2 value3
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>&gt; LPOP myList
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>&gt; LRANGE myList <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value3&#34;</span>
</span></span><span style="display:flex;"><span>&gt; LRANGE myList <span style="color:#ff0;font-weight:bold">0</span> -1
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value3&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>通过 <code>RPUSH/RPOP</code>或者<code>LPUSH/LPOP</code> 实现栈</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; RPUSH myList2 value1 value2 value3
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>&gt; RPOP myList2 <span style="color:#007f7f"># 将 list的最右边的元素取出</span>
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;value3&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我专门画了一个图方便大家理解 <code>RPUSH</code> , <code>LPOP</code> , <code>lpush</code> , <code>RPOP</code> 命令：</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-list.png"></p>
<p><strong>通过 <code>LRANGE</code> 查看对应下标范围的列表元素</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; RPUSH myList value1 value2 value3
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>&gt; LRANGE myList <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>&gt; LRANGE myList <span style="color:#ff0;font-weight:bold">0</span> -1
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>3) <span style="color:#0ff;font-weight:bold">&#34;value3&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 <code>LRANGE</code> 命令，你可以基于 List 实现分页查询，性能非常高！</p>
<p><strong>通过 <code>LLEN</code> 查看链表长度</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; LLEN myList
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景-1">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景-1">#</a></h3>
<p><strong>信息流展示</strong></p>
<ul>
<li>举例：最新文章、最新动态。</li>
<li>相关命令：<code>LPUSH</code>、<code>LRANGE</code>。</li>
</ul>
<p><strong>消息队列</strong></p>
<p>Redis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</p>
<p>相对来说，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</p>
<h2 id="hash哈希">Hash（哈希）<a hidden class="anchor" aria-hidden="true" href="#hash哈希">#</a></h2>
<h3 id="介绍-2">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍-2">#</a></h3>
<p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</p>
<p>Hash 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220719124421703.png"></p>
<h3 id="常用命令-2">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令-2">#</a></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>HSET key field value</td>
<td>设置指定哈希表中指定字段的值</td>
</tr>
<tr>
<td>HSETNX key field value</td>
<td>只有指定字段不存在时设置指定字段的值</td>
</tr>
<tr>
<td>HMSET key field1 value1 field2 value2 &hellip;</td>
<td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td>
</tr>
<tr>
<td>HGET key field</td>
<td>获取指定哈希表中指定字段的值</td>
</tr>
<tr>
<td>HMGET key field1 field2 &hellip;</td>
<td>获取指定哈希表中一个或者多个指定字段的值</td>
</tr>
<tr>
<td>HGETALL key</td>
<td>获取指定哈希表中所有的键值对</td>
</tr>
<tr>
<td>HEXISTS key field</td>
<td>查看指定哈希表中指定的字段是否存在</td>
</tr>
<tr>
<td>HDEL key field1 field2 &hellip;</td>
<td>删除一个或多个哈希表字段</td>
</tr>
<tr>
<td>HLEN key</td>
<td>获取指定哈希表中字段的数量</td>
</tr>
<tr>
<td>HINCRBY key field increment</td>
<td>对指定哈希中的指定字段做运算操作（正数为加，负数为减）</td>
</tr>
</tbody>
</table>
<p>更多 Redis Hash 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href="https://redis.io/commands/?group=hash">https://redis.io/commands/?group=hash</a> 。</p>
<p><strong>模拟对象数据存储</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; HMSET userInfoKey name <span style="color:#0ff;font-weight:bold">&#34;guide&#34;</span> description <span style="color:#0ff;font-weight:bold">&#34;dev&#34;</span> age <span style="color:#ff0;font-weight:bold">24</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; HEXISTS userInfoKey name <span style="color:#007f7f"># 查看 key 对应的 value中指定的字段是否存在。</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; HGET userInfoKey name <span style="color:#007f7f"># 获取存储在哈希表中指定字段的值。</span>
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;guide&#34;</span>
</span></span><span style="display:flex;"><span>&gt; HGET userInfoKey age
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;24&#34;</span>
</span></span><span style="display:flex;"><span>&gt; HGETALL userInfoKey <span style="color:#007f7f"># 获取在哈希表中指定 key 的所有字段和值</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;guide&#34;</span>
</span></span><span style="display:flex;"><span>3) <span style="color:#0ff;font-weight:bold">&#34;description&#34;</span>
</span></span><span style="display:flex;"><span>4) <span style="color:#0ff;font-weight:bold">&#34;dev&#34;</span>
</span></span><span style="display:flex;"><span>5) <span style="color:#0ff;font-weight:bold">&#34;age&#34;</span>
</span></span><span style="display:flex;"><span>6) <span style="color:#0ff;font-weight:bold">&#34;24&#34;</span>
</span></span><span style="display:flex;"><span>&gt; HSET userInfoKey name <span style="color:#0ff;font-weight:bold">&#34;GuideGeGe&#34;</span>
</span></span><span style="display:flex;"><span>&gt; HGET userInfoKey name
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;GuideGeGe&#34;</span>
</span></span><span style="display:flex;"><span>&gt; HINCRBY userInfoKey age <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">26</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景-2">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景-2">#</a></h3>
<p><strong>对象数据存储场景</strong></p>
<ul>
<li>举例：用户信息、商品信息、文章信息、购物车信息。</li>
<li>相关命令：<code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）。</li>
</ul>
<h2 id="set集合">Set（集合）<a hidden class="anchor" aria-hidden="true" href="#set集合">#</a></h2>
<h3 id="介绍-3">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍-3">#</a></h3>
<p>Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p>
<p>你可以基于 Set 轻易实现交集、并集、差集的操作，比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220719124430264.png"></p>
<h3 id="常用命令-3">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令-3">#</a></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD key member1 member2 &hellip;</td>
<td>向指定集合添加一个或多个元素</td>
</tr>
<tr>
<td>SMEMBERS key</td>
<td>获取指定集合中的所有元素</td>
</tr>
<tr>
<td>SCARD key</td>
<td>获取指定集合的元素数量</td>
</tr>
<tr>
<td>SISMEMBER key member</td>
<td>判断指定元素是否在指定集合中</td>
</tr>
<tr>
<td>SINTER key1 key2 &hellip;</td>
<td>获取给定所有集合的交集</td>
</tr>
<tr>
<td>SINTERSTORE destination key1 key2 &hellip;</td>
<td>将给定所有集合的交集存储在 destination 中</td>
</tr>
<tr>
<td>SUNION key1 key2 &hellip;</td>
<td>获取给定所有集合的并集</td>
</tr>
<tr>
<td>SUNIONSTORE destination key1 key2 &hellip;</td>
<td>将给定所有集合的并集存储在 destination 中</td>
</tr>
<tr>
<td>SDIFF key1 key2 &hellip;</td>
<td>获取给定所有集合的差集</td>
</tr>
<tr>
<td>SDIFFSTORE destination key1 key2 &hellip;</td>
<td>将给定所有集合的差集存储在 destination 中</td>
</tr>
<tr>
<td>SPOP key count</td>
<td>随机移除并获取指定集合中一个或多个元素</td>
</tr>
<tr>
<td>SRANDMEMBER key count</td>
<td>随机获取指定集合中指定数量的元素</td>
</tr>
</tbody>
</table>
<p>更多 Redis Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href="https://redis.io/commands/?group=set">https://redis.io/commands/?group=set</a> 。</p>
<p><strong>基本操作</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SADD mySet value1 value2
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>&gt; SADD mySet value1 <span style="color:#007f7f"># 不允许有重复元素，因此添加失败</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; SMEMBERS mySet
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>&gt; SCARD mySet
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>&gt; SISMEMBER mySet value1
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; SADD mySet2 value2 value3
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>mySet</code> : <code>value1</code>、<code>value2</code> 。</li>
<li><code>mySet2</code>：<code>value2</code>、<code>value3</code> 。</li>
</ul>
<p><strong>求交集</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SINTERSTORE mySet3 mySet mySet2
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; SMEMBERS mySet3
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>求并集</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SUNION mySet mySet2
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value3&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>3) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>求差集</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SDIFF mySet mySet2 <span style="color:#007f7f"># 差集是由所有属于 mySet 但不属于 A 的元素组成的集合</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景-3">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景-3">#</a></h3>
<p><strong>需要存放的数据不能重复的场景</strong></p>
<ul>
<li>举例：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</li>
<li>相关命令：<code>SCARD</code>（获取集合数量） 。</li>
</ul>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220719073733851.png"></p>
<p><strong>需要获取多个数据源交集、并集和差集的场景</strong></p>
<ul>
<li>举例：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等场景。</li>
<li>相关命令：<code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）。</li>
</ul>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220719074543513.png"></p>
<p><strong>需要随机获取数据源中的元素的场景</strong></p>
<ul>
<li>举例：抽奖系统、随机点名等场景。</li>
<li>相关命令：<code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）。</li>
</ul>
<h2 id="sorted-set有序集合">Sorted Set（有序集合）<a hidden class="anchor" aria-hidden="true" href="#sorted-set有序集合">#</a></h2>
<h3 id="介绍-4">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍-4">#</a></h3>
<p>Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220719124437791.png"></p>
<h3 id="常用命令-4">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令-4">#</a></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD key score1 member1 score2 member2 &hellip;</td>
<td>向指定有序集合添加一个或多个元素</td>
</tr>
<tr>
<td>ZCARD KEY</td>
<td>获取指定有序集合的元素数量</td>
</tr>
<tr>
<td>ZSCORE key member</td>
<td>获取指定有序集合中指定元素的 score 值</td>
</tr>
<tr>
<td>ZINTERSTORE destination numkeys key1 key2 &hellip;</td>
<td>将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td>
</tr>
<tr>
<td>ZUNIONSTORE destination numkeys key1 key2 &hellip;</td>
<td>求并集，其它和 ZINTERSTORE 类似</td>
</tr>
<tr>
<td>ZDIFFSTORE destination numkeys key1 key2 &hellip;</td>
<td>求差集，其它和 ZINTERSTORE 类似</td>
</tr>
<tr>
<td>ZRANGE key start end</td>
<td>获取指定有序集合 start 和 end 之间的元素（score 从低到高）</td>
</tr>
<tr>
<td>ZREVRANGE key start end</td>
<td>获取指定有序集合 start 和 end 之间的元素（score 从高到底）</td>
</tr>
<tr>
<td>ZREVRANK key member</td>
<td>获取指定有序集合中指定元素的排名(score 从大到小排序)</td>
</tr>
</tbody>
</table>
<p>更多 Redis Sorted Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href="https://redis.io/commands/?group=sorted-set">https://redis.io/commands/?group=sorted-set</a> 。</p>
<p><strong>基本操作</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; ZADD myZset 2.0 value1 1.0 value2
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>&gt; ZCARD myZset
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>&gt; ZSCORE myZset value1
</span></span><span style="display:flex;"><span>2.0
</span></span><span style="display:flex;"><span>&gt; ZRANGE myZset <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>&gt; ZREVRANGE myZset <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>&gt; ZADD myZset2 4.0 value2 3.0 value3
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>myZset</code> : <code>value1</code>(2.0)、<code>value2</code>(1.0) 。</li>
<li><code>myZset2</code>：<code>value2</code> （4.0）、<code>value3</code>(3.0) 。</li>
</ul>
<p><strong>获取指定元素的排名</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; ZREVRANK myZset value1
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; ZREVRANK myZset value2
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>求交集</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; ZINTERSTORE myZset3 <span style="color:#ff0;font-weight:bold">2</span> myZset myZset2
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; ZRANGE myZset3 <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">1</span> WITHSCORES
</span></span><span style="display:flex;"><span>value2
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">5</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>求并集</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; ZUNIONSTORE myZset4 <span style="color:#ff0;font-weight:bold">2</span> myZset myZset2
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>&gt; ZRANGE myZset4 <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">2</span> WITHSCORES
</span></span><span style="display:flex;"><span>value1
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>value3
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>value2
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">5</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>求差集</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; ZDIFF <span style="color:#ff0;font-weight:bold">2</span> myZset myZset2 WITHSCORES
</span></span><span style="display:flex;"><span>value1
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景-4">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景-4">#</a></h3>
<p><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></p>
<ul>
<li>举例：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li>
<li>相关命令：<code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>
</ul>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/2021060714195385.png"></p>
<p><strong>需要存储的数据有优先级或者重要程度的场景</strong> 比如优先级任务队列。</p>
<ul>
<li>举例：优先级任务队列。</li>
<li>相关命令：<code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>
</ul>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</td>
</tr>
<tr>
<td>List</td>
<td>Redis 的 List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</td>
</tr>
<tr>
<td>Hash</td>
<td>一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</td>
</tr>
<tr>
<td>Set</td>
<td>无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。</td>
</tr>
<tr>
<td>Zset</td>
<td>和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</td>
</tr>
</tbody>
</table>
<h1 id="redis-3-种特殊数据结构详解">Redis 3 种特殊数据结构详解<a hidden class="anchor" aria-hidden="true" href="#redis-3-种特殊数据结构详解">#</a></h1>
<p>除了 5 种基本的数据结构之外，Redis 还支持 3 种特殊的数据结构：Bitmap、HyperLogLog、GEO。</p>
<h2 id="bitmap">Bitmap<a hidden class="anchor" aria-hidden="true" href="#bitmap">#</a></h2>
<h3 id="介绍-5">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍-5">#</a></h3>
<p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p>
<p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220720194154133.png"></p>
<h3 id="常用命令-5">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令-5">#</a></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>SETBIT key offset value</td>
<td>设置指定 offset 位置的值</td>
</tr>
<tr>
<td>GETBIT key offset</td>
<td>获取指定 offset 位置的值</td>
</tr>
<tr>
<td>BITCOUNT key start end</td>
<td>获取 start 和 end 之前值为 1 的元素个数</td>
</tr>
<tr>
<td>BITOP operation destkey key1 key2 &hellip;</td>
<td>对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT</td>
</tr>
</tbody>
</table>
<p><strong>Bitmap 基本操作演示</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># SETBIT 会返回之前位的值（默认是 0）这里会生成 7 个位</span>
</span></span><span style="display:flex;"><span>&gt; SETBIT mykey <span style="color:#ff0;font-weight:bold">7</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; SETBIT mykey <span style="color:#ff0;font-weight:bold">7</span> <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; GETBIT mykey <span style="color:#ff0;font-weight:bold">7</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; SETBIT mykey <span style="color:#ff0;font-weight:bold">6</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; SETBIT mykey <span style="color:#ff0;font-weight:bold">8</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 通过 bitcount 统计被被设置为 1 的位的数量。</span>
</span></span><span style="display:flex;"><span>&gt; BITCOUNT mykey
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景-5">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景-5">#</a></h3>
<p><strong>需要保存状态信息（0/1 即可表示）的场景</strong></p>
<ul>
<li>举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li>
<li>相关命令：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</li>
</ul>
<h2 id="hyperloglog">HyperLogLog<a hidden class="anchor" aria-hidden="true" href="#hyperloglog">#</a></h2>
<h3 id="介绍-6">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍-6">#</a></h3>
<p>HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。</p>
<p>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：</p>
<ul>
<li><strong>稀疏矩阵</strong>：计数较少的时候，占用空间很小。</li>
<li><strong>稠密矩阵</strong>：计数达到某个阈值的时候，占用 12k 的空间。</li>
</ul>
<p>Redis 官方文档中有对应的详细说明：</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220721091424563.png"></p>
<p>基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> ）。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220720194154133.png"></p>
<p>HyperLogLog 的使用非常简单，但原理非常复杂。HyperLogLog 的原理以及在 Redis 中的实现可以看这篇文章：<a href="https://juejin.cn/post/6844903785744056333">HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的</a> 。</p>
<p>再推荐一个可以帮助理解 HyperLogLog 原理的工具：<a href="http://content.research.neustar.biz/blog/hll.html">Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure</a> 。</p>
<h3 id="常用命令-6">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令-6">#</a></h3>
<p>HyperLogLog 相关的命令非常少，最常用的也就 3 个。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>PFADD key element1 element2 &hellip;</td>
<td>添加一个或多个元素到 HyperLogLog 中</td>
</tr>
<tr>
<td>PFCOUNT key1 key2</td>
<td>获取一个或者多个 HyperLogLog 的唯一计数。</td>
</tr>
<tr>
<td>PFMERGE destkey sourcekey1 sourcekey2 &hellip;</td>
<td>将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。</td>
</tr>
</tbody>
</table>
<p><strong>HyperLogLog 基本操作演示</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; PFADD hll foo bar zap
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; PFADD hll zap zap zap
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; PFADD hll foo bar
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; PFCOUNT hll
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>&gt; PFADD some-other-hll <span style="color:#ff0;font-weight:bold">1</span> <span style="color:#ff0;font-weight:bold">2</span> <span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; PFCOUNT hll some-other-hll
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">6</span>
</span></span><span style="display:flex;"><span>&gt; PFMERGE desthll hll some-other-hll
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;OK&#34;</span>
</span></span><span style="display:flex;"><span>&gt; PFCOUNT desthll
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">6</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景-6">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景-6">#</a></h3>
<p><strong>数量量巨大（百万、千万级别以上）的计数场景</strong></p>
<ul>
<li>举例：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、</li>
<li>相关命令：<code>PFADD</code>、<code>PFCOUNT</code> 。</li>
</ul>
<h2 id="geospatial-index">Geospatial index<a hidden class="anchor" aria-hidden="true" href="#geospatial-index">#</a></h2>
<h3 id="介绍-7">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍-7">#</a></h3>
<p>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。</p>
<p>通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220720194359494.png"></p>
<h3 id="常用命令-7">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令-7">#</a></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>GEOADD key longitude1 latitude1 member1 &hellip;</td>
<td>添加一个或多个元素对应的经纬度信息到 GEO 中</td>
</tr>
<tr>
<td>GEOPOS key member1 member2 &hellip;</td>
<td>返回给定元素的经纬度信息</td>
</tr>
<tr>
<td>GEODIST key member1 member2 M/KM/FT/MI</td>
<td>返回两个给定元素之间的距离</td>
</tr>
<tr>
<td>GEORADIUS key longitude latitude radius distance</td>
<td>获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数</td>
</tr>
<tr>
<td>GEORADIUSBYMEMBER key member radius distance</td>
<td>类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素</td>
</tr>
</tbody>
</table>
<p><strong>基本操作</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; GEOADD personLocation 116.33 39.89 user1 116.34 39.90 user2 116.35 39.88 user3
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>&gt; GEOPOS personLocation user1
</span></span><span style="display:flex;"><span>116.3299986720085144
</span></span><span style="display:flex;"><span>39.89000061669732844
</span></span><span style="display:flex;"><span>&gt; GEODIST personLocation user1 user2 km
</span></span><span style="display:flex;"><span>1.4018
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 Redis 可视化工具查看 <code>personLocation</code> ，果不其然，底层就是 Sorted Set。</p>
<p>GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220721201545147.png"></p>
<p><strong>获取指定位置范围内的其他元素</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; GEORADIUS personLocation 116.33 39.87 <span style="color:#ff0;font-weight:bold">3</span> km
</span></span><span style="display:flex;"><span>user3
</span></span><span style="display:flex;"><span>user1
</span></span><span style="display:flex;"><span>&gt; GEORADIUS personLocation 116.33 39.87 <span style="color:#ff0;font-weight:bold">2</span> km
</span></span><span style="display:flex;"><span>&gt; GEORADIUS personLocation 116.33 39.87 <span style="color:#ff0;font-weight:bold">5</span> km
</span></span><span style="display:flex;"><span>user3
</span></span><span style="display:flex;"><span>user1
</span></span><span style="display:flex;"><span>user2
</span></span><span style="display:flex;"><span>&gt; GEORADIUSBYMEMBER personLocation user1 <span style="color:#ff0;font-weight:bold">5</span> km
</span></span><span style="display:flex;"><span>user3
</span></span><span style="display:flex;"><span>user1
</span></span><span style="display:flex;"><span>user2
</span></span><span style="display:flex;"><span>&gt; GEORADIUSBYMEMBER personLocation user1 <span style="color:#ff0;font-weight:bold">2</span> km
</span></span><span style="display:flex;"><span>user1
</span></span><span style="display:flex;"><span>user2
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>GEORADIUS</code> 命令的底层原理解析可以看看阿里的这篇文章：<a href="https://juejin.cn/post/6844903966061363207">Redis 到底是怎么实现“附近的人”这个功能的呢？</a> 。</p>
<p><strong>移除元素</strong>：</p>
<p>GEO 底层是 Sorted Set ，你可以对 GEO 使用 Sorted Set 相关的命令。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; ZREM personLocation user1
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; ZRANGE personLocation <span style="color:#ff0;font-weight:bold">0</span> -1
</span></span><span style="display:flex;"><span>user3
</span></span><span style="display:flex;"><span>user2
</span></span><span style="display:flex;"><span>&gt; ZSCORE personLocation user2
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">4069879562983946</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景-7">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景-7">#</a></h3>
<p><strong>需要管理使用地理空间数据的场景</strong></p>
<ul>
<li>举例：附近的人。</li>
<li>相关命令: <code>GEOADD</code>、<code>GEORADIUS</code>、<code>GEORADIUSBYMEMBER</code> 。</li>
</ul>
<h2 id="总结-1">总结<a hidden class="anchor" aria-hidden="true" href="#总结-1">#</a></h2>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitmap</td>
<td>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</td>
</tr>
<tr>
<td>HyperLogLog</td>
<td>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。不过，HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> ）。</td>
</tr>
<tr>
<td>Geospatial index</td>
<td>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。</td>
</tr>
</tbody>
</table>
<h1 id="redis持久化机制详解">Redis持久化机制详解<a hidden class="anchor" aria-hidden="true" href="#redis持久化机制详解">#</a></h1>
<p>使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。</p>
<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p>
<ul>
<li>快照（snapshotting，RDB）</li>
<li>只追加文件（append-only file, AOF）</li>
<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>
</ul>
<p>官方文档地址：https://redis.io/topics/persistence 。</p>
<h2 id="rdb-持久化">RDB 持久化<a hidden class="anchor" aria-hidden="true" href="#rdb-持久化">#</a></h2>
<h3 id="什么是-rdb-持久化">什么是 RDB 持久化？<a hidden class="anchor" aria-hidden="true" href="#什么是-rdb-持久化">#</a></h3>
<p>Redis 可以通过创建快照来获得存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>save <span style="color:#ff0;font-weight:bold">900</span> <span style="color:#ff0;font-weight:bold">1</span>           #在900秒(<span style="color:#ff0;font-weight:bold">15</span>分钟)之后<span style="color:#f00">，</span>如果至少有1个key发生变化<span style="color:#f00">，</span>Redis就会自动触发bgsave命令创建快照<span style="color:#f00">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>save <span style="color:#ff0;font-weight:bold">300</span> <span style="color:#ff0;font-weight:bold">10</span>          #在300秒(<span style="color:#ff0;font-weight:bold">5</span>分钟)之后<span style="color:#f00">，</span>如果至少有10个key发生变化<span style="color:#f00">，</span>Redis就会自动触发bgsave命令创建快照<span style="color:#f00">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>save <span style="color:#ff0;font-weight:bold">60</span> <span style="color:#ff0;font-weight:bold">10000</span>        #在60秒(<span style="color:#ff0;font-weight:bold">1</span>分钟)之后<span style="color:#f00">，</span>如果至少有10000个key发生变化<span style="color:#f00">，</span>Redis就会自动触发bgsave命令创建快照<span style="color:#f00">。</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="rdb-创建快照时会阻塞主线程吗">RDB 创建快照时会阻塞主线程吗？<a hidden class="anchor" aria-hidden="true" href="#rdb-创建快照时会阻塞主线程吗">#</a></h3>
<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程；</li>
<li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>
</ul>
<blockquote>
<p>这里说 Redis 主线程而不是主进程的主要是因为 Redis 启动之后主要是通过单线程的方式完成主要的工作。如果你想将其描述为 Redis 主进程，也没毛病。</p>
</blockquote>
<h2 id="aof-持久化">AOF 持久化<a hidden class="anchor" aria-hidden="true" href="#aof-持久化">#</a></h2>
<h3 id="什么是-aof-持久化">什么是 AOF 持久化？<a hidden class="anchor" aria-hidden="true" href="#什么是-aof-持久化">#</a></h3>
<p>与快照持久化相比，AOF 持久化的实时性更好。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了），可以通过 <code>appendonly</code> 参数开启：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>appendonly yes
</span></span></code></pre></td></tr></table>
</div>
</div><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ <code>fsync</code>策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。</p>
<p>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了。</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 <code>dir</code> 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>
<h3 id="aof-工作基本流程是怎样的">AOF 工作基本流程是怎样的？<a hidden class="anchor" aria-hidden="true" href="#aof-工作基本流程是怎样的">#</a></h3>
<p>AOF 持久化功能的实现可以简单分为 5 步：</p>
<ol>
<li><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中。</li>
<li><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。</li>
<li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。</li>
<li><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>
<li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li>
</ol>
<blockquote>
<p>Linux 系统直接提供了一些函数用于对文件和设备进行访问和控制，这些函数被称为 <strong>系统调用（syscall）</strong>。</p>
</blockquote>
<p>这里对上面提到的一些 Linux 系统调用再做一遍解释：</p>
<ul>
<li><code>write</code>：写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘。虽然提高了效率，但也带来了数据丢失的风险。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I/O 缓冲区的状态。</li>
<li><code>fsync</code>：<code>fsync</code>用于强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。</li>
</ul>
<p>AOF 工作流程图如下：</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/aof-work-process.png"></p>
<h3 id="aof-持久化方式有哪些">AOF 持久化方式有哪些？<a hidden class="anchor" aria-hidden="true" href="#aof-持久化方式有哪些">#</a></h3>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>
<ol>
<li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程（ <code>aof_fsync</code> 线程）立即会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）。</li>
<li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程（ <code>aof_fsync</code> 线程）每秒钟调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</li>
<li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）。</li>
</ol>
<p>可以看出：<strong>这 3 种持久化方式的主要区别在于 <code>fsync</code> 同步 AOF 文件的时机（刷盘）</strong>。</p>
<p>为了兼顾数据和写入性能，可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能受到的影响较小。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p>从 Redis 7.0.0 开始，Redis 使用了 <strong>Multi Part AOF</strong> 机制。顾名思义，Multi Part AOF 就是将原来的单个 AOF 文件拆分成多个 AOF 文件。在 Multi Part AOF 中，AOF 文件被分为三种类型，分别为：</p>
<ul>
<li>BASE：表示基础 AOF 文件，它一般由子进程通过重写产生，该文件最多只有一个。</li>
<li>INCR：表示增量 AOF 文件，它一般会在 AOFRW 开始执行时被创建，该文件可能存在多个。</li>
<li>HISTORY：表示历史 AOF 文件，它由 BASE 和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis 自动删除。</li>
</ul>
<p>Multi Part AOF 不是重点，了解即可，详细介绍可以看看阿里开发者的<a href="https://zhuanlan.zhihu.com/p/467217082">Redis 7.0 Multi Part AOF 的设计和实现</a> 这篇文章。</p>
<p><strong>相关 issue</strong>：<a href="https://github.com/Snailclimb/JavaGuide/issues/783">Redis 的 AOF 方式 #783</a>。</p>
<h3 id="aof-为什么是在执行完命令之后记录日志">AOF 为什么是在执行完命令之后记录日志？<a hidden class="anchor" aria-hidden="true" href="#aof-为什么是在执行完命令之后记录日志">#</a></h3>
<p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-aof-write-log-disc.png"></p>
<p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ul>
<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>
<ul>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li>
</ul>
<h3 id="aof-重写了解吗">AOF 重写了解吗？<a hidden class="anchor" aria-hidden="true" href="#aof-重写了解吗">#</a></h3>
<p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/aof-rewrite.png"></p>
<blockquote>
<p>AOF 重写（rewrite） 是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p>
</blockquote>
<p>由于 AOF 重写会进行大量的写入操作，为了避免对 Redis 正常处理命令请求造成影响，Redis 将 AOF 重写程序放到子进程里执行。</p>
<p>AOF 文件重写期间，Redis 还会维护一个 <strong>AOF 重写缓冲区</strong>，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>
<p>开启 AOF 重写功能，可以调用 <code>BGREWRITEAOF</code> 命令手动执行，也可以设置下面两个配置项，让程序自动决定触发时机：</p>
<ul>
<li><code>auto-aof-rewrite-min-size</code>：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;</li>
<li><code>auto-aof-rewrite-percentage</code>：执行 AOF 重写时，当前 AOF 大小（aof_current_size）和上一次重写时 AOF 大小（aof_base_size）的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。</li>
</ul>
<p>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</p>
<p>Redis 7.0 版本之后，AOF 重写机制得到了优化改进。下面这段内容摘自阿里开发者的<a href="https://mp.weixin.qq.com/s/RnoPPL7jiFSKkx3G4p57Pg">从 Redis7.0 发布看 Redis 的过去与未来</a> 这篇文章。</p>
<blockquote>
<p>AOF 重写期间的增量数据如何处理一直是个问题，在过去写期间的增量数据需要在内存中保留，写结束后再把这部分增量数据写入新的 AOF 文件中以保证数据完整性。可以看出来 AOF 写会额外消耗内存和磁盘 IO，这也是 Redis AOF 写的痛点，虽然之前也进行过多次改进但是资源消耗的本质问题一直没有解决。</p>
<p>阿里云的 Redis 企业版在最初也遇到了这个问题，在内部经过多次迭代开发，实现了 Multi-part AOF 机制来解决，同时也贡献给了社区并随此次 7.0 发布。具体方法是采用 base（全量数据）+inc（增量数据）独立文件存储的方式，彻底解决内存和 IO 资源的浪费，同时也支持对历史 AOF 文件的保存管理，结合 AOF 文件中的时间信息还可以实现 PITR 按时间点恢复（阿里云企业版 Tair 已支持），这进一步增强了 Redis 的数据可靠性，满足用户数据回档等需求。</p>
</blockquote>
<p><strong>相关 issue</strong>：<a href="https://github.com/Snailclimb/JavaGuide/issues/1439">Redis AOF 重写描述不准确 #1439</a>。</p>
<h3 id="aof-校验机制了解吗">AOF 校验机制了解吗？<a hidden class="anchor" aria-hidden="true" href="#aof-校验机制了解吗">#</a></h3>
<p>AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 <strong>校验和（checksum）</strong> 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。</p>
<p>类似地，RDB 文件也有类似的校验机制来保证 RDB 文件的正确性，这里就不重复进行介绍了。</p>
<h2 id="redis-40-对于持久化机制做了什么优化">Redis 4.0 对于持久化机制做了什么优化？<a hidden class="anchor" aria-hidden="true" href="#redis-40-对于持久化机制做了什么优化">#</a></h2>
<p>由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<p>官方文档地址：https://redis.io/topics/persistence</p>
<h2 id="如何选择-rdb-和-aof">如何选择 RDB 和 AOF？<a hidden class="anchor" aria-hidden="true" href="#如何选择-rdb-和-aof">#</a></h2>
<p>关于 RDB 和 AOF 的优缺点，官网上面也给了比较详细的说明<a href="https://redis.io/docs/manual/persistence/">Redis persistence</a>，这里结合自己的理解简单总结一下。</p>
<p><strong>RDB 比 AOF 优秀的地方</strong>：</p>
<ul>
<li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li>
<li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li>
</ul>
<p><strong>AOF 比 RDB 优秀的地方</strong>：</p>
<ul>
<li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li>
<li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li>
<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li>
</ul>
<p><strong>综上</strong>：</p>
<ul>
<li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li>
<li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li>
<li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li>
</ul>
<h1 id="redis内存碎片详解">Redis内存碎片详解<a hidden class="anchor" aria-hidden="true" href="#redis内存碎片详解">#</a></h1>
<h2 id="什么是内存碎片">什么是内存碎片?<a hidden class="anchor" aria-hidden="true" href="#什么是内存碎片">#</a></h2>
<p>你可以将内存碎片简单地理解为那些不可用的空闲内存。</p>
<p>举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/memory-fragmentation.png"></p>
<p>Redis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。</p>
<h2 id="为什么会有-redis-内存碎片">为什么会有 Redis 内存碎片?<a hidden class="anchor" aria-hidden="true" href="#为什么会有-redis-内存碎片">#</a></h2>
<p>Redis 内存碎片产生比较常见的 2 个原因：</p>
<p><strong>1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</strong></p>
<p>以下是这段 Redis 官方的原话：</p>
<blockquote>
<p>To store user keys, Redis allocates at most as much memory as the <code>maxmemory</code> setting enables (however there are small extra allocations possible).</p>
</blockquote>
<p>Redis 使用 <code>zmalloc</code> 方法(Redis 自己实现的内存分配方法)进行内存分配的时候，除了要分配 <code>size</code> 大小的内存之外，还会多分配 <code>PREFIX_SIZE</code> 大小的内存。</p>
<p><code>zmalloc</code> 方法源码如下（源码地址：https://github.com/antirez/redis-tools/blob/master/zmalloc.c）：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> *zmalloc(size_t size) {
</span></span><span style="display:flex;"><span>   <span style="color:#007f7f">// 分配指定大小的内存</span>
</span></span><span style="display:flex;"><span>   <span style="color:#fff;font-weight:bold">void</span> *ptr = malloc(size+PREFIX_SIZE);
</span></span><span style="display:flex;"><span>   <span style="color:#fff;font-weight:bold">if</span> (!ptr) zmalloc_oom_handler(size);
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>ifdef HAVE_MALLOC_SIZE
</span></span><span style="display:flex;"><span>   update_zmalloc_stat_alloc(zmalloc_size(ptr));
</span></span><span style="display:flex;"><span>   <span style="color:#fff;font-weight:bold">return</span> ptr;
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span><span style="color:#fff;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>   *((size_t*)ptr) = size;
</span></span><span style="display:flex;"><span>   update_zmalloc_stat_alloc(size+PREFIX_SIZE);
</span></span><span style="display:flex;"><span>   <span style="color:#fff;font-weight:bold">return</span> (<span style="color:#fff;font-weight:bold">char</span>*)ptr+PREFIX_SIZE;
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>endif
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外，Redis 可以使用多种内存分配器来分配内存（ libc、jemalloc、tcmalloc），默认使用 <a href="https://github.com/jemalloc/jemalloc">jemalloc</a>，而 jemalloc 按照一系列固定的大小（8 字节、16 字节、32 字节&hellip;&hellip;）来分配内存的。jemalloc 划分的内存单元如下图所示：</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/6803d3929e3e46c1b1c9d0bb9ee8e717.png"></p>
<p>当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间，就比如说程序需要申请 17 字节的内存，jemalloc 会直接给它分配 32 字节的内存，这样会导致有 15 字节内存的浪费。不过，jemalloc 专门针对内存碎片问题做了优化，一般不会存在过度碎片化的问题。</p>
<p><strong>2、频繁修改 Redis 中的数据也会产生内存碎片。</strong></p>
<p>当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。</p>
<p>这个在 Redis 官方文档中也有对应的原话:</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-docs-memory-optimization.png"></p>
<p>文档地址：https://redis.io/topics/memory-optimization 。</p>
<h2 id="如何查看-redis-内存碎片的信息">如何查看 Redis 内存碎片的信息？<a hidden class="anchor" aria-hidden="true" href="#如何查看-redis-内存碎片的信息">#</a></h2>
<p>使用 <code>info memory</code> 命令即可查看 Redis 内存相关的信息。下图中每个参数具体的含义，Redis 官方文档有详细的介绍：https://redis.io/commands/INFO 。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-info-memory.png"></p>
<p>Redis 内存碎片率的计算公式：<code>mem_fragmentation_ratio</code> （内存碎片率）= <code>used_memory_rss</code> (操作系统实际分配给 Redis 的物理内存空间大小)/ <code>used_memory</code>(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)</p>
<p>也就是说，<code>mem_fragmentation_ratio</code> （内存碎片率）的值越大代表内存碎片率越严重。</p>
<p>一定不要误认为<code>used_memory_rss</code> 减去 <code>used_memory</code>值就是内存碎片的大小！！！这不仅包括内存碎片，还包括其他进程开销，以及共享库、堆栈等的开销。</p>
<p>很多小伙伴可能要问了：“多大的内存碎片率才是需要清理呢？”。</p>
<p>通常情况下，我们认为 <code>mem_fragmentation_ratio &gt; 1.5</code> 的话才需要清理内存碎片。 <code>mem_fragmentation_ratio &gt; 1.5</code> 意味着你使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存。</p>
<p>如果想要快速查看内存碎片率的话，你还可以通过下面这个命令：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; redis-cli -p <span style="color:#ff0;font-weight:bold">6379</span> info | grep mem_fragmentation_ratio
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外，内存碎片率可能存在小于 1 的情况。这种情况我在日常使用中还没有遇到过，感兴趣的小伙伴可以看看这篇文章 <a href="https://mp.weixin.qq.com/s/drlDvp7bfq5jt2M5pTqJCw">故障分析 | Redis 内存碎片率太低该怎么办？- 爱可生开源社区</a> 。</p>
<h2 id="如何清理-redis-内存碎片">如何清理 Redis 内存碎片？<a hidden class="anchor" aria-hidden="true" href="#如何清理-redis-内存碎片">#</a></h2>
<p>Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。</p>
<p>直接通过 <code>config set</code> 命令将 <code>activedefrag</code> 配置项设置为 <code>yes</code> 即可。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>config <span style="color:#fff;font-weight:bold">set</span> activedefrag yes
</span></span></code></pre></td></tr></table>
</div>
</div><p>具体什么时候清理需要通过下面两个参数控制：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 内存碎片占用空间达到 500mb 的时候开始清理</span>
</span></span><span style="display:flex;"><span>config <span style="color:#fff;font-weight:bold">set</span> active-defrag-ignore-bytes 500mb
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 内存碎片率大于 1.5 的时候开始清理</span>
</span></span><span style="display:flex;"><span>config <span style="color:#fff;font-weight:bold">set</span> active-defrag-threshold-lower <span style="color:#ff0;font-weight:bold">50</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，我们可以通过下面两个参数来减少对 Redis 性能的影响：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 内存碎片清理所占用 CPU 时间的比例不低于 20%</span>
</span></span><span style="display:flex;"><span>config <span style="color:#fff;font-weight:bold">set</span> active-defrag-cycle-min <span style="color:#ff0;font-weight:bold">20</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 内存碎片清理所占用 CPU 时间的比例不高于 50%</span>
</span></span><span style="display:flex;"><span>config <span style="color:#fff;font-weight:bold">set</span> active-defrag-cycle-max <span style="color:#ff0;font-weight:bold">50</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外，重启节点可以做到内存碎片重新整理。如果你采用的是高可用架构的 Redis 集群的话，你可以将碎片率过高的主节点转换为从节点，以便进行安全重启。</p>
<h1 id="redis常见阻塞原因总结">Redis常见阻塞原因总结<a hidden class="anchor" aria-hidden="true" href="#redis常见阻塞原因总结">#</a></h1>
<h2 id="on-命令">O(n) 命令<a hidden class="anchor" aria-hidden="true" href="#on-命令">#</a></h2>
<p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：</p>
<ul>
<li><code>KEYS *</code>：会返回所有符合规则的 key。</li>
<li><code>HGETALL</code>：会返回一个 Hash 中所有的键值对。</li>
<li><code>LRANGE</code>：会返回 List 中指定范围内的元素。</li>
<li><code>SMEMBERS</code>：返回 Set 中的所有元素。</li>
<li><code>SINTER</code>/<code>SUNION</code>/<code>SDIFF</code>：计算多个 Set 的交集/并集/差集。</li>
<li>&hellip;&hellip;</li>
</ul>
<p>由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长，从而导致客户端阻塞。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</p>
<p>除了这些 O(n)时间复杂度的命令可能会导致阻塞之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：</p>
<ul>
<li><code>ZRANGE</code>/<code>ZREVRANGE</code>：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>
<li><code>ZREMRANGEBYRANK</code>/<code>ZREMRANGEBYSCORE</code>：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>
<li>&hellip;&hellip;</li>
</ul>
<h2 id="save-创建-rdb-快照">SAVE 创建 RDB 快照<a hidden class="anchor" aria-hidden="true" href="#save-创建-rdb-快照">#</a></h2>
<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程；</li>
<li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>
</ul>
<p>默认情况下，Redis 默认配置会使用 <code>bgsave</code> 命令。如果手动使用 <code>save</code> 命令生成 RDB 快照文件的话，就会阻塞主线程。</p>
<h2 id="aof">AOF<a hidden class="anchor" aria-hidden="true" href="#aof">#</a></h2>
<h3 id="aof-日志记录阻塞">AOF 日志记录阻塞<a hidden class="anchor" aria-hidden="true" href="#aof-日志记录阻塞">#</a></h3>
<p>Redis AOF 持久化机制是在执行完命令之后再记录日志，这和关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复）不同。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-aof-write-log-disc.png"></p>
<p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ul>
<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>
<ul>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li><strong>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）</strong>。</li>
</ul>
<h3 id="aof-刷盘阻塞">AOF 刷盘阻塞<a hidden class="anchor" aria-hidden="true" href="#aof-刷盘阻塞">#</a></h3>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>
<ol>
<li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程（ <code>aof_fsync</code> 线程）立即会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）。</li>
<li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程（ <code>aof_fsync</code> 线程）每秒钟调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</li>
<li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）。</li>
</ol>
<p>当后台线程（ <code>aof_fsync</code> 线程）调用 <code>fsync</code> 函数同步 AOF 文件时，需要等待，直到写入完成。当磁盘压力太大的时候，会导致 <code>fsync</code> 操作发生阻塞，主线程调用 <code>write</code> 函数时也会被阻塞。<code>fsync</code> 完成后，主线程执行 <code>write</code> 才能成功返回。</p>
<p>关于 AOF 工作流程的详细介绍可以查看：<a href="/">Redis 持久化机制详解</a>，有助于理解 AOF 刷盘阻塞。</p>
<h3 id="aof-重写阻塞">AOF 重写阻塞<a hidden class="anchor" aria-hidden="true" href="#aof-重写阻塞">#</a></h3>
<ol>
<li>fork 出一条子线程来将文件重写，在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子线程创建新 AOF 文件期间，记录服务器执行的所有写命令。</li>
<li>当子线程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。</li>
<li>最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</li>
</ol>
<p>阻塞就是出现在第 2 步的过程中，将缓冲区中新数据写到新文件的过程中会产生<strong>阻塞</strong>。</p>
<p>相关阅读：<a href="https://cloud.tencent.com/developer/article/1633077">Redis AOF 重写阻塞问题分析</a>。</p>
<h2 id="大-key">大 Key<a hidden class="anchor" aria-hidden="true" href="#大-key">#</a></h2>
<p>如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p>
<p>大 key 造成的阻塞问题如下：</p>
<ul>
<li>客户端超时阻塞：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
<li>引发网络阻塞：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li>阻塞工作线程：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
</ul>
<h3 id="查找大-key">查找大 key<a hidden class="anchor" aria-hidden="true" href="#查找大-key">#</a></h3>
<p>当我们在使用 Redis 自带的 <code>--bigkeys</code> 参数查找大 key 时，最好选择在从节点上执行该命令，因为主节点上执行时，会<strong>阻塞</strong>主节点。</p>
<ul>
<li>我们还可以使用 SCAN 命令来查找大 key；</li>
<li>通过分析 RDB 文件来找出 big key，这种方案的前提是 Redis 采用的是 RDB 持久化。网上有现成的工具：</li>
<li>
<ul>
<li>redis-rdb-tools：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>
<li>rdb_bigkeys：Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>
</ul>
</li>
</ul>
<h3 id="删除大-key">删除大 key<a hidden class="anchor" aria-hidden="true" href="#删除大-key">#</a></h3>
<p>删除操作的本质是要释放键值对占用的内存空间。</p>
<p>释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，<strong>操作系统需要把释放掉的内存块插入一个空闲内存块的链表</strong>，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会<strong>阻塞</strong>当前释放内存的应用程序。</p>
<p>所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。</p>
<p>删除大 key 时建议采用分批次删除和异步删除的方式进行。</p>
<h2 id="清空数据库">清空数据库<a hidden class="anchor" aria-hidden="true" href="#清空数据库">#</a></h2>
<p>清空数据库和上面 bigkey 删除也是同样道理，<code>flushdb</code>、<code>flushall</code> 也涉及到删除和释放所有的键值对，也是 Redis 的阻塞点。</p>
<h2 id="集群扩容">集群扩容<a hidden class="anchor" aria-hidden="true" href="#集群扩容">#</a></h2>
<p>Redis 集群可以进行节点的动态扩容缩容，这一过程目前还处于半自动状态，需要人工介入。</p>
<p>在扩缩容的时候，需要进行数据迁移。而 Redis 为了保证迁移的一致性，迁移所有操作都是同步操作。</p>
<p>执行迁移时，两端的 Redis 均会进入时长不等的阻塞状态，对于小 Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，严重的时候会触发集群内的故障转移，造成不必要的切换。</p>
<h2 id="swap内存交换">Swap（内存交换）<a hidden class="anchor" aria-hidden="true" href="#swap内存交换">#</a></h2>
<p><strong>什么是 Swap？</strong> Swap 直译过来是交换的意思，Linux 中的 Swap 常被称为内存交换或者交换分区。类似于 Windows 中的虚拟内存，就是当内存不足的时候，把一部分硬盘空间虚拟成内存使用，从而解决内存容量不足的情况。因此，Swap 分区的作用就是牺牲硬盘，增加内存，解决 VPS 内存不够用或者爆满的问题。</p>
<p>Swap 对于 Redis 来说是非常致命的，Redis 保证高性能的一个重要前提是所有的数据在内存中。如果操作系统把 Redis 使用的部分内存换出硬盘，由于内存与硬盘读写的速度并几个数量级，会导致发生交换后的 Redis 性能急剧下降。</p>
<p>识别 Redis 发生 Swap 的检查方法如下：</p>
<p>1、查询 Redis 进程号</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>reids-cli -p <span style="color:#ff0;font-weight:bold">6383</span> info server | grep process_id
</span></span><span style="display:flex;"><span>process_id: <span style="color:#ff0;font-weight:bold">4476</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>2、根据进程号查询内存交换信息</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat /proc/4476/smaps | grep Swap
</span></span><span style="display:flex;"><span>Swap: 0kB
</span></span><span style="display:flex;"><span>Swap: 0kB
</span></span><span style="display:flex;"><span>Swap: 4kB
</span></span><span style="display:flex;"><span>Swap: 0kB
</span></span><span style="display:flex;"><span>Swap: 0kB
</span></span><span style="display:flex;"><span>.....
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果交换量都是 0KB 或者个别的是 4KB，则正常。</p>
<p>预防内存交换的方法：</p>
<ul>
<li>保证机器充足的可用内存</li>
<li>确保所有 Redis 实例设置最大可用内存(maxmemory)，防止极端情况 Redis 内存不可控的增长</li>
<li>降低系统使用 swap 优先级，如<code>echo 10 &gt; /proc/sys/vm/swappiness</code></li>
</ul>
<h2 id="cpu-竞争">CPU 竞争<a hidden class="anchor" aria-hidden="true" href="#cpu-竞争">#</a></h2>
<p>Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。</p>
<p>可以通过<code>reids-cli --stat</code>获取当前 Redis 使用情况。通过<code>top</code>命令获取进程对 CPU 的利用率等信息 通过<code>info commandstats</code>统计信息分析出命令不合理开销时间，查看是否是因为高算法复杂度或者过度的内存优化问题。</p>
<h2 id="网络问题">网络问题<a hidden class="anchor" aria-hidden="true" href="#网络问题">#</a></h2>
<p>连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。</p>
<h1 id="redis大key处理">redis大key处理<a hidden class="anchor" aria-hidden="true" href="#redis大key处理">#</a></h1>
<h2 id="怎么才算大key">怎么才算大key<a hidden class="anchor" aria-hidden="true" href="#怎么才算大key">#</a></h2>
<p>大key 并不是指 key 的值很大，而是 key 对应的 value 很大（非常占内存）。一个key对应的value所占用的内存比较大，那么这个key就可以看作是 bigkey 。</p>
<ul>
<li>单个String类型的Key大小达到20KB并且OPS高</li>
<li>key本身的数据过大。例如，一个string类型的key，value为5MB。</li>
<li>key中的元素过多。例如，一个zset类型的key，元素超过10000个。</li>
<li>key中元素的数据过大。例如，一个Hash类型的key，元素只有500个，但是这些元素的value的总大小为100MB。</li>
</ul>
<h2 id="大key的影响">大KEY的影响<a hidden class="anchor" aria-hidden="true" href="#大key的影响">#</a></h2>
<p>知道了大key的定义，那么我们也得知道大key的带来的影响：</p>
<ul>
<li><strong>客户端超时阻塞：</strong> Redis 执行命令是单线程处理，然后在大 key处理时会比较耗时，那么就会发生阻塞 ，期间就会各种业务超时出现。</li>
<li><strong>引发网络阻塞：</strong> 每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于服务器来说是灾难性的。</li>
<li><strong>阻塞工作线程：</strong> 如果使用 del 删除大 key 时，会阻塞工作线程，无法处理后续的命令。</li>
<li><strong>内存分布不均：</strong> 集群各分片内存使用不均。某个分片占用内存较高或OOM，发送缓存区增大等，导致该分片其他Key被逐出，同时也会造成其他分片的资源浪费。</li>
</ul>
<h2 id="如何发现大key">如何发现大key<a hidden class="anchor" aria-hidden="true" href="#如何发现大key">#</a></h2>
<h3 id="使用redis提供的命令">使用redis提供的命令<a hidden class="anchor" aria-hidden="true" href="#使用redis提供的命令">#</a></h3>
<p>第一种：这个命令会扫描redis的所有key，对性能有影响，而且只能找出每种数据类型内存占用最大的key。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>redis-cli -p 6379 --bigkeys
</span></span></code></pre></td></tr></table>
</div>
</div><p>第二种：查看置顶key的内存占用</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>memory usage key名字
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="使用第三方工具">使用第三方工具<a hidden class="anchor" aria-hidden="true" href="#使用第三方工具">#</a></h3>
<ul>
<li><a href="https://github.com/sripathikrishnan/redis-rdb-tools">https://github.com/sripathikrishnan/redis-rdb-tools</a></li>
<li><a href="https://github.com/weiyanwei412/rdb_bigkeys">https://github.com/weiyanwei412/rdb_bigkeys</a></li>
<li>云服务内提供的可视化分析工具</li>
</ul>
<h3 id="bash脚本">bash脚本<a hidden class="anchor" aria-hidden="true" href="#bash脚本">#</a></h3>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span># 遍历所有 Key，并筛选出内存占用超过 1MB 的 Key
</span></span><span style="display:flex;"><span>redis-cli --scan | while read key; do
</span></span><span style="display:flex;"><span>    size=$(redis-cli MEMORY USAGE $key)
</span></span><span style="display:flex;"><span>    if [ &#34;$size&#34; -gt 1048576 ]; then
</span></span><span style="display:flex;"><span>        echo &#34;Big Key: $key, Size: $size bytes&#34;
</span></span><span style="display:flex;"><span>    fi
</span></span><span style="display:flex;"><span>done
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="如何解决大key问题">如何解决大key问题<a hidden class="anchor" aria-hidden="true" href="#如何解决大key问题">#</a></h2>
<h3 id="设计阶段避免-big-key">设计阶段避免 Big Key<a hidden class="anchor" aria-hidden="true" href="#设计阶段避免-big-key">#</a></h3>
<table>
<thead>
<tr>
<th>设计原则</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>拆分大数据</strong></td>
<td>将单个大 JSON 拆分为多个小字段存储</td>
</tr>
<tr>
<td><strong>合理选择数据类型</strong></td>
<td>使用 Hash 替代大字符串，便于分片和访问</td>
</tr>
<tr>
<td><strong>限制 Key 的大小</strong></td>
<td>通过业务逻辑限制 Key 的数据量，例如限制 List 元素数量</td>
</tr>
</tbody>
</table>
<h3 id="优化-big-key-的操作">优化 Big Key 的操作<a hidden class="anchor" aria-hidden="true" href="#优化-big-key-的操作">#</a></h3>
<table>
<thead>
<tr>
<th>操作</th>
<th>优化措施</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>删除 Big Key</strong></td>
<td>1. 分批次删除: <code>hscan</code>、<code>ltrim</code>、<code>sscan</code>指令分批次进行删除  <br>2. 异步删除: 使用 <code>UNLINK</code> 替代 <code>DEL</code>，异步删除减少阻塞：<code>UNLINK bigkey</code>；</td>
</tr>
<tr>
<td><strong>逐步迁移</strong></td>
<td>对大数据结构（如 List、Set）分批迁移或处理： <code>LRANGE</code> + <code>LTRIM</code></td>
</tr>
<tr>
<td><strong>监控访问/内存</strong></td>
<td>1. 避免对大对象使用全量操作（如 <code>HGETALL</code>、<code>SMEMBERS</code>），改用局部操作：<code>HSCAN</code>、<code>SSCAN</code>  <br>  <br>2. 可通过监控系统设置合理 Redis 内存报警阈值，如内存使用率超 70%、1 小时内内存增长率超 20%等进行提醒。</td>
</tr>
<tr>
<td><strong>开启 lazy-free 惰性删除/延迟释放</strong></td>
<td>值得是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="历史key未使用">历史key未使用<a hidden class="anchor" aria-hidden="true" href="#历史key未使用">#</a></h3>
<p>针对这种key场景，其实存在着历史原因，可能是伴随着某个业务下线或者不使用，往往对应实现的缓存操作代码会删除，但是对于缓存数据往往不会做任何处理，久而久之，这种脏数据会一直堆积，占用着资源。那么如果确定已经无使用，并且可以确认有持久化数据（如mysql、es等）备份的话，可以直接将对应key删除。</p>
<h3 id="元素数过多">元素数过多<a hidden class="anchor" aria-hidden="true" href="#元素数过多">#</a></h3>
<p>针对于Set、Hash这种场景，如果元素数量超过5000就视为大的key。如果对应value值不大，我们可以采取平铺的形式，</p>
<p>比如系统内历史的设计是存储下每个品牌对应的名称，那么就设置了统一的key，然后不同的品牌id作为fild，操作了hSet和hGet来存储获取数据，降低查询外围服务的频率。但是随着品牌数量的增长，导致元素逐步增多，元素个数就超过了大key的预设值了。这种根据场景，我们其实存储本身只有一个品牌名称，那么我们就针对于品牌id对应加上一个统一前缀作为唯一key，采用平铺方式缓存对应数据即可。针对这种数据的替换，我这里也总结了下具体要实现的步骤：</p>
<p>第一步：修改代码查询和赋值逻辑：</p>
<ol>
<li>把原始的hGet的逻辑修改为get获取；</li>
<li>把原始hSet的逻辑修改为set赋值。</li>
</ol>
<p>第二步：历史数据刷新到新缓存key：</p>
<p>为了避免上线之后出现缓存雪崩，因为替换了新的key，我们需要通过现有的HASH的数据刷新到新的缓存中，所以需要历史数据处理。</p>
<p>通过hGetAll获取所以元素数据，循环缓存元素数据操作存储新的缓存key和value。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> String refreshHistoryData(){
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>        String key = <span style="color:#0ff;font-weight:bold">&#34;historyKey&#34;</span>;
</span></span><span style="display:flex;"><span>        Map&lt;String, String&gt; redisInfoMap= redisUtils.<span style="color:#007f7f">hGetAll</span>(key);
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (redisInfoMap.<span style="color:#007f7f">isEmpty</span>()){
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span> <span style="color:#0ff;font-weight:bold">&#34;查询缓存无数据&#34;</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span> (Map.<span style="color:#007f7f">Entry</span>&lt;String, String&gt; entry : redisInfoMap.<span style="color:#007f7f">entrySet</span>()) {
</span></span><span style="display:flex;"><span>            String redisVal = entry.<span style="color:#007f7f">getValue</span>();
</span></span><span style="display:flex;"><span>            String filedKey = entry.<span style="color:#007f7f">getKey</span>();
</span></span><span style="display:flex;"><span>            String newDataRedisKey = <span style="color:#0ff;font-weight:bold">&#34;newDataKey&#34;</span>+filedKey;
</span></span><span style="display:flex;"><span>            redisUtils.<span style="color:#007f7f">set</span>(newDataRedisKey,redisVal);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#0ff;font-weight:bold">&#34;success&#34;</span>;
</span></span><span style="display:flex;"><span>    }<span style="color:#fff;font-weight:bold">catch</span> (Exception e){
</span></span><span style="display:flex;"><span>        LOG.<span style="color:#007f7f">error</span>(<span style="color:#0ff;font-weight:bold">&#34;refreshHistoryData 异常:&#34;</span>,e);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#0ff;font-weight:bold">&#34;failed&#34;</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：这里一定要先刷历史数据，再上线代码业务逻辑的修改。防止引发缓存雪崩。</p>
<h3 id="大对象转换存储形式">大对象转换存储形式<a hidden class="anchor" aria-hidden="true" href="#大对象转换存储形式">#</a></h3>
<p>复杂的大对象可以尝试将对象分拆成几个key-value， 使用mGet和mSet操作对应值或者pipeline的形式，最后拼装成需要返回的大对象。这样意义在于可以分散单次操作的压力，将操作压力平摊到多个redis实例中，降低对单个redis的IO影响。</p>
<p>这里以系统内订单对象为例：订单对象Order基础属性有几十个，如订单号、金额、时间、类型等，除此之外还要包含订单下的商品OrderSub、预售信息PresaleOrder、发票信息OrderInvoice、订单时效OrderPremiseInfo、订单轨迹OrderTrackInfo、订单详细费用OrderFee等信息。</p>
<p>那么对于每个订单相关信息，我们可以设置为单独的key，把订单信息和几个相关的关联数据每个按照单独key存储，接着通过mGet方式获取每个信息之后，最后封装成整体Order对象。下面仅展示关键伪代码以mSet和mGet实现。</p>
<p><strong>缓存定义：</strong></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">46
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">47
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">48
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">49
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">50
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">51
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">52
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">53
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">54
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">55
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">56
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">57
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">58
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">59
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">60
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">61
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">62
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">63
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">64
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">enum</span> CacheKeyConstant {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     * 订单基础缓存key
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     */</span>
</span></span><span style="display:flex;"><span>    REDIS_ORDER_BASE_INFO(<span style="color:#0ff;font-weight:bold">&#34;ORDER_BASE_INFO&#34;</span>),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     * 订单商品缓存key
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     */</span>
</span></span><span style="display:flex;"><span>    ORDER_SUB_INFO(<span style="color:#0ff;font-weight:bold">&#34;ORDER_SUB_INFO&#34;</span>),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     * 订单预售信息缓存key
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     */</span>
</span></span><span style="display:flex;"><span>    ORDER_PRESALE_INFO(<span style="color:#0ff;font-weight:bold">&#34;ORDER_PRESALE_INFO&#34;</span>),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     * 订单履约信息缓存key
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     */</span>
</span></span><span style="display:flex;"><span>    ORDER_PREMISE_INFO(<span style="color:#0ff;font-weight:bold">&#34;ORDER_PREMISE_INFO&#34;</span>),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     * 订单发票信息缓存key
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     */</span>
</span></span><span style="display:flex;"><span>    ORDER_INVOICE_INFO(<span style="color:#0ff;font-weight:bold">&#34;ORDER_INVOICE_INFO&#34;</span>),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     * 订单轨迹信息缓存key
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     */</span>
</span></span><span style="display:flex;"><span>    ORDER_TRACK_INFO(<span style="color:#0ff;font-weight:bold">&#34;ORDER_TRACK_INFO&#34;</span>),
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     * 订单详细费用信息缓存key
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     */</span>
</span></span><span style="display:flex;"><span>    ORDER_FEE_INFO(<span style="color:#0ff;font-weight:bold">&#34;ORDER_FEE_INFO&#34;</span>),
</span></span><span style="display:flex;"><span>    ;
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     * 前缀
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">private</span> String prefix;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     * 项目统一前缀
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f">     */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">final</span> String COMMON_PREFIX = <span style="color:#0ff;font-weight:bold">&#34;XXX&#34;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    CacheKeyConstant(String prefix){
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">this</span>.<span style="color:#007f7f">prefix</span> = prefix;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> String getPrefix(String subKey) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span>(StringUtil.<span style="color:#007f7f">isNotEmpty</span>(subKey)){
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">return</span> COMMON_PREFIX + prefix + <span style="color:#0ff;font-weight:bold">&#34;_&#34;</span> + subKey;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> COMMON_PREFIX + prefix;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">public</span> String getPrefix() {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> COMMON_PREFIX + prefix;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>缓存存储：</strong></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * @description 刷新订单到缓存
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * @param order 订单信息
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">boolean</span> refreshOrderToCache(Order order){
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span>(order == <span style="color:#fff;font-weight:bold">null</span> || order.<span style="color:#007f7f">getOrderId</span>() == <span style="color:#fff;font-weight:bold">null</span>){
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> ;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    String orderId = order.<span style="color:#007f7f">getOrderId</span>().<span style="color:#007f7f">toString</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//设置存储缓存数据</span>
</span></span><span style="display:flex;"><span>    Map&lt;String,String&gt; cacheOrderMap = <span style="color:#fff;font-weight:bold">new</span> HashMap&lt;&gt;(16);
</span></span><span style="display:flex;"><span>    cacheOrderMap.<span style="color:#007f7f">put</span>(CacheKeyConstant.<span style="color:#007f7f">ORDER_BASE_INFO</span>.<span style="color:#007f7f">getPrefix</span>(orderId), JSON.<span style="color:#007f7f">toJSONString</span>(buildBaseOrderVo(order)));
</span></span><span style="display:flex;"><span>    cacheOrderMap.<span style="color:#007f7f">put</span>(CacheKeyConstant.<span style="color:#007f7f">ORDER_SUB_INFO</span>.<span style="color:#007f7f">getPrefix</span>(orderId), JSON.<span style="color:#007f7f">toJSONString</span>(order.<span style="color:#007f7f">getCustomerOrderSubs</span>()));
</span></span><span style="display:flex;"><span>    cacheOrderMap.<span style="color:#007f7f">put</span>(CacheKeyConstant.<span style="color:#007f7f">ORDER_PRESALE_INFO</span>.<span style="color:#007f7f">getPrefix</span>(orderId), JSON.<span style="color:#007f7f">toJSONString</span>(order.<span style="color:#007f7f">getPresaleOrderData</span>()));
</span></span><span style="display:flex;"><span>    cacheOrderMap.<span style="color:#007f7f">put</span>(CacheKeyConstant.<span style="color:#007f7f">ORDER_INVOICE_INFO</span>.<span style="color:#007f7f">getPrefix</span>(orderId), JSON.<span style="color:#007f7f">toJSONString</span>(order.<span style="color:#007f7f">getOrderInvoice</span>()));
</span></span><span style="display:flex;"><span>    cacheOrderMap.<span style="color:#007f7f">put</span>(CacheKeyConstant.<span style="color:#007f7f">ORDER_TRACK_INFO</span>.<span style="color:#007f7f">getPrefix</span>(orderId), JSON.<span style="color:#007f7f">toJSONString</span>(order.<span style="color:#007f7f">getOrderTrackInfo</span>()));
</span></span><span style="display:flex;"><span>    cacheOrderMap.<span style="color:#007f7f">put</span>(CacheKeyConstant.<span style="color:#007f7f">ORDER_PREMISE_INFO</span>.<span style="color:#007f7f">getPrefix</span>(orderId), JSON.<span style="color:#007f7f">toJSONString</span>( order.<span style="color:#007f7f">getPresaleOrderData</span>()));
</span></span><span style="display:flex;"><span>    cacheOrderMap.<span style="color:#007f7f">put</span>(CacheKeyConstant.<span style="color:#007f7f">ORDER_FEE_INFO</span>.<span style="color:#007f7f">getPrefix</span>(orderId), JSON.<span style="color:#007f7f">toJSONString</span>(order.<span style="color:#007f7f">getOrderFeeVo</span>()));
</span></span><span style="display:flex;"><span>    superRedisUtils.<span style="color:#007f7f">mSetString</span>(cacheOrderMap);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>缓存获取：</strong></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">46
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">47
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">48
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">49
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">50
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">51
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">52
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">53
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">54
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">55
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">56
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">57
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">58
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">59
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">60
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">61
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * @description 通过订单号获取缓存数据
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * @param orderId 订单号
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * @return Order 订单实体信息
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> Order getOrderFromCache(String orderId){
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span>(StringUtils.<span style="color:#007f7f">isBlank</span>(orderId)){
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//定义查询缓存集合key</span>
</span></span><span style="display:flex;"><span>    List&lt;String&gt; queryOrderKey = Arrays.<span style="color:#007f7f">asList</span>(CacheKeyConstant.<span style="color:#007f7f">ORDER_BASE_INFO</span>.<span style="color:#007f7f">getPrefix</span>(orderId),CacheKeyConstant.<span style="color:#007f7f">ORDER_SUB_INFO</span>.<span style="color:#007f7f">getPrefix</span>(orderId),
</span></span><span style="display:flex;"><span>                                               CacheKeyConstant.<span style="color:#007f7f">ORDER_PRESALE_INFO</span>.<span style="color:#007f7f">getPrefix</span>(orderId),CacheKeyConstant.<span style="color:#007f7f">ORDER_INVOICE_INFO</span>.<span style="color:#007f7f">getPrefix</span>(orderId),CacheKeyConstant.<span style="color:#007f7f">ORDER_TRACK_INFO</span>.<span style="color:#007f7f">getPrefix</span>(orderId),
</span></span><span style="display:flex;"><span>                                               CacheKeyConstant.<span style="color:#007f7f">ORDER_PREMISE_INFO</span>.<span style="color:#007f7f">getPrefix</span>(orderId),CacheKeyConstant.<span style="color:#007f7f">ORDER_FEE_INFO</span>.<span style="color:#007f7f">getPrefix</span>(orderId));
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//查询结果</span>
</span></span><span style="display:flex;"><span>    List&lt;String&gt; result = redisUtils.<span style="color:#007f7f">mGet</span>(queryOrderKey);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//基础信息</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span>(CollectionUtils.<span style="color:#007f7f">isEmpty</span>(result)){
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    String[] resultInfo = result.<span style="color:#007f7f">toArray</span>(<span style="color:#fff;font-weight:bold">new</span> String[0]);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//基础信息</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span>(StringUtils.<span style="color:#007f7f">isBlank</span>(resultInfo[0])){
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    BaseOrderVo baseOrderVo = JSON.<span style="color:#007f7f">parseObject</span>(resultInfo[0],BaseOrderVo.<span style="color:#007f7f">class</span>);
</span></span><span style="display:flex;"><span>    Order order = coverBaseOrderVoToOrder(baseOrderVo);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//订单商品</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span>(StringUtils.<span style="color:#007f7f">isNotBlank</span>(resultInfo[1])){
</span></span><span style="display:flex;"><span>        List&lt;OrderSub&gt; orderSubs =JSON.<span style="color:#007f7f">parseObject</span>(result.<span style="color:#007f7f">get</span>(1), <span style="color:#fff;font-weight:bold">new</span> TypeReference&lt;List&lt;OrderSub&gt;&gt;(){});
</span></span><span style="display:flex;"><span>        order.<span style="color:#007f7f">setCustomerOrderSubs</span>(orderSubs);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//订单预售</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span>(StringUtils.<span style="color:#007f7f">isNotBlank</span>(resultInfo[2])){
</span></span><span style="display:flex;"><span>        PresaleOrderData presaleOrderData = JSON.<span style="color:#007f7f">parseObject</span>(resultInfo[2],PresaleOrderData.<span style="color:#007f7f">class</span>);
</span></span><span style="display:flex;"><span>        order.<span style="color:#007f7f">setPresaleOrderData</span>(presaleOrderData);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//订单发票</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span>(StringUtils.<span style="color:#007f7f">isNotBlank</span>(resultInfo[3])){
</span></span><span style="display:flex;"><span>        OrderInvoice orderInvoice = JSON.<span style="color:#007f7f">parseObject</span>(resultInfo[3],OrderInvoice.<span style="color:#007f7f">class</span>);
</span></span><span style="display:flex;"><span>        order.<span style="color:#007f7f">setOrderInvoice</span>(orderInvoice);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//订单轨迹</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span>(StringUtils.<span style="color:#007f7f">isNotBlank</span>(resultInfo[5])){
</span></span><span style="display:flex;"><span>        OrderTrackInfo orderTrackInfo = JSON.<span style="color:#007f7f">parseObject</span>(resultInfo[5],OrderTrackInfo.<span style="color:#007f7f">class</span>);
</span></span><span style="display:flex;"><span>        order.<span style="color:#007f7f">setOrderTrackInfo</span>(orderTrackInfo);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//订单履约信息</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span>(StringUtils.<span style="color:#007f7f">isNotBlank</span>(resultInfo[6])){
</span></span><span style="display:flex;"><span>        List&lt;OrderPremiseInfo&gt; orderPremiseInfos =JSON.<span style="color:#007f7f">parseObject</span>(result.<span style="color:#007f7f">get</span>(6), <span style="color:#fff;font-weight:bold">new</span> TypeReference&lt;List&lt;OrderPremiseInfo&gt;&gt;(){});
</span></span><span style="display:flex;"><span>        order.<span style="color:#007f7f">setPremiseInfos</span>(orderPremiseInfos);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">//订单费用明细信息</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span>(StringUtils.<span style="color:#007f7f">isNotBlank</span>(resultInfo[7])){
</span></span><span style="display:flex;"><span>        OrderFeeVo orderFeeVo = JSON.<span style="color:#007f7f">parseObject</span>(resultInfo[7],OrderFeeVo.<span style="color:#007f7f">class</span>);
</span></span><span style="display:flex;"><span>        order.<span style="color:#007f7f">setOrderFeeVo</span>(orderFeeVo);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> order;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：获取缓存的结果跟传入的key的顺序保持对应即可。</p>
<p><strong>缓存util方法封装：</strong></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> *
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * @description 同时将多个 key-value (域-值)对设置到缓存中。
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * @param mappings 需要插入的数据信息
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">void</span> mSetString(Map&lt;String, String&gt; mappings) {
</span></span><span style="display:flex;"><span>    CallerInfo callerInfo = Ump.<span style="color:#007f7f">methodReg</span>(UmpKeyConstants.<span style="color:#007f7f">REDIS</span>.<span style="color:#007f7f">REDIS_STATUS_READ_MSET</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>        redisClient.<span style="color:#007f7f">getClientInstance</span>().<span style="color:#007f7f">mSetString</span>(mappings);
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>        Ump.<span style="color:#007f7f">funcError</span>(callerInfo);
</span></span><span style="display:flex;"><span>    }<span style="color:#fff;font-weight:bold">finally</span> {
</span></span><span style="display:flex;"><span>        Ump.<span style="color:#007f7f">methodRegEnd</span>(callerInfo);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> *
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * @description 同时将多个key的结果返回。
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * @param queryKeys 查询的缓存key集合
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> List&lt;String&gt; mGet(List&lt;String&gt; queryKeys) {
</span></span><span style="display:flex;"><span>    CallerInfo callerInfo = Ump.<span style="color:#007f7f">methodReg</span>(UmpKeyConstants.<span style="color:#007f7f">REDIS</span>.<span style="color:#007f7f">REDIS_STATUS_READ_MGET</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> redisClient.<span style="color:#007f7f">getClientInstance</span>().<span style="color:#007f7f">mGet</span>(queryKeys.<span style="color:#007f7f">toArray</span>(<span style="color:#fff;font-weight:bold">new</span> String[0]));
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>        Ump.<span style="color:#007f7f">funcError</span>(callerInfo);
</span></span><span style="display:flex;"><span>    }<span style="color:#fff;font-weight:bold">finally</span> {
</span></span><span style="display:flex;"><span>        Ump.<span style="color:#007f7f">methodRegEnd</span>(callerInfo);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> ArrayList&lt;String&gt;(queryKeys.<span style="color:#007f7f">size</span>());
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里附上通过pipeline的util封装，可参考。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">/**
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * @description pipeline放松查询数据
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * @param redisKeyList
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * @return java.util.List&lt;java.lang.String&gt;
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> List&lt;String&gt; getValueByPipeline(List&lt;String&gt; redisKeyList) {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span>(CollectionUtils.<span style="color:#007f7f">isEmpty</span>(redisKeyList)){
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    List&lt;String&gt; resultInfo = <span style="color:#fff;font-weight:bold">new</span> ArrayList&lt;&gt;(redisKeyList);
</span></span><span style="display:flex;"><span>    CallerInfo callerInfo = Ump.<span style="color:#007f7f">methodReg</span>(UmpKeyConstants.<span style="color:#007f7f">REDIS</span>.<span style="color:#007f7f">REDIS_STATUS_READ_GET</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        PipelineClient pipelineClient = redisClient.<span style="color:#007f7f">getClientInstance</span>().<span style="color:#007f7f">pipelineClient</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">//添加批量查询任务</span>
</span></span><span style="display:flex;"><span>        List&lt;JimFuture&gt; futures = <span style="color:#fff;font-weight:bold">new</span> ArrayList&lt;&gt;();
</span></span><span style="display:flex;"><span>        redisKeyList.<span style="color:#007f7f">forEach</span>(redisKey -&gt; {
</span></span><span style="display:flex;"><span>            futures.<span style="color:#007f7f">add</span>(pipelineClient.<span style="color:#007f7f">get</span>(redisKey.<span style="color:#007f7f">getBytes</span>()));
</span></span><span style="display:flex;"><span>        });
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">//处理查询结果</span>
</span></span><span style="display:flex;"><span>        pipelineClient.<span style="color:#007f7f">flush</span>();
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">//可以等待future的返回结果，来判断命令是否成功。</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">for</span> (JimFuture future : futures) {
</span></span><span style="display:flex;"><span>            resultInfo.<span style="color:#007f7f">add</span>(<span style="color:#fff;font-weight:bold">new</span> String((<span style="color:#fff;font-weight:bold">byte</span>[])future.<span style="color:#007f7f">get</span>()));
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>        log.<span style="color:#007f7f">error</span>(<span style="color:#0ff;font-weight:bold">&#34;getValueByPipeline error:&#34;</span>,e);
</span></span><span style="display:flex;"><span>        Ump.<span style="color:#007f7f">funcError</span>(callerInfo);
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> ArrayList&lt;&gt;(redisKeyList.<span style="color:#007f7f">size</span>());
</span></span><span style="display:flex;"><span>    }<span style="color:#fff;font-weight:bold">finally</span> {
</span></span><span style="display:flex;"><span>        Ump.<span style="color:#007f7f">methodRegEnd</span>(callerInfo);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> resultInfo;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：Pipeline不建议用来设置缓存值，因为本身不是原子性的操作。</p>
<h3 id="压缩存储数据">压缩存储数据<a hidden class="anchor" aria-hidden="true" href="#压缩存储数据">#</a></h3>
<p>DefaultOutputStream</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">// 压缩</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">byte</span>[] compressToByteArray(String text) <span style="color:#fff;font-weight:bold">throws</span> IOException {
</span></span><span style="display:flex;"><span>    ByteArrayOutputStream outputStream = <span style="color:#fff;font-weight:bold">new</span> ByteArrayOutputStream();
</span></span><span style="display:flex;"><span>    Deflater deflater = <span style="color:#fff;font-weight:bold">new</span> Deflater();
</span></span><span style="display:flex;"><span>    DeflaterOutputStream deflaterOutputStream = <span style="color:#fff;font-weight:bold">new</span> DeflaterOutputStream(outputStream, deflater);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    deflaterOutputStream.<span style="color:#007f7f">write</span>(text.<span style="color:#007f7f">getBytes</span>());
</span></span><span style="display:flex;"><span>    deflaterOutputStream.<span style="color:#007f7f">close</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> outputStream.<span style="color:#007f7f">toByteArray</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 解压缩</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> String decompressFromByteArray(<span style="color:#fff;font-weight:bold">byte</span>[] bytes) <span style="color:#fff;font-weight:bold">throws</span> IOException {
</span></span><span style="display:flex;"><span>    ByteArrayInputStream inputStream = <span style="color:#fff;font-weight:bold">new</span> ByteArrayInputStream(bytes);
</span></span><span style="display:flex;"><span>    Inflater inflater = <span style="color:#fff;font-weight:bold">new</span> Inflater();
</span></span><span style="display:flex;"><span>    InflaterInputStream inflaterInputStream = <span style="color:#fff;font-weight:bold">new</span> InflaterInputStream(inputStream, inflater);
</span></span><span style="display:flex;"><span>    ByteArrayOutputStream outputStream = <span style="color:#fff;font-weight:bold">new</span> ByteArrayOutputStream();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">byte</span>[] buffer = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">byte</span>[1024];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> length;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> ((length = inflaterInputStream.<span style="color:#007f7f">read</span>(buffer)) != -1) {
</span></span><span style="display:flex;"><span>        outputStream.<span style="color:#007f7f">write</span>(buffer, 0, length);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    inflaterInputStream.<span style="color:#007f7f">close</span>();
</span></span><span style="display:flex;"><span>    outputStream.<span style="color:#007f7f">close</span>();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">byte</span>[] decompressedData = outputStream.<span style="color:#007f7f">toByteArray</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#fff;font-weight:bold">new</span> String(decompressedData);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>GZIPOutputStream</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">37
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">// 压缩</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> <span style="color:#fff;font-weight:bold">byte</span>[] compressGzip(String str) {
</span></span><span style="display:flex;"><span>    ByteArrayOutputStream outputStream = <span style="color:#fff;font-weight:bold">new</span> ByteArrayOutputStream();
</span></span><span style="display:flex;"><span>    GZIPOutputStream gzipOutputStream = <span style="color:#fff;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>        gzipOutputStream = <span style="color:#fff;font-weight:bold">new</span> GZIPOutputStream(outputStream);
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> RuntimeException(e);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>        gzipOutputStream.<span style="color:#007f7f">write</span>(str.<span style="color:#007f7f">getBytes</span>(<span style="color:#0ff;font-weight:bold">&#34;UTF-8&#34;</span>));
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> RuntimeException(e);
</span></span><span style="display:flex;"><span>    }<span style="color:#fff;font-weight:bold">finally</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>            gzipOutputStream.<span style="color:#007f7f">close</span>();
</span></span><span style="display:flex;"><span>        } <span style="color:#fff;font-weight:bold">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">throw</span> <span style="color:#fff;font-weight:bold">new</span> RuntimeException(e);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> outputStream.<span style="color:#007f7f">toByteArray</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 解压缩</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> String decompressGzip(<span style="color:#fff;font-weight:bold">byte</span>[] compressed) <span style="color:#fff;font-weight:bold">throws</span> IOException {
</span></span><span style="display:flex;"><span>    ByteArrayInputStream inputStream = <span style="color:#fff;font-weight:bold">new</span> ByteArrayInputStream(compressed);
</span></span><span style="display:flex;"><span>    GZIPInputStream gzipInputStream = <span style="color:#fff;font-weight:bold">new</span> GZIPInputStream(inputStream);
</span></span><span style="display:flex;"><span>    ByteArrayOutputStream outputStream = <span style="color:#fff;font-weight:bold">new</span> ByteArrayOutputStream();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">byte</span>[] buffer = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">byte</span>[1024];
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> length;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">while</span> ((length = gzipInputStream.<span style="color:#007f7f">read</span>(buffer)) &gt; 0) {
</span></span><span style="display:flex;"><span>        outputStream.<span style="color:#007f7f">write</span>(buffer, 0, length);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    gzipInputStream.<span style="color:#007f7f">close</span>();
</span></span><span style="display:flex;"><span>    outputStream.<span style="color:#007f7f">close</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> outputStream.<span style="color:#007f7f">toString</span>(<span style="color:#0ff;font-weight:bold">&#34;UTF-8&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>ZlibCompress</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">42
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#007f7f">// 压缩</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span>  <span style="color:#fff;font-weight:bold">byte</span>[] zlibCompress(String message) <span style="color:#fff;font-weight:bold">throws</span> Exception {
</span></span><span style="display:flex;"><span>    String chatacter = <span style="color:#0ff;font-weight:bold">&#34;UTF-8&#34;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">byte</span>[] input = message.<span style="color:#007f7f">getBytes</span>(chatacter);
</span></span><span style="display:flex;"><span>    BigDecimal bigDecimal = BigDecimal.<span style="color:#007f7f">valueOf</span>(0.<span style="color:#007f7f">25f</span>);
</span></span><span style="display:flex;"><span>    BigDecimal length = BigDecimal.<span style="color:#007f7f">valueOf</span>(input.<span style="color:#007f7f">length</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">byte</span>[] output = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">byte</span>[input.<span style="color:#007f7f">length</span> + 10 + <span style="color:#fff;font-weight:bold">new</span> Double(Math.<span style="color:#007f7f">ceil</span>(Double.<span style="color:#007f7f">parseDouble</span>(bigDecimal.<span style="color:#007f7f">multiply</span>(length).<span style="color:#007f7f">toString</span>()))).<span style="color:#007f7f">intValue</span>()];
</span></span><span style="display:flex;"><span>    Deflater compresser = <span style="color:#fff;font-weight:bold">new</span> Deflater();
</span></span><span style="display:flex;"><span>    compresser.<span style="color:#007f7f">setInput</span>(input);
</span></span><span style="display:flex;"><span>    compresser.<span style="color:#007f7f">finish</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">int</span> compressedDataLength = compresser.<span style="color:#007f7f">deflate</span>(output);
</span></span><span style="display:flex;"><span>    compresser.<span style="color:#007f7f">end</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> Arrays.<span style="color:#007f7f">copyOf</span>(output, compressedDataLength);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">// 解压缩</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> <span style="color:#fff;font-weight:bold">static</span> String zlibInfCompress(<span style="color:#fff;font-weight:bold">byte</span>[] data) {
</span></span><span style="display:flex;"><span>    String s = <span style="color:#fff;font-weight:bold">null</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Inflater decompresser = <span style="color:#fff;font-weight:bold">new</span> Inflater();
</span></span><span style="display:flex;"><span>    decompresser.<span style="color:#007f7f">reset</span>();
</span></span><span style="display:flex;"><span>    decompresser.<span style="color:#007f7f">setInput</span>(data);
</span></span><span style="display:flex;"><span>    ByteArrayOutputStream o = <span style="color:#fff;font-weight:bold">new</span> ByteArrayOutputStream(data.<span style="color:#007f7f">length</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">byte</span>[] buf = <span style="color:#fff;font-weight:bold">new</span> <span style="color:#fff;font-weight:bold">byte</span>[1024];
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">while</span> (!decompresser.<span style="color:#007f7f">finished</span>()) {
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">int</span> i = decompresser.<span style="color:#007f7f">inflate</span>(buf);
</span></span><span style="display:flex;"><span>            o.<span style="color:#007f7f">write</span>(buf, 0, i);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        s = o.<span style="color:#007f7f">toString</span>(<span style="color:#0ff;font-weight:bold">&#34;UTF-8&#34;</span>);
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">catch</span> (Exception e) {
</span></span><span style="display:flex;"><span>        e.<span style="color:#007f7f">printStackTrace</span>();
</span></span><span style="display:flex;"><span>    } <span style="color:#fff;font-weight:bold">finally</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">try</span> {
</span></span><span style="display:flex;"><span>            o.<span style="color:#007f7f">close</span>();
</span></span><span style="display:flex;"><span>        } <span style="color:#fff;font-weight:bold">catch</span> (IOException e) {
</span></span><span style="display:flex;"><span>            e.<span style="color:#007f7f">printStackTrace</span>();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    decompresser.<span style="color:#007f7f">end</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> s;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到压缩效率比较好，压缩效率可以从几百kb压缩到几kb内；当然也是看具体场景。不过这里就是最好是避免调用量大的场景使用，毕竟解压和压缩数据量大会比较耗费cpu性能。如果是黄金链路使用，还需要具体配合压测，对比前后接口性能。</p>
<h3 id="替换存储方案">替换存储方案<a hidden class="anchor" aria-hidden="true" href="#替换存储方案">#</a></h3>
<p>如果数据量庞大，那么其实本身是不是就不太适合redis这种缓存存储了。可以考虑es或者mongo这种文档式存储结构，存储大的数据格式。</p>
<h2 id="总结-2">总结<a hidden class="anchor" aria-hidden="true" href="#总结-2">#</a></h2>
<p>redis缓存的使用是一个支持业务和功能高并发的很好的使用方案，但是随着使用场景的多样性以及数据的增加，可能逐渐的会出现大key，日常使用中都可以注意以下几点：</p>
<p><strong>1.分而治之：</strong> 如果需要存储大量的数据，避免直接放到缓存中。可以将其拆分成多个小的value。</p>
<p><strong>2.避免使用不必要的数据结构：</strong> 例如，如果只需要存储一个字符串结构的数据，使用string就行，不需要使用Hash或者List。</p>
<p><strong>3.定期清理过期的key：</strong> 如果Redis中存在大量的过期key，就会导致Redis的性能下降，或者场景非必要以缓存来持久存储的，可以添加过期时间，定时清理过期的key。</p>
<p><strong>4.对象压缩：</strong> 将大的数据压缩成更小的数据，也是一种好的解决方案，不过要注意压缩和解压的频率，毕竟是比较耗费cpu的。</p>
<h1 id="redis-hotkey热-key">Redis hotkey（热 Key）<a hidden class="anchor" aria-hidden="true" href="#redis-hotkey热-key">#</a></h1>
<h2 id="如何定义热key">如何定义热key<a hidden class="anchor" aria-hidden="true" href="#如何定义热key">#</a></h2>
<p>热key的定义，通常以其接收到的Key被请求频率来判定，例如：</p>
<ul>
<li>QPS集中在特定的Key：Redis实例的总QPS为10,000，而其中一个Key的每秒访问量达到了7,000。那么这个key就算热key了。</li>
<li>带宽使用率集中在特定的Key：对一个拥有1000个成员且总大小为1 MB的HASH Key每秒发送大量的HGETALL操作请求。</li>
<li>CPU使用时间占比集中在特定的Key：对一个拥有10000个成员的Key（ZSET类型）每秒发送大量的ZRANGE操作请求。</li>
</ul>
<p>hotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p>
<h2 id="hotkey-有什么危害">hotkey 有什么危害？<a hidden class="anchor" aria-hidden="true" href="#hotkey-有什么危害">#</a></h2>
<ol>
<li><strong>流量集中超网卡上限</strong>：热点 Key 请求过多，超过主机网卡流量上限，会使该节点服务器的其他服务无法运行。</li>
<li><strong>打垮缓存分片服务</strong>：Redis 单点查询性能有限，热点 Key 查询超阈值会占用大量 CPU 资源，降低整体性能，严重时导致缓存分片服务崩溃（如 Redis 节点自重启），影响其他业务。</li>
<li><strong>集群访问倾斜</strong>：在集群架构下，会出现某个数据分片被大量访问，其他分片空闲的情况，可能导致该分片连接数耗尽，新连接请求被拒。</li>
<li><strong>DB 击穿与业务雪崩</strong>：热 Key 请求超 Redis 承受能力致缓存击穿，缓存失效时大量请求直抵 DB 层，DB 性能弱，易引发雪崩，影响业务。在抢购或秒杀场景下，还可能因库存 Key 请求量过大造成超卖</li>
</ol>
<h2 id="如何发现-hotkey">如何发现 hotkey？<a hidden class="anchor" aria-hidden="true" href="#如何发现-hotkey">#</a></h2>
<p><strong>1、凭借业务经验预估</strong><br>
具有一定可行性，例如整点秒杀活动中，活动信息 key 和头部楼层秒杀商品信息 key 通常是热点 key。但并非所有热 key 都能准确预测，可借助商家历史活动数据分析作为参考。</p>
<p><strong>2、业务侧自行监控收集</strong><br>
在操作 Redis 前添加代码进行数据统计并异步上报，类似日志采集，将 Redis 命令操作、结果、耗时等信息通过异步消息发送至采集消息队列。缺点是对代码有入侵性，可通过中间件集成在 Redis 二方包中。若有较好的 Daas 平台，可在 proxy 层监控，业务无感知，统一在平台查看监控。</p>
<p><strong>3、使用 Redis 自带命令</strong></p>
<ul>
<li>
<p><strong>monitor 命令</strong>：能实时抓取 Redis 服务器接收的命令，可通过代码统计热 key，也有现成分析工具如 redis - faina。但在高并发下存在内存暴增隐患，且会降低 Redis 性能。</p>
</li>
<li>
<p><strong>优点</strong>：这个方案的优点在于这个是 Redis 原生支持的功能，使用起来简单快捷。</p>
</li>
<li>
<p><strong>缺点</strong>：monitor 非常消耗性能，单个客户端执行 monitor 就会损耗 50% 的性能！不推荐这个方式！</p>
</li>
<li>
<p><strong>hotkeys 参数</strong>：Redis 4.0.3 提供此热点 key 发现功能，它是通过 scan + object freq 实现的。执行 redis - cli 时加 –hotkeys 选项即可。不过 key 较多时执行速度慢，且一般公司不允许直接连接 Redis 节点输入命令，多通过 Daas 平台查看热点 key 分析和监控 。</p>
</li>
</ul>
<p><strong>4、客户端收集</strong><br>
在操作 Redis 前添加统计 Redis 键值查询频次的逻辑，将统计数据发送到聚合计算平台计算，之后查看结果。</p>
<ul>
<li><strong>优点</strong>：对性能损耗较低。</li>
<li><strong>缺点</strong>：成本较大，若企业没有聚合计算平台则需引入。</li>
</ul>
<p><strong>5、代理层收集</strong>利用有些服务在请求 Redis 前会先请求代理服务这一特点，在代理层统一收集 Redis 热 Key 数据。比如<strong>京东的JD-hotkey</strong>、<strong>有赞的TMC中间件技术</strong>等</p>
<ul>
<li><strong>优点</strong>：客户端使用方便，无需考虑 SDK 多语言异构差异和升级成本高的问题。</li>
<li><strong>缺点</strong>：需要为 Redis 定制代理层进行转发等操作，构建代理成本高，且转发存在性能损耗 。</li>
</ul>
<h2 id="如何解决热key">如何解决热key<a hidden class="anchor" aria-hidden="true" href="#如何解决热key">#</a></h2>
<ol>
<li>热点key拆分：将热点数据分散到多个Key中，例如通过引入随机前缀，使不同用户请求分散到多个Key，多个key 分布在多实例中，避免集中访问单一Key。</li>
<li>多级缓存：在Redis前增加其他缓存层（如CDN、本地缓存)，以分担Redis的访问压力。</li>
<li>读写分离：通过Redis主从复制，将读请求分发到多个从节点，从而减轻单节点压力。</li>
<li>限流和降级：在热点Key访问过高时，应用限流策略，减少对Redis的请求，或者在必要时返回降级的数据或空值。</li>
</ol>
<h1 id="redis-中如何保证缓存与数据库的数据一致性">Redis 中如何保证缓存与数据库的数据一致性？<a hidden class="anchor" aria-hidden="true" href="#redis-中如何保证缓存与数据库的数据一致性">#</a></h1>
<p>推荐：</p>
<ol>
<li>先更新数据库，再删除缓存，后续等查询把数据库的数据回种到缓存中</li>
<li>缓存双删策略。更新数据库之前，删除一次缓存；更新完数据库后，再进行一次延迟删除</li>
<li>使用 Binlog 异步更新缓存，监听数据库的 Binlog 变化，通过异步方式更新 Redis 缓存</li>
</ol>
<p>不推荐：</p>
<ol>
<li>先更新缓存，再更新数据库</li>
<li>先更新数据库存，再更新缓存</li>
<li>先删除缓存，再更新数据库，后续等查询把数据库的数据回种到缓存中</li>
</ol>
<h1 id="redis分布式锁">redis分布式锁<a hidden class="anchor" aria-hidden="true" href="#redis分布式锁">#</a></h1>
<p>如果不使用框架，只基于 Redis 来实现分布锁，需要使用 <code>set ex nx</code> 命令 + lua 脚本。</p>
<ol>
<li>加锁：<code>SET 锁的名称 锁的值 EX 超时时间 NX</code>，EX：<strong>expire_time</strong> - 设置过期时间（秒），<strong>NX</strong>：Not eXists，只在键不存在时才设置。</li>
<li>解锁：使用 lua 脚本，先通过 get 获取 key 的 value 判断锁是否是自己加的，如果是则 del。</li>
</ol>
<p>lua 脚本如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-lua" data-lang="lua"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">if</span> redis.call(<span style="color:#0ff;font-weight:bold">&#34;GET&#34;</span>,KEYS[<span style="color:#ff0;font-weight:bold">1</span>]) == ARGV[<span style="color:#ff0;font-weight:bold">1</span>] <span style="color:#007f7f">-- 步骤1：检查锁的值是否匹配</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">then</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> redis.call(<span style="color:#0ff;font-weight:bold">&#34;DEL&#34;</span>,KEYS[<span style="color:#ff0;font-weight:bold">1</span>])  <span style="color:#007f7f">-- 步骤2：匹配则删除锁</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> <span style="color:#ff0;font-weight:bold">0</span>  <span style="color:#007f7f">-- 步骤3：不匹配返回失败</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">end</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>KEYS[1]</code>：锁的键名<br>
<code>ARGV[1]</code>：锁的值，客户端持有的唯一标识符</p>
<p>首先<strong>锁必须有过期机制</strong>。假设某个客户端加了锁之后宕机了，锁没有设置过期机制，会使得其他客户端都无法抢到锁。<br>
锁的值必须是唯一值，<strong>防止被别的客户端给释放</strong></p>
<p>我们来看下这个场景：</p>
<p>客户端 1 加锁成功，然后执行业务逻辑，但执行的时间超过了锁的过期时间<br>
此时锁已经过期被释放了，客户端 2 加锁成功<br>
客户端 2 执行业务逻辑<br>
客户端 1 执行完了，执行释放锁的逻辑，即删除锁。<br>
客户端 2 一脸懵，我还在执行着呢，怎么锁被人释放了？？</p>
<p>所以每个客户端加锁（客户端可能是每个线程），需要是设置一个唯一标识，比如一个 uuid，防止锁被别的客户端误释放了。<br>
因为需要先判断锁的值和唯一标识是否一致，一致后再删除释放锁，这里就涉及到两步操作，只有使用了 lua 脚本才能保证原子性，这也是为什么释放锁需要用 lua 脚本的原因。</p>
<h2 id="redis实现分布式锁可能遇到的问题">redis实现分布式锁可能遇到的问题<a hidden class="anchor" aria-hidden="true" href="#redis实现分布式锁可能遇到的问题">#</a></h2>
<h3 id="业务未执行完锁已到期看门狗自动续期">业务未执行完，锁已到期（看门狗自动续期）<a hidden class="anchor" aria-hidden="true" href="#业务未执行完锁已到期看门狗自动续期">#</a></h3>
<p>因为必须给redis设置过期时间，（为了避免持有锁的客户端崩溃或因网络问题断开连接时，锁无法被正常释放）。那么就有可能出现业务还在执行，锁已到期的情况。</p>
<p>解决方案：使用Redisson的看门狗机制自动续期锁。注意：不手动指定锁的超时时间，看门狗才能自动续期。</p>
<p>注意：把锁设置时间很长是不对的（比如半小时），是因为如果业务执行过程中发生异常（如线程崩溃、服务宕机、网络中断等），会导致无法解锁。这样一锁就是半小时，影响业务。</p>
<h3 id="被其他客户端解锁必须使用唯一随机值作为锁的值必须使用lua脚本比较锁的值后再删除解锁">被其他客户端解锁（必须使用唯一随机值作为锁的值，必须使用Lua脚本比较锁的值后再删除（解锁））<a hidden class="anchor" aria-hidden="true" href="#被其他客户端解锁必须使用唯一随机值作为锁的值必须使用lua脚本比较锁的值后再删除解锁">#</a></h3>
<ul>
<li><strong>问题：​</strong>​ 客户端A获取锁（值为<code>uuid_A</code>），处理时间过长导致锁超时释放。客户端B成功获取锁（值为<code>uuid_B</code>）。此时客户端A处理完成，执行释放锁操作（<code>DEL key</code>或判断值后DEL），它会误删客户端B持有的锁<code>uuid_B</code>。</li>
<li>​<strong>​解决1：​</strong>​ 每个客户端在获取锁时设置一个​<strong>​唯一且随机​</strong>​的值（如UUID）。在释放锁时，使用Lua脚本​<strong>​先检查锁的值是否仍等于自己设置的值，再执行删除​</strong>​。确保原子性。</li>
<li><strong>解决2</strong>：使用工具库，​像Redisson这样的库已内置了此逻辑。</li>
</ul>
<h3 id="单点故障问题">单点故障问题<a hidden class="anchor" aria-hidden="true" href="#单点故障问题">#</a></h3>
<p>如果 Redis 单机部署，当实例宕机或不可用，整个分布式锁服务将无法正常工作，阻塞业务的正常执行。</p>
<h3 id="非原子性的加锁操作必须使用带过期时间px的原子set-nx命令进行加锁">非原子性的加锁操作（必须使用带过期时间(<code>PX</code>)的原子<code>SET NX</code>命令进行加锁​）<a hidden class="anchor" aria-hidden="true" href="#非原子性的加锁操作必须使用带过期时间px的原子set-nx命令进行加锁">#</a></h3>
<p><strong>问题：​</strong>​ 在Redis单实例上，加锁操作<code>SET key value NX PX timeout</code>是原子性的。但如果错误地拆分成 <code>SETNX</code>+ <code>EXPIRE</code>两条命令，则可能在 <code>SETNX</code>成功但执行<code>EXPIRE</code>之前进程崩溃或延迟，导致锁永久不释放（死锁）。</p>
<p>​<strong>​解决：​</strong>​ ​<strong>​必须使用原子操作​</strong>​。在Redis 2.6.12+中，使用 <code>SET resource_name my_random_value NX PX 30000</code>（或相应的编程语言客户端命令）这一条命令完成设置值和设置过期时间。避免使用旧命令组合。</p>
<h3 id="主从问题">主从问题<a hidden class="anchor" aria-hidden="true" href="#主从问题">#</a></h3>
<p>如果线上 Redis 是主从+哨兵部署的，则分布式锁可能会有问题。因为 Redis 的主从复制过程是异步实现的，如果 Redis 主节点获取到锁之后，还没同步到其他的从节点，此时 Redis 主节点发生宕机了，这个时候新的主节点上没锁的数据，因此其他客户端可以获取锁，就会导致多个应用服务同时获取锁。基于这个情况，Redis 推出了 Redlock。</p>
<p>Redlock 是 Redis 官方推荐的一种实现分布式锁的算法，适用于集群环境下。</p>
<p><strong>Redlock 的基本思想</strong>：</p>
<ul>
<li>部署多个 Redis 实例（通常为 5 个）。</li>
<li>客户端在大多数实例（如至少 3 个）上请求锁，并在一定时间内获得成功，表示加锁成功。</li>
<li>使用 Redlock 可以提供更高的容错性，即使部分 Redis 实例故障，仍然可以获得锁。</li>
</ul>
<p><strong>Redlock 的实现流程</strong>：</p>
<ul>
<li>客户端尝试在每个 Redis 实例上加锁，必须在有限时间内（通常为锁的过期时间）完成所有实例的加锁。</li>
<li>如果大多数实例（N/2 + 1）加锁成功，则表示加锁成功。</li>
<li>否则，客户端将释放所有已经加锁的实例，重新尝试。</li>
</ul>
<p><strong>Redlock 的缺点包括</strong>：</p>
<ul>
<li><strong>复杂性</strong>：实现 Redlock 需要多个 Redis 实例，增加了系统的复杂性和维护成本。</li>
<li><strong>时间同步依赖</strong>：Redlock 依赖于多个节点的系统时间的一致性。如果节点之间的时间不同步（例如发生时间回拨），可能导致锁的有效性受到影响。</li>
<li><strong>不适用于高并发</strong>：在高并发场景下，因需要访问多个实例同时尝试获取锁，可能会导致锁获取的性能下降。</li>
<li><strong>锁的续期问题</strong>：在长时间的操作中，可能需要手动续期锁，因为涉及多个实例，增加了实现的复杂度和风险。</li>
</ul>
<h3 id="锁的竞争与客户端等待">锁的竞争与客户端等待<a hidden class="anchor" aria-hidden="true" href="#锁的竞争与客户端等待">#</a></h3>
<ul>
<li>​<strong>​问题：​</strong>​ 当锁被占用时，其他客户端如何高效、公平、低资源占用地等待锁，而不是粗暴轮询。</li>
<li>​<strong>​缓解：​</strong>​
<ul>
<li>​<strong>​带超时的阻塞尝试：​</strong>​ 使用<code>BLPOP</code>或<code>SUBSCRIBE</code>(Redisson使用PubSub)等方式让客户端阻塞等待锁释放通知，避免轮询。需要设置合理的等待超时时间。</li>
<li>​<strong>​退避策略：​</strong>​ 如果尝试加锁失败，不要立即重试，而是采用随机或指数退避（如<code>Exponential Backoff</code>）策略等待一段时间再尝试，减轻Redis和网络压力。</li>
</ul>
</li>
</ul>
<h3 id="锁的重入性reentrancy">锁的重入性（Reentrancy）<a hidden class="anchor" aria-hidden="true" href="#锁的重入性reentrancy">#</a></h3>
<ul>
<li><strong>问题：​</strong>​ 同一个线程在持有锁的情况下，能否再次成功获取该锁（通常是递归调用导致的需要）。</li>
<li>​<strong>​解决：​</strong>​ Redis的原子<code>SET NX</code>操作本身不支持重入。
<ul>
<li>​<strong>​在客户端实现计数器：​</strong>​ 在客户端内存中维护一个计数器（如ThreadLocal）。获取锁时将计数器+1；释放锁时将计数器-1，只有在计数器归零时才真正向Redis释放锁。需要确保获取/释放操作配对。Redisson已实现可重入锁。</li>
<li>​<strong>​在Redis中存储计数器：​</strong>​ 锁的值使用一个结构（如Hash）存储客户端标识和持有计数。使用Lua脚本保证检查和更新的原子性（检查是否是同一客户端，是则计数加1/减1）。</li>
</ul>
</li>
</ul>
<h2 id="分布式锁在未完成逻辑前过期怎么办">分布式锁在未完成逻辑前过期怎么办？<a hidden class="anchor" aria-hidden="true" href="#分布式锁在未完成逻辑前过期怎么办">#</a></h2>
<p>重点：使用Redisson 看门狗机制自动续期。</p>
<p>若锁在未完成逻辑前就过期，此时可能会产生数据不一致的问题。因为锁过期了，此时如果再出现一个客户端争抢锁，即可拿到锁然后同时进行业务操作，这等于锁失效了。此时可以在逻辑执行过程中<strong>定期续期锁</strong>，确保锁在处理过程中不会过期。</p>
<p>Redisson 的看门狗（watchdog）主要用来避免 Redis 中的锁在超时后业务逻辑还未执行完毕，锁却被自动释放的情况。它通过定期刷新锁的过期时间来实现自动续期。</p>
<p><strong>主要原理</strong>：</p>
<ol>
<li><strong>定时刷新</strong>：如果<strong>当前分布式锁未设置过期时间（注意：必须未设置过期时间，只要设置了过期时间，而不会启用看门狗）</strong>，Redisson 基于 Netty 时间轮启动一个定时任务，定期向 Redis 发送命令更新锁的过期时间，默认每 10s 发送一次请求，每次续期 30s。</li>
<li><strong>释放锁</strong>：当客户端主动释放锁时，Redisson 会取消看门狗刷新操作。如果客户端宕机了，定时任务自然也就无法执行了，此时等超时时间到了，锁也会自动释放。</li>
</ol>
<h3 id="如果获取锁的客户端挂了怎么办">如果获取锁的客户端挂了怎么办？<a hidden class="anchor" aria-hidden="true" href="#如果获取锁的客户端挂了怎么办">#</a></h3>
<p>从上面的分析我们可以得知，续期是通过定时任务执行的，如果当前客户端宕机，那么定时任务就没了，不会再执行、按照默认每 10s 续期 30s 的情况来看，锁不可能无限续期，等 30s 时间一到，集群中的其他客户端就可以获取锁，不会阻碍正常业务的执行。</p>
<h1 id="如何使用-redis-快速实现排行榜">如何使用 Redis 快速实现排行榜？<a hidden class="anchor" aria-hidden="true" href="#如何使用-redis-快速实现排行榜">#</a></h1>
<p>使用 <strong>Redis</strong> 实现排行榜的方式主要利用 <strong>Sorted Set（有序集合）</strong>，它可以高效地存储、更新、以及获取排名数据。</p>
<p>实现排行榜的主要步骤：</p>
<p>1）<strong>使用 Sorted Set 存储分数和成员</strong></p>
<ul>
<li>使用 Redis 的 <code>ZADD</code> 命令，将用户和对应的分数添加到有序集合中。例如：<code>ZADD leaderboard 1000 user1</code>，将用户 <code>user1</code> 的分数设置为 1000。<br>
2）<strong>获取排名</strong></li>
<li>使用 <code>ZRANK</code> 命令获取某个用户的排名。例如：<code>ZRANK leaderboard user1</code>，返回用户 <code>user1</code> 的排名（从 0 开始）。<br>
3）<strong>获取前 N 名</strong></li>
<li>使用 <code>ZREVRANGE</code> 命令获取分数最高的前 N 名。例如：<code>ZREVRANGE leaderboard 0 9 WITHSCORES</code>，获取排行榜前 10 名用户及其分数。<br>
4）<strong>更新分数</strong></li>
<li>如果用户的分数需要更新，可以使用 <code>ZINCRBY</code> 命令对其分数进行加减操作。例如：<code>ZINCRBY leaderboard 500 user1</code>，将用户 <code>user1</code> 的分数增加 500。</li>
</ul>
<h1 id="如何使用-redis-统计大量用户唯一访问量uv">如何使用 Redis 统计大量用户唯一访问量（UV）？<a hidden class="anchor" aria-hidden="true" href="#如何使用-redis-统计大量用户唯一访问量uv">#</a></h1>
<p>Redis 中 HyperLogLog 结构，可以快速实现网页 UV 、PV 等统计场景。它是一种<strong>基数估算算法</strong>的概率性数据结构，可以用极少的内存统计海量用户唯一访问量的近似值。</p>
<blockquote>
<p>Set 也可以实现，用于精确统计唯一用户访问量，但是但当用户数非常大时，内存开销较高。</p>
</blockquote>
<h1 id="如何在-redis-中实现队列和栈数据结构">如何在 Redis 中实现队列和栈数据结构？<a hidden class="anchor" aria-hidden="true" href="#如何在-redis-中实现队列和栈数据结构">#</a></h1>
<p>可以通过 <strong>List 类型</strong> 来实现 <strong>队列</strong> 和 <strong>栈</strong> ：</p>
<p><strong>实现队列（FIFO）</strong>：</p>
<ul>
<li>队列是一种 <strong>先进先出（FIFO）</strong> 的数据结构。在 Redis 中，可以使用 <strong><code>LPUSH</code></strong> 和 <strong><code>RPOP</code></strong> 命令组合来实现队列。</li>
<li><strong><code>LPUSH</code></strong> 向列表的左侧推入元素，而 <strong><code>RPOP</code></strong> 从列表的右侧弹出元素，这样可以保证最先进入的元素最先被弹出。</li>
</ul>
<p><strong>实现栈（LIFO）</strong>：</p>
<ul>
<li>栈是一种 <strong>后进先出（LIFO）</strong> 的数据结构。在 Redis 中，可以使用 <strong><code>LPUSH</code></strong> 和 <strong><code>LPOP</code></strong> 命令组合来实现栈。</li>
<li><strong><code>LPUSH</code></strong> 向列表的左侧推入元素，而 <strong><code>LPOP</code></strong> 从列表的左侧弹出元素，这样可以保证最后进入的元素最先被弹出。</li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://wjy6.netlify.app/tags/interview/">Interview</a></li>
      <li><a href="https://wjy6.netlify.app/tags/redis/">Redis</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://wjy6.netlify.app/">Wjy&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
