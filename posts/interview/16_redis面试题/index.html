<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>16_Redis面试题 | Wjy&#39;s Blog</title>
<meta name="keywords" content="interview">
<meta name="description" content="概述 Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于">
<meta name="author" content="Wjy">
<link rel="canonical" href="https://funny-toffee-4aa7c3.netlify.app/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://funny-toffee-4aa7c3.netlify.app/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://funny-toffee-4aa7c3.netlify.app/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://funny-toffee-4aa7c3.netlify.app/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://funny-toffee-4aa7c3.netlify.app/apple-touch-icon.png">
<link rel="mask-icon" href="https://funny-toffee-4aa7c3.netlify.app/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://funny-toffee-4aa7c3.netlify.app/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="https://funny-toffee-4aa7c3.netlify.app/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/">
  <meta property="og:site_name" content="Wjy&#39;s Blog">
  <meta property="og:title" content="16_Redis面试题">
  <meta property="og:description" content="概述 Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-28T05:00:00+00:00">
    <meta property="article:modified_time" content="2023-07-28T05:00:00+00:00">
    <meta property="article:tag" content="Interview">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="16_Redis面试题">
<meta name="twitter:description" content="概述 Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://funny-toffee-4aa7c3.netlify.app/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "16_Redis面试题",
      "item": "https://funny-toffee-4aa7c3.netlify.app/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "16_Redis面试题",
  "name": "16_Redis面试题",
  "description": "概述 Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于",
  "keywords": [
    "interview"
  ],
  "articleBody": "概述 Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。\n为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。\nRedis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。\n个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的在线 Redis 环境（少部分命令无法使用）来实际体验 Redis。\nRedis 为什么这么快？ Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：\nRedis 基于内存，内存的访问速度是磁盘的上千倍； Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）； Redis 内置了多种优化过后的数据结构实现，性能非常高。 分布式缓存常见的技术选型方案有哪些？ 分布式缓存的话，比较老牌同时也是使用的比较多的还是 Memcached 和 Redis。不过，现在基本没有看过还有项目使用 Memcached 来做缓存，都是直接用 Redis。\nMemcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。\n另外，腾讯也开源了一款类似于 Redis 的分布式高性能 KV 存储数据库，基于知名的开源项目 RocksDB 作为存储引擎 ，100% 兼容 Redis 协议和 Redis4.0 所有数据模型，名为 Tendis。\n关于 Redis 和 Tendis 的对比，腾讯官方曾经发过一篇文章：Redis vs Tendis：冷热混合存储版架构揭秘 ，可以简单参考一下。\n从这个项目的 GitHub 提交记录可以看出，Tendis 开源版几乎已经没有被维护更新了，加上其关注度并不高，使用的公司也比较少。因此，不建议你使用 Tendis 来实现分布式缓存。\n为什么要用 Redis/为什么要用缓存？ 下面我们主要从“高性能”和“高并发”这两点来回答这个问题。\n1、高性能\n假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。\n这样有什么好处呢？ 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。\n2、高并发\n一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。\nQPS（Query Per Second）：服务器每秒可以执行的查询次数；\n由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。\nRedis 应用 Redis 除了做缓存，还能做什么？ 分布式锁：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：分布式锁详解 。 限流：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》。 消息队列：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。 延时队列：Redisson 内置了延时队列（基于 sorted set 实现的）。 分布式 Session ：利用 string 或者 hash 保存 Session 数据，所有的服务器都可以访问。 复杂业务场景：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。 Redis 可以做消息队列么？ 实际项目中也没见谁使用 Redis 来做消息队列，对于这部分知识点大家了解就好了。\n先说结论：可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。\nRedis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现。\n通过 RPUSH/LPOP 或者 LPUSH/RPOP即可实现简易版消息队列：\n1 2 3 4 5 6 7 8 # 生产者生产消息 \u003e RPUSH myList msg1 msg2 (integer) 2 \u003e RPUSH myList msg3 (integer) 3 # 消费者消费消息 \u003e LPOP myList \"msg1\" 不过，通过 RPUSH/LPOP 或者 LPUSH/RPOP这样的方式存在性能问题，我们需要不断轮询去调用 RPOP 或 LPOP 来消费消息。当 List 为空时，大部分的轮询的请求都是无效请求，这种方式大量浪费了系统资源。\n因此，Redis 还提供了 BLPOP、BRPOP 这种阻塞式读取的命令（带 B-Bloking 的都是阻塞式），并且还支持一个超时参数。如果 List 为空，Redis 服务端不会立刻返回结果，它会等待 List 中有新数据后在返回或者是等待最多一个超时时间后返回空。如果将超时时间设置为 0 时，即可无限等待，直到弹出消息\n1 2 3 4 # 超时时间为 10s # 如果有数据立刻返回，否则最多等待10秒 \u003e BRPOP myList 10 null List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。\nRedis 2.0 引入了发布订阅 (pub/sub) 功能，解决了 List 实现消息队列没有广播机制的问题。\npub/sub 中引入了一个概念叫 channel（频道），发布订阅机制的实现就是基于这个 channel 来做的。\npub/sub 涉及发布者（Publisher）和订阅者（Subscriber，也叫消费者）两个角色：\n发布者通过 PUBLISH 投递消息给指定 channel。 订阅者通过SUBSCRIBE订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。 我们这里启动 3 个 Redis 客户端来简单演示一下：\npub/sub 既能单播又能广播，还支持 channel 的简单正则匹配。不过，消息丢失（客户端断开连接或者 Redis 宕机都会导致消息丢失）、消息堆积（发布者发布消息的时候不会管消费者的具体消费能力如何）等问题依然没有一个比较好的解决办法。\n为此，Redis 5.0 新增加的一个数据结构 Stream 来做消息队列。Stream 支持：\n发布 / 订阅模式 按照消费者组进行消费 消息持久化（ RDB 和 AOF） Stream 使用起来相对要麻烦一些，这里就不演示了。而且，Stream 在实际使用中依然会有一些小问题不太好解决比如在 Redis 发生故障恢复后不能保证消息至少被消费一次。\n综上，和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议不要使用 Redis 来做消息队列，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。\n相关阅读：Redis 消息队列发展历程 - 阿里开发者 - 2022。\nRedis 数据结构 关于 Redis 5 种基础数据结构和 3 种特殊数据结构的详细介绍请看下面这两篇文章：\nRedis 5 种基本数据结构详解 Redis 3 种特殊数据结构详解 Redis 常用的数据结构有哪些？ 5 种基础数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。 3 种特殊数据结构：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。 String 的应用场景有哪些？ String 是 Redis 中最简单同时也是最常用的一个数据结构。String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。\nString 的常见应用场景如下：\n常规数据（比如 session、token、序列化后的对象、图片的路径）的缓存； 计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数； 分布式锁(利用 SETNX key value 命令可以实现一个最简易的分布式锁)； …… 关于 String 的详细介绍请看这篇文章：Redis 5 种基本数据结构详解。\nString 还是 Hash 存储对象数据更好呢？ String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。 String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。 在绝大部分情况，我们建议使用 String 来存储对象数据即可！\nString 的底层实现是什么？ Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 \\0 结尾的字符数组），而是自己编写了 SDS（Simple Dynamic String，简单动态字符串） 来作为底层实现。\nSDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。\nRedis7.0 的 SDS 的部分源码如下（https://github.com/redis/redis/blob/7.0/src/sds.h）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */ struct __attribute__ ((__packed__)) sdshdr5 { unsigned char flags; /* 3 lsb of type, and 5 msb of string length */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr8 { uint8_t len; /* used */ uint8_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr16 { uint16_t len; /* used */ uint16_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr32 { uint32_t len; /* used */ uint32_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; struct __attribute__ ((__packed__)) sdshdr64 { uint64_t len; /* used */ uint64_t alloc; /* excluding the header and null terminator */ unsigned char flags; /* 3 lsb of type, 5 unused bits */ char buf[]; }; 通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。\n类型 字节 位 sdshdr5 \u003c 1 \u003c8 sdshdr8 1 8 sdshdr16 2 16 sdshdr32 4 32 sdshdr64 8 64 对于后四种实现都包含了下面这 4 个属性：\nlen：字符串的长度也就是已经使用的字节数 alloc：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小 buf[]：实际存储字符串的数组 flags：低三位保存类型标志 SDS 相比于 C 语言中的字符串有如下提升：\n可以避免缓冲区溢出：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。 获取字符串长度的复杂度较低：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。 减少内存分配次数：为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。 二进制安全：C 语言中的字符串以空字符 \\0 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。 🤐 多提一嘴，很多文章里 SDS 的定义是下面这样的：\n1 2 3 4 5 struct sdshdr { unsigned int len; unsigned int free; char buf[]; }; 这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，len 和 free 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。\n购物车信息用 String 还是 Hash 存储更好呢? 由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：\n用户 id 为 key 商品 id 为 field，商品数量为 value 那用户购物车信息的维护具体应该怎么操作呢？\n用户添加商品就是往 Hash 里面增加新的 field 与 value； 查询购物车信息就是遍历对应的 Hash； 更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）； 删除商品就是删除 Hash 中对应的 field； 清空购物车直接删除对应的 key 即可。 这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。\n使用 Redis 实现一个排行榜怎么做？ Redis 中有一个叫做 sorted set 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。\n相关的一些 Redis 命令: ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。\nSet 的应用场景是什么？ Redis 中 Set 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。\nSet 的常见应用场景如下：\n存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 HyperLogLog更适合一些）、文章点赞、动态点赞等等。 需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。 需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。 使用 Set 实现抽奖系统怎么做？ 如果想要使用 Set 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：\nSADD key member1 member2 ...：向指定集合添加一个或多个元素。 SPOP key count：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。 SRANDMEMBER key count : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。 使用 Bitmap 统计活跃用户怎么做？ Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。\n你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。\n如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。\n初始化数据：\n1 2 3 4 5 6 \u003e SETBIT 20210308 1 1 (integer) 0 \u003e SETBIT 20210308 2 1 (integer) 0 \u003e SETBIT 20210309 1 1 (integer) 0 统计 20210308~20210309 总活跃用户数:\n1 2 3 4 \u003e BITOP and desk1 20210308 20210309 (integer) 1 \u003e BITCOUNT desk1 (integer) 1 统计 20210308~20210309 在线活跃用户数:\n1 2 3 4 \u003e BITOP or desk2 20210308 20210309 (integer) 1 \u003e BITCOUNT desk2 (integer) 2 使用 HyperLogLog 统计页面 UV 怎么做？ 使用 HyperLogLog 统计页面 UV 主要需要用到下面这两个命令：\nPFADD key element1 element2 ...：添加一个或多个元素到 HyperLogLog 中。 PFCOUNT key1 key2：获取一个或者多个 HyperLogLog 的唯一计数。 1、将访问指定页面的每个用户 ID 添加到 HyperLogLog 中。\n1 PFADD PAGE_1:UV USER1 USER2 ...... USERn 2、统计指定页面的 UV。\n1 PFCOUNT PAGE_1:UV Redis 线程模型（重要） 对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。\nRedis 单线程模型了解吗？ Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型 （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。\n《Redis 设计与实现》有一段话是如是介绍文件事件处理器的，我觉得写得挺不错。\nRedis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。\n文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。 当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。 虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。\n既然是单线程，那怎么监听大量的客户端连接呢？\nRedis 通过 IO 多路复用程序 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。\n这样的好处非常明显：I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗（和 NIO 中的 Selector 组件很像）。\n文件事件处理器（file event handler）主要是包含 4 个部分：\n多个 socket（客户端连接） IO 多路复用程序（支持多个客户端连接的关键） 文件事件分派器（将 socket 关联到相应的事件处理器） 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器） Redis6.0 之前为什么不使用多线程？ 虽然说 Redis 是单线程模型，但是，实际上，Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。\n不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。\n为此，Redis 4.0 之后新增了UNLINK（可以看作是 DEL 的异步版本）、FLUSHALL ASYNC（清空所有数据库的所有 key，不仅仅是当前 SELECT 的数据库）、FLUSHDB ASYNC（清空当前 SELECT 数据库中的所有 key）等异步命令。\n大体上来说，Redis 6.0 之前主要还是单线程处理。\n那 Redis6.0 之前为什么不使用多线程？ 我觉得主要原因有 3 点：\n单线程编程容易并且更容易维护； Redis 的性能瓶颈不在 CPU ，主要在内存和网络； 多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。 Redis6.0 之后为何引入了多线程？ Redis6.0 引入多线程主要是为了提高网络 IO 读写性能，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。\n虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。\nRedis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置 IO 线程数 \u003e 1，需要修改 redis 配置文件 redis.conf：\n1 io-threads 4 #设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程 另外：\nio-threads 的个数一旦设置，不能通过 config 动态设置。 当设置 ssl 后，io-threads 将不工作。 开启多线程后，默认只会使用多线程进行 IO 写入 writes，即发送数据给客户端，如果需要开启多线程 IO 读取 reads，同样需要修改 redis 配置文件 redis.conf :\n1 io-threads-do-reads yes 但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启\nRedis 后台线程了解吗？ 我们虽然经常说 Redis 是单线程模型（主要逻辑是单线程完成的），但实际还有一些后台线程用于执行一些比较耗时的操作：\n通过 bio_close_file 后台线程来释放 AOF / RDB 等过程中产生的临时文件资源。 通过 bio_aof_fsync 后台线程调用 fsync 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。 通过 bio_lazy_free后台线程释放大对象（已删除）占用的内存空间. 在bio.h 文件中有定义（Redis 6.0 版本，源码地址：https://github.com/redis/redis/blob/6.0/src/bio.h）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #ifndef __BIO_H #define __BIO_H /* Exported API */ void bioInit(void); void bioCreateBackgroundJob(int type, void *arg1, void *arg2, void *arg3); unsigned long long bioPendingJobsOfType(int type); unsigned long long bioWaitStepOfType(int type); time_t bioOlderJobOfType(int type); void bioKillThreads(void); /* Background job opcodes */ #define BIO_CLOSE_FILE 0 /* Deferred close(2) syscall. */ #define BIO_AOF_FSYNC 1 /* Deferred AOF fsync. */ #define BIO_LAZY_FREE 2 /* Deferred objects freeing. */ #define BIO_NUM_OPS 3 #endif Redis 内存管理 Redis 给缓存数据设置过期时间有啥用？ 一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？\n因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。\nRedis 自带了给缓存数据设置过期时间的功能，比如：\n1 2 3 4 5 6 127.0.0.1:6379\u003e expire key 60 # 数据在 60s 后过期 (integer) 1 127.0.0.1:6379\u003e setex key 60 value # 数据在 60s 后过期 (setex:[set] + [ex]pire) OK 127.0.0.1:6379\u003e ttl key # 查看数据还有多久过期 (integer) 56 注意：Redis 中除了字符串类型有自己独有设置过期时间的命令 setex 外，其他方法都需要依靠 expire 命令来设置过期时间 。另外， persist 命令可以移除一个键的过期时间。\n过期时间除了有助于缓解内存的消耗，还有什么其他用么？\n很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。\n如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。\nRedis 是如何判断数据是否过期的呢？ Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。\n过期字典是存储在 redisDb 这个结构里的：\n1 2 3 4 5 6 7 typedef struct redisDb { ... dict *dict; //数据库键空间,保存着数据库中所有键值对 dict *expires // 过期字典,保存着键的过期时间 ... } redisDb; 过期的数据的删除策略了解么？ 如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？\n常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：\n惰性删除：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。 定期删除：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。 定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 定期删除+惰性/懒汉式删除 。\n但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。\n怎么解决这个问题呢？答案就是：Redis 内存淘汰机制。\nRedis 内存淘汰机制了解么？ 相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?\nRedis 提供 6 种数据淘汰策略：\nvolatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。 volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰。 volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。 allkeys-lru（least recently used）：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。 allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰。 no-eviction：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！ 4.0 版本后增加以下两种：\nvolatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰。 allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。 Redis 事务 什么是 Redis 事务？ 你可以将 Redis 中的事务理解为：Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。\nRedis 事务实际开发中使用的非常少，功能比较鸡肋，不要将其和我们平时理解的关系型数据库的事务混淆了。\n除了不满足原子性和持久性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。\n因此，Redis 事务是不建议在日常开发中使用的。\n如何使用 Redis 事务？ Redis 可以通过 MULTI，EXEC，DISCARD 和 WATCH 等命令来实现事务(Transaction)功能。\n1 2 3 4 5 6 7 8 9 \u003e MULTI OK \u003e SET PROJECT \"JavaGuide\" QUEUED \u003e GET PROJECT QUEUED \u003e EXEC 1) OK 2) \"JavaGuide\" MULTI 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 EXEC 命令后，再执行所有的命令。\n这个过程是这样的：\n开始事务（MULTI）； 命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)； 执行事务(EXEC)。 你也可以通过 DISCARD 命令取消一个事务，它会清空事务队列中保存的所有命令。\n1 2 3 4 5 6 7 8 \u003e MULTI OK \u003e SET PROJECT \"JavaGuide\" QUEUED \u003e GET PROJECT QUEUED \u003e DISCARD OK 你可以通过WATCH 命令监听指定的 Key，当调用 EXEC 命令执行事务时，如果一个被 WATCH 命令监视的 Key 被 其他客户端/Session 修改的话，整个事务都不会被执行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 # 客户端 1 \u003e SET PROJECT \"RustGuide\" OK \u003e WATCH PROJECT OK \u003e MULTI OK \u003e SET PROJECT \"JavaGuide\" QUEUED # 客户端 2 # 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值 \u003e SET PROJECT \"GoGuide\" # 客户端 1 # 修改失败，因为 PROJECT 的值被客户端2修改了 \u003e EXEC (nil) \u003e GET PROJECT \"GoGuide\" 不过，如果 WATCH 与 事务 在同一个 Session 里，并且被 WATCH 监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的（相关 issue：WATCH 命令碰到 MULTI 命令时的不同效果）。\n事务内部修改 WATCH 监视的 Key：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 \u003e SET PROJECT \"JavaGuide\" OK \u003e WATCH PROJECT OK \u003e MULTI OK \u003e SET PROJECT \"JavaGuide1\" QUEUED \u003e SET PROJECT \"JavaGuide2\" QUEUED \u003e SET PROJECT \"JavaGuide3\" QUEUED \u003e EXEC 1) OK 2) OK 3) OK 127.0.0.1:6379\u003e GET PROJECT \"JavaGuide3\" 事务外部修改 WATCH 监视的 Key：\n1 2 3 4 5 6 7 8 9 10 11 12 \u003e SET PROJECT \"JavaGuide\" OK \u003e WATCH PROJECT OK \u003e SET PROJECT \"JavaGuide2\" OK \u003e MULTI OK \u003e GET USER QUEUED \u003e EXEC (nil) Redis 官网相关介绍 https://redis.io/topics/transactions\nRedis 事务支持原子性吗？ Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性：1. 原子性，2. 隔离性，3. 持久性，4. 一致性。\n原子性（Atomicity）： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用； 隔离性（Isolation）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的； 持久性（Durability）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 一致性（Consistency）： 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的； Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的。\nRedis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。\nRedis 事务支持持久性吗？ Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:\n快照（snapshotting，RDB） 只追加文件（append-only file, AOF） RDB 和 AOF 的混合持久化(Redis 4.0 新增) 与 RDB 持久化相比，AOF 持久化的实时性更好。在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ fsync策略），它们分别是：\n1 2 3 appendfsync always #每次有数据修改发生时都会调用fsync函数同步AOF文件,fsync完成后线程返回,这样会严重降低Redis的速度 appendfsync everysec #每秒钟调用fsync函数同步一次AOF文件 appendfsync no #让操作系统决定何时进行同步，一般为30秒一次 AOF 持久化的fsync策略为 no、everysec 时都会存在数据丢失的情况 。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。\n因此，Redis 事务的持久性也是没办法保证的。\n如何解决 Redis 事务的缺陷？ Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。\n一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。\n不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， 严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。\n如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。\n另外，Redis 7.0 新增了 Redis functions 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。\nRedis 性能优化（重要） 除了下面介绍的内容之外，再推荐两篇不错的文章：\n你的 Redis 真的变慢了吗？性能优化如何做 - 阿里开发者 Redis 常见阻塞原因总结 - JavaGuide 使用批量操作减少网络传输 一个 Redis 命令的执行可以简化为以下 4 步：\n发送命令 命令排队 命令执行 返回结果 其中，第 1 步和第 4 步耗费时间之和称为 Round Trip Time (RTT,往返时间) ，也就是数据在网络上传输的时间。\n使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。\n另外，除了能减少 RTT 之外，发送一次命令的 socket I/O 成本也比较高（涉及上下文切换，存在read()和write()系统调用），批量操作还可以减少 socket I/O 成本。这个在官方对 pipeline 的介绍中有提到：https://redis.io/docs/manual/pipelining/ 。\n原生批量操作命令 Redis 中有一些原生支持批量操作的命令，比如：\nMGET(获取一个或多个指定 key 的值)、MSET(设置一个或多个指定 key 的值)、 HMGET(获取指定哈希表中一个或者多个指定字段的值)、HMSET(同时将一个或多个 field-value 对设置到指定哈希表中)、 SADD（向指定集合添加一个或多个元素） …… 不过，在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，使用这些原生批量操作命令可能会存在一些小问题需要解决。就比如说 MGET 无法保证所有的 key 都在同一个 hash slot（哈希槽）上，MGET可能还是需要多次网络传输，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。\n整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：\n找到 key 对应的所有 hash slot； 分别向对应的 Redis 节点发起 MGET 请求获取数据； 等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。 如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。\nRedis Cluster 并没有使用一致性哈希，采用的是 哈希槽分区 ，每一个键值对都属于一个 hash slot（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。\n我在 Redis 集群详解（付费） 这篇文章中详细介绍了 Redis Cluster 这部分的内容，感兴趣地可以看看。\npipeline 对于不支持批量操作的命令，我们可以利用 pipeline（流水线) 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。不过，需要注意控制一次批量操作的 元素个数(例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。\n与MGET、MSET等原生批量操作命令一样，pipeline 同样在 Redis Cluster 上使用会存在一些小问题。原因类似，无法保证所有的 key 都在同一个 hash slot（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。\n原生批量操作命令和 pipeline 的是有区别的，使用的时候需要注意：\n原生批量操作命令是原子操作，pipeline 是非原子操作。 pipeline 可以打包不同的命令，原生批量操作命令不可以。 原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。 顺带补充一下 pipeline 和 Redis 事务的对比：\n事务是原子操作，pipeline 是非原子操作。两个不同的事务不会同时运行，而 pipeline 可以同时以交错方式执行。 Redis 事务中每个命令都需要发送到服务端，而 Pipeline 只需要发送一次，请求次数更少。 事务可以看作是一个原子操作，但其实并不满足原子性。当我们提到 Redis 中的原子操作时，主要指的是这个操作（比如事务、Lua 脚本）不会被其他操作（比如其他事务、Lua 脚本）打扰，并不能完全保证这个操作中的所有写命令要么都执行要么都不执行。这主要也是因为 Redis 是不支持回滚操作。\n另外，pipeline 不适用于执行顺序有依赖关系的一批命令。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 Lua 脚本 。\nLua 脚本 Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是 原子操作 。也就是说，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。\n并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。\n不过， Lua 脚本依然存在下面这些缺陷：\n如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。 Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 hash slot（哈希槽）上。 大量 key 集中过期问题 我在前面提到过：对于过期 key，Redis 采用的是 定期删除+惰性/懒汉式删除 策略。\n定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。\n如何解决呢？ 下面是两种常见的方法：\n给 key 设置随机过期时间。 开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。 个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。\nRedis bigkey（大 Key） 什么是 bigkey？ 简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。\nbigkey 有什么危害？ bigkey 除了会消耗更多的内存空间和带宽，还会对性能造成比较大的影响。因此，我们应该尽量避免 Redis 中存在 bigkey。\n如何发现 bigkey？ 1、使用 Redis 自带的 --bigkeys 参数来查找。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 # redis-cli -p 6379 --bigkeys # Scanning the entire keyspace to find biggest keys as well as # average sizes per key type. You can use -i 0.1 to sleep 0.1 sec # per 100 SCAN commands (not usually needed). [00.00%] Biggest string found so far '\"ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20\"' with 4437 bytes [00.00%] Biggest list found so far '\"my-list\"' with 17 items -------- summary ------- Sampled 5 keys in the keyspace! Total key length in bytes is 264 (avg len 52.80) Biggest list found '\"my-list\"' has 17 items Biggest string found '\"ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20\"' has 4437 bytes 1 lists with 17 items (20.00% of keys, avg size 17.00) 0 hashs with 0 fields (00.00% of keys, avg size 0.00) 4 strings with 4831 bytes (80.00% of keys, avg size 1207.75) 0 streams with 0 entries (00.00% of keys, avg size 0.00) 0 sets with 0 members (00.00% of keys, avg size 0.00) 0 zsets with 0 members (00.00% of keys, avg size 0.00 从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。然而，一个 key 的元素多并不代表占用内存也多，需要我们根据具体的业务情况来进一步判断。\n在线上执行该命令时，为了降低对 Redis 的影响，需要指定 -i 参数控制扫描的频率。redis-cli -p 6379 --bigkeys -i 3 表示扫描过程中每次扫描后休息的时间间隔为 3 秒。\n2、借助开源工具分析 RDB 文件。\n通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。\n网上有现成的代码/工具可以直接拿来使用：\nredis-rdb-tools：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具 rdb_bigkeys : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。 3、借助公有云的 Redis 分析服务。\n如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。\n这里以阿里云 Redis 为例说明，它支持 bigkey 实时分析、发现，文档地址：https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature 。\n如何处理 bigkey？ bigkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：\n分割 bigkey：将一个 bigkey 分割为多个小 key。这种方式需要修改业务层的代码，一般不推荐这样做。 手动清理：Redis 4.0+ 可以使用 UNLINK 命令来异步删除一个或多个指定的 key。Redis 4.0 以下可以考虑使用 SCAN 命令结合 DEL 命令来分批次删除。 采用合适的数据结构：比如使用 HyperLogLog 统计页面 UV。 开启 lazy-free（惰性删除/延迟释放） ：lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程 Redis hotkey（热 Key） 什么是 hotkey？ 简单来说，如果一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 hotkey。例如在 Redis 实例的每秒处理请求达到 5000 次，而其中某个 key 的每秒访问量就高达 2000 次，那这个 key 就可以看作是 hotkey。\nhotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。\nhotkey 有什么危害？ 处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。此外，如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。\n因此，hotkey 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。\n如何发现 hotkey？ 1、使用 Redis 自带的 --hotkeys 参数来查找。\nRedis 4.0.3 版本中新增了 hotkeys 参数，该参数能够返回所有 key 的被访问次数。\n使用该方案的前提条件是 Redis Server 的 maxmemory-policy 参数设置为 LFU 算法，不然就会出现如下所示的错误。\n1 2 3 4 5 6 7 # redis-cli -p 6379 --hotkeys # Scanning the entire keyspace to find hot keys as well as # average sizes per key type. You can use -i 0.1 to sleep 0.1 sec # per 100 SCAN commands (not usually needed). Error: ERR An LFU maxmemory policy is not selected, access frequency not tracked. Please note that when switching between policies at runtime LRU and LFU data will take some time to adjust. Redis 中有两种 LFU 算法：\nvolatile-lfu（least frequently used）：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰。 allkeys-lfu（least frequently used）：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。 以下是配置文件 redis.conf 中的示例：\n1 2 3 4 5 # 使用 volatile-lfu 策略 maxmemory-policy volatile-lfu # 或者使用 allkeys-lfu 策略 maxmemory-policy allkeys-lfu 需要注意的是，hotkeys 参数命令也会增加 Redis 实例的 CPU 和内存消耗（全局扫描），因此需要谨慎使用。\n2、使用MONITOR 命令。\nMONITOR 命令是 Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。\n由于该命令对 Redis 性能的影响比较大，因此禁止长时间开启 MONITOR（生产环境中建议谨慎使用该命令）。\n1 2 3 4 5 6 7 8 9 10 11 12 # redis-cli 127.0.0.1:6379\u003e MONITOR OK 1683638260.637378 [0 172.17.0.1:61516] \"ping\" 1683638267.144236 [0 172.17.0.1:61518] \"smembers\" \"mySet\" 1683638268.941863 [0 172.17.0.1:61518] \"smembers\" \"mySet\" 1683638269.551671 [0 172.17.0.1:61518] \"smembers\" \"mySet\" 1683638270.646256 [0 172.17.0.1:61516] \"ping\" 1683638270.849551 [0 172.17.0.1:61518] \"smembers\" \"mySet\" 1683638271.926945 [0 172.17.0.1:61518] \"smembers\" \"mySet\" 1683638274.276599 [0 172.17.0.1:61518] \"smembers\" \"mySet2\" 1683638276.327234 [0 172.17.0.1:61518] \"smembers\" \"mySet\" 在发生紧急情况时，我们可以选择在合适的时机短暂执行 MONITOR 命令并将输出重定向至文件，在关闭 MONITOR 命令后通过对文件中请求进行归类分析即可找出这段时间中的 hotkey。\n3、借助开源项目。\n京东零售的 hotkey 这个项目不光支持 hotkey 的发现，还支持 hotkey 的处理。\n京东零售开源的 hotkey\n4、根据业务情况提前预估。\n可以根据业务情况来预估一些 hotkey，比如参与秒杀活动的商品数据等。不过，我们无法预估所有 hotkey 的出现，比如突发的热点新闻事件等。\n5、业务代码中记录分析。\n在业务代码中添加相应的逻辑对 key 的访问情况进行记录分析。不过，这种方式会让业务代码的复杂性增加，一般也不会采用。\n6、借助公有云的 Redis 分析服务。\n如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。\n这里以阿里云 Redis 为例说明，它支持 hotkey 实时分析、发现，文档地址：https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature 。\n如何解决 hotkey？ hotkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：\n读写分离：主节点处理写请求，从节点处理读请求。 使用 Redis Cluster：将热点数据分散存储在多个 Redis 节点上。 二级缓存：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。 除了这些方法之外，如果你使用的公有云的 Redis 服务话，还可以留意其提供的开箱即用的解决方案。\n这里以阿里云 Redis 为例说明，它支持通过代理查询缓存功能（Proxy Query Cache）优化热点 Key 问题。\n慢查询命令 为什么会有慢查询命令？ 我们知道一个 Redis 命令的执行可以简化为以下 4 步：\n发送命令 命令排队 命令执行 返回结果 Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。\nRedis 为什么会有慢查询命令呢？\nRedis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：\nKEYS *：会返回所有符合规则的 key。 HGETALL：会返回一个 Hash 中所有的键值对。 LRANGE：会返回 List 中指定范围内的元素。 SMEMBERS：返回 Set 中的所有元素。 SINTER/SUNION/SDIFF：计算多个 Set 的交集/并集/差集。 …… 由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 HSCAN、SSCAN、ZSCAN 代替。\n除了这些 O(n)时间复杂度的命令可能会导致慢查询之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：\nZRANGE/ZREVRANGE：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。 ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。 …… 如何找到慢查询命令？ 在 redis.conf 文件中，我们可以使用 slowlog-log-slower-than 参数设置耗时命令的阈值，并使用 slowlog-max-len 参数设置耗时命令的最大记录条数。\n当 Redis 服务器检测到执行时间超过 slowlog-log-slower-than阈值的命令时，就会将该命令记录在慢查询日志(slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。\n⚠️注意：由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。\nslowlog-log-slower-than和slowlog-max-len的默认配置如下(可以自行修改)：\n1 2 3 4 5 6 7 8 # The following time is expressed in microseconds, so 1000000 is equivalent # to one second. Note that a negative number disables the slow log, while # a value of zero forces the logging of every command. slowlog-log-slower-than 10000 # There is no limit to this length. Just be aware that it will consume memory. # You can reclaim memory used by the slow log with SLOWLOG RESET. slowlog-max-len 128 除了修改配置文件之外，你也可以直接通过 CONFIG 命令直接设置：\n1 2 3 4 # 命令执行耗时超过 10000 微妙（即10毫秒）就会被记录 CONFIG SET slowlog-log-slower-than 10000 # 只保留最近 128 条耗时命令 CONFIG SET slowlog-max-len 128 获取慢查询日志的内容很简单，直接使用SLOWLOG GET 命令即可。\n1 2 3 4 5 6 7 8 9 127.0.0.1:6379\u003e SLOWLOG GET #慢日志查询 1) 1) (integer) 5 2) (integer) 1684326682 3) (integer) 12000 4) 1) \"KEYS\" 2) \"*\" 5) \"172.17.0.1:61152\" 6) \"\" // ... 慢查询日志中的每个条目都由以下六个值组成：\n唯一渐进的日志标识符。 处理记录命令的 Unix 时间戳。 执行所需的时间量，以微秒为单位。 组成命令参数的数组。 客户端 IP 地址和端口。 客户端名称。 SLOWLOG GET 命令默认返回最近 10 条的的慢查询命令，你也自己可以指定返回的慢查询命令的数量 SLOWLOG GET N。\n下面是其他比较常用的慢查询相关的命令：\n1 2 3 4 5 6 # 返回慢查询命令的数量 127.0.0.1:6379\u003e SLOWLOG LEN (integer) 128 # 清空慢查询命令 127.0.0.1:6379\u003e SLOWLOG RESET OK Redis 生产问题（重要） 缓存穿透 什么是缓存穿透？ 缓存穿透说简单点就是大量请求的 key 是不合理的，根本不存在于缓存中，也不存在于数据库中 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。\n举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。\n有哪些解决办法？ 最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。\n1）缓存无效 key\n如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：SET key value EX 10086 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。\n另外，这里多说一嘴，一般情况下我们是这样设计 key 的：表名:列名:主键名:主键值 。\n如果用 Java 代码展示的话，差不多是下面这样的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public Object getObjectInclNullById(Integer id) { // 从缓存中获取数据 Object cacheValue = cache.get(id); // 缓存为空 if (cacheValue == null) { // 从数据库中获取 Object storageValue = storage.get(key); // 缓存空对象 cache.set(key, storageValue); // 如果存储数据为空，需要设置一个过期时间(300秒) if (storageValue == null) { // 必须设置过期时间，否则有被攻击的风险 cache.expire(key, 60 * 5); } return storageValue; } return cacheValue; } 2）布隆过滤器\n布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。\n具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。\n加入布隆过滤器之后的缓存处理流程图如下。\n但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是：布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。\n为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！\n我们先来看一下，当一个元素加入布隆过滤器中的时候，会进行哪些操作：\n使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。 根据得到的哈希值，在位数组中把对应下标的值置为 1。 我们再来看一下，当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：\n对给定元素再次进行相同的哈希计算； 得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。 然后，一定会出现这样一种情况：不同的字符串可能哈希出来的位置相同。 （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）\n更多关于布隆过滤器的内容可以看我的这篇原创：《不了解布隆过滤器？一文给你整的明明白白！》 ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。\n缓存击穿 什么是缓存击穿？ 缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期） 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。\n举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。\n有哪些解决办法？ 设置热点数据永不过期或者过期时间比较长。 针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。 请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。 缓存穿透和缓存击穿有什么区别？ 缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。\n缓存击穿中，请求的 key 对应的是 热点数据 ，该数据 存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期） 。\n缓存雪崩 什么是缓存雪崩？ 我发现缓存雪崩这名字起的有点意思，哈哈。\n实际上，缓存雪崩描述的就是这样一个简单的场景：缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。\n另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。\n举个例子：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。\n有哪些解决办法？ 针对 Redis 服务不可用的情况：\n采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。 限流，避免同时处理大量的请求。 针对热点缓存失效的情况：\n设置不同的失效时间比如随机设置缓存的失效时间。 缓存永不失效（不太推荐，实用性太差）。 设置二级缓存。 缓存雪崩和缓存击穿有什么区别？ 缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。\n如何保证缓存和数据库数据的一致性？ 细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。\n下面单独对 Cache Aside Pattern（旁路缓存模式） 来聊聊。\nCache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。\n如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：\n缓存失效时间变短（不推荐，治标不治本）：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。 增加 cache 更新重试机制（常用）：如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。 相关文章推荐：缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹\nRedis 集群 Redis Sentinel：\n什么是 Sentinel？ 有什么用？ Sentinel 如何检测节点是否下线？主观下线与客观下线的区别? Sentinel 是如何实现故障转移的？ 为什么建议部署多个 sentinel 节点（哨兵集群）？ Sentinel 如何选择出新的 master（选举机制）? 如何从 Sentinel 集群中选择出 Leader ？ Sentinel 可以防止脑裂吗？ Redis Cluster：\n为什么需要 Redis Cluster？解决了什么问题？有什么优势？ Redis Cluster 是如何分片的？ 为什么 Redis Cluster 的哈希槽是 16384 个? 如何确定给定 key 的应该分布到哪个哈希槽中？ Redis Cluster 支持重新分配哈希槽吗？ Redis Cluster 扩容缩容期间可以提供服务吗？ Redis Cluster 中的节点是怎么进行通信的？ Redis 使用规范 实际使用 Redis 的过程中，我们尽量要准守一些常见的规范，比如：\n使用连接池：避免频繁创建关闭客户端连接。 尽量不使用 O(n)指令，使用 O(n) 命令时要关注 n 的数量：像 KEYS *、HGETALL、LRANGE、SMEMBERS、SINTER/SUNION/SDIFF等 O(n) 命令并非不能使用，但是需要明确 n 的值。另外，有遍历的需求可以使用 HSCAN、SSCAN、ZSCAN 代替。 使用批量操作减少网络传输：原生批量操作命令（比如 MGET、MSET等等）、pipeline、Lua 脚本。 尽量不适用 Redis 事务：Redis 事务实现的功能比较鸡肋，可以使用 Lua 脚本代替。 禁止长时间开启 monitor：对性能影响比较大。 控制 key 的生命周期：避免 Redis 中存放了太多不经常被访问的数据。 …… 相关文章推荐：阿里云 Redis 开发规范 。\n3种常用的缓存读写策略详解 Cache Aside Pattern（旁路缓存模式） Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。\nCache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。\n下面我们来看一下这个策略模式下的缓存读写步骤。\n写：\n先更新 db 然后直接删除 cache 。 读 :\n从 cache 中读取数据，读取到就直接返回 cache 中读取不到的话，就从 db 中读取数据返回 再把数据放到 cache 中。 简单画了一张图帮助大家理解读的步骤。\n你仅仅了解了上面这些内容的话是远远不够的，我们还要搞懂其中的原理。\n比如说面试官很可能会追问：“在写数据的过程中，可以先删除 cache ，后更新 db 么？”\n答案： 那肯定是不行的！因为这样可能会造成 数据库（db）和缓存（Cache）数据不一致的问题。\n举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。\n这个过程可以简单描述为：\n请求 1 先把 cache 中的 A 数据删除 -\u003e 请求 2 从 db 中读取数据-\u003e请求 1 再把 db 中的 A 数据更新\n当你这样回答之后，面试官可能会紧接着就追问：“在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？”\n答案： 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。\n举例：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。\n这个过程可以简单描述为：\n请求 1 从 db 读数据 A-\u003e 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -\u003e 请求 1 将数据 A 写入 cache\n现在我们再来分析一下 Cache Aside Pattern 的缺陷。\n缺陷 1：首次请求数据一定不在 cache 的问题\n解决办法：可以将热点数据可以提前放入 cache 中。\n缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。\n解决办法：\n数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。 可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。 Read/Write Through Pattern（读写穿透） Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。\n这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入 db 的功能。\n写（Write Through）：\n先查 cache，cache 中不存在，直接更新 db。 cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（同步更新 cache 和 db）。 简单画了一张图帮助大家理解写的步骤。\n读(Read Through)：\n从 cache 中读取数据，读取到就直接返回 。 读取不到的话，先从 db 加载，写入到 cache 后返回响应。 简单画了一张图帮助大家理解读的步骤。\nRead-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。\n和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。\nWrite Behind Pattern（异步缓存写入） Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。\n但是，两个又有很大的不同：Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。\n很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。\n这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。\nWrite Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。\nRedis 5 种基本数据结构详解 Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。\n这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。\nRedis 基本数据结构的底层数据结构实现如下：\nString List Hash Set Zset SDS LinkedList/ZipList/QuickList Hash Table、ZipList ZipList、Intset ZipList、SkipList Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。\n你可以在 Redis 官网上找到 Redis 数据结构非常详细的介绍：\nRedis Data Structures Redis Data types tutorial 未来随着 Redis 新版本的发布，可能会有新的数据结构出现，通过查阅 Redis 官网对应的介绍，你总能获取到最靠谱的信息。\nString（字符串） 介绍 String 是 Redis 中最简单同时也是最常用的一个数据结构。\nString 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。\n虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 简单动态字符串（Simple Dynamic String，SDS）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。\n常用命令 命令 介绍 SET key value 设置指定 key 的值 SETNX key value 只有在 key 不存在时设置 key 的值 GET key 获取指定 key 的值 MSET key1 value1 key2 value2 … 设置一个或多个指定 key 的值 MGET key1 key2 … 获取一个或多个指定 key 的值 STRLEN key 返回 key 所储存的字符串值的长度 INCR key 将 key 中储存的数字值增一 DECR key 将 key 中储存的数字值减一 EXISTS key 判断指定 key 是否存在 DEL key（通用） 删除指定的 key EXPIRE key seconds（通用） 给指定 key 设置过期时间 更多 Redis String 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=string 。\n基本操作：\n1 2 3 4 5 6 7 8 9 10 11 12 \u003e SET key value OK \u003e GET key \"value\" \u003e EXISTS key (integer) 1 \u003e STRLEN key (integer) 5 \u003e DEL key (integer) 1 \u003e GET key (nil) 批量设置：\n1 2 3 4 5 \u003e MSET key1 value1 key2 value2 OK \u003e MGET key1 key2 # 批量获取多个 key 对应的 value 1) \"value1\" 2) \"value2\" 计数器（字符串的内容为整数的时候可以使用）：\n1 2 3 4 5 6 7 8 9 10 \u003e SET number 1 OK \u003e INCR number # 将 key 中储存的数字值增一 (integer) 2 \u003e GET number \"2\" \u003e DECR number # 将 key 中储存的数字值减一 (integer) 1 \u003e GET number \"1\" 设置过期时间（默认为永不过期）：\n1 2 3 4 5 6 \u003e EXPIRE key 60 (integer) 1 \u003e SETEX key 60 value # 设置值并设置过期时间 OK \u003e TTL key (integer) 56 应用场景 需要存储常规数据的场景\n举例：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。 相关命令：SET、GET。 需要计数的场景\n举例：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。 相关命令：SET、GET、 INCR、DECR 。 分布式锁\n利用 SETNX key value 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。\nList（列表） 介绍 Redis 中的 List 其实就是链表数据结构的实现。我在 线性数据结构 :数组、链表、栈、队列 这篇文章中详细介绍了链表这种数据结构，我这里就不多做介绍了。\n许多高级编程语言都内置了链表的实现比如 Java 中的 LinkedList，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 List 的实现为一个 双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。\n常用命令 命令 介绍 RPUSH key value1 value2 … 在指定列表的尾部（右边）添加一个或多个元素 LPUSH key value1 value2 … 在指定列表的头部（左边）添加一个或多个元素 LSET key index value 将指定列表索引 index 位置的值设置为 value LPOP key 移除并获取指定列表的第一个元素(最左边) RPOP key 移除并获取指定列表的最后一个元素(最右边) LLEN key 获取列表元素数量 LRANGE key start end 获取列表 start 和 end 之间 的元素 更多 Redis List 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=list 。\n通过 RPUSH/LPOP 或者 LPUSH/RPOP实现队列：\n1 2 3 4 5 6 7 8 9 10 11 12 \u003e RPUSH myList value1 (integer) 1 \u003e RPUSH myList value2 value3 (integer) 3 \u003e LPOP myList \"value1\" \u003e LRANGE myList 0 1 1) \"value2\" 2) \"value3\" \u003e LRANGE myList 0 -1 1) \"value2\" 2) \"value3\" 通过 RPUSH/RPOP或者LPUSH/LPOP 实现栈：\n1 2 3 4 \u003e RPUSH myList2 value1 value2 value3 (integer) 3 \u003e RPOP myList2 # 将 list的最右边的元素取出 \"value3\" 我专门画了一个图方便大家理解 RPUSH , LPOP , lpush , RPOP 命令：\n通过 LRANGE 查看对应下标范围的列表元素：\n1 2 3 4 5 6 7 8 9 \u003e RPUSH myList value1 value2 value3 (integer) 3 \u003e LRANGE myList 0 1 1) \"value1\" 2) \"value2\" \u003e LRANGE myList 0 -1 1) \"value1\" 2) \"value2\" 3) \"value3\" 通过 LRANGE 命令，你可以基于 List 实现分页查询，性能非常高！\n通过 LLEN 查看链表长度：\n1 2 \u003e LLEN myList (integer) 3 应用场景 信息流展示\n举例：最新文章、最新动态。 相关命令：LPUSH、LRANGE。 消息队列\nRedis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。\n相对来说，Redis 5.0 新增加的一个数据结构 Stream 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。\nHash（哈希） 介绍 Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。\nHash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。\n常用命令 命令 介绍 HSET key field value 设置指定哈希表中指定字段的值 HSETNX key field value 只有指定字段不存在时设置指定字段的值 HMSET key field1 value1 field2 value2 … 同时将一个或多个 field-value (域-值)对设置到指定哈希表中 HGET key field 获取指定哈希表中指定字段的值 HMGET key field1 field2 … 获取指定哈希表中一个或者多个指定字段的值 HGETALL key 获取指定哈希表中所有的键值对 HEXISTS key field 查看指定哈希表中指定的字段是否存在 HDEL key field1 field2 … 删除一个或多个哈希表字段 HLEN key 获取指定哈希表中字段的数量 HINCRBY key field increment 对指定哈希中的指定字段做运算操作（正数为加，负数为减） 更多 Redis Hash 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=hash 。\n模拟对象数据存储：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 \u003e HMSET userInfoKey name \"guide\" description \"dev\" age 24 OK \u003e HEXISTS userInfoKey name # 查看 key 对应的 value中指定的字段是否存在。 (integer) 1 \u003e HGET userInfoKey name # 获取存储在哈希表中指定字段的值。 \"guide\" \u003e HGET userInfoKey age \"24\" \u003e HGETALL userInfoKey # 获取在哈希表中指定 key 的所有字段和值 1) \"name\" 2) \"guide\" 3) \"description\" 4) \"dev\" 5) \"age\" 6) \"24\" \u003e HSET userInfoKey name \"GuideGeGe\" \u003e HGET userInfoKey name \"GuideGeGe\" \u003e HINCRBY userInfoKey age 2 (integer) 26 应用场景 对象数据存储场景\n举例：用户信息、商品信息、文章信息、购物车信息。 相关命令：HSET （设置单个字段的值）、HMSET（设置多个字段的值）、HGET（获取单个字段的值）、HMGET（获取多个字段的值）。 Set（集合） 介绍 Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。\n你可以基于 Set 轻易实现交集、并集、差集的操作，比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。\n常用命令 命令 介绍 SADD key member1 member2 … 向指定集合添加一个或多个元素 SMEMBERS key 获取指定集合中的所有元素 SCARD key 获取指定集合的元素数量 SISMEMBER key member 判断指定元素是否在指定集合中 SINTER key1 key2 … 获取给定所有集合的交集 SINTERSTORE destination key1 key2 … 将给定所有集合的交集存储在 destination 中 SUNION key1 key2 … 获取给定所有集合的并集 SUNIONSTORE destination key1 key2 … 将给定所有集合的并集存储在 destination 中 SDIFF key1 key2 … 获取给定所有集合的差集 SDIFFSTORE destination key1 key2 … 将给定所有集合的差集存储在 destination 中 SPOP key count 随机移除并获取指定集合中一个或多个元素 SRANDMEMBER key count 随机获取指定集合中指定数量的元素 更多 Redis Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=set 。\n基本操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 \u003e SADD mySet value1 value2 (integer) 2 \u003e SADD mySet value1 # 不允许有重复元素，因此添加失败 (integer) 0 \u003e SMEMBERS mySet 1) \"value1\" 2) \"value2\" \u003e SCARD mySet (integer) 2 \u003e SISMEMBER mySet value1 (integer) 1 \u003e SADD mySet2 value2 value3 (integer) 2 mySet : value1、value2 。 mySet2：value2、value3 。 求交集：\n1 2 3 4 \u003e SINTERSTORE mySet3 mySet mySet2 (integer) 1 \u003e SMEMBERS mySet3 1) \"value2\" 求并集：\n1 2 3 4 \u003e SUNION mySet mySet2 1) \"value3\" 2) \"value2\" 3) \"value1\" 求差集：\n1 2 \u003e SDIFF mySet mySet2 # 差集是由所有属于 mySet 但不属于 A 的元素组成的集合 1) \"value1\" 应用场景 需要存放的数据不能重复的场景\n举例：网站 UV 统计（数据量巨大的场景还是 HyperLogLog更适合一些）、文章点赞、动态点赞等场景。 相关命令：SCARD（获取集合数量） 。 需要获取多个数据源交集、并集和差集的场景\n举例：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等场景。 相关命令：SINTER（交集）、SINTERSTORE （交集）、SUNION （并集）、SUNIONSTORE（并集）、SDIFF（差集）、SDIFFSTORE （差集）。 需要随机获取数据源中的元素的场景\n举例：抽奖系统、随机点名等场景。 相关命令：SPOP（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、SRANDMEMBER（随机获取集合中的元素，适合允许重复中奖的场景）。 Sorted Set（有序集合） 介绍 Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。\n常用命令 命令 介绍 ZADD key score1 member1 score2 member2 … 向指定有序集合添加一个或多个元素 ZCARD KEY 获取指定有序集合的元素数量 ZSCORE key member 获取指定有序集合中指定元素的 score 值 ZINTERSTORE destination numkeys key1 key2 … 将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量 ZUNIONSTORE destination numkeys key1 key2 … 求并集，其它和 ZINTERSTORE 类似 ZDIFFSTORE destination numkeys key1 key2 … 求差集，其它和 ZINTERSTORE 类似 ZRANGE key start end 获取指定有序集合 start 和 end 之间的元素（score 从低到高） ZREVRANGE key start end 获取指定有序集合 start 和 end 之间的元素（score 从高到底） ZREVRANK key member 获取指定有序集合中指定元素的排名(score 从大到小排序) 更多 Redis Sorted Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：https://redis.io/commands/?group=sorted-set 。\n基本操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u003e ZADD myZset 2.0 value1 1.0 value2 (integer) 2 \u003e ZCARD myZset 2 \u003e ZSCORE myZset value1 2.0 \u003e ZRANGE myZset 0 1 1) \"value2\" 2) \"value1\" \u003e ZREVRANGE myZset 0 1 1) \"value1\" 2) \"value2\" \u003e ZADD myZset2 4.0 value2 3.0 value3 (integer) 2 myZset : value1(2.0)、value2(1.0) 。 myZset2：value2 （4.0）、value3(3.0) 。 获取指定元素的排名：\n1 2 3 4 \u003e ZREVRANK myZset value1 0 \u003e ZREVRANK myZset value2 1 求交集：\n1 2 3 4 5 \u003e ZINTERSTORE myZset3 2 myZset myZset2 1 \u003e ZRANGE myZset3 0 1 WITHSCORES value2 5 求并集：\n1 2 3 4 5 6 7 8 9 \u003e ZUNIONSTORE myZset4 2 myZset myZset2 3 \u003e ZRANGE myZset4 0 2 WITHSCORES value1 2 value3 3 value2 5 求差集：\n1 2 3 \u003e ZDIFF 2 myZset myZset2 WITHSCORES value1 2 应用场景 需要随机获取数据源中的元素根据某个权重进行排序的场景\n举例：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。 相关命令：ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。 需要存储的数据有优先级或者重要程度的场景 比如优先级任务队列。\n举例：优先级任务队列。 相关命令：ZRANGE (从小到大排序)、 ZREVRANGE （从大到小排序）、ZREVRANK (指定元素排名)。 总结 数据类型 说明 String 一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。 List Redis 的 List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。 Hash 一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。 Set 无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 HashSet 。 Zset 和 Set 相比，Sorted Set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。 Redis 3 种特殊数据结构详解 除了 5 种基本的数据结构之外，Redis 还支持 3 种特殊的数据结构：Bitmap、HyperLogLog、GEO。\nBitmap 介绍 Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。\n你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。\n常用命令 命令 介绍 SETBIT key offset value 设置指定 offset 位置的值 GETBIT key offset 获取指定 offset 位置的值 BITCOUNT key start end 获取 start 和 end 之前值为 1 的元素个数 BITOP operation destkey key1 key2 … 对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT Bitmap 基本操作演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # SETBIT 会返回之前位的值（默认是 0）这里会生成 7 个位 \u003e SETBIT mykey 7 1 (integer) 0 \u003e SETBIT mykey 7 0 (integer) 1 \u003e GETBIT mykey 7 (integer) 0 \u003e SETBIT mykey 6 1 (integer) 0 \u003e SETBIT mykey 8 1 (integer) 0 # 通过 bitcount 统计被被设置为 1 的位的数量。 \u003e BITCOUNT mykey (integer) 2 应用场景 需要保存状态信息（0/1 即可表示）的场景\n举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。 相关命令：SETBIT、GETBIT、BITCOUNT、BITOP。 HyperLogLog 介绍 HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。\nRedis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近2^64个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：\n稀疏矩阵：计数较少的时候，占用空间很小。 稠密矩阵：计数达到某个阈值的时候，占用 12k 的空间。 Redis 官方文档中有对应的详细说明：\n基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 0.81% ）。\nHyperLogLog 的使用非常简单，但原理非常复杂。HyperLogLog 的原理以及在 Redis 中的实现可以看这篇文章：HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的 。\n再推荐一个可以帮助理解 HyperLogLog 原理的工具：Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure 。\n常用命令 HyperLogLog 相关的命令非常少，最常用的也就 3 个。\n命令 介绍 PFADD key element1 element2 … 添加一个或多个元素到 HyperLogLog 中 PFCOUNT key1 key2 获取一个或者多个 HyperLogLog 的唯一计数。 PFMERGE destkey sourcekey1 sourcekey2 … 将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。 HyperLogLog 基本操作演示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u003e PFADD hll foo bar zap (integer) 1 \u003e PFADD hll zap zap zap (integer) 0 \u003e PFADD hll foo bar (integer) 0 \u003e PFCOUNT hll (integer) 3 \u003e PFADD some-other-hll 1 2 3 (integer) 1 \u003e PFCOUNT hll some-other-hll (integer) 6 \u003e PFMERGE desthll hll some-other-hll \"OK\" \u003e PFCOUNT desthll (integer) 6 应用场景 数量量巨大（百万、千万级别以上）的计数场景\n举例：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、 相关命令：PFADD、PFCOUNT 。 Geospatial index 介绍 Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。\n通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。\n常用命令 命令 介绍 GEOADD key longitude1 latitude1 member1 … 添加一个或多个元素对应的经纬度信息到 GEO 中 GEOPOS key member1 member2 … 返回给定元素的经纬度信息 GEODIST key member1 member2 M/KM/FT/MI 返回两个给定元素之间的距离 GEORADIUS key longitude latitude radius distance 获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数 GEORADIUSBYMEMBER key member radius distance 类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素 基本操作：\n1 2 3 4 5 6 7 \u003e GEOADD personLocation 116.33 39.89 user1 116.34 39.90 user2 116.35 39.88 user3 3 \u003e GEOPOS personLocation user1 116.3299986720085144 39.89000061669732844 \u003e GEODIST personLocation user1 user2 km 1.4018 通过 Redis 可视化工具查看 personLocation ，果不其然，底层就是 Sorted Set。\nGEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。\n获取指定位置范围内的其他元素：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 \u003e GEORADIUS personLocation 116.33 39.87 3 km user3 user1 \u003e GEORADIUS personLocation 116.33 39.87 2 km \u003e GEORADIUS personLocation 116.33 39.87 5 km user3 user1 user2 \u003e GEORADIUSBYMEMBER personLocation user1 5 km user3 user1 user2 \u003e GEORADIUSBYMEMBER personLocation user1 2 km user1 user2 GEORADIUS 命令的底层原理解析可以看看阿里的这篇文章：Redis 到底是怎么实现“附近的人”这个功能的呢？ 。\n移除元素：\nGEO 底层是 Sorted Set ，你可以对 GEO 使用 Sorted Set 相关的命令。\n1 2 3 4 5 6 7 \u003e ZREM personLocation user1 1 \u003e ZRANGE personLocation 0 -1 user3 user2 \u003e ZSCORE personLocation user2 4069879562983946 应用场景 需要管理使用地理空间数据的场景\n举例：附近的人。 相关命令: GEOADD、GEORADIUS、GEORADIUSBYMEMBER 。 总结 数据类型 说明 Bitmap 你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。 HyperLogLog Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近2^64个不同元素。不过，HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 0.81% ）。 Geospatial index Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。 Redis持久化机制详解 使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。\nRedis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:\n快照（snapshotting，RDB） 只追加文件（append-only file, AOF） RDB 和 AOF 的混合持久化(Redis 4.0 新增) 官方文档地址：https://redis.io/topics/persistence 。\nRDB 持久化 什么是 RDB 持久化？ Redis 可以通过创建快照来获得存储在内存里面的数据在 某个时间点 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。\n快照持久化是 Redis 默认采用的持久化方式，在 redis.conf 配置文件中默认有此下配置：\n1 2 3 4 5 save 900 1 #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。 save 300 10 #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。 save 60 10000 #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。 RDB 创建快照时会阻塞主线程吗？ Redis 提供了两个命令来生成 RDB 快照文件：\nsave : 同步保存操作，会阻塞 Redis 主线程； bgsave : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。 这里说 Redis 主线程而不是主进程的主要是因为 Redis 启动之后主要是通过单线程的方式完成主要的工作。如果你想将其描述为 Redis 主进程，也没毛病。\nAOF 持久化 什么是 AOF 持久化？ 与快照持久化相比，AOF 持久化的实时性更好。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了），可以通过 appendonly 参数开启：\n1 appendonly yes 开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 server.aof_buf 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ fsync策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。\n只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了。\nAOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 appendonly.aof。\nAOF 工作基本流程是怎样的？ AOF 持久化功能的实现可以简单分为 5 步：\n命令追加（append）：所有的写命令会追加到 AOF 缓冲区中。 文件写入（write）：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用write函数（系统调用），write将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。 文件同步（fsync）：AOF 缓冲区根据对应的持久化方式（ fsync 策略）向硬盘做同步操作。这一步需要调用 fsync 函数（系统调用）， fsync 针对单个文件操作，对其进行强制硬盘同步，fsync 将阻塞直到写入磁盘完成后返回，保证了数据持久化。 文件重写（rewrite）：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。 重启加载（load）：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。 Linux 系统直接提供了一些函数用于对文件和设备进行访问和控制，这些函数被称为 系统调用（syscall）。\n这里对上面提到的一些 Linux 系统调用再做一遍解释：\nwrite：写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘。虽然提高了效率，但也带来了数据丢失的风险。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I/O 缓冲区的状态。 fsync：fsync用于强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。 AOF 工作流程图如下：\nAOF 持久化方式有哪些？ 在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ fsync策略），它们分别是：\nappendfsync always：主线程调用 write 执行写操作后，后台线程（ aof_fsync 线程）立即会调用 fsync 函数同步 AOF 文件（刷盘），fsync 完成后线程返回，这样会严重降低 Redis 的性能（write + fsync）。 appendfsync everysec：主线程调用 write 执行写操作后立即返回，由后台线程（ aof_fsync 线程）每秒钟调用 fsync 函数（系统调用）同步一次 AOF 文件（write+fsync，fsync间隔为 1 秒） appendfsync no：主线程调用 write 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（write但不fsync，fsync 的时机由操作系统决定）。 可以看出：这 3 种持久化方式的主要区别在于 fsync 同步 AOF 文件的时机（刷盘）。\n为了兼顾数据和写入性能，可以考虑 appendfsync everysec 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能受到的影响较小。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。\n从 Redis 7.0.0 开始，Redis 使用了 Multi Part AOF 机制。顾名思义，Multi Part AOF 就是将原来的单个 AOF 文件拆分成多个 AOF 文件。在 Multi Part AOF 中，AOF 文件被分为三种类型，分别为：\nBASE：表示基础 AOF 文件，它一般由子进程通过重写产生，该文件最多只有一个。 INCR：表示增量 AOF 文件，它一般会在 AOFRW 开始执行时被创建，该文件可能存在多个。 HISTORY：表示历史 AOF 文件，它由 BASE 和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis 自动删除。 Multi Part AOF 不是重点，了解即可，详细介绍可以看看阿里开发者的Redis 7.0 Multi Part AOF 的设计和实现 这篇文章。\n相关 issue：Redis 的 AOF 方式 #783。\nAOF 为什么是在执行完命令之后记录日志？ 关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。\n为什么是在执行完命令之后记录日志呢？\n避免额外的检查开销，AOF 记录日志不会对命令进行语法检查； 在命令执行完之后再记录，不会阻塞当前的命令执行。 这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：\n如果刚执行完命令 Redis 就宕机会导致对应的修改丢失； 可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。 AOF 重写了解吗？ 当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。\nAOF 重写（rewrite） 是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。\n由于 AOF 重写会进行大量的写入操作，为了避免对 Redis 正常处理命令请求造成影响，Redis 将 AOF 重写程序放到子进程里执行。\nAOF 文件重写期间，Redis 还会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。\n开启 AOF 重写功能，可以调用 BGREWRITEAOF 命令手动执行，也可以设置下面两个配置项，让程序自动决定触发时机：\nauto-aof-rewrite-min-size：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB; auto-aof-rewrite-percentage：执行 AOF 重写时，当前 AOF 大小（aof_current_size）和上一次重写时 AOF 大小（aof_base_size）的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。 Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。\nRedis 7.0 版本之后，AOF 重写机制得到了优化改进。下面这段内容摘自阿里开发者的从 Redis7.0 发布看 Redis 的过去与未来 这篇文章。\nAOF 重写期间的增量数据如何处理一直是个问题，在过去写期间的增量数据需要在内存中保留，写结束后再把这部分增量数据写入新的 AOF 文件中以保证数据完整性。可以看出来 AOF 写会额外消耗内存和磁盘 IO，这也是 Redis AOF 写的痛点，虽然之前也进行过多次改进但是资源消耗的本质问题一直没有解决。\n阿里云的 Redis 企业版在最初也遇到了这个问题，在内部经过多次迭代开发，实现了 Multi-part AOF 机制来解决，同时也贡献给了社区并随此次 7.0 发布。具体方法是采用 base（全量数据）+inc（增量数据）独立文件存储的方式，彻底解决内存和 IO 资源的浪费，同时也支持对历史 AOF 文件的保存管理，结合 AOF 文件中的时间信息还可以实现 PITR 按时间点恢复（阿里云企业版 Tair 已支持），这进一步增强了 Redis 的数据可靠性，满足用户数据回档等需求。\n相关 issue：Redis AOF 重写描述不准确 #1439。\nAOF 校验机制了解吗？ AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 校验和（checksum） 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。\n类似地，RDB 文件也有类似的校验机制来保证 RDB 文件的正确性，这里就不重复进行介绍了。\nRedis 4.0 对于持久化机制做了什么优化？ 由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 aof-use-rdb-preamble 开启）。\n如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。\n官方文档地址：https://redis.io/topics/persistence\n如何选择 RDB 和 AOF？ 关于 RDB 和 AOF 的优缺点，官网上面也给了比较详细的说明Redis persistence，这里结合自己的理解简单总结一下。\nRDB 比 AOF 优秀的地方：\nRDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。 使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。 AOF 比 RDB 优秀的地方：\nRDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。 RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。 AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行FLUSHALL命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。 综上：\nRedis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。 不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。 如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。 Redis内存碎片详解 什么是内存碎片? 你可以将内存碎片简单地理解为那些不可用的空闲内存。\n举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。\nRedis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。\n为什么会有 Redis 内存碎片? Redis 内存碎片产生比较常见的 2 个原因：\n1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。\n以下是这段 Redis 官方的原话：\nTo store user keys, Redis allocates at most as much memory as the maxmemory setting enables (however there are small extra allocations possible).\nRedis 使用 zmalloc 方法(Redis 自己实现的内存分配方法)进行内存分配的时候，除了要分配 size 大小的内存之外，还会多分配 PREFIX_SIZE 大小的内存。\nzmalloc 方法源码如下（源码地址：https://github.com/antirez/redis-tools/blob/master/zmalloc.c）：\n1 2 3 4 5 6 7 8 9 10 11 12 13 void *zmalloc(size_t size) { // 分配指定大小的内存 void *ptr = malloc(size+PREFIX_SIZE); if (!ptr) zmalloc_oom_handler(size); #ifdef HAVE_MALLOC_SIZE update_zmalloc_stat_alloc(zmalloc_size(ptr)); return ptr; #else *((size_t*)ptr) = size; update_zmalloc_stat_alloc(size+PREFIX_SIZE); return (char*)ptr+PREFIX_SIZE; #endif } 另外，Redis 可以使用多种内存分配器来分配内存（ libc、jemalloc、tcmalloc），默认使用 jemalloc，而 jemalloc 按照一系列固定的大小（8 字节、16 字节、32 字节……）来分配内存的。jemalloc 划分的内存单元如下图所示：\n当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间，就比如说程序需要申请 17 字节的内存，jemalloc 会直接给它分配 32 字节的内存，这样会导致有 15 字节内存的浪费。不过，jemalloc 专门针对内存碎片问题做了优化，一般不会存在过度碎片化的问题。\n2、频繁修改 Redis 中的数据也会产生内存碎片。\n当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。\n这个在 Redis 官方文档中也有对应的原话:\n文档地址：https://redis.io/topics/memory-optimization 。\n如何查看 Redis 内存碎片的信息？ 使用 info memory 命令即可查看 Redis 内存相关的信息。下图中每个参数具体的含义，Redis 官方文档有详细的介绍：https://redis.io/commands/INFO 。\nRedis 内存碎片率的计算公式：mem_fragmentation_ratio （内存碎片率）= used_memory_rss (操作系统实际分配给 Redis 的物理内存空间大小)/ used_memory(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)\n也就是说，mem_fragmentation_ratio （内存碎片率）的值越大代表内存碎片率越严重。\n一定不要误认为used_memory_rss 减去 used_memory值就是内存碎片的大小！！！这不仅包括内存碎片，还包括其他进程开销，以及共享库、堆栈等的开销。\n很多小伙伴可能要问了：“多大的内存碎片率才是需要清理呢？”。\n通常情况下，我们认为 mem_fragmentation_ratio \u003e 1.5 的话才需要清理内存碎片。 mem_fragmentation_ratio \u003e 1.5 意味着你使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存。\n如果想要快速查看内存碎片率的话，你还可以通过下面这个命令：\n1 \u003e redis-cli -p 6379 info | grep mem_fragmentation_ratio 另外，内存碎片率可能存在小于 1 的情况。这种情况我在日常使用中还没有遇到过，感兴趣的小伙伴可以看看这篇文章 故障分析 | Redis 内存碎片率太低该怎么办？- 爱可生开源社区 。\n如何清理 Redis 内存碎片？ Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。\n直接通过 config set 命令将 activedefrag 配置项设置为 yes 即可。\n1 config set activedefrag yes 具体什么时候清理需要通过下面两个参数控制：\n1 2 3 4 # 内存碎片占用空间达到 500mb 的时候开始清理 config set active-defrag-ignore-bytes 500mb # 内存碎片率大于 1.5 的时候开始清理 config set active-defrag-threshold-lower 50 通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，我们可以通过下面两个参数来减少对 Redis 性能的影响：\n1 2 3 4 # 内存碎片清理所占用 CPU 时间的比例不低于 20% config set active-defrag-cycle-min 20 # 内存碎片清理所占用 CPU 时间的比例不高于 50% config set active-defrag-cycle-max 50 另外，重启节点可以做到内存碎片重新整理。如果你采用的是高可用架构的 Redis 集群的话，你可以将碎片率过高的主节点转换为从节点，以便进行安全重启。\nRedis常见阻塞原因总结 O(n) 命令 Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：\nKEYS *：会返回所有符合规则的 key。 HGETALL：会返回一个 Hash 中所有的键值对。 LRANGE：会返回 List 中指定范围内的元素。 SMEMBERS：返回 Set 中的所有元素。 SINTER/SUNION/SDIFF：计算多个 Set 的交集/并集/差集。 …… 由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长，从而导致客户端阻塞。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 HSCAN、SSCAN、ZSCAN 代替。\n除了这些 O(n)时间复杂度的命令可能会导致阻塞之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：\nZRANGE/ZREVRANGE：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。 ZREMRANGEBYRANK/ZREMRANGEBYSCORE：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。 …… SAVE 创建 RDB 快照 Redis 提供了两个命令来生成 RDB 快照文件：\nsave : 同步保存操作，会阻塞 Redis 主线程； bgsave : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。 默认情况下，Redis 默认配置会使用 bgsave 命令。如果手动使用 save 命令生成 RDB 快照文件的话，就会阻塞主线程。\nAOF AOF 日志记录阻塞 Redis AOF 持久化机制是在执行完命令之后再记录日志，这和关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复）不同。\n为什么是在执行完命令之后记录日志呢？\n避免额外的检查开销，AOF 记录日志不会对命令进行语法检查； 在命令执行完之后再记录，不会阻塞当前的命令执行。 这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：\n如果刚执行完命令 Redis 就宕机会导致对应的修改丢失； 可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。 AOF 刷盘阻塞 开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 server.aof_buf 中，然后再根据 appendfsync 配置来决定何时将其同步到硬盘中的 AOF 文件。\n在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ fsync策略），它们分别是：\nappendfsync always：主线程调用 write 执行写操作后，后台线程（ aof_fsync 线程）立即会调用 fsync 函数同步 AOF 文件（刷盘），fsync 完成后线程返回，这样会严重降低 Redis 的性能（write + fsync）。 appendfsync everysec：主线程调用 write 执行写操作后立即返回，由后台线程（ aof_fsync 线程）每秒钟调用 fsync 函数（系统调用）同步一次 AOF 文件（write+fsync，fsync间隔为 1 秒） appendfsync no：主线程调用 write 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（write但不fsync，fsync 的时机由操作系统决定）。 当后台线程（ aof_fsync 线程）调用 fsync 函数同步 AOF 文件时，需要等待，直到写入完成。当磁盘压力太大的时候，会导致 fsync 操作发生阻塞，主线程调用 write 函数时也会被阻塞。fsync 完成后，主线程执行 write 才能成功返回。\n关于 AOF 工作流程的详细介绍可以查看：Redis 持久化机制详解，有助于理解 AOF 刷盘阻塞。\nAOF 重写阻塞 fork 出一条子线程来将文件重写，在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子线程创建新 AOF 文件期间，记录服务器执行的所有写命令。 当子线程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。 最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。 阻塞就是出现在第 2 步的过程中，将缓冲区中新数据写到新文件的过程中会产生阻塞。\n相关阅读：Redis AOF 重写阻塞问题分析。\n大 Key 如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。\n大 key 造成的阻塞问题如下：\n客户端超时阻塞：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。 引发网络阻塞：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。 阻塞工作线程：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。 查找大 key 当我们在使用 Redis 自带的 --bigkeys 参数查找大 key 时，最好选择在从节点上执行该命令，因为主节点上执行时，会阻塞主节点。\n我们还可以使用 SCAN 命令来查找大 key； 通过分析 RDB 文件来找出 big key，这种方案的前提是 Redis 采用的是 RDB 持久化。网上有现成的工具： redis-rdb-tools：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具 rdb_bigkeys：Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。 删除大 key 删除操作的本质是要释放键值对占用的内存空间。\n释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，操作系统需要把释放掉的内存块插入一个空闲内存块的链表，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会阻塞当前释放内存的应用程序。\n所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。\n删除大 key 时建议采用分批次删除和异步删除的方式进行。\n清空数据库 清空数据库和上面 bigkey 删除也是同样道理，flushdb、flushall 也涉及到删除和释放所有的键值对，也是 Redis 的阻塞点。\n集群扩容 Redis 集群可以进行节点的动态扩容缩容，这一过程目前还处于半自动状态，需要人工介入。\n在扩缩容的时候，需要进行数据迁移。而 Redis 为了保证迁移的一致性，迁移所有操作都是同步操作。\n执行迁移时，两端的 Redis 均会进入时长不等的阻塞状态，对于小 Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，严重的时候会触发集群内的故障转移，造成不必要的切换。\nSwap（内存交换） 什么是 Swap？ Swap 直译过来是交换的意思，Linux 中的 Swap 常被称为内存交换或者交换分区。类似于 Windows 中的虚拟内存，就是当内存不足的时候，把一部分硬盘空间虚拟成内存使用，从而解决内存容量不足的情况。因此，Swap 分区的作用就是牺牲硬盘，增加内存，解决 VPS 内存不够用或者爆满的问题。\nSwap 对于 Redis 来说是非常致命的，Redis 保证高性能的一个重要前提是所有的数据在内存中。如果操作系统把 Redis 使用的部分内存换出硬盘，由于内存与硬盘读写的速度并几个数量级，会导致发生交换后的 Redis 性能急剧下降。\n识别 Redis 发生 Swap 的检查方法如下：\n1、查询 Redis 进程号\n1 2 reids-cli -p 6383 info server | grep process_id process_id: 4476 2、根据进程号查询内存交换信息\n1 2 3 4 5 6 7 cat /proc/4476/smaps | grep Swap Swap: 0kB Swap: 0kB Swap: 4kB Swap: 0kB Swap: 0kB ..... 如果交换量都是 0KB 或者个别的是 4KB，则正常。\n预防内存交换的方法：\n保证机器充足的可用内存 确保所有 Redis 实例设置最大可用内存(maxmemory)，防止极端情况 Redis 内存不可控的增长 降低系统使用 swap 优先级，如echo 10 \u003e /proc/sys/vm/swappiness CPU 竞争 Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。\n可以通过reids-cli --stat获取当前 Redis 使用情况。通过top命令获取进程对 CPU 的利用率等信息 通过info commandstats统计信息分析出命令不合理开销时间，查看是否是因为高算法复杂度或者过度的内存优化问题。\n网络问题 连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。\n",
  "wordCount" : "39762",
  "inLanguage": "en",
  "datePublished": "2023-07-28T05:00:00Z",
  "dateModified": "2023-07-28T05:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Wjy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://funny-toffee-4aa7c3.netlify.app/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Wjy's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://funny-toffee-4aa7c3.netlify.app/favicon.ico"
    }
  }
}
</script>

  <script id="MathJax-script" async src="https://cdn.bootcdn.net/ajax/libs/mathjax/3.2.2/es5/tex-chtml.min.js"></script>
<script>
  MathJax = {
    tex: {
      displayMath: [['\\[', '\\]'], ['$$', '$$']],  
      inlineMath:  [['\\(', '\\)'], ['$', '$']],  
    }
  };
</script>

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://funny-toffee-4aa7c3.netlify.app/" accesskey="h" title="Wjy&#39;s Blog (Alt + H)">Wjy&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://funny-toffee-4aa7c3.netlify.app/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://funny-toffee-4aa7c3.netlify.app/">Home</a>&nbsp;»&nbsp;<a href="https://funny-toffee-4aa7c3.netlify.app/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      16_Redis面试题
    </h1>
    <div class="post-meta"><span title='2023-07-28 05:00:00 +0000 UTC'>2023-07-28</span>&nbsp;·&nbsp;Wjy

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#%e6%a6%82%e8%bf%b0" aria-label="概述">概述</a><ul>
                        
                <li>
                    <a href="#redis-%e4%b8%ba%e4%bb%80%e4%b9%88%e8%bf%99%e4%b9%88%e5%bf%ab" aria-label="Redis 为什么这么快？">Redis 为什么这么快？</a></li>
                <li>
                    <a href="#%e5%88%86%e5%b8%83%e5%bc%8f%e7%bc%93%e5%ad%98%e5%b8%b8%e8%a7%81%e7%9a%84%e6%8a%80%e6%9c%af%e9%80%89%e5%9e%8b%e6%96%b9%e6%a1%88%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="分布式缓存常见的技术选型方案有哪些？">分布式缓存常见的技术选型方案有哪些？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8-redis%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e7%94%a8%e7%bc%93%e5%ad%98" aria-label="为什么要用 Redis/为什么要用缓存？">为什么要用 Redis/为什么要用缓存？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e5%ba%94%e7%94%a8" aria-label="Redis 应用">Redis 应用</a><ul>
                        
                <li>
                    <a href="#redis-%e9%99%a4%e4%ba%86%e5%81%9a%e7%bc%93%e5%ad%98%e8%bf%98%e8%83%bd%e5%81%9a%e4%bb%80%e4%b9%88" aria-label="Redis 除了做缓存，还能做什么？">Redis 除了做缓存，还能做什么？</a></li>
                <li>
                    <a href="#redis-%e5%8f%af%e4%bb%a5%e5%81%9a%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e4%b9%88" aria-label="Redis 可以做消息队列么？">Redis 可以做消息队列么？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="Redis 数据结构">Redis 数据结构</a><ul>
                        
                <li>
                    <a href="#redis-%e5%b8%b8%e7%94%a8%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="Redis 常用的数据结构有哪些？">Redis 常用的数据结构有哪些？</a></li>
                <li>
                    <a href="#string-%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="String 的应用场景有哪些？">String 的应用场景有哪些？</a></li>
                <li>
                    <a href="#string-%e8%bf%98%e6%98%af-hash-%e5%ad%98%e5%82%a8%e5%af%b9%e8%b1%a1%e6%95%b0%e6%8d%ae%e6%9b%b4%e5%a5%bd%e5%91%a2" aria-label="String 还是 Hash 存储对象数据更好呢？">String 还是 Hash 存储对象数据更好呢？</a></li>
                <li>
                    <a href="#string-%e7%9a%84%e5%ba%95%e5%b1%82%e5%ae%9e%e7%8e%b0%e6%98%af%e4%bb%80%e4%b9%88" aria-label="String 的底层实现是什么？">String 的底层实现是什么？</a></li>
                <li>
                    <a href="#%e8%b4%ad%e7%89%a9%e8%bd%a6%e4%bf%a1%e6%81%af%e7%94%a8-string-%e8%bf%98%e6%98%af-hash-%e5%ad%98%e5%82%a8%e6%9b%b4%e5%a5%bd%e5%91%a2" aria-label="购物车信息用 String 还是 Hash 存储更好呢?">购物车信息用 String 还是 Hash 存储更好呢?</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-redis-%e5%ae%9e%e7%8e%b0%e4%b8%80%e4%b8%aa%e6%8e%92%e8%a1%8c%e6%a6%9c%e6%80%8e%e4%b9%88%e5%81%9a" aria-label="使用 Redis 实现一个排行榜怎么做？">使用 Redis 实现一个排行榜怎么做？</a></li>
                <li>
                    <a href="#set-%e7%9a%84%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af%e6%98%af%e4%bb%80%e4%b9%88" aria-label="Set 的应用场景是什么？">Set 的应用场景是什么？</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-set-%e5%ae%9e%e7%8e%b0%e6%8a%bd%e5%a5%96%e7%b3%bb%e7%bb%9f%e6%80%8e%e4%b9%88%e5%81%9a" aria-label="使用 Set 实现抽奖系统怎么做？">使用 Set 实现抽奖系统怎么做？</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-bitmap-%e7%bb%9f%e8%ae%a1%e6%b4%bb%e8%b7%83%e7%94%a8%e6%88%b7%e6%80%8e%e4%b9%88%e5%81%9a" aria-label="使用 Bitmap 统计活跃用户怎么做？">使用 Bitmap 统计活跃用户怎么做？</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-hyperloglog-%e7%bb%9f%e8%ae%a1%e9%a1%b5%e9%9d%a2-uv-%e6%80%8e%e4%b9%88%e5%81%9a" aria-label="使用 HyperLogLog 统计页面 UV 怎么做？">使用 HyperLogLog 统计页面 UV 怎么做？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b%e9%87%8d%e8%a6%81" aria-label="Redis 线程模型（重要）">Redis 线程模型（重要）</a><ul>
                        
                <li>
                    <a href="#redis-%e5%8d%95%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="Redis 单线程模型了解吗？">Redis 单线程模型了解吗？</a></li>
                <li>
                    <a href="#redis60-%e4%b9%8b%e5%89%8d%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e4%bd%bf%e7%94%a8%e5%a4%9a%e7%ba%bf%e7%a8%8b" aria-label="Redis6.0 之前为什么不使用多线程？">Redis6.0 之前为什么不使用多线程？</a></li>
                <li>
                    <a href="#redis60-%e4%b9%8b%e5%90%8e%e4%b8%ba%e4%bd%95%e5%bc%95%e5%85%a5%e4%ba%86%e5%a4%9a%e7%ba%bf%e7%a8%8b" aria-label="Redis6.0 之后为何引入了多线程？">Redis6.0 之后为何引入了多线程？</a></li>
                <li>
                    <a href="#redis-%e5%90%8e%e5%8f%b0%e7%ba%bf%e7%a8%8b%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="Redis 后台线程了解吗？">Redis 后台线程了解吗？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e5%86%85%e5%ad%98%e7%ae%a1%e7%90%86" aria-label="Redis 内存管理">Redis 内存管理</a><ul>
                        
                <li>
                    <a href="#redis-%e7%bb%99%e7%bc%93%e5%ad%98%e6%95%b0%e6%8d%ae%e8%ae%be%e7%bd%ae%e8%bf%87%e6%9c%9f%e6%97%b6%e9%97%b4%e6%9c%89%e5%95%a5%e7%94%a8" aria-label="Redis 给缓存数据设置过期时间有啥用？">Redis 给缓存数据设置过期时间有啥用？</a></li>
                <li>
                    <a href="#redis-%e6%98%af%e5%a6%82%e4%bd%95%e5%88%a4%e6%96%ad%e6%95%b0%e6%8d%ae%e6%98%af%e5%90%a6%e8%bf%87%e6%9c%9f%e7%9a%84%e5%91%a2" aria-label="Redis 是如何判断数据是否过期的呢？">Redis 是如何判断数据是否过期的呢？</a></li>
                <li>
                    <a href="#%e8%bf%87%e6%9c%9f%e7%9a%84%e6%95%b0%e6%8d%ae%e7%9a%84%e5%88%a0%e9%99%a4%e7%ad%96%e7%95%a5%e4%ba%86%e8%a7%a3%e4%b9%88" aria-label="过期的数据的删除策略了解么？">过期的数据的删除策略了解么？</a></li>
                <li>
                    <a href="#redis-%e5%86%85%e5%ad%98%e6%b7%98%e6%b1%b0%e6%9c%ba%e5%88%b6%e4%ba%86%e8%a7%a3%e4%b9%88" aria-label="Redis 内存淘汰机制了解么？">Redis 内存淘汰机制了解么？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e4%ba%8b%e5%8a%a1" aria-label="Redis 事务">Redis 事务</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-redis-%e4%ba%8b%e5%8a%a1" aria-label="什么是 Redis 事务？">什么是 Redis 事务？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bd%bf%e7%94%a8-redis-%e4%ba%8b%e5%8a%a1" aria-label="如何使用 Redis 事务？">如何使用 Redis 事务？</a></li>
                <li>
                    <a href="#redis-%e4%ba%8b%e5%8a%a1%e6%94%af%e6%8c%81%e5%8e%9f%e5%ad%90%e6%80%a7%e5%90%97" aria-label="Redis 事务支持原子性吗？">Redis 事务支持原子性吗？</a></li>
                <li>
                    <a href="#redis-%e4%ba%8b%e5%8a%a1%e6%94%af%e6%8c%81%e6%8c%81%e4%b9%85%e6%80%a7%e5%90%97" aria-label="Redis 事务支持持久性吗？">Redis 事务支持持久性吗？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3-redis-%e4%ba%8b%e5%8a%a1%e7%9a%84%e7%bc%ba%e9%99%b7" aria-label="如何解决 Redis 事务的缺陷？">如何解决 Redis 事务的缺陷？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96%e9%87%8d%e8%a6%81" aria-label="Redis 性能优化（重要）">Redis 性能优化（重要）</a><ul>
                        
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8%e6%89%b9%e9%87%8f%e6%93%8d%e4%bd%9c%e5%87%8f%e5%b0%91%e7%bd%91%e7%bb%9c%e4%bc%a0%e8%be%93" aria-label="使用批量操作减少网络传输">使用批量操作减少网络传输</a><ul>
                        
                <li>
                    <a href="#%e5%8e%9f%e7%94%9f%e6%89%b9%e9%87%8f%e6%93%8d%e4%bd%9c%e5%91%bd%e4%bb%a4" aria-label="原生批量操作命令">原生批量操作命令</a></li>
                <li>
                    <a href="#pipeline" aria-label="pipeline">pipeline</a></li>
                <li>
                    <a href="#lua-%e8%84%9a%e6%9c%ac" aria-label="Lua 脚本">Lua 脚本</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a4%a7%e9%87%8f-key-%e9%9b%86%e4%b8%ad%e8%bf%87%e6%9c%9f%e9%97%ae%e9%a2%98" aria-label="大量 key 集中过期问题">大量 key 集中过期问题</a></li>
                <li>
                    <a href="#redis-bigkey%e5%a4%a7-key" aria-label="Redis bigkey（大 Key）">Redis bigkey（大 Key）</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-bigkey" aria-label="什么是 bigkey？">什么是 bigkey？</a></li>
                <li>
                    <a href="#bigkey-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8d%b1%e5%ae%b3" aria-label="bigkey 有什么危害？">bigkey 有什么危害？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%8f%91%e7%8e%b0-bigkey" aria-label="如何发现 bigkey？">如何发现 bigkey？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%a4%84%e7%90%86-bigkey" aria-label="如何处理 bigkey？">如何处理 bigkey？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-hotkey%e7%83%ad-key" aria-label="Redis hotkey（热 Key）">Redis hotkey（热 Key）</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-hotkey" aria-label="什么是 hotkey？">什么是 hotkey？</a></li>
                <li>
                    <a href="#hotkey-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8d%b1%e5%ae%b3" aria-label="hotkey 有什么危害？">hotkey 有什么危害？</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%8f%91%e7%8e%b0-hotkey" aria-label="如何发现 hotkey？">如何发现 hotkey？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e8%a7%a3%e5%86%b3-hotkey" aria-label="如何解决 hotkey？">如何解决 hotkey？</a></li>
                <li>
                    <a href="#%e6%85%a2%e6%9f%a5%e8%af%a2%e5%91%bd%e4%bb%a4" aria-label="慢查询命令">慢查询命令</a><ul>
                        
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e6%9c%89%e6%85%a2%e6%9f%a5%e8%af%a2%e5%91%bd%e4%bb%a4" aria-label="为什么会有慢查询命令？">为什么会有慢查询命令？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e6%89%be%e5%88%b0%e6%85%a2%e6%9f%a5%e8%af%a2%e5%91%bd%e4%bb%a4" aria-label="如何找到慢查询命令？">如何找到慢查询命令？</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#redis-%e7%94%9f%e4%ba%a7%e9%97%ae%e9%a2%98%e9%87%8d%e8%a6%81" aria-label="Redis 生产问题（重要）">Redis 生产问题（重要）</a><ul>
                        
                <li>
                    <a href="#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f" aria-label="缓存穿透">缓存穿透</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f" aria-label="什么是缓存穿透？">什么是缓存穿透？</a></li>
                <li>
                    <a href="#%e6%9c%89%e5%93%aa%e4%ba%9b%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95" aria-label="有哪些解决办法？">有哪些解决办法？</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf" aria-label="缓存击穿">缓存击穿</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf" aria-label="什么是缓存击穿？">什么是缓存击穿？</a></li>
                <li>
                    <a href="#%e6%9c%89%e5%93%aa%e4%ba%9b%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95-1" aria-label="有哪些解决办法？">有哪些解决办法？</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%ad%98%e7%a9%bf%e9%80%8f%e5%92%8c%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="缓存穿透和缓存击穿有什么区别？">缓存穿透和缓存击穿有什么区别？</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9" aria-label="缓存雪崩">缓存雪崩</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9" aria-label="什么是缓存雪崩？">什么是缓存雪崩？</a></li>
                <li>
                    <a href="#%e6%9c%89%e5%93%aa%e4%ba%9b%e8%a7%a3%e5%86%b3%e5%8a%9e%e6%b3%95-2" aria-label="有哪些解决办法？">有哪些解决办法？</a></li>
                <li>
                    <a href="#%e7%bc%93%e5%ad%98%e9%9b%aa%e5%b4%a9%e5%92%8c%e7%bc%93%e5%ad%98%e5%87%bb%e7%a9%bf%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="缓存雪崩和缓存击穿有什么区别？">缓存雪崩和缓存击穿有什么区别？</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e4%bf%9d%e8%af%81%e7%bc%93%e5%ad%98%e5%92%8c%e6%95%b0%e6%8d%ae%e5%ba%93%e6%95%b0%e6%8d%ae%e7%9a%84%e4%b8%80%e8%87%b4%e6%80%a7" aria-label="如何保证缓存和数据库数据的一致性？">如何保证缓存和数据库数据的一致性？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-%e9%9b%86%e7%be%a4" aria-label="Redis 集群">Redis 集群</a></li>
                <li>
                    <a href="#redis-%e4%bd%bf%e7%94%a8%e8%a7%84%e8%8c%83" aria-label="Redis 使用规范">Redis 使用规范</a></li>
                <li>
                    <a href="#3%e7%a7%8d%e5%b8%b8%e7%94%a8%e7%9a%84%e7%bc%93%e5%ad%98%e8%af%bb%e5%86%99%e7%ad%96%e7%95%a5%e8%af%a6%e8%a7%a3" aria-label="3种常用的缓存读写策略详解">3种常用的缓存读写策略详解</a><ul>
                        
                <li>
                    <a href="#cache-aside-pattern%e6%97%81%e8%b7%af%e7%bc%93%e5%ad%98%e6%a8%a1%e5%bc%8f" aria-label="Cache Aside Pattern（旁路缓存模式）">Cache Aside Pattern（旁路缓存模式）</a></li>
                <li>
                    <a href="#readwrite-through-pattern%e8%af%bb%e5%86%99%e7%a9%bf%e9%80%8f" aria-label="Read/Write Through Pattern（读写穿透）">Read/Write Through Pattern（读写穿透）</a></li>
                <li>
                    <a href="#write-behind-pattern%e5%bc%82%e6%ad%a5%e7%bc%93%e5%ad%98%e5%86%99%e5%85%a5" aria-label="Write Behind Pattern（异步缓存写入）">Write Behind Pattern（异步缓存写入）</a></li></ul>
                </li>
                <li>
                    <a href="#redis-5-%e7%a7%8d%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e8%af%a6%e8%a7%a3" aria-label="Redis 5 种基本数据结构详解">Redis 5 种基本数据结构详解</a><ul>
                        
                <li>
                    <a href="#string%e5%ad%97%e7%ac%a6%e4%b8%b2" aria-label="String（字符串）">String（字符串）</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#list%e5%88%97%e8%a1%a8" aria-label="List（列表）">List（列表）</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d-1" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-1" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-1" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#hash%e5%93%88%e5%b8%8c" aria-label="Hash（哈希）">Hash（哈希）</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d-2" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-2" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-2" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#set%e9%9b%86%e5%90%88" aria-label="Set（集合）">Set（集合）</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d-3" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-3" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-3" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#sorted-set%e6%9c%89%e5%ba%8f%e9%9b%86%e5%90%88" aria-label="Sorted Set（有序集合）">Sorted Set（有序集合）</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d-4" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-4" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-4" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#redis-3-%e7%a7%8d%e7%89%b9%e6%ae%8a%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84%e8%af%a6%e8%a7%a3" aria-label="Redis 3 种特殊数据结构详解">Redis 3 种特殊数据结构详解</a><ul>
                        
                <li>
                    <a href="#bitmap" aria-label="Bitmap">Bitmap</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d-5" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-5" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-5" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#hyperloglog" aria-label="HyperLogLog">HyperLogLog</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d-6" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-6" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-6" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#geospatial-index" aria-label="Geospatial index">Geospatial index</a><ul>
                        
                <li>
                    <a href="#%e4%bb%8b%e7%bb%8d-7" aria-label="介绍">介绍</a></li>
                <li>
                    <a href="#%e5%b8%b8%e7%94%a8%e5%91%bd%e4%bb%a4-7" aria-label="常用命令">常用命令</a></li>
                <li>
                    <a href="#%e5%ba%94%e7%94%a8%e5%9c%ba%e6%99%af-7" aria-label="应用场景">应用场景</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93-1" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#redis%e6%8c%81%e4%b9%85%e5%8c%96%e6%9c%ba%e5%88%b6%e8%af%a6%e8%a7%a3" aria-label="Redis持久化机制详解">Redis持久化机制详解</a><ul>
                        
                <li>
                    <a href="#rdb-%e6%8c%81%e4%b9%85%e5%8c%96" aria-label="RDB 持久化">RDB 持久化</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-rdb-%e6%8c%81%e4%b9%85%e5%8c%96" aria-label="什么是 RDB 持久化？">什么是 RDB 持久化？</a></li>
                <li>
                    <a href="#rdb-%e5%88%9b%e5%bb%ba%e5%bf%ab%e7%85%a7%e6%97%b6%e4%bc%9a%e9%98%bb%e5%a1%9e%e4%b8%bb%e7%ba%bf%e7%a8%8b%e5%90%97" aria-label="RDB 创建快照时会阻塞主线程吗？">RDB 创建快照时会阻塞主线程吗？</a></li></ul>
                </li>
                <li>
                    <a href="#aof-%e6%8c%81%e4%b9%85%e5%8c%96" aria-label="AOF 持久化">AOF 持久化</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af-aof-%e6%8c%81%e4%b9%85%e5%8c%96" aria-label="什么是 AOF 持久化？">什么是 AOF 持久化？</a></li>
                <li>
                    <a href="#aof-%e5%b7%a5%e4%bd%9c%e5%9f%ba%e6%9c%ac%e6%b5%81%e7%a8%8b%e6%98%af%e6%80%8e%e6%a0%b7%e7%9a%84" aria-label="AOF 工作基本流程是怎样的？">AOF 工作基本流程是怎样的？</a></li>
                <li>
                    <a href="#aof-%e6%8c%81%e4%b9%85%e5%8c%96%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="AOF 持久化方式有哪些？">AOF 持久化方式有哪些？</a></li>
                <li>
                    <a href="#aof-%e4%b8%ba%e4%bb%80%e4%b9%88%e6%98%af%e5%9c%a8%e6%89%a7%e8%a1%8c%e5%ae%8c%e5%91%bd%e4%bb%a4%e4%b9%8b%e5%90%8e%e8%ae%b0%e5%bd%95%e6%97%a5%e5%bf%97" aria-label="AOF 为什么是在执行完命令之后记录日志？">AOF 为什么是在执行完命令之后记录日志？</a></li>
                <li>
                    <a href="#aof-%e9%87%8d%e5%86%99%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="AOF 重写了解吗？">AOF 重写了解吗？</a></li>
                <li>
                    <a href="#aof-%e6%a0%a1%e9%aa%8c%e6%9c%ba%e5%88%b6%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="AOF 校验机制了解吗？">AOF 校验机制了解吗？</a></li></ul>
                </li>
                <li>
                    <a href="#redis-40-%e5%af%b9%e4%ba%8e%e6%8c%81%e4%b9%85%e5%8c%96%e6%9c%ba%e5%88%b6%e5%81%9a%e4%ba%86%e4%bb%80%e4%b9%88%e4%bc%98%e5%8c%96" aria-label="Redis 4.0 对于持久化机制做了什么优化？">Redis 4.0 对于持久化机制做了什么优化？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9-rdb-%e5%92%8c-aof" aria-label="如何选择 RDB 和 AOF？">如何选择 RDB 和 AOF？</a></li></ul>
                </li>
                <li>
                    <a href="#redis%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87%e8%af%a6%e8%a7%a3" aria-label="Redis内存碎片详解">Redis内存碎片详解</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87" aria-label="什么是内存碎片?">什么是内存碎片?</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%bc%9a%e6%9c%89-redis-%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87" aria-label="为什么会有 Redis 内存碎片?">为什么会有 Redis 内存碎片?</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e6%9f%a5%e7%9c%8b-redis-%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87%e7%9a%84%e4%bf%a1%e6%81%af" aria-label="如何查看 Redis 内存碎片的信息？">如何查看 Redis 内存碎片的信息？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e6%b8%85%e7%90%86-redis-%e5%86%85%e5%ad%98%e7%a2%8e%e7%89%87" aria-label="如何清理 Redis 内存碎片？">如何清理 Redis 内存碎片？</a></li></ul>
                </li>
                <li>
                    <a href="#redis%e5%b8%b8%e8%a7%81%e9%98%bb%e5%a1%9e%e5%8e%9f%e5%9b%a0%e6%80%bb%e7%bb%93" aria-label="Redis常见阻塞原因总结">Redis常见阻塞原因总结</a><ul>
                        
                <li>
                    <a href="#on-%e5%91%bd%e4%bb%a4" aria-label="O(n) 命令">O(n) 命令</a></li>
                <li>
                    <a href="#save-%e5%88%9b%e5%bb%ba-rdb-%e5%bf%ab%e7%85%a7" aria-label="SAVE 创建 RDB 快照">SAVE 创建 RDB 快照</a></li>
                <li>
                    <a href="#aof" aria-label="AOF">AOF</a><ul>
                        
                <li>
                    <a href="#aof-%e6%97%a5%e5%bf%97%e8%ae%b0%e5%bd%95%e9%98%bb%e5%a1%9e" aria-label="AOF 日志记录阻塞">AOF 日志记录阻塞</a></li>
                <li>
                    <a href="#aof-%e5%88%b7%e7%9b%98%e9%98%bb%e5%a1%9e" aria-label="AOF 刷盘阻塞">AOF 刷盘阻塞</a></li>
                <li>
                    <a href="#aof-%e9%87%8d%e5%86%99%e9%98%bb%e5%a1%9e" aria-label="AOF 重写阻塞">AOF 重写阻塞</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%a4%a7-key" aria-label="大 Key">大 Key</a><ul>
                        
                <li>
                    <a href="#%e6%9f%a5%e6%89%be%e5%a4%a7-key" aria-label="查找大 key">查找大 key</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e5%a4%a7-key" aria-label="删除大 key">删除大 key</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%b8%85%e7%a9%ba%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="清空数据库">清空数据库</a></li>
                <li>
                    <a href="#%e9%9b%86%e7%be%a4%e6%89%a9%e5%ae%b9" aria-label="集群扩容">集群扩容</a></li>
                <li>
                    <a href="#swap%e5%86%85%e5%ad%98%e4%ba%a4%e6%8d%a2" aria-label="Swap（内存交换）">Swap（内存交换）</a></li>
                <li>
                    <a href="#cpu-%e7%ab%9e%e4%ba%89" aria-label="CPU 竞争">CPU 竞争</a></li>
                <li>
                    <a href="#%e7%bd%91%e7%bb%9c%e9%97%ae%e9%a2%98" aria-label="网络问题">网络问题</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="概述">概述<a hidden class="anchor" aria-hidden="true" href="#概述">#</a></h1>
<p><a href="https://redis.io/">Redis</a> 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。</p>
<p>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap、HyperLogLog、GEO）。并且，Redis 还支持事务、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</p>
<p>Redis 没有外部依赖，Linux 和 OS X 是 Redis 开发和测试最多的两个操作系统，官方推荐生产环境使用 Linux 部署 Redis。</p>
<p>个人学习的话，你可以自己本机安装 Redis 或者通过 Redis 官网提供的<a href="https://try.redis.io/">在线 Redis 环境</a>（少部分命令无法使用）来实际体验 Redis。</p>
<h2 id="redis-为什么这么快">Redis 为什么这么快？<a hidden class="anchor" aria-hidden="true" href="#redis-为什么这么快">#</a></h2>
<p>Redis 内部做了非常多的性能优化，比较重要的有下面 3 点：</p>
<ol>
<li>Redis 基于内存，内存的访问速度是磁盘的上千倍；</li>
<li>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；</li>
<li>Redis 内置了多种优化过后的数据结构实现，性能非常高。</li>
</ol>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/why-redis-so-fast-d3507ae8.png"></p>
<h2 id="分布式缓存常见的技术选型方案有哪些">分布式缓存常见的技术选型方案有哪些？<a hidden class="anchor" aria-hidden="true" href="#分布式缓存常见的技术选型方案有哪些">#</a></h2>
<p>分布式缓存的话，比较老牌同时也是使用的比较多的还是 <strong>Memcached</strong> 和 <strong>Redis</strong>。不过，现在基本没有看过还有项目使用 <strong>Memcached</strong> 来做缓存，都是直接用 <strong>Redis</strong>。</p>
<p>Memcached 是分布式缓存最开始兴起的那会，比较常用的。后来，随着 Redis 的发展，大家慢慢都转而使用更加强大的 Redis 了。</p>
<p>另外，腾讯也开源了一款类似于 Redis 的分布式高性能 KV 存储数据库，基于知名的开源项目 <a href="https://github.com/facebook/rocksdb">RocksDB</a> 作为存储引擎 ，100% 兼容 Redis 协议和 Redis4.0 所有数据模型，名为 <a href="https://github.com/Tencent/Tendis">Tendis</a>。</p>
<p>关于 Redis 和 Tendis 的对比，腾讯官方曾经发过一篇文章：<a href="https://mp.weixin.qq.com/s/MeYkfOIdnU6LYlsGb24KjQ">Redis vs Tendis：冷热混合存储版架构揭秘</a> ，可以简单参考一下。</p>
<p>从这个项目的 GitHub 提交记录可以看出，Tendis 开源版几乎已经没有被维护更新了，加上其关注度并不高，使用的公司也比较少。因此，不建议你使用 Tendis 来实现分布式缓存。</p>
<h2 id="为什么要用-redis为什么要用缓存">为什么要用 Redis/为什么要用缓存？<a hidden class="anchor" aria-hidden="true" href="#为什么要用-redis为什么要用缓存">#</a></h2>
<p>下面我们主要从“高性能”和“高并发”这两点来回答这个问题。</p>
<p><strong>1、高性能</strong></p>
<p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p>
<p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p>
<p><strong>2、高并发</strong></p>
<p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p>
<blockquote>
<p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p>
</blockquote>
<p>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p>
<h1 id="redis-应用">Redis 应用<a hidden class="anchor" aria-hidden="true" href="#redis-应用">#</a></h1>
<h2 id="redis-除了做缓存还能做什么">Redis 除了做缓存，还能做什么？<a hidden class="anchor" aria-hidden="true" href="#redis-除了做缓存还能做什么">#</a></h2>
<ul>
<li><strong>分布式锁</strong>：通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。关于 Redis 实现分布式锁的详细介绍，可以看我写的这篇文章：<a href="https://javaguide.cn/distributed-system/distributed-lock.html">分布式锁详解</a> 。</li>
<li><strong>限流</strong>：一般是通过 Redis + Lua 脚本的方式来实现限流。相关阅读：<a href="https://mp.weixin.qq.com/s/kyFAWH3mVNJvurQDt4vchA">《我司用了 6 年的 Redis 分布式限流器，可以说是非常厉害了！》</a>。</li>
<li><strong>消息队列</strong>：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li>
<li><strong>延时队列</strong>：Redisson 内置了延时队列（基于 sorted set 实现的）。</li>
<li><strong>分布式 Session</strong> ：利用 string 或者 hash 保存 Session 数据，所有的服务器都可以访问。</li>
<li><strong>复杂业务场景</strong>：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li>
</ul>
<h2 id="redis-可以做消息队列么">Redis 可以做消息队列么？<a hidden class="anchor" aria-hidden="true" href="#redis-可以做消息队列么">#</a></h2>
<blockquote>
<p>实际项目中也没见谁使用 Redis 来做消息队列，对于这部分知识点大家了解就好了。</p>
</blockquote>
<p>先说结论：可以是可以，但不建议使用 Redis 来做消息队列。和专业的消息队列相比，还是有很多欠缺的地方。</p>
<p><strong>Redis 2.0 之前，如果想要使用 Redis 来做消息队列的话，只能通过 List 来实现。</strong></p>
<p>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>即可实现简易版消息队列：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 生产者生产消息</span>
</span></span><span style="display:flex;"><span>&gt; RPUSH myList msg1 msg2
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>&gt; RPUSH myList msg3
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 消费者消费消息</span>
</span></span><span style="display:flex;"><span>&gt; LPOP myList
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;msg1&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过，通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>这样的方式存在性能问题，我们需要不断轮询去调用 <code>RPOP</code> 或 <code>LPOP</code> 来消费消息。当 List 为空时，大部分的轮询的请求都是无效请求，这种方式大量浪费了系统资源。</p>
<p>因此，Redis 还提供了 <code>BLPOP</code>、<code>BRPOP</code> 这种阻塞式读取的命令（带 B-Bloking 的都是阻塞式），并且还支持一个超时参数。如果 List 为空，Redis 服务端不会立刻返回结果，它会等待 List 中有新数据后在返回或者是等待最多一个超时时间后返回空。如果将超时时间设置为 0 时，即可无限等待，直到弹出消息</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 超时时间为 10s</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 如果有数据立刻返回，否则最多等待10秒</span>
</span></span><span style="display:flex;"><span>&gt; BRPOP myList <span style="color:#ff0;font-weight:bold">10</span>
</span></span><span style="display:flex;"><span>null
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>List 实现消息队列功能太简单，像消息确认机制等功能还需要我们自己实现，最要命的是没有广播机制，消息也只能被消费一次。</strong></p>
<p><strong>Redis 2.0 引入了发布订阅 (pub/sub) 功能，解决了 List 实现消息队列没有广播机制的问题。</strong></p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-pub-sub.png"></p>
<p>pub/sub 中引入了一个概念叫 <strong>channel（频道）</strong>，发布订阅机制的实现就是基于这个 channel 来做的。</p>
<p>pub/sub 涉及发布者（Publisher）和订阅者（Subscriber，也叫消费者）两个角色：</p>
<ul>
<li>发布者通过 <code>PUBLISH</code> 投递消息给指定 channel。</li>
<li>订阅者通过<code>SUBSCRIBE</code>订阅它关心的 channel。并且，订阅者可以订阅一个或者多个 channel。</li>
</ul>
<p>我们这里启动 3 个 Redis 客户端来简单演示一下：</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-pubsub-message-queue.png"></p>
<p>pub/sub 既能单播又能广播，还支持 channel 的简单正则匹配。不过，消息丢失（客户端断开连接或者 Redis 宕机都会导致消息丢失）、消息堆积（发布者发布消息的时候不会管消费者的具体消费能力如何）等问题依然没有一个比较好的解决办法。</p>
<p>为此，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 来做消息队列。<code>Stream</code> 支持：</p>
<ul>
<li>发布 / 订阅模式</li>
<li>按照消费者组进行消费</li>
<li>消息持久化（ RDB 和 AOF）</li>
</ul>
<p><code>Stream</code> 使用起来相对要麻烦一些，这里就不演示了。而且，<code>Stream</code> 在实际使用中依然会有一些小问题不太好解决比如在 Redis 发生故障恢复后不能保证消息至少被消费一次。</p>
<p>综上，和专业的消息队列相比，使用 Redis 来实现消息队列还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议不要使用 Redis 来做消息队列，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p>
<p>相关阅读：<a href="https://mp.weixin.qq.com/s/gCUT5TcCQRAxYkTJfTRjJw">Redis 消息队列发展历程 - 阿里开发者 - 2022</a>。</p>
<h1 id="redis-数据结构">Redis 数据结构<a hidden class="anchor" aria-hidden="true" href="#redis-数据结构">#</a></h1>
<blockquote>
<p>关于 Redis 5 种基础数据结构和 3 种特殊数据结构的详细介绍请看下面这两篇文章：</p>
<ul>
<li><a href="https://javaguide.cn/database/redis/redis-data-structures-01.html">Redis 5 种基本数据结构详解</a></li>
<li><a href="https://javaguide.cn/database/redis/redis-data-structures-02.html">Redis 3 种特殊数据结构详解</a></li>
</ul>
</blockquote>
<h2 id="redis-常用的数据结构有哪些">Redis 常用的数据结构有哪些？<a hidden class="anchor" aria-hidden="true" href="#redis-常用的数据结构有哪些">#</a></h2>
<ul>
<li><strong>5 种基础数据结构</strong>：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li>
<li><strong>3 种特殊数据结构</strong>：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li>
</ul>
<h2 id="string-的应用场景有哪些">String 的应用场景有哪些？<a hidden class="anchor" aria-hidden="true" href="#string-的应用场景有哪些">#</a></h2>
<p>String 是 Redis 中最简单同时也是最常用的一个数据结构。String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>
<p>String 的常见应用场景如下：</p>
<ul>
<li>常规数据（比如 session、token、序列化后的对象、图片的路径）的缓存；</li>
<li>计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li>
<li>分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li>
<li>&hellip;&hellip;</li>
</ul>
<p>关于 String 的详细介绍请看这篇文章：<a href="https://javaguide.cn/database/redis/redis-data-structures-01.html">Redis 5 种基本数据结构详解</a>。</p>
<h2 id="string-还是-hash-存储对象数据更好呢">String 还是 Hash 存储对象数据更好呢？<a hidden class="anchor" aria-hidden="true" href="#string-还是-hash-存储对象数据更好呢">#</a></h2>
<ul>
<li>String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li>
<li>String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li>
</ul>
<p>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</p>
<h2 id="string-的底层实现是什么">String 的底层实现是什么？<a hidden class="anchor" aria-hidden="true" href="#string-的底层实现是什么">#</a></h2>
<p>Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 <code>\0</code> 结尾的字符数组），而是自己编写了 <a href="https://github.com/antirez/sds">SDS</a>（Simple Dynamic String，简单动态字符串） 来作为底层实现。</p>
<p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。</p>
<p>Redis7.0 的 SDS 的部分源码如下（https://github.com/redis/redis/blob/7.0/src/sds.h）：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#007f7f">/* Note: sdshdr5 is never used, we just access the flags byte directly.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"> * However is here to document the layout of type 5 SDS strings. */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> __attribute__ ((__packed__)) sdshdr5 {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> flags; <span style="color:#007f7f">/* 3 lsb of type, and 5 msb of string length */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> __attribute__ ((__packed__)) sdshdr8 {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint8_t</span> len; <span style="color:#007f7f">/* used */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint8_t</span> alloc; <span style="color:#007f7f">/* excluding the header and null terminator */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> flags; <span style="color:#007f7f">/* 3 lsb of type, 5 unused bits */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> __attribute__ ((__packed__)) sdshdr16 {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint16_t</span> len; <span style="color:#007f7f">/* used */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint16_t</span> alloc; <span style="color:#007f7f">/* excluding the header and null terminator */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> flags; <span style="color:#007f7f">/* 3 lsb of type, 5 unused bits */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> __attribute__ ((__packed__)) sdshdr32 {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint32_t</span> len; <span style="color:#007f7f">/* used */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint32_t</span> alloc; <span style="color:#007f7f">/* excluding the header and null terminator */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> flags; <span style="color:#007f7f">/* 3 lsb of type, 5 unused bits */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> __attribute__ ((__packed__)) sdshdr64 {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint64_t</span> len; <span style="color:#007f7f">/* used */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">uint64_t</span> alloc; <span style="color:#007f7f">/* excluding the header and null terminator */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">char</span> flags; <span style="color:#007f7f">/* 3 lsb of type, 5 unused bits */</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>字节</th>
<th>位</th>
</tr>
</thead>
<tbody>
<tr>
<td>sdshdr5</td>
<td>&lt; 1</td>
<td>&lt;8</td>
</tr>
<tr>
<td>sdshdr8</td>
<td>1</td>
<td>8</td>
</tr>
<tr>
<td>sdshdr16</td>
<td>2</td>
<td>16</td>
</tr>
<tr>
<td>sdshdr32</td>
<td>4</td>
<td>32</td>
</tr>
<tr>
<td>sdshdr64</td>
<td>8</td>
<td>64</td>
</tr>
</tbody>
</table>
<p>对于后四种实现都包含了下面这 4 个属性：</p>
<ul>
<li><code>len</code>：字符串的长度也就是已经使用的字节数</li>
<li><code>alloc</code>：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小</li>
<li><code>buf[]</code>：实际存储字符串的数组</li>
<li><code>flags</code>：低三位保存类型标志</li>
</ul>
<p>SDS 相比于 C 语言中的字符串有如下提升：</p>
<ol>
<li><strong>可以避免缓冲区溢出</strong>：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li>
<li><strong>获取字符串长度的复杂度较低</strong>：C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li>
<li><strong>减少内存分配次数</strong>：为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li>
<li><strong>二进制安全</strong>：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li>
</ol>
<p>🤐 多提一嘴，很多文章里 SDS 的定义是下面这样的：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">struct</span> sdshdr {
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> len;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">unsigned</span> <span style="color:#fff;font-weight:bold">int</span> free;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">char</span> buf[];
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></td></tr></table>
</div>
</div><p>这个也没错，Redis 3.2 之前就是这样定义的。后来，由于这种方式的定义存在问题，<code>len</code> 和 <code>free</code> 的定义用了 4 个字节，造成了浪费。Redis 3.2 之后，Redis 改进了 SDS 的定义，将其划分为了现在的 5 种类型。</p>
<h2 id="购物车信息用-string-还是-hash-存储更好呢">购物车信息用 String 还是 Hash 存储更好呢?<a hidden class="anchor" aria-hidden="true" href="#购物车信息用-string-还是-hash-存储更好呢">#</a></h2>
<p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p>
<ul>
<li>用户 id 为 key</li>
<li>商品 id 为 field，商品数量为 value</li>
</ul>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/hash-shopping-cart.png"></p>
<p>那用户购物车信息的维护具体应该怎么操作呢？</p>
<ul>
<li>用户添加商品就是往 Hash 里面增加新的 field 与 value；</li>
<li>查询购物车信息就是遍历对应的 Hash；</li>
<li>更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li>
<li>删除商品就是删除 Hash 中对应的 field；</li>
<li>清空购物车直接删除对应的 key 即可。</li>
</ul>
<p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p>
<h2 id="使用-redis-实现一个排行榜怎么做">使用 Redis 实现一个排行榜怎么做？<a hidden class="anchor" aria-hidden="true" href="#使用-redis-实现一个排行榜怎么做">#</a></h2>
<p>Redis 中有一个叫做 <code>sorted set</code> 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p>
<p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p>
<h2 id="set-的应用场景是什么">Set 的应用场景是什么？<a hidden class="anchor" aria-hidden="true" href="#set-的应用场景是什么">#</a></h2>
<p>Redis 中 <code>Set</code> 是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。</p>
<p>Set 的常见应用场景如下：</p>
<ul>
<li>存放的数据不能重复的场景：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等等。</li>
<li>需要获取多个数据源交集、并集和差集的场景：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等等。</li>
<li>需要随机获取数据源中的元素的场景：抽奖系统、随机点名等等。</li>
</ul>
<h2 id="使用-set-实现抽奖系统怎么做">使用 Set 实现抽奖系统怎么做？<a hidden class="anchor" aria-hidden="true" href="#使用-set-实现抽奖系统怎么做">#</a></h2>
<p>如果想要使用 Set 实现一个简单的抽奖系统的话，直接使用下面这几个命令就可以了：</p>
<ul>
<li><code>SADD key member1 member2 ...</code>：向指定集合添加一个或多个元素。</li>
<li><code>SPOP key count</code>：随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li>
<li><code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li>
</ul>
<h2 id="使用-bitmap-统计活跃用户怎么做">使用 Bitmap 统计活跃用户怎么做？<a hidden class="anchor" aria-hidden="true" href="#使用-bitmap-统计活跃用户怎么做">#</a></h2>
<p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p>
<p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p>
<p>如果想要使用 Bitmap 统计活跃用户的话，可以使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</p>
<p>初始化数据：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SETBIT <span style="color:#ff0;font-weight:bold">20210308</span> <span style="color:#ff0;font-weight:bold">1</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; SETBIT <span style="color:#ff0;font-weight:bold">20210308</span> <span style="color:#ff0;font-weight:bold">2</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; SETBIT <span style="color:#ff0;font-weight:bold">20210309</span> <span style="color:#ff0;font-weight:bold">1</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>统计 20210308~20210309 总活跃用户数:</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; BITOP and desk1 <span style="color:#ff0;font-weight:bold">20210308</span> <span style="color:#ff0;font-weight:bold">20210309</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; BITCOUNT desk1
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>统计 20210308~20210309 在线活跃用户数:</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; BITOP or desk2 <span style="color:#ff0;font-weight:bold">20210308</span> <span style="color:#ff0;font-weight:bold">20210309</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; BITCOUNT desk2
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="使用-hyperloglog-统计页面-uv-怎么做">使用 HyperLogLog 统计页面 UV 怎么做？<a hidden class="anchor" aria-hidden="true" href="#使用-hyperloglog-统计页面-uv-怎么做">#</a></h2>
<p>使用 HyperLogLog 统计页面 UV 主要需要用到下面这两个命令：</p>
<ul>
<li><code>PFADD key element1 element2 ...</code>：添加一个或多个元素到 HyperLogLog 中。</li>
<li><code>PFCOUNT key1 key2</code>：获取一个或者多个 HyperLogLog 的唯一计数。</li>
</ul>
<p>1、将访问指定页面的每个用户 ID 添加到 <code>HyperLogLog</code> 中。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>PFADD PAGE_1:UV USER1 USER2 ...... USERn
</span></span></code></pre></td></tr></table>
</div>
</div><p>2、统计指定页面的 UV。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>PFCOUNT PAGE_1:UV
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="redis-线程模型重要">Redis 线程模型（重要）<a hidden class="anchor" aria-hidden="true" href="#redis-线程模型重要">#</a></h1>
<p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p>
<h2 id="redis-单线程模型了解吗">Redis 单线程模型了解吗？<a hidden class="anchor" aria-hidden="true" href="#redis-单线程模型了解吗">#</a></h2>
<p><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p>
<p>《Redis 设计与实现》有一段话是如是介绍文件事件处理器的，我觉得写得挺不错。</p>
<blockquote>
<p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。</p>
<ul>
<li>文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li>
<li>当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li>
</ul>
<p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p>
</blockquote>
<p><strong>既然是单线程，那怎么监听大量的客户端连接呢？</strong></p>
<p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p>
<p>这样的好处非常明显：<strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p>
<p>文件事件处理器（file event handler）主要是包含 4 个部分：</p>
<ul>
<li>多个 socket（客户端连接）</li>
<li>IO 多路复用程序（支持多个客户端连接的关键）</li>
<li>文件事件分派器（将 socket 关联到相应的事件处理器）</li>
<li>事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li>
</ul>
<h2 id="redis60-之前为什么不使用多线程">Redis6.0 之前为什么不使用多线程？<a hidden class="anchor" aria-hidden="true" href="#redis60-之前为什么不使用多线程">#</a></h2>
<p>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p>
<p>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。</p>
<p>为此，Redis 4.0 之后新增了<code>UNLINK</code>（可以看作是 <code>DEL</code> 的异步版本）、<code>FLUSHALL ASYNC</code>（清空所有数据库的所有 key，不仅仅是当前 <code>SELECT</code> 的数据库）、<code>FLUSHDB ASYNC</code>（清空当前 <code>SELECT</code> 数据库中的所有 key）等异步命令。</p>
<p>大体上来说，Redis 6.0 之前主要还是单线程处理。</p>
<p><strong>那 Redis6.0 之前为什么不使用多线程？</strong> 我觉得主要原因有 3 点：</p>
<ul>
<li>单线程编程容易并且更容易维护；</li>
<li>Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li>
<li>多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li>
</ul>
<h2 id="redis60-之后为何引入了多线程">Redis6.0 之后为何引入了多线程？<a hidden class="anchor" aria-hidden="true" href="#redis60-之后为何引入了多线程">#</a></h2>
<p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p>
<p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p>
<p>Redis6.0 的多线程默认是禁用的，只使用主线程。如需开启需要设置 IO 线程数 &gt; 1，需要修改 redis 配置文件 <code>redis.conf</code>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>io-threads <span style="color:#ff0;font-weight:bold">4</span> <span style="color:#007f7f">#设置1的话只会开启主线程，官网建议4核的机器建议设置为2或3个线程，8核的建议设置为6个线程</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外：</p>
<ul>
<li>io-threads 的个数一旦设置，不能通过 config 动态设置。</li>
<li>当设置 ssl 后，io-threads 将不工作。</li>
</ul>
<p>开启多线程后，默认只会使用多线程进行 IO 写入 writes，即发送数据给客户端，如果需要开启多线程 IO 读取 reads，同样需要修改 redis 配置文件 <code>redis.conf</code> :</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>io-threads-do-reads yes
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是官网描述开启多线程读并不能有太大提升，因此一般情况下并不建议开启</p>
<h2 id="redis-后台线程了解吗">Redis 后台线程了解吗？<a hidden class="anchor" aria-hidden="true" href="#redis-后台线程了解吗">#</a></h2>
<p>我们虽然经常说 Redis 是单线程模型（主要逻辑是单线程完成的），但实际还有一些后台线程用于执行一些比较耗时的操作：</p>
<ul>
<li>通过 <code>bio_close_file</code> 后台线程来释放 AOF / RDB 等过程中产生的临时文件资源。</li>
<li>通过 <code>bio_aof_fsync</code> 后台线程调用 <code>fsync</code> 函数将系统内核缓冲区还未同步到到磁盘的数据强制刷到磁盘（ AOF 文件）。</li>
<li>通过 <code>bio_lazy_free</code>后台线程释放大对象（已删除）占用的内存空间.</li>
</ul>
<p>在<code>bio.h</code> 文件中有定义（Redis 6.0 版本，源码地址：https://github.com/redis/redis/blob/6.0/src/bio.h）：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f00">#</span>ifndef __BIO_H
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>define __BIO_H
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* Exported API */</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> bioInit(<span style="color:#fff;font-weight:bold">void</span>);
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> bioCreateBackgroundJob(<span style="color:#fff;font-weight:bold">int</span> type, <span style="color:#fff;font-weight:bold">void</span> *arg1, <span style="color:#fff;font-weight:bold">void</span> *arg2, <span style="color:#fff;font-weight:bold">void</span> *arg3);
</span></span><span style="display:flex;"><span>unsigned <span style="color:#fff;font-weight:bold">long</span> <span style="color:#fff;font-weight:bold">long</span> bioPendingJobsOfType(<span style="color:#fff;font-weight:bold">int</span> type);
</span></span><span style="display:flex;"><span>unsigned <span style="color:#fff;font-weight:bold">long</span> <span style="color:#fff;font-weight:bold">long</span> bioWaitStepOfType(<span style="color:#fff;font-weight:bold">int</span> type);
</span></span><span style="display:flex;"><span>time_t bioOlderJobOfType(<span style="color:#fff;font-weight:bold">int</span> type);
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> bioKillThreads(<span style="color:#fff;font-weight:bold">void</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">/* Background job opcodes */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>define BIO_CLOSE_FILE    0 <span style="color:#007f7f">/* Deferred close(2) syscall. */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>define BIO_AOF_FSYNC     1 <span style="color:#007f7f">/* Deferred AOF fsync. */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>define BIO_LAZY_FREE     2 <span style="color:#007f7f">/* Deferred objects freeing. */</span>
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>define BIO_NUM_OPS       3
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>endif
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="redis-内存管理">Redis 内存管理<a hidden class="anchor" aria-hidden="true" href="#redis-内存管理">#</a></h1>
<h2 id="redis-给缓存数据设置过期时间有啥用">Redis 给缓存数据设置过期时间有啥用？<a hidden class="anchor" aria-hidden="true" href="#redis-给缓存数据设置过期时间有啥用">#</a></h2>
<p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p>
<p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p>
<p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>127.0.0.1:6379&gt; expire key <span style="color:#ff0;font-weight:bold">60</span> <span style="color:#007f7f"># 数据在 60s 后过期</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; setex key <span style="color:#ff0;font-weight:bold">60</span> value <span style="color:#007f7f"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; ttl key <span style="color:#007f7f"># 查看数据还有多久过期</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">56</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>注意：<strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p>
<p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p>
<p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。</p>
<p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p>
<h2 id="redis-是如何判断数据是否过期的呢">Redis 是如何判断数据是否过期的呢？<a hidden class="anchor" aria-hidden="true" href="#redis-是如何判断数据是否过期的呢">#</a></h2>
<p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-expired-dictionary.png"></p>
<p>过期字典是存储在 redisDb 这个结构里的：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">typedef</span> <span style="color:#fff;font-weight:bold">struct</span> redisDb {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    dict *dict;     <span style="color:#007f7f">//数据库键空间,保存着数据库中所有键值对
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    dict *expires   <span style="color:#007f7f">// 过期字典,保存着键的过期时间
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>    ...
</span></span><span style="display:flex;"><span>} redisDb;
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="过期的数据的删除策略了解么">过期的数据的删除策略了解么？<a hidden class="anchor" aria-hidden="true" href="#过期的数据的删除策略了解么">#</a></h2>
<p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p>
<p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p>
<ol>
<li><strong>惰性删除</strong>：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li>
<li><strong>定期删除</strong>：每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li>
</ol>
<p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p>
<p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p>
<p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p>
<h2 id="redis-内存淘汰机制了解么">Redis 内存淘汰机制了解么？<a hidden class="anchor" aria-hidden="true" href="#redis-内存淘汰机制了解么">#</a></h2>
<blockquote>
<p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p>
</blockquote>
<p>Redis 提供 6 种数据淘汰策略：</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最近最少使用的数据淘汰。</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选将要过期的数据淘汰。</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中任意选择数据淘汰。</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）。</li>
<li><strong>allkeys-random</strong>：从数据集（<code>server.db[i].dict</code>）中任意选择数据淘汰。</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li>
</ol>
<h1 id="redis-事务">Redis 事务<a hidden class="anchor" aria-hidden="true" href="#redis-事务">#</a></h1>
<h2 id="什么是-redis-事务">什么是 Redis 事务？<a hidden class="anchor" aria-hidden="true" href="#什么是-redis-事务">#</a></h2>
<p>你可以将 Redis 中的事务理解为：<strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p>
<p>Redis 事务实际开发中使用的非常少，功能比较鸡肋，不要将其和我们平时理解的关系型数据库的事务混淆了。</p>
<p>除了不满足原子性和持久性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。</p>
<p>因此，Redis 事务是不建议在日常开发中使用的。</p>
<h2 id="如何使用-redis-事务">如何使用 Redis 事务？<a hidden class="anchor" aria-hidden="true" href="#如何使用-redis-事务">#</a></h2>
<p>Redis 可以通过 <strong><code>MULTI</code>，<code>EXEC</code>，<code>DISCARD</code> 和 <code>WATCH</code></strong> 等命令来实现事务(Transaction)功能。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; MULTI
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide&#34;</span>
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; GET PROJECT
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; EXEC
</span></span><span style="display:flex;"><span>1) OK
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;JavaGuide&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><a href="https://redis.io/commands/multi"><code>MULTI</code></a> 命令后可以输入多个命令，Redis 不会立即执行这些命令，而是将它们放到队列，当调用了 <a href="https://redis.io/commands/exec"><code>EXEC</code></a> 命令后，再执行所有的命令。</p>
<p>这个过程是这样的：</p>
<ol>
<li>开始事务（<code>MULTI</code>）；</li>
<li>命令入队(批量操作 Redis 的命令，先进先出（FIFO）的顺序执行)；</li>
<li>执行事务(<code>EXEC</code>)。</li>
</ol>
<p>你也可以通过 <a href="https://redis.io/commands/discard"><code>DISCARD</code></a> 命令取消一个事务，它会清空事务队列中保存的所有命令。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; MULTI
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide&#34;</span>
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; GET PROJECT
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; DISCARD
</span></span><span style="display:flex;"><span>OK
</span></span></code></pre></td></tr></table>
</div>
</div><p>你可以通过<a href="https://redis.io/commands/watch"><code>WATCH</code></a> 命令监听指定的 Key，当调用 <code>EXEC</code> 命令执行事务时，如果一个被 <code>WATCH</code> 命令监视的 Key 被 <strong>其他客户端/Session</strong> 修改的话，整个事务都不会被执行。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 客户端 1</span>
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;RustGuide&#34;</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; WATCH PROJECT
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; MULTI
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide&#34;</span>
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 客户端 2</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 在客户端 1 执行 EXEC 命令提交事务之前修改 PROJECT 的值</span>
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;GoGuide&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 客户端 1</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 修改失败，因为 PROJECT 的值被客户端2修改了</span>
</span></span><span style="display:flex;"><span>&gt; EXEC
</span></span><span style="display:flex;"><span>(nil)
</span></span><span style="display:flex;"><span>&gt; GET PROJECT
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;GoGuide&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>不过，如果 <strong>WATCH</strong> 与 <strong>事务</strong> 在同一个 Session 里，并且被 <strong>WATCH</strong> 监视的 Key 被修改的操作发生在事务内部，这个事务是可以被执行成功的（相关 issue：<a href="https://github.com/Snailclimb/JavaGuide/issues/1714">WATCH 命令碰到 MULTI 命令时的不同效果</a>）。</p>
<p>事务内部修改 WATCH 监视的 Key：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide&#34;</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; WATCH PROJECT
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; MULTI
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide1&#34;</span>
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide2&#34;</span>
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide3&#34;</span>
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; EXEC
</span></span><span style="display:flex;"><span>1) OK
</span></span><span style="display:flex;"><span>2) OK
</span></span><span style="display:flex;"><span>3) OK
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; GET PROJECT
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;JavaGuide3&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>事务外部修改 WATCH 监视的 Key：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide&#34;</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; WATCH PROJECT
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; SET PROJECT <span style="color:#0ff;font-weight:bold">&#34;JavaGuide2&#34;</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; MULTI
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; GET USER
</span></span><span style="display:flex;"><span>QUEUED
</span></span><span style="display:flex;"><span>&gt; EXEC
</span></span><span style="display:flex;"><span>(nil)
</span></span></code></pre></td></tr></table>
</div>
</div><p>Redis 官网相关介绍 <a href="https://redis.io/topics/transactions">https://redis.io/topics/transactions</a></p>
<h2 id="redis-事务支持原子性吗">Redis 事务支持原子性吗？<a hidden class="anchor" aria-hidden="true" href="#redis-事务支持原子性吗">#</a></h2>
<p>Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性：<strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p>
<ol>
<li><strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li>
<li><strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li>
<li><strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li>
<li><strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li>
</ol>
<p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的。</p>
<p>Redis 官网也解释了自己为啥不支持回滚。简单来说就是 Redis 开发者们觉得没必要支持回滚，这样更简单便捷并且性能更好。Redis 开发者觉得即使命令执行错误也应该在开发过程中就被发现而不是生产过程中。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-rollback.png"></p>
<h2 id="redis-事务支持持久性吗">Redis 事务支持持久性吗？<a hidden class="anchor" aria-hidden="true" href="#redis-事务支持持久性吗">#</a></h2>
<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p>
<ul>
<li>快照（snapshotting，RDB）</li>
<li>只追加文件（append-only file, AOF）</li>
<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>
</ul>
<p>与 RDB 持久化相比，AOF 持久化的实时性更好。在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>appendfsync always    <span style="color:#007f7f">#每次有数据修改发生时都会调用fsync函数同步AOF文件,fsync完成后线程返回,这样会严重降低Redis的速度</span>
</span></span><span style="display:flex;"><span>appendfsync everysec  <span style="color:#007f7f">#每秒钟调用fsync函数同步一次AOF文件</span>
</span></span><span style="display:flex;"><span>appendfsync no        <span style="color:#007f7f">#让操作系统决定何时进行同步，一般为30秒一次</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>AOF 持久化的<code>fsync</code>策略为 no、everysec 时都会存在数据丢失的情况 。always 下可以基本是可以满足持久性要求的，但性能太差，实际开发过程中不会使用。</p>
<p>因此，Redis 事务的持久性也是没办法保证的。</p>
<h2 id="如何解决-redis-事务的缺陷">如何解决 Redis 事务的缺陷？<a hidden class="anchor" aria-hidden="true" href="#如何解决-redis-事务的缺陷">#</a></h2>
<p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</p>
<p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</p>
<p>不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， <strong>严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</strong></p>
<p>如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。</p>
<p>另外，Redis 7.0 新增了 <a href="https://redis.io/docs/manual/programmability/functions-intro/">Redis functions</a> 特性，你可以将 Redis functions 看作是比 Lua 更强大的脚本。</p>
<h1 id="redis-性能优化重要">Redis 性能优化（重要）<a hidden class="anchor" aria-hidden="true" href="#redis-性能优化重要">#</a></h1>
<p>除了下面介绍的内容之外，再推荐两篇不错的文章：</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s/nNEuYw0NlYGhuKKKKoWfcQ">你的 Redis 真的变慢了吗？性能优化如何做 - 阿里开发者</a></li>
<li><a href="https://javaguide.cn/database/redis/redis-common-blocking-problems-summary.html">Redis 常见阻塞原因总结 - JavaGuide</a></li>
</ul>
<h2 id="使用批量操作减少网络传输">使用批量操作减少网络传输<a hidden class="anchor" aria-hidden="true" href="#使用批量操作减少网络传输">#</a></h2>
<p>一个 Redis 命令的执行可以简化为以下 4 步：</p>
<ol>
<li>发送命令</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ol>
<p>其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是数据在网络上传输的时间。</p>
<p>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。</p>
<p>另外，除了能减少 RTT 之外，发送一次命令的 socket I/O 成本也比较高（涉及上下文切换，存在<code>read()</code>和<code>write()</code>系统调用），批量操作还可以减少 socket I/O 成本。这个在官方对 pipeline 的介绍中有提到：https://redis.io/docs/manual/pipelining/ 。</p>
<h3 id="原生批量操作命令">原生批量操作命令<a hidden class="anchor" aria-hidden="true" href="#原生批量操作命令">#</a></h3>
<p>Redis 中有一些原生支持批量操作的命令，比如：</p>
<ul>
<li><code>MGET</code>(获取一个或多个指定 key 的值)、<code>MSET</code>(设置一个或多个指定 key 的值)、</li>
<li><code>HMGET</code>(获取指定哈希表中一个或者多个指定字段的值)、<code>HMSET</code>(同时将一个或多个 field-value 对设置到指定哈希表中)、</li>
<li><code>SADD</code>（向指定集合添加一个或多个元素）</li>
<li>&hellip;&hellip;</li>
</ul>
<p>不过，在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，使用这些原生批量操作命令可能会存在一些小问题需要解决。就比如说 <code>MGET</code> 无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上，<code>MGET</code>可能还是需要多次网络传输，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。</p>
<p>整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：</p>
<ol>
<li>找到 key 对应的所有 hash slot；</li>
<li>分别向对应的 Redis 节点发起 <code>MGET</code> 请求获取数据；</li>
<li>等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。</li>
</ol>
<p>如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。</p>
<blockquote>
<p>Redis Cluster 并没有使用一致性哈希，采用的是 <strong>哈希槽分区</strong> ，每一个键值对都属于一个 <strong>hash slot</strong>（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。</p>
<p>我在 <a href="https://javaguide.cn/database/redis/redis-cluster.html">Redis 集群详解（付费）</a> 这篇文章中详细介绍了 Redis Cluster 这部分的内容，感兴趣地可以看看。</p>
</blockquote>
<h3 id="pipeline">pipeline<a hidden class="anchor" aria-hidden="true" href="#pipeline">#</a></h3>
<p>对于不支持批量操作的命令，我们可以利用 <strong>pipeline（流水线)</strong> 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。不过，需要注意控制一次批量操作的 <strong>元素个数</strong>(例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。</p>
<p>与<code>MGET</code>、<code>MSET</code>等原生批量操作命令一样，pipeline 同样在 Redis Cluster 上使用会存在一些小问题。原因类似，无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。</p>
<p>原生批量操作命令和 pipeline 的是有区别的，使用的时候需要注意：</p>
<ul>
<li>原生批量操作命令是原子操作，pipeline 是非原子操作。</li>
<li>pipeline 可以打包不同的命令，原生批量操作命令不可以。</li>
<li>原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。</li>
</ul>
<p>顺带补充一下 pipeline 和 Redis 事务的对比：</p>
<ul>
<li>事务是原子操作，pipeline 是非原子操作。两个不同的事务不会同时运行，而 pipeline 可以同时以交错方式执行。</li>
<li>Redis 事务中每个命令都需要发送到服务端，而 Pipeline 只需要发送一次，请求次数更少。</li>
</ul>
<blockquote>
<p>事务可以看作是一个原子操作，但其实并不满足原子性。当我们提到 Redis 中的原子操作时，主要指的是这个操作（比如事务、Lua 脚本）不会被其他操作（比如其他事务、Lua 脚本）打扰，并不能完全保证这个操作中的所有写命令要么都执行要么都不执行。这主要也是因为 Redis 是不支持回滚操作。</p>
</blockquote>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-pipeline-vs-transaction.png"></p>
<p>另外，pipeline 不适用于执行顺序有依赖关系的一批命令。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 <strong>Lua 脚本</strong> 。</p>
<h3 id="lua-脚本">Lua 脚本<a hidden class="anchor" aria-hidden="true" href="#lua-脚本">#</a></h3>
<p>Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是 <strong>原子操作</strong> 。也就是说，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。</p>
<p>并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。</p>
<p>不过， Lua 脚本依然存在下面这些缺陷：</p>
<ul>
<li>如果 Lua 脚本运行时出错并中途结束，之后的操作不会进行，但是之前已经发生的写操作不会撤销，所以即使使用了 Lua 脚本，也不能实现类似数据库回滚的原子性。</li>
<li>Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。</li>
</ul>
<h2 id="大量-key-集中过期问题">大量 key 集中过期问题<a hidden class="anchor" aria-hidden="true" href="#大量-key-集中过期问题">#</a></h2>
<p>我在前面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 策略。</p>
<p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p>
<p><strong>如何解决呢？</strong> 下面是两种常见的方法：</p>
<ol>
<li>给 key 设置随机过期时间。</li>
<li>开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li>
</ol>
<p>个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</p>
<h2 id="redis-bigkey大-key">Redis bigkey（大 Key）<a hidden class="anchor" aria-hidden="true" href="#redis-bigkey大-key">#</a></h2>
<h3 id="什么是-bigkey">什么是 bigkey？<a hidden class="anchor" aria-hidden="true" href="#什么是-bigkey">#</a></h3>
<p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p>
<h3 id="bigkey-有什么危害">bigkey 有什么危害？<a hidden class="anchor" aria-hidden="true" href="#bigkey-有什么危害">#</a></h3>
<p>bigkey 除了会消耗更多的内存空间和带宽，还会对性能造成比较大的影响。因此，我们应该尽量避免 Redis 中存在 bigkey。</p>
<h3 id="如何发现-bigkey">如何发现 bigkey？<a hidden class="anchor" aria-hidden="true" href="#如何发现-bigkey">#</a></h3>
<p><strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># redis-cli -p 6379 --bigkeys</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># Scanning the entire keyspace to find biggest keys as well as</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># per 100 SCAN commands (not usually needed).</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>[00.00%] Biggest string found so far <span style="color:#0ff;font-weight:bold">&#39;&#34;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&#34;&#39;</span> with <span style="color:#ff0;font-weight:bold">4437</span> bytes
</span></span><span style="display:flex;"><span>[00.00%] Biggest list   found so far <span style="color:#0ff;font-weight:bold">&#39;&#34;my-list&#34;&#39;</span> with <span style="color:#ff0;font-weight:bold">17</span> items
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>-------- summary -------
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Sampled <span style="color:#ff0;font-weight:bold">5</span> keys in the keyspace!
</span></span><span style="display:flex;"><span>Total key length in bytes is <span style="color:#ff0;font-weight:bold">264</span> (avg len 52.80)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Biggest   list found <span style="color:#0ff;font-weight:bold">&#39;&#34;my-list&#34;&#39;</span> has <span style="color:#ff0;font-weight:bold">17</span> items
</span></span><span style="display:flex;"><span>Biggest string found <span style="color:#0ff;font-weight:bold">&#39;&#34;ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20&#34;&#39;</span> has <span style="color:#ff0;font-weight:bold">4437</span> bytes
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">1</span> lists with <span style="color:#ff0;font-weight:bold">17</span> items (20.00% of keys, avg size 17.00)
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">0</span> hashs with <span style="color:#ff0;font-weight:bold">0</span> fields (00.00% of keys, avg size 0.00)
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">4</span> strings with <span style="color:#ff0;font-weight:bold">4831</span> bytes (80.00% of keys, avg size 1207.75)
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">0</span> streams with <span style="color:#ff0;font-weight:bold">0</span> entries (00.00% of keys, avg size 0.00)
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">0</span> sets with <span style="color:#ff0;font-weight:bold">0</span> members (00.00% of keys, avg size 0.00)
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">0</span> zsets with <span style="color:#ff0;font-weight:bold">0</span> members (00.00% of keys, avg size 0.00
</span></span></code></pre></td></tr></table>
</div>
</div><p>从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。然而，一个 key 的元素多并不代表占用内存也多，需要我们根据具体的业务情况来进一步判断。</p>
<p>在线上执行该命令时，为了降低对 Redis 的影响，需要指定 <code>-i</code> 参数控制扫描的频率。<code>redis-cli -p 6379 --bigkeys -i 3</code> 表示扫描过程中每次扫描后休息的时间间隔为 3 秒。</p>
<p><strong>2、借助开源工具分析 RDB 文件。</strong></p>
<p>通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p>
<p>网上有现成的代码/工具可以直接拿来使用：</p>
<ul>
<li><a href="https://github.com/sripathikrishnan/redis-rdb-tools">redis-rdb-tools</a>：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>
<li><a href="https://github.com/weiyanwei412/rdb_bigkeys">rdb_bigkeys</a> : Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>
</ul>
<p><strong>3、借助公有云的 Redis 分析服务。</strong></p>
<p>如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。</p>
<p>这里以阿里云 Redis 为例说明，它支持 bigkey 实时分析、发现，文档地址：<a href="https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature">https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature</a> 。</p>
<h3 id="如何处理-bigkey">如何处理 bigkey？<a hidden class="anchor" aria-hidden="true" href="#如何处理-bigkey">#</a></h3>
<p>bigkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p>
<ul>
<li><strong>分割 bigkey</strong>：将一个 bigkey 分割为多个小 key。这种方式需要修改业务层的代码，一般不推荐这样做。</li>
<li><strong>手动清理</strong>：Redis 4.0+ 可以使用 <code>UNLINK</code> 命令来异步删除一个或多个指定的 key。Redis 4.0 以下可以考虑使用 <code>SCAN</code> 命令结合 <code>DEL</code> 命令来分批次删除。</li>
<li><strong>采用合适的数据结构</strong>：比如使用 HyperLogLog 统计页面 UV。</li>
<li><strong>开启 lazy-free（惰性删除/延迟释放）</strong> ：lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程</li>
</ul>
<h2 id="redis-hotkey热-key">Redis hotkey（热 Key）<a hidden class="anchor" aria-hidden="true" href="#redis-hotkey热-key">#</a></h2>
<h3 id="什么是-hotkey">什么是 hotkey？<a hidden class="anchor" aria-hidden="true" href="#什么是-hotkey">#</a></h3>
<p>简单来说，如果一个 key 的访问次数比较多且明显多于其他 key 的话，那这个 key 就可以看作是 hotkey。例如在 Redis 实例的每秒处理请求达到 5000 次，而其中某个 key 的每秒访问量就高达 2000 次，那这个 key 就可以看作是 hotkey。</p>
<p>hotkey 出现的原因主要是某个热点数据访问量暴增，如重大的热搜事件、参与秒杀的商品。</p>
<h3 id="hotkey-有什么危害">hotkey 有什么危害？<a hidden class="anchor" aria-hidden="true" href="#hotkey-有什么危害">#</a></h3>
<p>处理 hotkey 会占用大量的 CPU 和带宽，可能会影响 Redis 实例对其他请求的正常处理。此外，如果突然访问 hotkey 的请求超出了 Redis 的处理能力，Redis 就会直接宕机。这种情况下，大量请求将落到后面的数据库上，可能会导致数据库崩溃。</p>
<p>因此，hotkey 很可能成为系统性能的瓶颈点，需要单独对其进行优化，以确保系统的高可用性和稳定性。</p>
<h2 id="如何发现-hotkey">如何发现 hotkey？<a hidden class="anchor" aria-hidden="true" href="#如何发现-hotkey">#</a></h2>
<p><strong>1、使用 Redis 自带的 <code>--hotkeys</code> 参数来查找。</strong></p>
<p>Redis 4.0.3 版本中新增了 <code>hotkeys</code> 参数，该参数能够返回所有 key 的被访问次数。</p>
<p>使用该方案的前提条件是 Redis Server 的 <code>maxmemory-policy</code> 参数设置为 LFU 算法，不然就会出现如下所示的错误。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># redis-cli -p 6379 --hotkeys</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># Scanning the entire keyspace to find hot keys as well as</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># per 100 SCAN commands (not usually needed).</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Error: ERR An LFU maxmemory policy is not selected, access frequency not tracked. Please note that when switching between policies at runtime LRU and LFU data will take some <span style="color:#fff;font-weight:bold">time</span> to adjust.
</span></span></code></pre></td></tr></table>
</div>
</div><p>Redis 中有两种 LFU 算法：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（<code>server.db[i].expires</code>）中挑选最不经常使用的数据淘汰。</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key。</li>
</ol>
<p>以下是配置文件 <code>redis.conf</code> 中的示例：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-properties" data-lang="properties"><span style="display:flex;"><span><span style="color:#007f7f"># 使用 volatile-lfu 策略</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">maxmemory-policy</span> <span style="color:#0ff;font-weight:bold">volatile-lfu</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 或者使用 allkeys-lfu 策略</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">maxmemory-policy</span> <span style="color:#0ff;font-weight:bold">allkeys-lfu</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>需要注意的是，<code>hotkeys</code> 参数命令也会增加 Redis 实例的 CPU 和内存消耗（全局扫描），因此需要谨慎使用。</p>
<p><strong>2、使用<code>MONITOR</code> 命令。</strong></p>
<p><code>MONITOR</code> 命令是 Redis 提供的一种实时查看 Redis 的所有操作的方式，可以用于临时监控 Redis 实例的操作情况，包括读写、删除等操作。</p>
<p>由于该命令对 Redis 性能的影响比较大，因此禁止长时间开启 <code>MONITOR</code>（生产环境中建议谨慎使用该命令）。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#f00">#</span> redis-cli
</span></span><span style="display:flex;"><span>127.<span style="color:#007f7f">0</span>.<span style="color:#007f7f">0</span>.<span style="color:#007f7f">1</span>:6379&gt; MONITOR
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>1683638260.<span style="color:#007f7f">637378</span> [0 172.<span style="color:#007f7f">17</span>.<span style="color:#007f7f">0</span>.<span style="color:#007f7f">1</span>:61516] <span style="color:#0ff;font-weight:bold">&#34;ping&#34;</span>
</span></span><span style="display:flex;"><span>1683638267.<span style="color:#007f7f">144236</span> [0 172.<span style="color:#007f7f">17</span>.<span style="color:#007f7f">0</span>.<span style="color:#007f7f">1</span>:61518] <span style="color:#0ff;font-weight:bold">&#34;smembers&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;mySet&#34;</span>
</span></span><span style="display:flex;"><span>1683638268.<span style="color:#007f7f">941863</span> [0 172.<span style="color:#007f7f">17</span>.<span style="color:#007f7f">0</span>.<span style="color:#007f7f">1</span>:61518] <span style="color:#0ff;font-weight:bold">&#34;smembers&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;mySet&#34;</span>
</span></span><span style="display:flex;"><span>1683638269.<span style="color:#007f7f">551671</span> [0 172.<span style="color:#007f7f">17</span>.<span style="color:#007f7f">0</span>.<span style="color:#007f7f">1</span>:61518] <span style="color:#0ff;font-weight:bold">&#34;smembers&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;mySet&#34;</span>
</span></span><span style="display:flex;"><span>1683638270.<span style="color:#007f7f">646256</span> [0 172.<span style="color:#007f7f">17</span>.<span style="color:#007f7f">0</span>.<span style="color:#007f7f">1</span>:61516] <span style="color:#0ff;font-weight:bold">&#34;ping&#34;</span>
</span></span><span style="display:flex;"><span>1683638270.<span style="color:#007f7f">849551</span> [0 172.<span style="color:#007f7f">17</span>.<span style="color:#007f7f">0</span>.<span style="color:#007f7f">1</span>:61518] <span style="color:#0ff;font-weight:bold">&#34;smembers&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;mySet&#34;</span>
</span></span><span style="display:flex;"><span>1683638271.<span style="color:#007f7f">926945</span> [0 172.<span style="color:#007f7f">17</span>.<span style="color:#007f7f">0</span>.<span style="color:#007f7f">1</span>:61518] <span style="color:#0ff;font-weight:bold">&#34;smembers&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;mySet&#34;</span>
</span></span><span style="display:flex;"><span>1683638274.<span style="color:#007f7f">276599</span> [0 172.<span style="color:#007f7f">17</span>.<span style="color:#007f7f">0</span>.<span style="color:#007f7f">1</span>:61518] <span style="color:#0ff;font-weight:bold">&#34;smembers&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;mySet2&#34;</span>
</span></span><span style="display:flex;"><span>1683638276.<span style="color:#007f7f">327234</span> [0 172.<span style="color:#007f7f">17</span>.<span style="color:#007f7f">0</span>.<span style="color:#007f7f">1</span>:61518] <span style="color:#0ff;font-weight:bold">&#34;smembers&#34;</span> <span style="color:#0ff;font-weight:bold">&#34;mySet&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>在发生紧急情况时，我们可以选择在合适的时机短暂执行 <code>MONITOR</code> 命令并将输出重定向至文件，在关闭 <code>MONITOR</code> 命令后通过对文件中请求进行归类分析即可找出这段时间中的 hotkey。</p>
<p><strong>3、借助开源项目。</strong></p>
<p>京东零售的 <a href="https://gitee.com/jd-platform-opensource/hotkey">hotkey</a> 这个项目不光支持 hotkey 的发现，还支持 hotkey 的处理。</p>
<p><img alt="京东零售开源的 hotkey" loading="lazy" src="https://oss.javaguide.cn/github/javaguide/database/redis/jd-hotkey.png">京东零售开源的 hotkey</p>
<p><strong>4、根据业务情况提前预估。</strong></p>
<p>可以根据业务情况来预估一些 hotkey，比如参与秒杀活动的商品数据等。不过，我们无法预估所有 hotkey 的出现，比如突发的热点新闻事件等。</p>
<p><strong>5、业务代码中记录分析。</strong></p>
<p>在业务代码中添加相应的逻辑对 key 的访问情况进行记录分析。不过，这种方式会让业务代码的复杂性增加，一般也不会采用。</p>
<p><strong>6、借助公有云的 Redis 分析服务。</strong></p>
<p>如果你用的是公有云的 Redis 服务的话，可以看看其是否提供了 key 分析功能（一般都提供了）。</p>
<p>这里以阿里云 Redis 为例说明，它支持 hotkey 实时分析、发现，文档地址：<a href="https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature">https://www.alibabacloud.com/help/zh/apsaradb-for-redis/latest/use-the-real-time-key-statistics-feature</a> 。</p>
<h2 id="如何解决-hotkey">如何解决 hotkey？<a hidden class="anchor" aria-hidden="true" href="#如何解决-hotkey">#</a></h2>
<p>hotkey 的常见处理以及优化办法如下（这些方法可以配合起来使用）：</p>
<ul>
<li><strong>读写分离</strong>：主节点处理写请求，从节点处理读请求。</li>
<li><strong>使用 Redis Cluster</strong>：将热点数据分散存储在多个 Redis 节点上。</li>
<li><strong>二级缓存</strong>：hotkey 采用二级缓存的方式进行处理，将 hotkey 存放一份到 JVM 本地内存中（可以用 Caffeine）。</li>
</ul>
<p>除了这些方法之外，如果你使用的公有云的 Redis 服务话，还可以留意其提供的开箱即用的解决方案。</p>
<p>这里以阿里云 Redis 为例说明，它支持通过代理查询缓存功能（Proxy Query Cache）优化热点 Key 问题。</p>
<h2 id="慢查询命令">慢查询命令<a hidden class="anchor" aria-hidden="true" href="#慢查询命令">#</a></h2>
<h3 id="为什么会有慢查询命令">为什么会有慢查询命令？<a hidden class="anchor" aria-hidden="true" href="#为什么会有慢查询命令">#</a></h3>
<p>我们知道一个 Redis 命令的执行可以简化为以下 4 步：</p>
<ol>
<li>发送命令</li>
<li>命令排队</li>
<li>命令执行</li>
<li>返回结果</li>
</ol>
<p>Redis 慢查询统计的是命令执行这一步骤的耗时，慢查询命令也就是那些命令执行时间较长的命令。</p>
<p>Redis 为什么会有慢查询命令呢？</p>
<p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：</p>
<ul>
<li><code>KEYS *</code>：会返回所有符合规则的 key。</li>
<li><code>HGETALL</code>：会返回一个 Hash 中所有的键值对。</li>
<li><code>LRANGE</code>：会返回 List 中指定范围内的元素。</li>
<li><code>SMEMBERS</code>：返回 Set 中的所有元素。</li>
<li><code>SINTER</code>/<code>SUNION</code>/<code>SDIFF</code>：计算多个 Set 的交集/并集/差集。</li>
<li>&hellip;&hellip;</li>
</ul>
<p>由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</p>
<p>除了这些 O(n)时间复杂度的命令可能会导致慢查询之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：</p>
<ul>
<li><code>ZRANGE</code>/<code>ZREVRANGE</code>：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>
<li><code>ZREMRANGEBYRANK</code>/<code>ZREMRANGEBYSCORE</code>：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>
<li>&hellip;&hellip;</li>
</ul>
<h3 id="如何找到慢查询命令">如何找到慢查询命令？<a hidden class="anchor" aria-hidden="true" href="#如何找到慢查询命令">#</a></h3>
<p>在 <code>redis.conf</code> 文件中，我们可以使用 <code>slowlog-log-slower-than</code> 参数设置耗时命令的阈值，并使用 <code>slowlog-max-len</code> 参数设置耗时命令的最大记录条数。</p>
<p>当 Redis 服务器检测到执行时间超过 <code>slowlog-log-slower-than</code>阈值的命令时，就会将该命令记录在慢查询日志(slow log) 中，这点和 MySQL 记录慢查询语句类似。当慢查询日志超过设定的最大记录条数之后，Redis 会把最早的执行命令依次舍弃。</p>
<p>⚠️注意：由于慢查询日志会占用一定内存空间，如果设置最大记录条数过大，可能会导致内存占用过高的问题。</p>
<p><code>slowlog-log-slower-than</code>和<code>slowlog-max-len</code>的默认配置如下(可以自行修改)：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-nginx" data-lang="nginx"><span style="display:flex;"><span><span style="color:#007f7f"># The following time is expressed in microseconds, so 1000000 is equivalent
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"># to one second. Note that a negative number disables the slow log, while
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"># a value of zero forces the logging of every command.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">slowlog-log-slower-than</span> <span style="color:#ff0;font-weight:bold">10000</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># There is no limit to this length. Just be aware that it will consume memory.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"># You can reclaim memory used by the slow log with SLOWLOG RESET.
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#0ff;font-weight:bold">slowlog-max-len</span> <span style="color:#ff0;font-weight:bold">128</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>除了修改配置文件之外，你也可以直接通过 <code>CONFIG</code> 命令直接设置：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 命令执行耗时超过 10000 微妙（即10毫秒）就会被记录</span>
</span></span><span style="display:flex;"><span>CONFIG SET slowlog-log-slower-than <span style="color:#ff0;font-weight:bold">10000</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 只保留最近 128 条耗时命令</span>
</span></span><span style="display:flex;"><span>CONFIG SET slowlog-max-len <span style="color:#ff0;font-weight:bold">128</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>获取慢查询日志的内容很简单，直接使用<code>SLOWLOG GET</code> 命令即可。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>127.<span style="color:#007f7f">0</span>.<span style="color:#007f7f">0</span>.<span style="color:#007f7f">1</span>:6379&gt; SLOWLOG GET <span style="color:#f00">#</span>慢日志查询
</span></span><span style="display:flex;"><span> 1) 1) (integer) 5
</span></span><span style="display:flex;"><span>   2) (integer) 1684326682
</span></span><span style="display:flex;"><span>   3) (integer) 12000
</span></span><span style="display:flex;"><span>   4) 1) <span style="color:#0ff;font-weight:bold">&#34;KEYS&#34;</span>
</span></span><span style="display:flex;"><span>      2) <span style="color:#0ff;font-weight:bold">&#34;*&#34;</span>
</span></span><span style="display:flex;"><span>   5) <span style="color:#0ff;font-weight:bold">&#34;172.17.0.1:61152&#34;</span>
</span></span><span style="display:flex;"><span>   6) <span style="color:#0ff;font-weight:bold">&#34;&#34;</span>
</span></span><span style="display:flex;"><span>  <span style="color:#007f7f">// ...</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>慢查询日志中的每个条目都由以下六个值组成：</p>
<ol>
<li>唯一渐进的日志标识符。</li>
<li>处理记录命令的 Unix 时间戳。</li>
<li>执行所需的时间量，以微秒为单位。</li>
<li>组成命令参数的数组。</li>
<li>客户端 IP 地址和端口。</li>
<li>客户端名称。</li>
</ol>
<p><code>SLOWLOG GET</code> 命令默认返回最近 10 条的的慢查询命令，你也自己可以指定返回的慢查询命令的数量 <code>SLOWLOG GET N</code>。</p>
<p>下面是其他比较常用的慢查询相关的命令：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 返回慢查询命令的数量</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; SLOWLOG LEN
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">128</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 清空慢查询命令</span>
</span></span><span style="display:flex;"><span>127.0.0.1:6379&gt; SLOWLOG RESET
</span></span><span style="display:flex;"><span>OK
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="redis-生产问题重要">Redis 生产问题（重要）<a hidden class="anchor" aria-hidden="true" href="#redis-生产问题重要">#</a></h1>
<h2 id="缓存穿透">缓存穿透<a hidden class="anchor" aria-hidden="true" href="#缓存穿透">#</a></h2>
<h3 id="什么是缓存穿透">什么是缓存穿透？<a hidden class="anchor" aria-hidden="true" href="#什么是缓存穿透">#</a></h3>
<p>缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-cache-penetration.png"></p>
<p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p>
<h3 id="有哪些解决办法">有哪些解决办法？<a hidden class="anchor" aria-hidden="true" href="#有哪些解决办法">#</a></h3>
<p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p>
<p><strong>1）缓存无效 key</strong></p>
<p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下：<code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p>
<p>另外，这里多说一嘴，一般情况下我们是这样设计 key 的：<code>表名:列名:主键名:主键值</code> 。</p>
<p>如果用 Java 代码展示的话，差不多是下面这样的：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">public</span> Object getObjectInclNullById(Integer id) {
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 从缓存中获取数据</span>
</span></span><span style="display:flex;"><span>    Object cacheValue = cache.<span style="color:#007f7f">get</span>(id);
</span></span><span style="display:flex;"><span>    <span style="color:#007f7f">// 缓存为空</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">if</span> (cacheValue == <span style="color:#fff;font-weight:bold">null</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 从数据库中获取</span>
</span></span><span style="display:flex;"><span>        Object storageValue = storage.<span style="color:#007f7f">get</span>(key);
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 缓存空对象</span>
</span></span><span style="display:flex;"><span>        cache.<span style="color:#007f7f">set</span>(key, storageValue);
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">// 如果存储数据为空，需要设置一个过期时间(300秒)</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">if</span> (storageValue == <span style="color:#fff;font-weight:bold">null</span>) {
</span></span><span style="display:flex;"><span>            <span style="color:#007f7f">// 必须设置过期时间，否则有被攻击的风险</span>
</span></span><span style="display:flex;"><span>            cache.<span style="color:#007f7f">expire</span>(key, 60 * 5);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">return</span> storageValue;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">return</span> cacheValue;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>2）布隆过滤器</strong></p>
<p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆过滤器就是我们想要找的那个“人”。</p>
<p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p>
<p>加入布隆过滤器之后的缓存处理流程图如下。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-cache-penetration-bloom-filter.png"></p>
<p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是：<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p>
<p><em>为什么会出现误判的情况呢? 我们还要从布隆过滤器的原理来说！</em></p>
<p>我们先来看一下，<strong>当一个元素加入布隆过滤器中的时候，会进行哪些操作：</strong></p>
<ol>
<li>使用布隆过滤器中的哈希函数对元素值进行计算，得到哈希值（有几个哈希函数得到几个哈希值）。</li>
<li>根据得到的哈希值，在位数组中把对应下标的值置为 1。</li>
</ol>
<p>我们再来看一下，<strong>当我们需要判断一个元素是否存在于布隆过滤器的时候，会进行哪些操作：</strong></p>
<ol>
<li>对给定元素再次进行相同的哈希计算；</li>
<li>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</li>
</ol>
<p>然后，一定会出现这样一种情况：<strong>不同的字符串可能哈希出来的位置相同。</strong> （可以适当增加位数组大小或者调整我们的哈希函数来降低概率）</p>
<p>更多关于布隆过滤器的内容可以看我的这篇原创：<a href="https://javaguide.cn/cs-basics/data-structure/bloom-filter/">《不了解布隆过滤器？一文给你整的明明白白！》</a> ，强烈推荐，个人感觉网上应该找不到总结的这么明明白白的文章了。</p>
<h2 id="缓存击穿">缓存击穿<a hidden class="anchor" aria-hidden="true" href="#缓存击穿">#</a></h2>
<h3 id="什么是缓存击穿">什么是缓存击穿？<a hidden class="anchor" aria-hidden="true" href="#什么是缓存击穿">#</a></h3>
<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-cache-breakdown.png"></p>
<p>举个例子：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
<h3 id="有哪些解决办法-1">有哪些解决办法？<a hidden class="anchor" aria-hidden="true" href="#有哪些解决办法-1">#</a></h3>
<ul>
<li>设置热点数据永不过期或者过期时间比较长。</li>
<li>针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li>
<li>请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li>
</ul>
<h3 id="缓存穿透和缓存击穿有什么区别">缓存穿透和缓存击穿有什么区别？<a hidden class="anchor" aria-hidden="true" href="#缓存穿透和缓存击穿有什么区别">#</a></h3>
<p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p>
<p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。</p>
<h2 id="缓存雪崩">缓存雪崩<a hidden class="anchor" aria-hidden="true" href="#缓存雪崩">#</a></h2>
<h3 id="什么是缓存雪崩">什么是缓存雪崩？<a hidden class="anchor" aria-hidden="true" href="#什么是缓存雪崩">#</a></h3>
<p>我发现缓存雪崩这名字起的有点意思，哈哈。</p>
<p>实际上，缓存雪崩描述的就是这样一个简单的场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p>
<p>另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-cache-avalanche.png"></p>
<p>举个例子：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p>
<h3 id="有哪些解决办法-2">有哪些解决办法？<a hidden class="anchor" aria-hidden="true" href="#有哪些解决办法-2">#</a></h3>
<p><strong>针对 Redis 服务不可用的情况：</strong></p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<p><strong>针对热点缓存失效的情况：</strong></p>
<ol>
<li>设置不同的失效时间比如随机设置缓存的失效时间。</li>
<li>缓存永不失效（不太推荐，实用性太差）。</li>
<li>设置二级缓存。</li>
</ol>
<h3 id="缓存雪崩和缓存击穿有什么区别">缓存雪崩和缓存击穿有什么区别？<a hidden class="anchor" aria-hidden="true" href="#缓存雪崩和缓存击穿有什么区别">#</a></h3>
<p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</p>
<h2 id="如何保证缓存和数据库数据的一致性">如何保证缓存和数据库数据的一致性？<a hidden class="anchor" aria-hidden="true" href="#如何保证缓存和数据库数据的一致性">#</a></h2>
<p>细说的话可以扯很多，但是我觉得其实没太大必要（小声 BB：很多解决方案我也没太弄明白）。我个人觉得引入缓存之后，如果为了短时间的不一致性问题，选择让系统设计变得更加复杂的话，完全没必要。</p>
<p>下面单独对 <strong>Cache Aside Pattern（旁路缓存模式）</strong> 来聊聊。</p>
<p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p>
<p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p>
<ol>
<li><strong>缓存失效时间变短（不推荐，治标不治本）</strong>：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li>
<li><strong>增加 cache 更新重试机制（常用）</strong>：如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li>
</ol>
<p>相关文章推荐：<a href="https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&chksm=e8beb8e5dfc931f3e35655da9da0b61c79f2843101c130cf38996446975014f958a6481aacf1&scene=178&cur_album_id=1699766580538032128#rd">缓存和数据库一致性问题，看这篇就够了 - 水滴与银弹</a></p>
<h1 id="redis-集群">Redis 集群<a hidden class="anchor" aria-hidden="true" href="#redis-集群">#</a></h1>
<p><strong>Redis Sentinel</strong>：</p>
<ol>
<li>什么是 Sentinel？ 有什么用？</li>
<li>Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?</li>
<li>Sentinel 是如何实现故障转移的？</li>
<li>为什么建议部署多个 sentinel 节点（哨兵集群）？</li>
<li>Sentinel 如何选择出新的 master（选举机制）?</li>
<li>如何从 Sentinel 集群中选择出 Leader ？</li>
<li>Sentinel 可以防止脑裂吗？</li>
</ol>
<p><strong>Redis Cluster</strong>：</p>
<ol>
<li>为什么需要 Redis Cluster？解决了什么问题？有什么优势？</li>
<li>Redis Cluster 是如何分片的？</li>
<li>为什么 Redis Cluster 的哈希槽是 16384 个?</li>
<li>如何确定给定 key 的应该分布到哪个哈希槽中？</li>
<li>Redis Cluster 支持重新分配哈希槽吗？</li>
<li>Redis Cluster 扩容缩容期间可以提供服务吗？</li>
<li>Redis Cluster 中的节点是怎么进行通信的？</li>
</ol>
<h1 id="redis-使用规范">Redis 使用规范<a hidden class="anchor" aria-hidden="true" href="#redis-使用规范">#</a></h1>
<p>实际使用 Redis 的过程中，我们尽量要准守一些常见的规范，比如：</p>
<ol>
<li>使用连接池：避免频繁创建关闭客户端连接。</li>
<li>尽量不使用 O(n)指令，使用 O(n) 命令时要关注 n 的数量：像 <code>KEYS *</code>、<code>HGETALL</code>、<code>LRANGE</code>、<code>SMEMBERS</code>、<code>SINTER</code>/<code>SUNION</code>/<code>SDIFF</code>等 O(n) 命令并非不能使用，但是需要明确 n 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</li>
<li>使用批量操作减少网络传输：原生批量操作命令（比如 <code>MGET</code>、<code>MSET</code>等等）、pipeline、Lua 脚本。</li>
<li>尽量不适用 Redis 事务：Redis 事务实现的功能比较鸡肋，可以使用 Lua 脚本代替。</li>
<li>禁止长时间开启 monitor：对性能影响比较大。</li>
<li>控制 key 的生命周期：避免 Redis 中存放了太多不经常被访问的数据。</li>
<li>&hellip;&hellip;</li>
</ol>
<p>相关文章推荐：<a href="https://developer.aliyun.com/article/531067">阿里云 Redis 开发规范</a> 。</p>
<h1 id="3种常用的缓存读写策略详解">3种常用的缓存读写策略详解<a hidden class="anchor" aria-hidden="true" href="#3种常用的缓存读写策略详解">#</a></h1>
<h2 id="cache-aside-pattern旁路缓存模式">Cache Aside Pattern（旁路缓存模式）<a hidden class="anchor" aria-hidden="true" href="#cache-aside-pattern旁路缓存模式">#</a></h2>
<p><strong>Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。</strong></p>
<p>Cache Aside Pattern 中服务端需要同时维系 db 和 cache，并且是以 db 的结果为准。</p>
<p>下面我们来看一下这个策略模式下的缓存读写步骤。</p>
<p><strong>写</strong>：</p>
<ul>
<li>先更新 db</li>
<li>然后直接删除 cache 。</li>
</ul>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/cache-aside-write.png"></p>
<p><strong>读</strong> :</p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回</li>
<li>cache 中读取不到的话，就从 db 中读取数据返回</li>
<li>再把数据放到 cache 中。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/cache-aside-read.png"></p>
<p>你仅仅了解了上面这些内容的话是远远不够的，我们还要搞懂其中的原理。</p>
<p>比如说面试官很可能会追问：“<strong>在写数据的过程中，可以先删除 cache ，后更新 db 么？</strong>”</p>
<p><strong>答案：</strong> 那肯定是不行的！因为这样可能会造成 <strong>数据库（db）和缓存（Cache）数据不一致</strong>的问题。</p>
<p>举例：请求 1 先写数据 A，请求 2 随后读数据 A 的话，就很有可能产生数据不一致性的问题。</p>
<p>这个过程可以简单描述为：</p>
<blockquote>
<p>请求 1 先把 cache 中的 A 数据删除 -&gt; 请求 2 从 db 中读取数据-&gt;请求 1 再把 db 中的 A 数据更新</p>
</blockquote>
<p>当你这样回答之后，面试官可能会紧接着就追问：“<strong>在写数据的过程中，先更新 db，后删除 cache 就没有问题了么？</strong>”</p>
<p><strong>答案：</strong> 理论上来说还是可能会出现数据不一致性的问题，不过概率非常小，因为缓存的写入速度是比数据库的写入速度快很多。</p>
<p>举例：请求 1 先读数据 A，请求 2 随后写数据 A，并且数据 A 在请求 1 请求之前不在缓存中的话，也有可能产生数据不一致性的问题。</p>
<p>这个过程可以简单描述为：</p>
<blockquote>
<p>请求 1 从 db 读数据 A-&gt; 请求 2 更新 db 中的数据 A（此时缓存中无数据 A ，故不用执行删除缓存操作 ） -&gt; 请求 1 将数据 A 写入 cache</p>
</blockquote>
<p>现在我们再来分析一下 <strong>Cache Aside Pattern 的缺陷</strong>。</p>
<p><strong>缺陷 1：首次请求数据一定不在 cache 的问题</strong></p>
<p>解决办法：可以将热点数据可以提前放入 cache 中。</p>
<p><strong>缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。</strong></p>
<p>解决办法：</p>
<ul>
<li>数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。</li>
<li>可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。</li>
</ul>
<h2 id="readwrite-through-pattern读写穿透">Read/Write Through Pattern（读写穿透）<a hidden class="anchor" aria-hidden="true" href="#readwrite-through-pattern读写穿透">#</a></h2>
<p>Read/Write Through Pattern 中服务端把 cache 视为主要数据存储，从中读取数据并将数据写入其中。cache 服务负责将此数据读取和写入 db，从而减轻了应用程序的职责。</p>
<p>这种缓存读写策略小伙伴们应该也发现了在平时在开发过程中非常少见。抛去性能方面的影响，大概率是因为我们经常使用的分布式缓存 Redis 并没有提供 cache 将数据写入 db 的功能。</p>
<p><strong>写（Write Through）：</strong></p>
<ul>
<li>先查 cache，cache 中不存在，直接更新 db。</li>
<li>cache 中存在，则先更新 cache，然后 cache 服务自己更新 db（<strong>同步更新 cache 和 db</strong>）。</li>
</ul>
<p>简单画了一张图帮助大家理解写的步骤。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/write-through.png"></p>
<p><strong>读(Read Through)：</strong></p>
<ul>
<li>从 cache 中读取数据，读取到就直接返回 。</li>
<li>读取不到的话，先从 db 加载，写入到 cache 后返回响应。</li>
</ul>
<p>简单画了一张图帮助大家理解读的步骤。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/read-through.png"></p>
<p>Read-Through Pattern 实际只是在 Cache-Aside Pattern 之上进行了封装。在 Cache-Aside Pattern 下，发生读请求的时候，如果 cache 中不存在对应的数据，是由客户端自己负责把数据写入 cache，而 Read Through Pattern 则是 cache 服务自己来写入缓存的，这对客户端是透明的。</p>
<p>和 Cache Aside Pattern 一样， Read-Through Pattern 也有首次请求数据一定不再 cache 的问题，对于热点数据可以提前放入缓存中。</p>
<h2 id="write-behind-pattern异步缓存写入">Write Behind Pattern（异步缓存写入）<a hidden class="anchor" aria-hidden="true" href="#write-behind-pattern异步缓存写入">#</a></h2>
<p>Write Behind Pattern 和 Read/Write Through Pattern 很相似，两者都是由 cache 服务来负责 cache 和 db 的读写。</p>
<p>但是，两个又有很大的不同：<strong>Read/Write Through 是同步更新 cache 和 db，而 Write Behind 则是只更新缓存，不直接更新 db，而是改为异步批量的方式来更新 db。</strong></p>
<p>很明显，这种方式对数据一致性带来了更大的挑战，比如 cache 数据可能还没异步更新 db 的话，cache 服务可能就就挂掉了。</p>
<p>这种策略在我们平时开发过程中也非常非常少见，但是不代表它的应用场景少，比如消息队列中消息的异步写入磁盘、MySQL 的 Innodb Buffer Pool 机制都用到了这种策略。</p>
<p>Write Behind Pattern 下 db 的写性能非常高，非常适合一些数据经常变化又对数据一致性要求没那么高的场景，比如浏览量、点赞量。</p>
<h1 id="redis-5-种基本数据结构详解">Redis 5 种基本数据结构详解<a hidden class="anchor" aria-hidden="true" href="#redis-5-种基本数据结构详解">#</a></h1>
<p>Redis 共有 5 种基本数据结构：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</p>
<p>这 5 种数据结构是直接提供给用户使用的，是数据的保存形式，其底层实现主要依赖这 8 种数据结构：简单动态字符串（SDS）、LinkedList（双向链表）、Hash Table（哈希表）、SkipList（跳跃表）、Intset（整数集合）、ZipList（压缩列表）、QuickList（快速列表）。</p>
<p>Redis 基本数据结构的底层数据结构实现如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">String</th>
<th style="text-align:left">List</th>
<th style="text-align:left">Hash</th>
<th style="text-align:left">Set</th>
<th style="text-align:left">Zset</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">SDS</td>
<td style="text-align:left">LinkedList/ZipList/QuickList</td>
<td style="text-align:left">Hash Table、ZipList</td>
<td style="text-align:left">ZipList、Intset</td>
<td style="text-align:left">ZipList、SkipList</td>
</tr>
</tbody>
</table>
<p>Redis 3.2 之前，List 底层实现是 LinkedList 或者 ZipList。 Redis 3.2 之后，引入了 LinkedList 和 ZipList 的结合 QuickList，List 的底层实现变为 QuickList。</p>
<p>你可以在 Redis 官网上找到 Redis 数据结构非常详细的介绍：</p>
<ul>
<li><a href="https://redis.com/redis-enterprise/data-structures/">Redis Data Structures</a></li>
<li><a href="https://redis.io/docs/manual/data-types/data-types-tutorial/">Redis Data types tutorial</a></li>
</ul>
<p>未来随着 Redis 新版本的发布，可能会有新的数据结构出现，通过查阅 Redis 官网对应的介绍，你总能获取到最靠谱的信息。</p>
<h2 id="string字符串">String（字符串）<a hidden class="anchor" aria-hidden="true" href="#string字符串">#</a></h2>
<h3 id="介绍">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍">#</a></h3>
<p>String 是 Redis 中最简单同时也是最常用的一个数据结构。</p>
<p>String 是一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220719124403897.png"></p>
<p>虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（Simple Dynamic String，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外，Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</p>
<h3 id="常用命令">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令">#</a></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>SET key value</td>
<td>设置指定 key 的值</td>
</tr>
<tr>
<td>SETNX key value</td>
<td>只有在 key 不存在时设置 key 的值</td>
</tr>
<tr>
<td>GET key</td>
<td>获取指定 key 的值</td>
</tr>
<tr>
<td>MSET key1 value1 key2 value2 …</td>
<td>设置一个或多个指定 key 的值</td>
</tr>
<tr>
<td>MGET key1 key2 &hellip;</td>
<td>获取一个或多个指定 key 的值</td>
</tr>
<tr>
<td>STRLEN key</td>
<td>返回 key 所储存的字符串值的长度</td>
</tr>
<tr>
<td>INCR key</td>
<td>将 key 中储存的数字值增一</td>
</tr>
<tr>
<td>DECR key</td>
<td>将 key 中储存的数字值减一</td>
</tr>
<tr>
<td>EXISTS key</td>
<td>判断指定 key 是否存在</td>
</tr>
<tr>
<td>DEL key（通用）</td>
<td>删除指定的 key</td>
</tr>
<tr>
<td>EXPIRE key seconds（通用）</td>
<td>给指定 key 设置过期时间</td>
</tr>
</tbody>
</table>
<p>更多 Redis String 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href="https://redis.io/commands/?group=string">https://redis.io/commands/?group=string</a> 。</p>
<p><strong>基本操作</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SET key value
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; GET key
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;value&#34;</span>
</span></span><span style="display:flex;"><span>&gt; EXISTS key
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; STRLEN key
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">5</span>
</span></span><span style="display:flex;"><span>&gt; DEL key
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; GET key
</span></span><span style="display:flex;"><span>(nil)
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>批量设置</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; MSET key1 value1 key2 value2
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; MGET key1 key2 <span style="color:#007f7f"># 批量获取多个 key 对应的 value</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>计数器（字符串的内容为整数的时候可以使用）：</strong></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SET number <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; INCR number <span style="color:#007f7f"># 将 key 中储存的数字值增一</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>&gt; GET number
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;2&#34;</span>
</span></span><span style="display:flex;"><span>&gt; DECR number <span style="color:#007f7f"># 将 key 中储存的数字值减一</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; GET number
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;1&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>设置过期时间（默认为永不过期）</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; EXPIRE key <span style="color:#ff0;font-weight:bold">60</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; SETEX key <span style="color:#ff0;font-weight:bold">60</span> value <span style="color:#007f7f"># 设置值并设置过期时间</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; TTL key
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">56</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景">#</a></h3>
<p><strong>需要存储常规数据的场景</strong></p>
<ul>
<li>举例：缓存 session、token、图片地址、序列化后的对象(相比较于 Hash 存储更节省内存)。</li>
<li>相关命令：<code>SET</code>、<code>GET</code>。</li>
</ul>
<p><strong>需要计数的场景</strong></p>
<ul>
<li>举例：用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数。</li>
<li>相关命令：<code>SET</code>、<code>GET</code>、 <code>INCR</code>、<code>DECR</code> 。</li>
</ul>
<p><strong>分布式锁</strong></p>
<p>利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁（存在一些缺陷，通常不建议这样实现分布式锁）。</p>
<h2 id="list列表">List（列表）<a hidden class="anchor" aria-hidden="true" href="#list列表">#</a></h2>
<h3 id="介绍-1">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍-1">#</a></h3>
<p>Redis 中的 List 其实就是链表数据结构的实现。我在 <a href="https://javaguide.cn/cs-basics/data-structure/linear-data-structure.html">线性数据结构 :数组、链表、栈、队列</a> 这篇文章中详细介绍了链表这种数据结构，我这里就不多做介绍了。</p>
<p>许多高级编程语言都内置了链表的实现比如 Java 中的 <code>LinkedList</code>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 List 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220719124413287.png"></p>
<h3 id="常用命令-1">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令-1">#</a></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>RPUSH key value1 value2 &hellip;</td>
<td>在指定列表的尾部（右边）添加一个或多个元素</td>
</tr>
<tr>
<td>LPUSH key value1 value2 &hellip;</td>
<td>在指定列表的头部（左边）添加一个或多个元素</td>
</tr>
<tr>
<td>LSET key index value</td>
<td>将指定列表索引 index 位置的值设置为 value</td>
</tr>
<tr>
<td>LPOP key</td>
<td>移除并获取指定列表的第一个元素(最左边)</td>
</tr>
<tr>
<td>RPOP key</td>
<td>移除并获取指定列表的最后一个元素(最右边)</td>
</tr>
<tr>
<td>LLEN key</td>
<td>获取列表元素数量</td>
</tr>
<tr>
<td>LRANGE key start end</td>
<td>获取列表 start 和 end 之间 的元素</td>
</tr>
</tbody>
</table>
<p>更多 Redis List 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href="https://redis.io/commands/?group=list">https://redis.io/commands/?group=list</a> 。</p>
<p><strong>通过 <code>RPUSH/LPOP</code> 或者 <code>LPUSH/RPOP</code>实现队列</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; RPUSH myList value1
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; RPUSH myList value2 value3
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>&gt; LPOP myList
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>&gt; LRANGE myList <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value3&#34;</span>
</span></span><span style="display:flex;"><span>&gt; LRANGE myList <span style="color:#ff0;font-weight:bold">0</span> -1
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value3&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>通过 <code>RPUSH/RPOP</code>或者<code>LPUSH/LPOP</code> 实现栈</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; RPUSH myList2 value1 value2 value3
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>&gt; RPOP myList2 <span style="color:#007f7f"># 将 list的最右边的元素取出</span>
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;value3&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我专门画了一个图方便大家理解 <code>RPUSH</code> , <code>LPOP</code> , <code>lpush</code> , <code>RPOP</code> 命令：</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-list.png"></p>
<p><strong>通过 <code>LRANGE</code> 查看对应下标范围的列表元素</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; RPUSH myList value1 value2 value3
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>&gt; LRANGE myList <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>&gt; LRANGE myList <span style="color:#ff0;font-weight:bold">0</span> -1
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>3) <span style="color:#0ff;font-weight:bold">&#34;value3&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 <code>LRANGE</code> 命令，你可以基于 List 实现分页查询，性能非常高！</p>
<p><strong>通过 <code>LLEN</code> 查看链表长度</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; LLEN myList
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">3</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景-1">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景-1">#</a></h3>
<p><strong>信息流展示</strong></p>
<ul>
<li>举例：最新文章、最新动态。</li>
<li>相关命令：<code>LPUSH</code>、<code>LRANGE</code>。</li>
</ul>
<p><strong>消息队列</strong></p>
<p>Redis List 数据结构可以用来做消息队列，只是功能过于简单且存在很多缺陷，不建议这样做。</p>
<p>相对来说，Redis 5.0 新增加的一个数据结构 <code>Stream</code> 更适合做消息队列一些，只是功能依然非常简陋。和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。</p>
<h2 id="hash哈希">Hash（哈希）<a hidden class="anchor" aria-hidden="true" href="#hash哈希">#</a></h2>
<h3 id="介绍-2">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍-2">#</a></h3>
<p>Redis 中的 Hash 是一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</p>
<p>Hash 类似于 JDK1.8 前的 <code>HashMap</code>，内部实现也差不多(数组 + 链表)。不过，Redis 的 Hash 做了更多优化。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220719124421703.png"></p>
<h3 id="常用命令-2">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令-2">#</a></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>HSET key field value</td>
<td>设置指定哈希表中指定字段的值</td>
</tr>
<tr>
<td>HSETNX key field value</td>
<td>只有指定字段不存在时设置指定字段的值</td>
</tr>
<tr>
<td>HMSET key field1 value1 field2 value2 &hellip;</td>
<td>同时将一个或多个 field-value (域-值)对设置到指定哈希表中</td>
</tr>
<tr>
<td>HGET key field</td>
<td>获取指定哈希表中指定字段的值</td>
</tr>
<tr>
<td>HMGET key field1 field2 &hellip;</td>
<td>获取指定哈希表中一个或者多个指定字段的值</td>
</tr>
<tr>
<td>HGETALL key</td>
<td>获取指定哈希表中所有的键值对</td>
</tr>
<tr>
<td>HEXISTS key field</td>
<td>查看指定哈希表中指定的字段是否存在</td>
</tr>
<tr>
<td>HDEL key field1 field2 &hellip;</td>
<td>删除一个或多个哈希表字段</td>
</tr>
<tr>
<td>HLEN key</td>
<td>获取指定哈希表中字段的数量</td>
</tr>
<tr>
<td>HINCRBY key field increment</td>
<td>对指定哈希中的指定字段做运算操作（正数为加，负数为减）</td>
</tr>
</tbody>
</table>
<p>更多 Redis Hash 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href="https://redis.io/commands/?group=hash">https://redis.io/commands/?group=hash</a> 。</p>
<p><strong>模拟对象数据存储</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; HMSET userInfoKey name <span style="color:#0ff;font-weight:bold">&#34;guide&#34;</span> description <span style="color:#0ff;font-weight:bold">&#34;dev&#34;</span> age <span style="color:#ff0;font-weight:bold">24</span>
</span></span><span style="display:flex;"><span>OK
</span></span><span style="display:flex;"><span>&gt; HEXISTS userInfoKey name <span style="color:#007f7f"># 查看 key 对应的 value中指定的字段是否存在。</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; HGET userInfoKey name <span style="color:#007f7f"># 获取存储在哈希表中指定字段的值。</span>
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;guide&#34;</span>
</span></span><span style="display:flex;"><span>&gt; HGET userInfoKey age
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;24&#34;</span>
</span></span><span style="display:flex;"><span>&gt; HGETALL userInfoKey <span style="color:#007f7f"># 获取在哈希表中指定 key 的所有字段和值</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;name&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;guide&#34;</span>
</span></span><span style="display:flex;"><span>3) <span style="color:#0ff;font-weight:bold">&#34;description&#34;</span>
</span></span><span style="display:flex;"><span>4) <span style="color:#0ff;font-weight:bold">&#34;dev&#34;</span>
</span></span><span style="display:flex;"><span>5) <span style="color:#0ff;font-weight:bold">&#34;age&#34;</span>
</span></span><span style="display:flex;"><span>6) <span style="color:#0ff;font-weight:bold">&#34;24&#34;</span>
</span></span><span style="display:flex;"><span>&gt; HSET userInfoKey name <span style="color:#0ff;font-weight:bold">&#34;GuideGeGe&#34;</span>
</span></span><span style="display:flex;"><span>&gt; HGET userInfoKey name
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;GuideGeGe&#34;</span>
</span></span><span style="display:flex;"><span>&gt; HINCRBY userInfoKey age <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">26</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景-2">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景-2">#</a></h3>
<p><strong>对象数据存储场景</strong></p>
<ul>
<li>举例：用户信息、商品信息、文章信息、购物车信息。</li>
<li>相关命令：<code>HSET</code> （设置单个字段的值）、<code>HMSET</code>（设置多个字段的值）、<code>HGET</code>（获取单个字段的值）、<code>HMGET</code>（获取多个字段的值）。</li>
</ul>
<h2 id="set集合">Set（集合）<a hidden class="anchor" aria-hidden="true" href="#set集合">#</a></h2>
<h3 id="介绍-3">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍-3">#</a></h3>
<p>Redis 中的 Set 类型是一种无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。当你需要存储一个列表数据，又不希望出现重复数据时，Set 是一个很好的选择，并且 Set 提供了判断某个元素是否在一个 Set 集合内的重要接口，这个也是 List 所不能提供的。</p>
<p>你可以基于 Set 轻易实现交集、并集、差集的操作，比如你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。这样的话，Set 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220719124430264.png"></p>
<h3 id="常用命令-3">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令-3">#</a></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>SADD key member1 member2 &hellip;</td>
<td>向指定集合添加一个或多个元素</td>
</tr>
<tr>
<td>SMEMBERS key</td>
<td>获取指定集合中的所有元素</td>
</tr>
<tr>
<td>SCARD key</td>
<td>获取指定集合的元素数量</td>
</tr>
<tr>
<td>SISMEMBER key member</td>
<td>判断指定元素是否在指定集合中</td>
</tr>
<tr>
<td>SINTER key1 key2 &hellip;</td>
<td>获取给定所有集合的交集</td>
</tr>
<tr>
<td>SINTERSTORE destination key1 key2 &hellip;</td>
<td>将给定所有集合的交集存储在 destination 中</td>
</tr>
<tr>
<td>SUNION key1 key2 &hellip;</td>
<td>获取给定所有集合的并集</td>
</tr>
<tr>
<td>SUNIONSTORE destination key1 key2 &hellip;</td>
<td>将给定所有集合的并集存储在 destination 中</td>
</tr>
<tr>
<td>SDIFF key1 key2 &hellip;</td>
<td>获取给定所有集合的差集</td>
</tr>
<tr>
<td>SDIFFSTORE destination key1 key2 &hellip;</td>
<td>将给定所有集合的差集存储在 destination 中</td>
</tr>
<tr>
<td>SPOP key count</td>
<td>随机移除并获取指定集合中一个或多个元素</td>
</tr>
<tr>
<td>SRANDMEMBER key count</td>
<td>随机获取指定集合中指定数量的元素</td>
</tr>
</tbody>
</table>
<p>更多 Redis Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href="https://redis.io/commands/?group=set">https://redis.io/commands/?group=set</a> 。</p>
<p><strong>基本操作</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SADD mySet value1 value2
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>&gt; SADD mySet value1 <span style="color:#007f7f"># 不允许有重复元素，因此添加失败</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; SMEMBERS mySet
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>&gt; SCARD mySet
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>&gt; SISMEMBER mySet value1
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; SADD mySet2 value2 value3
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>mySet</code> : <code>value1</code>、<code>value2</code> 。</li>
<li><code>mySet2</code>：<code>value2</code>、<code>value3</code> 。</li>
</ul>
<p><strong>求交集</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SINTERSTORE mySet3 mySet mySet2
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; SMEMBERS mySet3
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>求并集</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SUNION mySet mySet2
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value3&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>3) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>求差集</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; SDIFF mySet mySet2 <span style="color:#007f7f"># 差集是由所有属于 mySet 但不属于 A 的元素组成的集合</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景-3">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景-3">#</a></h3>
<p><strong>需要存放的数据不能重复的场景</strong></p>
<ul>
<li>举例：网站 UV 统计（数据量巨大的场景还是 <code>HyperLogLog</code>更适合一些）、文章点赞、动态点赞等场景。</li>
<li>相关命令：<code>SCARD</code>（获取集合数量） 。</li>
</ul>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220719073733851.png"></p>
<p><strong>需要获取多个数据源交集、并集和差集的场景</strong></p>
<ul>
<li>举例：共同好友(交集)、共同粉丝(交集)、共同关注(交集)、好友推荐（差集）、音乐推荐（差集）、订阅号推荐（差集+交集） 等场景。</li>
<li>相关命令：<code>SINTER</code>（交集）、<code>SINTERSTORE</code> （交集）、<code>SUNION</code> （并集）、<code>SUNIONSTORE</code>（并集）、<code>SDIFF</code>（差集）、<code>SDIFFSTORE</code> （差集）。</li>
</ul>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220719074543513.png"></p>
<p><strong>需要随机获取数据源中的元素的场景</strong></p>
<ul>
<li>举例：抽奖系统、随机点名等场景。</li>
<li>相关命令：<code>SPOP</code>（随机获取集合中的元素并移除，适合不允许重复中奖的场景）、<code>SRANDMEMBER</code>（随机获取集合中的元素，适合允许重复中奖的场景）。</li>
</ul>
<h2 id="sorted-set有序集合">Sorted Set（有序集合）<a hidden class="anchor" aria-hidden="true" href="#sorted-set有序集合">#</a></h2>
<h3 id="介绍-4">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍-4">#</a></h3>
<p>Sorted Set 类似于 Set，但和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220719124437791.png"></p>
<h3 id="常用命令-4">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令-4">#</a></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>ZADD key score1 member1 score2 member2 &hellip;</td>
<td>向指定有序集合添加一个或多个元素</td>
</tr>
<tr>
<td>ZCARD KEY</td>
<td>获取指定有序集合的元素数量</td>
</tr>
<tr>
<td>ZSCORE key member</td>
<td>获取指定有序集合中指定元素的 score 值</td>
</tr>
<tr>
<td>ZINTERSTORE destination numkeys key1 key2 &hellip;</td>
<td>将给定所有有序集合的交集存储在 destination 中，对相同元素对应的 score 值进行 SUM 聚合操作，numkeys 为集合数量</td>
</tr>
<tr>
<td>ZUNIONSTORE destination numkeys key1 key2 &hellip;</td>
<td>求并集，其它和 ZINTERSTORE 类似</td>
</tr>
<tr>
<td>ZDIFFSTORE destination numkeys key1 key2 &hellip;</td>
<td>求差集，其它和 ZINTERSTORE 类似</td>
</tr>
<tr>
<td>ZRANGE key start end</td>
<td>获取指定有序集合 start 和 end 之间的元素（score 从低到高）</td>
</tr>
<tr>
<td>ZREVRANGE key start end</td>
<td>获取指定有序集合 start 和 end 之间的元素（score 从高到底）</td>
</tr>
<tr>
<td>ZREVRANK key member</td>
<td>获取指定有序集合中指定元素的排名(score 从大到小排序)</td>
</tr>
</tbody>
</table>
<p>更多 Redis Sorted Set 命令以及详细使用指南，请查看 Redis 官网对应的介绍：<a href="https://redis.io/commands/?group=sorted-set">https://redis.io/commands/?group=sorted-set</a> 。</p>
<p><strong>基本操作</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; ZADD myZset 2.0 value1 1.0 value2
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>&gt; ZCARD myZset
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>&gt; ZSCORE myZset value1
</span></span><span style="display:flex;"><span>2.0
</span></span><span style="display:flex;"><span>&gt; ZRANGE myZset <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>&gt; ZREVRANGE myZset <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>1) <span style="color:#0ff;font-weight:bold">&#34;value1&#34;</span>
</span></span><span style="display:flex;"><span>2) <span style="color:#0ff;font-weight:bold">&#34;value2&#34;</span>
</span></span><span style="display:flex;"><span>&gt; ZADD myZset2 4.0 value2 3.0 value3
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li><code>myZset</code> : <code>value1</code>(2.0)、<code>value2</code>(1.0) 。</li>
<li><code>myZset2</code>：<code>value2</code> （4.0）、<code>value3</code>(3.0) 。</li>
</ul>
<p><strong>获取指定元素的排名</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; ZREVRANK myZset value1
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; ZREVRANK myZset value2
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">1</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>求交集</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; ZINTERSTORE myZset3 <span style="color:#ff0;font-weight:bold">2</span> myZset myZset2
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; ZRANGE myZset3 <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">1</span> WITHSCORES
</span></span><span style="display:flex;"><span>value2
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">5</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>求并集</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">9
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; ZUNIONSTORE myZset4 <span style="color:#ff0;font-weight:bold">2</span> myZset myZset2
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>&gt; ZRANGE myZset4 <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#ff0;font-weight:bold">2</span> WITHSCORES
</span></span><span style="display:flex;"><span>value1
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">2</span>
</span></span><span style="display:flex;"><span>value3
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>value2
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">5</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>求差集</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; ZDIFF <span style="color:#ff0;font-weight:bold">2</span> myZset myZset2 WITHSCORES
</span></span><span style="display:flex;"><span>value1
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景-4">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景-4">#</a></h3>
<p><strong>需要随机获取数据源中的元素根据某个权重进行排序的场景</strong></p>
<ul>
<li>举例：各种排行榜比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</li>
<li>相关命令：<code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>
</ul>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/2021060714195385.png"></p>
<p><strong>需要存储的数据有优先级或者重要程度的场景</strong> 比如优先级任务队列。</p>
<ul>
<li>举例：优先级任务队列。</li>
<li>相关命令：<code>ZRANGE</code> (从小到大排序)、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</li>
</ul>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String</td>
<td>一种二进制安全的数据结构，可以用来存储任何类型的数据比如字符串、整数、浮点数、图片（图片的 base64 编码或者解码或者图片的路径）、序列化后的对象。</td>
</tr>
<tr>
<td>List</td>
<td>Redis 的 List 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</td>
</tr>
<tr>
<td>Hash</td>
<td>一个 String 类型的 field-value（键值对） 的映射表，特别适合用于存储对象，后续操作的时候，你可以直接修改这个对象中的某些字段的值。</td>
</tr>
<tr>
<td>Set</td>
<td>无序集合，集合中的元素没有先后顺序但都唯一，有点类似于 Java 中的 <code>HashSet</code> 。</td>
</tr>
<tr>
<td>Zset</td>
<td>和 Set 相比，Sorted Set 增加了一个权重参数 <code>score</code>，使得集合中的元素能够按 <code>score</code> 进行有序排列，还可以通过 <code>score</code> 的范围来获取元素的列表。有点像是 Java 中 <code>HashMap</code> 和 <code>TreeSet</code> 的结合体。</td>
</tr>
</tbody>
</table>
<h1 id="redis-3-种特殊数据结构详解">Redis 3 种特殊数据结构详解<a hidden class="anchor" aria-hidden="true" href="#redis-3-种特殊数据结构详解">#</a></h1>
<p>除了 5 种基本的数据结构之外，Redis 还支持 3 种特殊的数据结构：Bitmap、HyperLogLog、GEO。</p>
<h2 id="bitmap">Bitmap<a hidden class="anchor" aria-hidden="true" href="#bitmap">#</a></h2>
<h3 id="介绍-5">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍-5">#</a></h3>
<p>Bitmap 存储的是连续的二进制数字（0 和 1），通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</p>
<p>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220720194154133.png"></p>
<h3 id="常用命令-5">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令-5">#</a></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>SETBIT key offset value</td>
<td>设置指定 offset 位置的值</td>
</tr>
<tr>
<td>GETBIT key offset</td>
<td>获取指定 offset 位置的值</td>
</tr>
<tr>
<td>BITCOUNT key start end</td>
<td>获取 start 和 end 之前值为 1 的元素个数</td>
</tr>
<tr>
<td>BITOP operation destkey key1 key2 &hellip;</td>
<td>对一个或多个 Bitmap 进行运算，可用运算符有 AND, OR, XOR 以及 NOT</td>
</tr>
</tbody>
</table>
<p><strong>Bitmap 基本操作演示</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># SETBIT 会返回之前位的值（默认是 0）这里会生成 7 个位</span>
</span></span><span style="display:flex;"><span>&gt; SETBIT mykey <span style="color:#ff0;font-weight:bold">7</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; SETBIT mykey <span style="color:#ff0;font-weight:bold">7</span> <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; GETBIT mykey <span style="color:#ff0;font-weight:bold">7</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; SETBIT mykey <span style="color:#ff0;font-weight:bold">6</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; SETBIT mykey <span style="color:#ff0;font-weight:bold">8</span> <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 通过 bitcount 统计被被设置为 1 的位的数量。</span>
</span></span><span style="display:flex;"><span>&gt; BITCOUNT mykey
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">2</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景-5">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景-5">#</a></h3>
<p><strong>需要保存状态信息（0/1 即可表示）的场景</strong></p>
<ul>
<li>举例：用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li>
<li>相关命令：<code>SETBIT</code>、<code>GETBIT</code>、<code>BITCOUNT</code>、<code>BITOP</code>。</li>
</ul>
<h2 id="hyperloglog">HyperLogLog<a hidden class="anchor" aria-hidden="true" href="#hyperloglog">#</a></h2>
<h3 id="介绍-6">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍-6">#</a></h3>
<p>HyperLogLog 是一种有名的基数计数概率算法 ，基于 LogLog Counting(LLC)优化改进得来，并不是 Redis 特有的，Redis 只是实现了这个算法并提供了一些开箱即用的 API。</p>
<p>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。这是真的厉害，这就是数学的魅力么！并且，Redis 对 HyperLogLog 的存储结构做了优化，采用两种方式计数：</p>
<ul>
<li><strong>稀疏矩阵</strong>：计数较少的时候，占用空间很小。</li>
<li><strong>稠密矩阵</strong>：计数达到某个阈值的时候，占用 12k 的空间。</li>
</ul>
<p>Redis 官方文档中有对应的详细说明：</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220721091424563.png"></p>
<p>基数计数概率算法为了节省内存并不会直接存储元数据，而是通过一定的概率统计方法预估基数值（集合中包含元素的个数）。因此， HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> ）。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220720194154133.png"></p>
<p>HyperLogLog 的使用非常简单，但原理非常复杂。HyperLogLog 的原理以及在 Redis 中的实现可以看这篇文章：<a href="https://juejin.cn/post/6844903785744056333">HyperLogLog 算法的原理讲解以及 Redis 是如何应用它的</a> 。</p>
<p>再推荐一个可以帮助理解 HyperLogLog 原理的工具：<a href="http://content.research.neustar.biz/blog/hll.html">Sketch of the Day: HyperLogLog — Cornerstone of a Big Data Infrastructure</a> 。</p>
<h3 id="常用命令-6">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令-6">#</a></h3>
<p>HyperLogLog 相关的命令非常少，最常用的也就 3 个。</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>PFADD key element1 element2 &hellip;</td>
<td>添加一个或多个元素到 HyperLogLog 中</td>
</tr>
<tr>
<td>PFCOUNT key1 key2</td>
<td>获取一个或者多个 HyperLogLog 的唯一计数。</td>
</tr>
<tr>
<td>PFMERGE destkey sourcekey1 sourcekey2 &hellip;</td>
<td>将多个 HyperLogLog 合并到 destkey 中，destkey 会结合多个源，算出对应的唯一计数。</td>
</tr>
</tbody>
</table>
<p><strong>HyperLogLog 基本操作演示</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; PFADD hll foo bar zap
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; PFADD hll zap zap zap
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; PFADD hll foo bar
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">0</span>
</span></span><span style="display:flex;"><span>&gt; PFCOUNT hll
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>&gt; PFADD some-other-hll <span style="color:#ff0;font-weight:bold">1</span> <span style="color:#ff0;font-weight:bold">2</span> <span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; PFCOUNT hll some-other-hll
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">6</span>
</span></span><span style="display:flex;"><span>&gt; PFMERGE desthll hll some-other-hll
</span></span><span style="display:flex;"><span><span style="color:#0ff;font-weight:bold">&#34;OK&#34;</span>
</span></span><span style="display:flex;"><span>&gt; PFCOUNT desthll
</span></span><span style="display:flex;"><span>(integer) <span style="color:#ff0;font-weight:bold">6</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景-6">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景-6">#</a></h3>
<p><strong>数量量巨大（百万、千万级别以上）的计数场景</strong></p>
<ul>
<li>举例：热门网站每日/每周/每月访问 ip 数统计、热门帖子 uv 统计、</li>
<li>相关命令：<code>PFADD</code>、<code>PFCOUNT</code> 。</li>
</ul>
<h2 id="geospatial-index">Geospatial index<a hidden class="anchor" aria-hidden="true" href="#geospatial-index">#</a></h2>
<h3 id="介绍-7">介绍<a hidden class="anchor" aria-hidden="true" href="#介绍-7">#</a></h3>
<p>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。</p>
<p>通过 GEO 我们可以轻松实现两个位置距离的计算、获取指定位置附近的元素等功能。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220720194359494.png"></p>
<h3 id="常用命令-7">常用命令<a hidden class="anchor" aria-hidden="true" href="#常用命令-7">#</a></h3>
<table>
<thead>
<tr>
<th>命令</th>
<th>介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>GEOADD key longitude1 latitude1 member1 &hellip;</td>
<td>添加一个或多个元素对应的经纬度信息到 GEO 中</td>
</tr>
<tr>
<td>GEOPOS key member1 member2 &hellip;</td>
<td>返回给定元素的经纬度信息</td>
</tr>
<tr>
<td>GEODIST key member1 member2 M/KM/FT/MI</td>
<td>返回两个给定元素之间的距离</td>
</tr>
<tr>
<td>GEORADIUS key longitude latitude radius distance</td>
<td>获取指定位置附近 distance 范围内的其他元素，支持 ASC(由近到远)、DESC（由远到近）、Count(数量) 等参数</td>
</tr>
<tr>
<td>GEORADIUSBYMEMBER key member radius distance</td>
<td>类似于 GEORADIUS 命令，只是参照的中心点是 GEO 中的元素</td>
</tr>
</tbody>
</table>
<p><strong>基本操作</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; GEOADD personLocation 116.33 39.89 user1 116.34 39.90 user2 116.35 39.88 user3
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">3</span>
</span></span><span style="display:flex;"><span>&gt; GEOPOS personLocation user1
</span></span><span style="display:flex;"><span>116.3299986720085144
</span></span><span style="display:flex;"><span>39.89000061669732844
</span></span><span style="display:flex;"><span>&gt; GEODIST personLocation user1 user2 km
</span></span><span style="display:flex;"><span>1.4018
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 Redis 可视化工具查看 <code>personLocation</code> ，果不其然，底层就是 Sorted Set。</p>
<p>GEO 中存储的地理位置信息的经纬度数据通过 GeoHash 算法转换成了一个整数，这个整数作为 Sorted Set 的 score(权重参数)使用。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/image-20220721201545147.png"></p>
<p><strong>获取指定位置范围内的其他元素</strong>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; GEORADIUS personLocation 116.33 39.87 <span style="color:#ff0;font-weight:bold">3</span> km
</span></span><span style="display:flex;"><span>user3
</span></span><span style="display:flex;"><span>user1
</span></span><span style="display:flex;"><span>&gt; GEORADIUS personLocation 116.33 39.87 <span style="color:#ff0;font-weight:bold">2</span> km
</span></span><span style="display:flex;"><span>&gt; GEORADIUS personLocation 116.33 39.87 <span style="color:#ff0;font-weight:bold">5</span> km
</span></span><span style="display:flex;"><span>user3
</span></span><span style="display:flex;"><span>user1
</span></span><span style="display:flex;"><span>user2
</span></span><span style="display:flex;"><span>&gt; GEORADIUSBYMEMBER personLocation user1 <span style="color:#ff0;font-weight:bold">5</span> km
</span></span><span style="display:flex;"><span>user3
</span></span><span style="display:flex;"><span>user1
</span></span><span style="display:flex;"><span>user2
</span></span><span style="display:flex;"><span>&gt; GEORADIUSBYMEMBER personLocation user1 <span style="color:#ff0;font-weight:bold">2</span> km
</span></span><span style="display:flex;"><span>user1
</span></span><span style="display:flex;"><span>user2
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>GEORADIUS</code> 命令的底层原理解析可以看看阿里的这篇文章：<a href="https://juejin.cn/post/6844903966061363207">Redis 到底是怎么实现“附近的人”这个功能的呢？</a> 。</p>
<p><strong>移除元素</strong>：</p>
<p>GEO 底层是 Sorted Set ，你可以对 GEO 使用 Sorted Set 相关的命令。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; ZREM personLocation user1
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span>&gt; ZRANGE personLocation <span style="color:#ff0;font-weight:bold">0</span> -1
</span></span><span style="display:flex;"><span>user3
</span></span><span style="display:flex;"><span>user2
</span></span><span style="display:flex;"><span>&gt; ZSCORE personLocation user2
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">4069879562983946</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="应用场景-7">应用场景<a hidden class="anchor" aria-hidden="true" href="#应用场景-7">#</a></h3>
<p><strong>需要管理使用地理空间数据的场景</strong></p>
<ul>
<li>举例：附近的人。</li>
<li>相关命令: <code>GEOADD</code>、<code>GEORADIUS</code>、<code>GEORADIUSBYMEMBER</code> 。</li>
</ul>
<h2 id="总结-1">总结<a hidden class="anchor" aria-hidden="true" href="#总结-1">#</a></h2>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bitmap</td>
<td>你可以将 Bitmap 看作是一个存储二进制数字（0 和 1）的数组，数组中每个元素的下标叫做 offset（偏移量）。通过 Bitmap, 只需要一个 bit 位来表示某个元素对应的值或者状态，key 就是对应元素本身 。我们知道 8 个 bit 可以组成一个 byte，所以 Bitmap 本身会极大的节省储存空间。</td>
</tr>
<tr>
<td>HyperLogLog</td>
<td>Redis 提供的 HyperLogLog 占用空间非常非常小，只需要 12k 的空间就能存储接近<code>2^64</code>个不同元素。不过，HyperLogLog 的计数结果并不是一个精确值，存在一定的误差（标准误差为 <code>0.81%</code> ）。</td>
</tr>
<tr>
<td>Geospatial index</td>
<td>Geospatial index（地理空间索引，简称 GEO） 主要用于存储地理位置信息，基于 Sorted Set 实现。</td>
</tr>
</tbody>
</table>
<h1 id="redis持久化机制详解">Redis持久化机制详解<a hidden class="anchor" aria-hidden="true" href="#redis持久化机制详解">#</a></h1>
<p>使用缓存的时候，我们经常需要对内存中的数据进行持久化也就是将内存中的数据写入到硬盘中。大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了做数据同步（比如 Redis 集群的主从节点通过 RDB 文件同步数据）。</p>
<p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持 3 种持久化方式:</p>
<ul>
<li>快照（snapshotting，RDB）</li>
<li>只追加文件（append-only file, AOF）</li>
<li>RDB 和 AOF 的混合持久化(Redis 4.0 新增)</li>
</ul>
<p>官方文档地址：https://redis.io/topics/persistence 。</p>
<h2 id="rdb-持久化">RDB 持久化<a hidden class="anchor" aria-hidden="true" href="#rdb-持久化">#</a></h2>
<h3 id="什么是-rdb-持久化">什么是 RDB 持久化？<a hidden class="anchor" aria-hidden="true" href="#什么是-rdb-持久化">#</a></h3>
<p>Redis 可以通过创建快照来获得存储在内存里面的数据在 <strong>某个时间点</strong> 上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p>
<p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-clojure" data-lang="clojure"><span style="display:flex;"><span>save <span style="color:#ff0;font-weight:bold">900</span> <span style="color:#ff0;font-weight:bold">1</span>           #在900秒(<span style="color:#ff0;font-weight:bold">15</span>分钟)之后<span style="color:#f00">，</span>如果至少有1个key发生变化<span style="color:#f00">，</span>Redis就会自动触发bgsave命令创建快照<span style="color:#f00">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>save <span style="color:#ff0;font-weight:bold">300</span> <span style="color:#ff0;font-weight:bold">10</span>          #在300秒(<span style="color:#ff0;font-weight:bold">5</span>分钟)之后<span style="color:#f00">，</span>如果至少有10个key发生变化<span style="color:#f00">，</span>Redis就会自动触发bgsave命令创建快照<span style="color:#f00">。</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>save <span style="color:#ff0;font-weight:bold">60</span> <span style="color:#ff0;font-weight:bold">10000</span>        #在60秒(<span style="color:#ff0;font-weight:bold">1</span>分钟)之后<span style="color:#f00">，</span>如果至少有10000个key发生变化<span style="color:#f00">，</span>Redis就会自动触发bgsave命令创建快照<span style="color:#f00">。</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="rdb-创建快照时会阻塞主线程吗">RDB 创建快照时会阻塞主线程吗？<a hidden class="anchor" aria-hidden="true" href="#rdb-创建快照时会阻塞主线程吗">#</a></h3>
<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程；</li>
<li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>
</ul>
<blockquote>
<p>这里说 Redis 主线程而不是主进程的主要是因为 Redis 启动之后主要是通过单线程的方式完成主要的工作。如果你想将其描述为 Redis 主进程，也没毛病。</p>
</blockquote>
<h2 id="aof-持久化">AOF 持久化<a hidden class="anchor" aria-hidden="true" href="#aof-持久化">#</a></h2>
<h3 id="什么是-aof-持久化">什么是 AOF 持久化？<a hidden class="anchor" aria-hidden="true" href="#什么是-aof-持久化">#</a></h3>
<p>与快照持久化相比，AOF 持久化的实时性更好。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化（Redis 6.0 之后已经默认是开启了），可以通过 <code>appendonly</code> 参数开启：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>appendonly yes
</span></span></code></pre></td></tr></table>
</div>
</div><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再写入到 AOF 文件中（此时还在系统内核缓存区未同步到磁盘），最后再根据持久化方式（ <code>fsync</code>策略）的配置来决定何时将系统内核缓存区的数据同步到硬盘中的。</p>
<p>只有同步到磁盘中才算持久化保存了，否则依然存在数据丢失的风险，比如说：系统内核缓存区的数据还未同步，磁盘机器就宕机了，那这部分数据就算丢失了。</p>
<p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 <code>dir</code> 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p>
<h3 id="aof-工作基本流程是怎样的">AOF 工作基本流程是怎样的？<a hidden class="anchor" aria-hidden="true" href="#aof-工作基本流程是怎样的">#</a></h3>
<p>AOF 持久化功能的实现可以简单分为 5 步：</p>
<ol>
<li><strong>命令追加（append）</strong>：所有的写命令会追加到 AOF 缓冲区中。</li>
<li><strong>文件写入（write）</strong>：将 AOF 缓冲区的数据写入到 AOF 文件中。这一步需要调用<code>write</code>函数（系统调用），<code>write</code>将数据写入到了系统内核缓冲区之后直接返回了（延迟写）。注意！！！此时并没有同步到磁盘。</li>
<li><strong>文件同步（fsync）</strong>：AOF 缓冲区根据对应的持久化方式（ <code>fsync</code> 策略）向硬盘做同步操作。这一步需要调用 <code>fsync</code> 函数（系统调用）， <code>fsync</code> 针对单个文件操作，对其进行强制硬盘同步，<code>fsync</code> 将阻塞直到写入磁盘完成后返回，保证了数据持久化。</li>
<li><strong>文件重写（rewrite）</strong>：随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。</li>
<li><strong>重启加载（load）</strong>：当 Redis 重启时，可以加载 AOF 文件进行数据恢复。</li>
</ol>
<blockquote>
<p>Linux 系统直接提供了一些函数用于对文件和设备进行访问和控制，这些函数被称为 <strong>系统调用（syscall）</strong>。</p>
</blockquote>
<p>这里对上面提到的一些 Linux 系统调用再做一遍解释：</p>
<ul>
<li><code>write</code>：写入系统内核缓冲区之后直接返回（仅仅是写到缓冲区），不会立即同步到硬盘。虽然提高了效率，但也带来了数据丢失的风险。同步硬盘操作通常依赖于系统调度机制，Linux 内核通常为 30s 同步一次，具体值取决于写出的数据量和 I/O 缓冲区的状态。</li>
<li><code>fsync</code>：<code>fsync</code>用于强制刷新系统内核缓冲区（同步到到磁盘），确保写磁盘操作结束才会返回。</li>
</ul>
<p>AOF 工作流程图如下：</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/aof-work-process.png"></p>
<h3 id="aof-持久化方式有哪些">AOF 持久化方式有哪些？<a hidden class="anchor" aria-hidden="true" href="#aof-持久化方式有哪些">#</a></h3>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>
<ol>
<li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程（ <code>aof_fsync</code> 线程）立即会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）。</li>
<li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程（ <code>aof_fsync</code> 线程）每秒钟调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</li>
<li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）。</li>
</ol>
<p>可以看出：<strong>这 3 种持久化方式的主要区别在于 <code>fsync</code> 同步 AOF 文件的时机（刷盘）</strong>。</p>
<p>为了兼顾数据和写入性能，可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能受到的影响较小。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p>
<p>从 Redis 7.0.0 开始，Redis 使用了 <strong>Multi Part AOF</strong> 机制。顾名思义，Multi Part AOF 就是将原来的单个 AOF 文件拆分成多个 AOF 文件。在 Multi Part AOF 中，AOF 文件被分为三种类型，分别为：</p>
<ul>
<li>BASE：表示基础 AOF 文件，它一般由子进程通过重写产生，该文件最多只有一个。</li>
<li>INCR：表示增量 AOF 文件，它一般会在 AOFRW 开始执行时被创建，该文件可能存在多个。</li>
<li>HISTORY：表示历史 AOF 文件，它由 BASE 和 INCR AOF 变化而来，每次 AOFRW 成功完成时，本次 AOFRW 之前对应的 BASE 和 INCR AOF 都将变为 HISTORY，HISTORY 类型的 AOF 会被 Redis 自动删除。</li>
</ul>
<p>Multi Part AOF 不是重点，了解即可，详细介绍可以看看阿里开发者的<a href="https://zhuanlan.zhihu.com/p/467217082">Redis 7.0 Multi Part AOF 的设计和实现</a> 这篇文章。</p>
<p><strong>相关 issue</strong>：<a href="https://github.com/Snailclimb/JavaGuide/issues/783">Redis 的 AOF 方式 #783</a>。</p>
<h3 id="aof-为什么是在执行完命令之后记录日志">AOF 为什么是在执行完命令之后记录日志？<a hidden class="anchor" aria-hidden="true" href="#aof-为什么是在执行完命令之后记录日志">#</a></h3>
<p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-aof-write-log-disc.png"></p>
<p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ul>
<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>
<ul>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li>
</ul>
<h3 id="aof-重写了解吗">AOF 重写了解吗？<a hidden class="anchor" aria-hidden="true" href="#aof-重写了解吗">#</a></h3>
<p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/aof-rewrite.png"></p>
<blockquote>
<p>AOF 重写（rewrite） 是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p>
</blockquote>
<p>由于 AOF 重写会进行大量的写入操作，为了避免对 Redis 正常处理命令请求造成影响，Redis 将 AOF 重写程序放到子进程里执行。</p>
<p>AOF 文件重写期间，Redis 还会维护一个 <strong>AOF 重写缓冲区</strong>，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p>
<p>开启 AOF 重写功能，可以调用 <code>BGREWRITEAOF</code> 命令手动执行，也可以设置下面两个配置项，让程序自动决定触发时机：</p>
<ul>
<li><code>auto-aof-rewrite-min-size</code>：如果 AOF 文件大小小于该值，则不会触发 AOF 重写。默认值为 64 MB;</li>
<li><code>auto-aof-rewrite-percentage</code>：执行 AOF 重写时，当前 AOF 大小（aof_current_size）和上一次重写时 AOF 大小（aof_base_size）的比值。如果当前 AOF 文件大小增加了这个百分比值，将触发 AOF 重写。将此值设置为 0 将禁用自动 AOF 重写。默认值为 100。</li>
</ul>
<p>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</p>
<p>Redis 7.0 版本之后，AOF 重写机制得到了优化改进。下面这段内容摘自阿里开发者的<a href="https://mp.weixin.qq.com/s/RnoPPL7jiFSKkx3G4p57Pg">从 Redis7.0 发布看 Redis 的过去与未来</a> 这篇文章。</p>
<blockquote>
<p>AOF 重写期间的增量数据如何处理一直是个问题，在过去写期间的增量数据需要在内存中保留，写结束后再把这部分增量数据写入新的 AOF 文件中以保证数据完整性。可以看出来 AOF 写会额外消耗内存和磁盘 IO，这也是 Redis AOF 写的痛点，虽然之前也进行过多次改进但是资源消耗的本质问题一直没有解决。</p>
<p>阿里云的 Redis 企业版在最初也遇到了这个问题，在内部经过多次迭代开发，实现了 Multi-part AOF 机制来解决，同时也贡献给了社区并随此次 7.0 发布。具体方法是采用 base（全量数据）+inc（增量数据）独立文件存储的方式，彻底解决内存和 IO 资源的浪费，同时也支持对历史 AOF 文件的保存管理，结合 AOF 文件中的时间信息还可以实现 PITR 按时间点恢复（阿里云企业版 Tair 已支持），这进一步增强了 Redis 的数据可靠性，满足用户数据回档等需求。</p>
</blockquote>
<p><strong>相关 issue</strong>：<a href="https://github.com/Snailclimb/JavaGuide/issues/1439">Redis AOF 重写描述不准确 #1439</a>。</p>
<h3 id="aof-校验机制了解吗">AOF 校验机制了解吗？<a hidden class="anchor" aria-hidden="true" href="#aof-校验机制了解吗">#</a></h3>
<p>AOF 校验机制是 Redis 在启动时对 AOF 文件进行检查，以判断文件是否完整，是否有损坏或者丢失的数据。这个机制的原理其实非常简单，就是通过使用一种叫做 <strong>校验和（checksum）</strong> 的数字来验证 AOF 文件。这个校验和是通过对整个 AOF 文件内容进行 CRC64 算法计算得出的数字。如果文件内容发生了变化，那么校验和也会随之改变。因此，Redis 在启动时会比较计算出的校验和与文件末尾保存的校验和（计算的时候会把最后一行保存校验和的内容给忽略点），从而判断 AOF 文件是否完整。如果发现文件有问题，Redis 就会拒绝启动并提供相应的错误信息。AOF 校验机制十分简单有效，可以提高 Redis 数据的可靠性。</p>
<p>类似地，RDB 文件也有类似的校验机制来保证 RDB 文件的正确性，这里就不重复进行介绍了。</p>
<h2 id="redis-40-对于持久化机制做了什么优化">Redis 4.0 对于持久化机制做了什么优化？<a hidden class="anchor" aria-hidden="true" href="#redis-40-对于持久化机制做了什么优化">#</a></h2>
<p>由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p>
<p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>
<p>官方文档地址：https://redis.io/topics/persistence</p>
<h2 id="如何选择-rdb-和-aof">如何选择 RDB 和 AOF？<a hidden class="anchor" aria-hidden="true" href="#如何选择-rdb-和-aof">#</a></h2>
<p>关于 RDB 和 AOF 的优缺点，官网上面也给了比较详细的说明<a href="https://redis.io/docs/manual/persistence/">Redis persistence</a>，这里结合自己的理解简单总结一下。</p>
<p><strong>RDB 比 AOF 优秀的地方</strong>：</p>
<ul>
<li>RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会比 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li>
<li>使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li>
</ul>
<p><strong>AOF 比 RDB 优秀的地方</strong>：</p>
<ul>
<li>RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li>
<li>RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li>
<li>AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li>
</ul>
<p><strong>综上</strong>：</p>
<ul>
<li>Redis 保存的数据丢失一些也没什么影响的话，可以选择使用 RDB。</li>
<li>不建议单独使用 AOF，因为时不时地创建一个 RDB 快照可以进行数据库备份、更快的重启以及解决 AOF 引擎错误。</li>
<li>如果保存的数据要求安全性比较高的话，建议同时开启 RDB 和 AOF 持久化或者开启 RDB 和 AOF 混合持久化。</li>
</ul>
<h1 id="redis内存碎片详解">Redis内存碎片详解<a hidden class="anchor" aria-hidden="true" href="#redis内存碎片详解">#</a></h1>
<h2 id="什么是内存碎片">什么是内存碎片?<a hidden class="anchor" aria-hidden="true" href="#什么是内存碎片">#</a></h2>
<p>你可以将内存碎片简单地理解为那些不可用的空闲内存。</p>
<p>举个例子：操作系统为你分配了 32 字节的连续内存空间，而你存储数据实际只需要使用 24 字节内存空间，那这多余出来的 8 字节内存空间如果后续没办法再被分配存储其他数据的话，就可以被称为内存碎片。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/memory-fragmentation.png"></p>
<p>Redis 内存碎片虽然不会影响 Redis 性能，但是会增加内存消耗。</p>
<h2 id="为什么会有-redis-内存碎片">为什么会有 Redis 内存碎片?<a hidden class="anchor" aria-hidden="true" href="#为什么会有-redis-内存碎片">#</a></h2>
<p>Redis 内存碎片产生比较常见的 2 个原因：</p>
<p><strong>1、Redis 存储存储数据的时候向操作系统申请的内存空间可能会大于数据实际需要的存储空间。</strong></p>
<p>以下是这段 Redis 官方的原话：</p>
<blockquote>
<p>To store user keys, Redis allocates at most as much memory as the <code>maxmemory</code> setting enables (however there are small extra allocations possible).</p>
</blockquote>
<p>Redis 使用 <code>zmalloc</code> 方法(Redis 自己实现的内存分配方法)进行内存分配的时候，除了要分配 <code>size</code> 大小的内存之外，还会多分配 <code>PREFIX_SIZE</code> 大小的内存。</p>
<p><code>zmalloc</code> 方法源码如下（源码地址：https://github.com/antirez/redis-tools/blob/master/zmalloc.c）：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">void</span> *zmalloc(size_t size) {
</span></span><span style="display:flex;"><span>   <span style="color:#007f7f">// 分配指定大小的内存</span>
</span></span><span style="display:flex;"><span>   <span style="color:#fff;font-weight:bold">void</span> *ptr = malloc(size+PREFIX_SIZE);
</span></span><span style="display:flex;"><span>   <span style="color:#fff;font-weight:bold">if</span> (!ptr) zmalloc_oom_handler(size);
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>ifdef HAVE_MALLOC_SIZE
</span></span><span style="display:flex;"><span>   update_zmalloc_stat_alloc(zmalloc_size(ptr));
</span></span><span style="display:flex;"><span>   <span style="color:#fff;font-weight:bold">return</span> ptr;
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span><span style="color:#fff;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>   *((size_t*)ptr) = size;
</span></span><span style="display:flex;"><span>   update_zmalloc_stat_alloc(size+PREFIX_SIZE);
</span></span><span style="display:flex;"><span>   <span style="color:#fff;font-weight:bold">return</span> (<span style="color:#fff;font-weight:bold">char</span>*)ptr+PREFIX_SIZE;
</span></span><span style="display:flex;"><span><span style="color:#f00">#</span>endif
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外，Redis 可以使用多种内存分配器来分配内存（ libc、jemalloc、tcmalloc），默认使用 <a href="https://github.com/jemalloc/jemalloc">jemalloc</a>，而 jemalloc 按照一系列固定的大小（8 字节、16 字节、32 字节&hellip;&hellip;）来分配内存的。jemalloc 划分的内存单元如下图所示：</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/6803d3929e3e46c1b1c9d0bb9ee8e717.png"></p>
<p>当程序申请的内存最接近某个固定值时，jemalloc 会给它分配相应大小的空间，就比如说程序需要申请 17 字节的内存，jemalloc 会直接给它分配 32 字节的内存，这样会导致有 15 字节内存的浪费。不过，jemalloc 专门针对内存碎片问题做了优化，一般不会存在过度碎片化的问题。</p>
<p><strong>2、频繁修改 Redis 中的数据也会产生内存碎片。</strong></p>
<p>当 Redis 中的某个数据删除时，Redis 通常不会轻易释放内存给操作系统。</p>
<p>这个在 Redis 官方文档中也有对应的原话:</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-docs-memory-optimization.png"></p>
<p>文档地址：https://redis.io/topics/memory-optimization 。</p>
<h2 id="如何查看-redis-内存碎片的信息">如何查看 Redis 内存碎片的信息？<a hidden class="anchor" aria-hidden="true" href="#如何查看-redis-内存碎片的信息">#</a></h2>
<p>使用 <code>info memory</code> 命令即可查看 Redis 内存相关的信息。下图中每个参数具体的含义，Redis 官方文档有详细的介绍：https://redis.io/commands/INFO 。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-info-memory.png"></p>
<p>Redis 内存碎片率的计算公式：<code>mem_fragmentation_ratio</code> （内存碎片率）= <code>used_memory_rss</code> (操作系统实际分配给 Redis 的物理内存空间大小)/ <code>used_memory</code>(Redis 内存分配器为了存储数据实际申请使用的内存空间大小)</p>
<p>也就是说，<code>mem_fragmentation_ratio</code> （内存碎片率）的值越大代表内存碎片率越严重。</p>
<p>一定不要误认为<code>used_memory_rss</code> 减去 <code>used_memory</code>值就是内存碎片的大小！！！这不仅包括内存碎片，还包括其他进程开销，以及共享库、堆栈等的开销。</p>
<p>很多小伙伴可能要问了：“多大的内存碎片率才是需要清理呢？”。</p>
<p>通常情况下，我们认为 <code>mem_fragmentation_ratio &gt; 1.5</code> 的话才需要清理内存碎片。 <code>mem_fragmentation_ratio &gt; 1.5</code> 意味着你使用 Redis 存储实际大小 2G 的数据需要使用大于 3G 的内存。</p>
<p>如果想要快速查看内存碎片率的话，你还可以通过下面这个命令：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>&gt; redis-cli -p <span style="color:#ff0;font-weight:bold">6379</span> info | grep mem_fragmentation_ratio
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外，内存碎片率可能存在小于 1 的情况。这种情况我在日常使用中还没有遇到过，感兴趣的小伙伴可以看看这篇文章 <a href="https://mp.weixin.qq.com/s/drlDvp7bfq5jt2M5pTqJCw">故障分析 | Redis 内存碎片率太低该怎么办？- 爱可生开源社区</a> 。</p>
<h2 id="如何清理-redis-内存碎片">如何清理 Redis 内存碎片？<a hidden class="anchor" aria-hidden="true" href="#如何清理-redis-内存碎片">#</a></h2>
<p>Redis4.0-RC3 版本以后自带了内存整理，可以避免内存碎片率过大的问题。</p>
<p>直接通过 <code>config set</code> 命令将 <code>activedefrag</code> 配置项设置为 <code>yes</code> 即可。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>config <span style="color:#fff;font-weight:bold">set</span> activedefrag yes
</span></span></code></pre></td></tr></table>
</div>
</div><p>具体什么时候清理需要通过下面两个参数控制：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 内存碎片占用空间达到 500mb 的时候开始清理</span>
</span></span><span style="display:flex;"><span>config <span style="color:#fff;font-weight:bold">set</span> active-defrag-ignore-bytes 500mb
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 内存碎片率大于 1.5 的时候开始清理</span>
</span></span><span style="display:flex;"><span>config <span style="color:#fff;font-weight:bold">set</span> active-defrag-threshold-lower <span style="color:#ff0;font-weight:bold">50</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过 Redis 自动内存碎片清理机制可能会对 Redis 的性能产生影响，我们可以通过下面两个参数来减少对 Redis 性能的影响：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#007f7f"># 内存碎片清理所占用 CPU 时间的比例不低于 20%</span>
</span></span><span style="display:flex;"><span>config <span style="color:#fff;font-weight:bold">set</span> active-defrag-cycle-min <span style="color:#ff0;font-weight:bold">20</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f"># 内存碎片清理所占用 CPU 时间的比例不高于 50%</span>
</span></span><span style="display:flex;"><span>config <span style="color:#fff;font-weight:bold">set</span> active-defrag-cycle-max <span style="color:#ff0;font-weight:bold">50</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外，重启节点可以做到内存碎片重新整理。如果你采用的是高可用架构的 Redis 集群的话，你可以将碎片率过高的主节点转换为从节点，以便进行安全重启。</p>
<h1 id="redis常见阻塞原因总结">Redis常见阻塞原因总结<a hidden class="anchor" aria-hidden="true" href="#redis常见阻塞原因总结">#</a></h1>
<h2 id="on-命令">O(n) 命令<a hidden class="anchor" aria-hidden="true" href="#on-命令">#</a></h2>
<p>Redis 中的大部分命令都是 O(1)时间复杂度，但也有少部分 O(n) 时间复杂度的命令，例如：</p>
<ul>
<li><code>KEYS *</code>：会返回所有符合规则的 key。</li>
<li><code>HGETALL</code>：会返回一个 Hash 中所有的键值对。</li>
<li><code>LRANGE</code>：会返回 List 中指定范围内的元素。</li>
<li><code>SMEMBERS</code>：返回 Set 中的所有元素。</li>
<li><code>SINTER</code>/<code>SUNION</code>/<code>SDIFF</code>：计算多个 Set 的交集/并集/差集。</li>
<li>&hellip;&hellip;</li>
</ul>
<p>由于这些命令时间复杂度是 O(n)，有时候也会全表扫描，随着 n 的增大，执行耗时也会越长，从而导致客户端阻塞。不过， 这些命令并不是一定不能使用，但是需要明确 N 的值。另外，有遍历的需求可以使用 <code>HSCAN</code>、<code>SSCAN</code>、<code>ZSCAN</code> 代替。</p>
<p>除了这些 O(n)时间复杂度的命令可能会导致阻塞之外， 还有一些时间复杂度可能在 O(N) 以上的命令，例如：</p>
<ul>
<li><code>ZRANGE</code>/<code>ZREVRANGE</code>：返回指定 Sorted Set 中指定排名范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 为返回的元素数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>
<li><code>ZREMRANGEBYRANK</code>/<code>ZREMRANGEBYSCORE</code>：移除 Sorted Set 中指定排名范围/指定 score 范围内的所有元素。时间复杂度为 O(log(n)+m)，n 为所有元素的数量， m 被删除元素的数量，当 m 和 n 相当大时，O(n) 的时间复杂度更小。</li>
<li>&hellip;&hellip;</li>
</ul>
<h2 id="save-创建-rdb-快照">SAVE 创建 RDB 快照<a hidden class="anchor" aria-hidden="true" href="#save-创建-rdb-快照">#</a></h2>
<p>Redis 提供了两个命令来生成 RDB 快照文件：</p>
<ul>
<li><code>save</code> : 同步保存操作，会阻塞 Redis 主线程；</li>
<li><code>bgsave</code> : fork 出一个子进程，子进程执行，不会阻塞 Redis 主线程，默认选项。</li>
</ul>
<p>默认情况下，Redis 默认配置会使用 <code>bgsave</code> 命令。如果手动使用 <code>save</code> 命令生成 RDB 快照文件的话，就会阻塞主线程。</p>
<h2 id="aof">AOF<a hidden class="anchor" aria-hidden="true" href="#aof">#</a></h2>
<h3 id="aof-日志记录阻塞">AOF 日志记录阻塞<a hidden class="anchor" aria-hidden="true" href="#aof-日志记录阻塞">#</a></h3>
<p>Redis AOF 持久化机制是在执行完命令之后再记录日志，这和关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复）不同。</p>
<p><img loading="lazy" src="/posts/interview/16_redis%E9%9D%A2%E8%AF%95%E9%A2%98/redis-aof-write-log-disc.png"></p>
<p><strong>为什么是在执行完命令之后记录日志呢？</strong></p>
<ul>
<li>避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li>
<li>在命令执行完之后再记录，不会阻塞当前的命令执行。</li>
</ul>
<p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p>
<ul>
<li>如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li>
<li><strong>可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）</strong>。</li>
</ul>
<h3 id="aof-刷盘阻塞">AOF 刷盘阻塞<a hidden class="anchor" aria-hidden="true" href="#aof-刷盘阻塞">#</a></h3>
<p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到 AOF 缓冲区 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式（ <code>fsync</code>策略），它们分别是：</p>
<ol>
<li><code>appendfsync always</code>：主线程调用 <code>write</code> 执行写操作后，后台线程（ <code>aof_fsync</code> 线程）立即会调用 <code>fsync</code> 函数同步 AOF 文件（刷盘），<code>fsync</code> 完成后线程返回，这样会严重降低 Redis 的性能（<code>write</code> + <code>fsync</code>）。</li>
<li><code>appendfsync everysec</code>：主线程调用 <code>write</code> 执行写操作后立即返回，由后台线程（ <code>aof_fsync</code> 线程）每秒钟调用 <code>fsync</code> 函数（系统调用）同步一次 AOF 文件（<code>write</code>+<code>fsync</code>，<code>fsync</code>间隔为 1 秒）</li>
<li><code>appendfsync no</code>：主线程调用 <code>write</code> 执行写操作后立即返回，让操作系统决定何时进行同步，Linux 下一般为 30 秒一次（<code>write</code>但不<code>fsync</code>，<code>fsync</code> 的时机由操作系统决定）。</li>
</ol>
<p>当后台线程（ <code>aof_fsync</code> 线程）调用 <code>fsync</code> 函数同步 AOF 文件时，需要等待，直到写入完成。当磁盘压力太大的时候，会导致 <code>fsync</code> 操作发生阻塞，主线程调用 <code>write</code> 函数时也会被阻塞。<code>fsync</code> 完成后，主线程执行 <code>write</code> 才能成功返回。</p>
<p>关于 AOF 工作流程的详细介绍可以查看：<a href="/">Redis 持久化机制详解</a>，有助于理解 AOF 刷盘阻塞。</p>
<h3 id="aof-重写阻塞">AOF 重写阻塞<a hidden class="anchor" aria-hidden="true" href="#aof-重写阻塞">#</a></h3>
<ol>
<li>fork 出一条子线程来将文件重写，在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子线程创建新 AOF 文件期间，记录服务器执行的所有写命令。</li>
<li>当子线程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。</li>
<li>最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</li>
</ol>
<p>阻塞就是出现在第 2 步的过程中，将缓冲区中新数据写到新文件的过程中会产生<strong>阻塞</strong>。</p>
<p>相关阅读：<a href="https://cloud.tencent.com/developer/article/1633077">Redis AOF 重写阻塞问题分析</a>。</p>
<h2 id="大-key">大 Key<a hidden class="anchor" aria-hidden="true" href="#大-key">#</a></h2>
<p>如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p>
<p>大 key 造成的阻塞问题如下：</p>
<ul>
<li>客户端超时阻塞：由于 Redis 执行命令是单线程处理，然后在操作大 key 时会比较耗时，那么就会阻塞 Redis，从客户端这一视角看，就是很久很久都没有响应。</li>
<li>引发网络阻塞：每次获取大 key 产生的网络流量较大，如果一个 key 的大小是 1 MB，每秒访问量为 1000，那么每秒会产生 1000MB 的流量，这对于普通千兆网卡的服务器来说是灾难性的。</li>
<li>阻塞工作线程：如果使用 del 删除大 key 时，会阻塞工作线程，这样就没办法处理后续的命令。</li>
</ul>
<h3 id="查找大-key">查找大 key<a hidden class="anchor" aria-hidden="true" href="#查找大-key">#</a></h3>
<p>当我们在使用 Redis 自带的 <code>--bigkeys</code> 参数查找大 key 时，最好选择在从节点上执行该命令，因为主节点上执行时，会<strong>阻塞</strong>主节点。</p>
<ul>
<li>我们还可以使用 SCAN 命令来查找大 key；</li>
<li>通过分析 RDB 文件来找出 big key，这种方案的前提是 Redis 采用的是 RDB 持久化。网上有现成的工具：</li>
<li>
<ul>
<li>redis-rdb-tools：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li>
<li>rdb_bigkeys：Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li>
</ul>
</li>
</ul>
<h3 id="删除大-key">删除大 key<a hidden class="anchor" aria-hidden="true" href="#删除大-key">#</a></h3>
<p>删除操作的本质是要释放键值对占用的内存空间。</p>
<p>释放内存只是第一步，为了更加高效地管理内存空间，在应用程序释放内存时，<strong>操作系统需要把释放掉的内存块插入一个空闲内存块的链表</strong>，以便后续进行管理和再分配。这个过程本身需要一定时间，而且会<strong>阻塞</strong>当前释放内存的应用程序。</p>
<p>所以，如果一下子释放了大量内存，空闲内存块链表操作时间就会增加，相应地就会造成 Redis 主线程的阻塞，如果主线程发生了阻塞，其他所有请求可能都会超时，超时越来越多，会造成 Redis 连接耗尽，产生各种异常。</p>
<p>删除大 key 时建议采用分批次删除和异步删除的方式进行。</p>
<h2 id="清空数据库">清空数据库<a hidden class="anchor" aria-hidden="true" href="#清空数据库">#</a></h2>
<p>清空数据库和上面 bigkey 删除也是同样道理，<code>flushdb</code>、<code>flushall</code> 也涉及到删除和释放所有的键值对，也是 Redis 的阻塞点。</p>
<h2 id="集群扩容">集群扩容<a hidden class="anchor" aria-hidden="true" href="#集群扩容">#</a></h2>
<p>Redis 集群可以进行节点的动态扩容缩容，这一过程目前还处于半自动状态，需要人工介入。</p>
<p>在扩缩容的时候，需要进行数据迁移。而 Redis 为了保证迁移的一致性，迁移所有操作都是同步操作。</p>
<p>执行迁移时，两端的 Redis 均会进入时长不等的阻塞状态，对于小 Key，该时间可以忽略不计，但如果一旦 Key 的内存使用过大，严重的时候会触发集群内的故障转移，造成不必要的切换。</p>
<h2 id="swap内存交换">Swap（内存交换）<a hidden class="anchor" aria-hidden="true" href="#swap内存交换">#</a></h2>
<p><strong>什么是 Swap？</strong> Swap 直译过来是交换的意思，Linux 中的 Swap 常被称为内存交换或者交换分区。类似于 Windows 中的虚拟内存，就是当内存不足的时候，把一部分硬盘空间虚拟成内存使用，从而解决内存容量不足的情况。因此，Swap 分区的作用就是牺牲硬盘，增加内存，解决 VPS 内存不够用或者爆满的问题。</p>
<p>Swap 对于 Redis 来说是非常致命的，Redis 保证高性能的一个重要前提是所有的数据在内存中。如果操作系统把 Redis 使用的部分内存换出硬盘，由于内存与硬盘读写的速度并几个数量级，会导致发生交换后的 Redis 性能急剧下降。</p>
<p>识别 Redis 发生 Swap 的检查方法如下：</p>
<p>1、查询 Redis 进程号</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>reids-cli -p <span style="color:#ff0;font-weight:bold">6383</span> info server | grep process_id
</span></span><span style="display:flex;"><span>process_id: <span style="color:#ff0;font-weight:bold">4476</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>2、根据进程号查询内存交换信息</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>cat /proc/4476/smaps | grep Swap
</span></span><span style="display:flex;"><span>Swap: 0kB
</span></span><span style="display:flex;"><span>Swap: 0kB
</span></span><span style="display:flex;"><span>Swap: 4kB
</span></span><span style="display:flex;"><span>Swap: 0kB
</span></span><span style="display:flex;"><span>Swap: 0kB
</span></span><span style="display:flex;"><span>.....
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果交换量都是 0KB 或者个别的是 4KB，则正常。</p>
<p>预防内存交换的方法：</p>
<ul>
<li>保证机器充足的可用内存</li>
<li>确保所有 Redis 实例设置最大可用内存(maxmemory)，防止极端情况 Redis 内存不可控的增长</li>
<li>降低系统使用 swap 优先级，如<code>echo 10 &gt; /proc/sys/vm/swappiness</code></li>
</ul>
<h2 id="cpu-竞争">CPU 竞争<a hidden class="anchor" aria-hidden="true" href="#cpu-竞争">#</a></h2>
<p>Redis 是典型的 CPU 密集型应用，不建议和其他多核 CPU 密集型服务部署在一起。当其他进程过度消耗 CPU 时，将严重影响 Redis 的吞吐量。</p>
<p>可以通过<code>reids-cli --stat</code>获取当前 Redis 使用情况。通过<code>top</code>命令获取进程对 CPU 的利用率等信息 通过<code>info commandstats</code>统计信息分析出命令不合理开销时间，查看是否是因为高算法复杂度或者过度的内存优化问题。</p>
<h2 id="网络问题">网络问题<a hidden class="anchor" aria-hidden="true" href="#网络问题">#</a></h2>
<p>连接拒绝、网络延迟，网卡软中断等网络问题也可能会导致 Redis 阻塞。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://funny-toffee-4aa7c3.netlify.app/tags/interview/">Interview</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2024 <a href="https://funny-toffee-4aa7c3.netlify.app/">Wjy&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>