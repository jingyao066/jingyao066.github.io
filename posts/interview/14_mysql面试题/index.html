<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>14_MySQL面试题 | Wjy&#39;s Blog</title>
<meta name="keywords" content="interview">
<meta name="description" content="MySQL字段类型 MySQL 字段类型可以简单分为三大类： 数值类型：整型（tinyint、smallint、mediumint、int 和 bigint）">
<meta name="author" content="Wjy">
<link rel="canonical" href="https://009965.xyz/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.css" rel="preload stylesheet" as="style">
<link rel="icon" href="https://009965.xyz/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://009965.xyz/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://009965.xyz/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://009965.xyz/apple-touch-icon.png">
<link rel="mask-icon" href="https://009965.xyz/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://009965.xyz/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
  

<meta property="og:url" content="https://009965.xyz/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/">
  <meta property="og:site_name" content="Wjy&#39;s Blog">
  <meta property="og:title" content="14_MySQL面试题">
  <meta property="og:description" content="MySQL字段类型 MySQL 字段类型可以简单分为三大类： 数值类型：整型（tinyint、smallint、mediumint、int 和 bigint）">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2023-07-24T05:00:00+00:00">
    <meta property="article:modified_time" content="2023-07-24T05:00:00+00:00">
    <meta property="article:tag" content="Interview">
      <meta property="og:image" content="https://009965.xyz/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/not-using-covering-index-demo.png">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://009965.xyz/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/not-using-covering-index-demo.png">
<meta name="twitter:title" content="14_MySQL面试题">
<meta name="twitter:description" content="MySQL字段类型 MySQL 字段类型可以简单分为三大类： 数值类型：整型（tinyint、smallint、mediumint、int 和 bigint）">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://009965.xyz/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "14_MySQL面试题",
      "item": "https://009965.xyz/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "14_MySQL面试题",
  "name": "14_MySQL面试题",
  "description": "MySQL字段类型 MySQL 字段类型可以简单分为三大类： 数值类型：整型（tinyint、smallint、mediumint、int 和 bigint）",
  "keywords": [
    "interview"
  ],
  "articleBody": "MySQL字段类型 MySQL 字段类型可以简单分为三大类：\n数值类型：整型（tinyint、smallint、mediumint、int 和 bigint）、浮点型（float 和 double）、定点型（decimal） 字符串类型：char、varchar、tinytext、text、mediumtext、longtext、tinyblob、blob、mediumblob 和 longblob 等，最常用的是 char 和 varchar 。 日期时间类型：year、time、date、datetime 和 timestamp 等。 char 和 varchar 的区别是什么？ char 和 varchar 是最常用到的字符串类型，两者的主要区别在于：char 是定长字符串，varchar 是变长字符串。\nchar 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；varchar 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。\nchar 更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。varchar 类型适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。\nchar(M) 和 varchar(M) 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。\nvarchar(100)和 varchar(10)的区别是什么？ varchar(100)和 varchar(10)都是变长类型，表示能存储最多 100 个字符和 10 个字符。因此，varchar (100) 可以满足更大范围的字符存储需求，有更好的业务拓展性。而 varchar(10)存储超过 10 个字符时，就需要修改表结构才可以。\n虽说 varchar(100)和 varchar(10)能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，这也是很多人容易误解的一点。\n不过，varchar(100)会消耗更多的内存。这是因为 varchar 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，varcahr(100)是按照 100 这个长度来进行的，也就会消耗更多内存。\ndecimal 和 float/double 的区别是什么？ decimal 和 float 的区别是：decimal 是定点数，float/double 是浮点数。decimal 可以存储精确的小数值，float/double 只能存储近似的小数值。\ndecimal 用于存储有精度要求的小数比如与金钱相关的数据，可以避免浮点数带来的精度损失。\n在 Java 中，MySQL 的 decimal 类型对应的是 Java 类 java.math.BigDecimal 。\n为什么不推荐使用 text 和 blob？ text 类型类似于 char（0 - 255 字节）、varchar（0 - 65 535 字节），不过其可以存储更长的字符串，也就是长文本数据，比如一篇博客的内容。\n类型 可存储大小 用途 TINYTEXT 0 - 255 字节 一般文本字符串 TEXT 0 - 65 535 字节 长文本字符串 MEDIUMTEXT 0 - 16 772 150 字节 较大文本数据 LONGTEXT 0 - 4 294 967 295 字节 极大文本数据 blob 类型主要用于存储二进制大对象，例如图片，音视频等文件。\n类型 可存储大小 用途 TINYBLOB 0 - 255 字节 短文本二进制字符串 BLOB 0 - 65KB 二进制字符串 MEDIUMBLOB 0 - 16MB 二进制形式的长文本数据 LONGBLOB 0 - 4GB 二进制形式的极大文本数据 日常开发中，text 类型用的很少，但偶尔会用，blob 类型就属于是基本不用。如果预期长度范围 varchar 就满足，就避免使用 text。\n数据库规范中一般不推荐使用 blob 及 text 类型，二者的部分缺点和限制如下：\n不能有默认值。 在遇到使用临时表的情况时，无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》这本书有提到）。 检索效率比 char 和 varchar 低。 不能直接创建索引，需要指定前缀长度。 会消耗大量的网络和 IO 带宽。 可能会导致表上的 DML 操作都变得较慢。 …… datetime 和 timestamp 的区别是什么？ DateTime 类型没有时区信息，Timestamp 和时区有关。\nTimestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。\nDateTime：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59 Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59 关于两者的详细对比，请参考我写的MySQL 时间类型数据存储建议。\nNULL 和 ’’ 的区别是什么？ NULL 跟 ''(空字符串)是两个完全不一样的值，区别如下：\nNULL 代表一个不确定的值,就算是两个 NULL,它俩也不一定相等。例如，SELECT NULL=NULL的结果为 false，但是在我们使用DISTINCT,GROUP BY,ORDER BY时,NULL又被认为是相等的。 ''的长度是 0，是不占用空间的，而NULL 是需要占用空间的。 NULL 会影响聚合函数的结果。例如，SUM、AVG、MIN、MAX 等聚合函数会忽略 NULL 值。 COUNT 的处理方式取决于参数的类型。如果参数是 *(COUNT(*))，则会统计所有的记录数，包括 NULL 值；如果参数是某个字段名(COUNT(列名))，则会忽略 NULL 值，只统计非空值的个数。 查询 NULL 值时，必须使用 IS NULL 或 IS NOT NULLl 来判断，而不能使用 =、!=、 \u003c、\u003e 之类的比较运算符。而''是可以使用这些比较运算符的。 看了上面的介绍之后，相信你对另外一个高频面试题：“为什么MySQL不建议使用 NULL 作为列默认值？”也有了答案。\nMySQL 存储引擎 MySQL 支持哪些存储引擎？默认使用哪个？ MySQL 支持多种存储引擎，你可以通过 SHOW ENGINES 命令来查看 MySQL 支持的所有存储引擎。\nMySQL 当前默认的存储引擎是 InnoDB。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。我这里使用的 MySQL 版本是 8.x，不同的 MySQL 版本之间可能会有差别。MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。\n你可以通过 SELECT VERSION() 命令查看你的 MySQL 版本。\n1 2 3 4 5 6 7 mysql\u003e SELECT VERSION(); +-----------+ | VERSION() | +-----------+ | 8.0.27 | +-----------+ 1 row in set (0.00 sec) 你也可以通过 SHOW VARIABLES LIKE '%storage_engine%' 命令直接查看 MySQL 当前默认的存储引擎。\n1 2 3 4 5 6 7 8 9 10 mysql\u003e SHOW VARIABLES LIKE '%storage_engine%'; +---------------------------------+-----------+ | Variable_name | Value | +---------------------------------+-----------+ | default_storage_engine | InnoDB | | default_tmp_storage_engine | InnoDB | | disabled_storage_engines | | | internal_tmp_mem_storage_engine | TempTable | +---------------------------------+-----------+ 4 rows in set (0.00 sec) 如果你想要深入了解每个存储引擎以及它们之间的区别，推荐你去阅读以下 MySQL 官方文档对应的介绍(面试不会问这么细，了解即可)：\nInnoDB 存储引擎详细介绍：https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html 。 其他存储引擎详细介绍：https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html 。 MySQL 存储引擎架构了解吗？ MySQL 存储引擎采用的是 插件式架构 ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。存储引擎是基于表的，而不是数据库。\n并且，你还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。这些非官方提供的存储引擎可以称为第三方存储引擎，区别于官方存储引擎。像目前最常用的 InnoDB 其实刚开始就是一个第三方存储引擎，后面由于过于优秀，其被 Oracle 直接收购了。\nMySQL 官方文档也有介绍到如何编写一个自定义存储引擎，地址：https://dev.mysql.com/doc/internals/en/custom-engine.html 。\nMyISAM 和 InnoDB 有什么区别？ MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。\n虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。\nMySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。\n言归正传！咱们下面还是来简单对比一下两者：\n1.是否支持行级锁\nMyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。\n也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！\n2.是否支持事务\nMyISAM 不提供事务支持。\nInnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。\n关于 MySQL 事务的详细介绍，可以看看我写的这篇文章：MySQL 事务隔离级别详解。\n3.是否支持外键\nMyISAM 不支持，而 InnoDB 支持。\n外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！\n阿里的《Java 开发手册》也是明确规定禁止使用外键的。\n不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定。\n总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。\n4.是否支持数据库异常崩溃后的安全恢复\nMyISAM 不支持，而 InnoDB 支持。\n使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 redo log 。\n5.是否支持 MVCC\nMyISAM 不支持，而 InnoDB 支持。\n讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。\n6.索引实现不一样。\n虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。\nInnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。\n详细区别，推荐你看看我写的这篇文章：MySQL 索引详解。\n7.性能有差别。\nInnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。\n总结：\nInnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。 MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。 MyISAM 不支持外键，而 InnoDB 支持。 MyISAM 不支持 MVCC，而 InnoDB 支持。 虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。 MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。 InnoDB 的性能比 MyISAM 更强大。 MyISAM 和 InnoDB 如何选择？ 大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意啊！）。\n《MySQL 高性能》上面有一句话这样写到:\n不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。\n一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。\n因此，对于咱们日常开发的业务系统来说，你几乎找不到什么理由再使用 MyISAM 作为自己的 MySQL 数据库的存储引擎。\nMySQL 查询缓存 执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用\nmy.cnf 加入以下配置，重启 MySQL 开启查询缓存\n1 2 query_cache_type=1 query_cache_size=600000 MySQL 执行以下命令也可以开启查询缓存\n1 2 set global query_cache_type=1; set global query_cache_size=600000; 如上，开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。\n查询缓存不命中的情况：\n任何两个查询在任何字符上的不同都会导致缓存不命中。 如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。 缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。 缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。此外，还可以通过 sql_cache 和 sql_no_cache 来控制某个查询语句是否需要缓存：\n1 SELECT sql_no_cache COUNT(*) FROM usr; MySQL 事务 何谓事务？ 我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：\n数据库中途突然因为某些原因挂掉了。 客户端突然因为网络原因连接不上数据库了。 并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。 …… 上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。事务的概念起源于数据库，目前，已经成为一个比较广泛的概念。\n何为事务？ 一言蔽之，事务是逻辑上的一组操作，要么都执行，要么都不执行。\n事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。\n将小明的余额减少 1000 元 将小红的余额增加 1000 元。 事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。\n何谓数据库事务？ 大多数情况下，我们在谈论事务的时候，如果没有特指分布式事务，往往指的就是数据库事务。\n数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。\n那数据库事务有什么作用呢？\n简单来说，数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：要么全部执行成功,要么全部不执行 。\n1 2 3 4 5 6 # 开启一个事务 START TRANSACTION; # 多条 SQL 语句 SQL1,SQL2... ## 提交事务 COMMIT; 另外，关系型数据库（例如：MySQL、SQL Server、Oracle 等）事务都有 ACID 特性：\n原子性（Atomicity）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；\n一致性（Consistency）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；\n隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；\n持久性（Durability）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。\n这里要额外补充一点：只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！ 想必大家也和我一样，被 ACID 这个概念被误导了很久! 我也是看周志明老师的公开课《周志明的软件架构课》才搞清楚的。\n并发事务带来了哪些问题? 在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。\n脏读（Dirty read） 一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。\n例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19，事务1回滚导致对A的修改并未提交到数据库， A 的值还是 20。\n丢失修改（Lost to modify） 在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。\n例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。\n不可重复读（Unrepeatable read） 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。\n例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。\n幻读（Phantom read） 幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。\n例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。\n不可重复读和幻读有什么区别？ 不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改； 幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。 幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。\n举个例子：执行 delete 和 update 操作的时候，可以直接对记录加锁，保证事务安全。而执行 insert 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 insert 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。\n并发事务的控制方式有哪些？ MySQL 中并发事务的控制方式无非就两种：锁 和 MVCC。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。\n锁 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 读写锁 来实现并发控制。\n共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。 排他锁（X 锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。 读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 表级锁(table-level locking) 和 行级锁(row-level locking) 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。\nMVCC 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。\nMVCC 在 MySQL 中实现所依赖的手段主要是: 隐藏字段、read view、undo log。\nundo log : undo log 用于记录某行数据的多个版本的数据。 read view 和 隐藏字段 : 用来判断当前版本数据的可见性。 关于 InnoDB 对 MVCC 的具体实现可以看这篇文章：InnoDB 存储引擎对 MVCC 的实现 。\nSQL 标准定义了哪些事务隔离级别? SQL 标准定义了四个隔离级别：\nREAD-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE(可串行化)：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 隔离级别 脏读 不可重复读 幻读 READ-UNCOMMITTED √ √ √ READ-COMMITTED × √ √ REPEATABLE-READ × × √ SERIALIZABLE × × × MySQL 的隔离级别是基于锁实现的吗？ MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。\nSERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。\nMySQL 的默认隔离级别是什么? MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过SELECT @@tx_isolation;命令来查看，MySQL 8.0 该命令改为SELECT @@transaction_isolation;\n1 2 3 4 5 6 mysql\u003e SELECT @@tx_isolation; +-----------------+ | @@tx_isolation | +-----------------+ | REPEATABLE-READ | +-----------------+ 关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章：MySQL 事务隔离级别详解\nMySQL锁 表级锁和行级锁了解吗？有什么区别？ MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。\n行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。\n表级锁和行级锁对比：\n表级锁： MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。 行级锁： MySQL 中锁定粒度最小的一种锁，是 针对索引字段加的锁 ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。 行级锁的使用有什么注意事项？ InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 UPDATE、DELETE 语句时，如果 WHERE条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！\n不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。\nInnoDB 有哪几类行锁？ InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：\n记录锁（Record Lock）：也被称为记录锁，属于单个行记录上的锁。 间隙锁（Gap Lock）：锁定一个范围，不包括记录本身。 临键锁（Next-Key Lock）：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。 在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。\n一些大厂面试中可能会问到 Next-Key Lock 的加锁范围，这里推荐一篇文章：MySQL next-key lock 加锁范围是什么？ - 程序员小航 - 2021 。\n共享锁和排他锁呢？ 不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：\n共享锁（S 锁）：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。 排他锁（X 锁）：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。 排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。\nS 锁 X 锁 S 锁 不冲突 冲突 X 锁 冲突 冲突 由于 MVCC 的存在，对于一般的 SELECT 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。\n1 2 3 4 5 6 # 共享锁 可以在 MySQL 5.7 和 MySQL 8.0 中使用 SELECT ... LOCK IN SHARE MODE; # 共享锁 可以在 MySQL 8.0 中使用 SELECT ... FOR SHARE; # 排他锁 SELECT ... FOR UPDATE; 意向锁有什么作用？ 如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。\n意向锁是表级锁，共有两种：\n意向共享锁（Intention Shared Lock，IS 锁）：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。 意向排他锁（Intention Exclusive Lock，IX 锁）：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。 意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。\n意向锁之间是互相兼容的。\nIS 锁 IX 锁 IS 锁 兼容 兼容 IX 锁 兼容 兼容 意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。\nIS 锁 IX 锁 S 锁 兼容 互斥 X 锁 互斥 互斥 当前读和快照读有什么区别？ 快照读（一致性非锁定读）就是单纯的 SELECT 语句，但不包括下面这两类 SELECT 语句：\n1 2 3 4 5 SELECT ... FOR UPDATE # 共享锁 可以在 MySQL 5.7 和 MySQL 8.0 中使用 SELECT ... LOCK IN SHARE MODE; # 共享锁 可以在 MySQL 8.0 中使用 SELECT ... FOR SHARE; 快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。\n快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。\n只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：\n在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。 在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。 快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。\n当前读 （一致性锁定读）就是给行记录加 X 锁或 S 锁。\n当前读的一些常见 SQL 语句类型如下：\n1 2 3 4 5 6 7 8 9 10 # 对读的记录加一个X锁 SELECT...FOR UPDATE # 对读的记录加一个S锁 SELECT...LOCK IN SHARE MODE # 对读的记录加一个S锁 SELECT...FOR SHARE # 对修改的记录加一个X锁 INSERT... UPDATE... DELETE... 自增锁有了解吗？ 不太重要的一个知识点，简单了解即可。\n关系型数据库设计表的时候，通常会有一列作为自增主键。InnoDB 中的自增主键会涉及一种比较特殊的表级锁— 自增锁（AUTO-INC Locks） 。\n1 2 3 4 5 6 CREATE TABLE `sequence_id` ( `id` bigint(20) unsigned NOT NULL AUTO_INCREMENT, `stub` char(10) NOT NULL DEFAULT '', PRIMARY KEY (`id`), UNIQUE KEY `stub` (`stub`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; 更准确点来说，不仅仅是自增主键，AUTO_INCREMENT的列都会涉及到自增锁，毕竟非主键也可以设置自增长。\n如果一个事务正在插入数据到有自增列的表时，会先获取自增锁，拿不到就可能会被阻塞住。这里的阻塞行为只是自增锁行为的其中一种，可以理解为自增锁就是一个接口，其具体的实现有多种。具体的配置项为 innodb_autoinc_lock_mode （MySQL 5.1.22 引入），可以选择的值如下：\ninnodb_autoinc_lock_mode 介绍 0 传统模式 1 连续模式（MySQL 8.0 之前默认） 2 交错模式(MySQL 8.0 之后默认) 交错模式下，所有的“INSERT-LIKE”语句（所有的插入语句，包括：INSERT、REPLACE、INSERT…SELECT、REPLACE…SELECT、LOAD DATA等）都不使用表级锁，使用的是轻量级互斥锁实现，多条插入语句可以并发执行，速度更快，扩展性也更好。\n不过，如果你的 MySQL 数据库有主从同步需求并且 Binlog 存储格式为 Statement 的话，不要将 InnoDB 自增锁模式设置为交叉模式，不然会有数据不一致性问题。这是因为并发情况下插入语句的执行顺序就无法得到保障。\n如果 MySQL 采用的格式为 Statement ，那么 MySQL 的主从同步实际上同步的就是一条一条的 SQL 语句。\nMySQL 性能优化 能用 MySQL 直接存储文件（比如图片）吗？ 可以是可以，直接存储文件对应的二进制数据即可。不过，还是建议不要在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。\n可以选择使用云服务厂商提供的开箱即用的文件存储服务，成熟稳定，价格也比较低。\n也可以选择自建文件存储服务，实现起来也不难，基于 FastDFS、MinIO（推荐） 等开源项目就可以实现分布式文件服务。\n数据库只存储文件地址信息，文件由文件存储服务负责存储。\nMySQL 如何存储 IP 地址？ 可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。\nMySQL 提供了两个方法来处理 ip 地址\nINET_ATON()：把 ip 转为无符号整型 (4-8 位) INET_NTOA() :把整型的 ip 转为地址 插入数据前，先用 INET_ATON() 把 ip 地址转为整型，显示数据时，使用 INET_NTOA() 把整型的 ip 地址转为地址显示即可。\n如何分析 SQL 的性能？ 我们可以使用 EXPLAIN 命令来分析 SQL 的 执行计划 。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。\nEXPLAIN 并不会真的去执行相关的语句，而是通过 查询优化器 对语句进行分析，找出最优的查询方案，并显示对应的信息。\nEXPLAIN 适用于 SELECT, DELETE, INSERT, REPLACE, 和 UPDATE语句，我们一般分析 SELECT 查询较多。\n我们这里简单来演示一下 EXPLAIN 的使用。\nEXPLAIN 的输出格式如下：\n1 2 3 4 5 6 7 mysql\u003e EXPLAIN SELECT `score`,`name` FROM `cus_order` ORDER BY `score` DESC; +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+ | 1 | SIMPLE | cus_order | NULL | ALL | NULL | NULL | NULL | NULL | 997572 | 100.00 | Using filesort | +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+ 1 row in set, 1 warning (0.00 sec) 各个字段的含义如下：\n列名 含义 id SELECT 查询的序列标识符 select_type SELECT 关键字对应的查询类型 table 用到的表名 partitions 匹配的分区，对于未分区的表，值为 NULL type 表的访问方法 possible_keys 可能用到的索引 key 实际用到的索引 key_len 所选索引的长度 ref 当使用索引等值查询时，与索引作比较的列或常量 rows 预计要读取的行数 filtered 按表条件过滤后，留存的记录数的百分比 Extra 附加信息 数据库命名规范 所有数据库对象名称必须使用小写字母并用下划线分割 所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来） 数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符 临时库表必须以 tmp_ 为前缀并以日期为后缀，备份表必须以 bak_ 为前缀并以日期 (时间戳) 为后缀 所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低） 数据库基本设计规范 所有表必须使用 InnoDB 存储引擎 没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）。\nInnoDB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。\n数据库和表的字符集统一使用 UTF8 兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。\n参考文章：\nMySQL 字符集不一致导致索引失效的一个真实案例 MySQL 字符集详解 所有表和字段都需要添加注释 使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护\n尽量控制单表数据量的大小，建议控制在 500 万以内 500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。\n可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小\n谨慎使用 MySQL 分区表 分区表在物理上表现为多个文件，在逻辑上表现为一个表；\n谨慎选择分区键，跨分区查询效率可能更低；\n建议采用物理分表的方式管理大数据。\n经常一起使用的列放到一个表中 避免更多的关联操作。\n禁止在表中建立预留字段 预留字段的命名很难做到见名识义。 预留字段无法确认存储的数据类型，所以无法选择合适的类型。 对预留字段类型的修改，会对表进行锁定。 禁止在数据库中存储文件（比如图片）这类大的二进制数据 在数据库中存储文件会严重影响数据库性能，消耗过多存储空间。\n文件（比如图片）这类大的二进制数据通常存储于文件服务器，数据库只存储文件地址信息。\n不要被数据库范式所束缚 一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度。\n禁止在线上做数据库压力测试 禁止从开发环境,测试环境直接连接生产环境数据库 安全隐患极大，要对生产环境抱有敬畏之心！\n数据库字段设计规范 优先选择符合存储需要的最小的数据类型 存储字节越小，占用也就空间越小，性能也越好。\na.某些字符串可以转换成数字类型存储比如可以将 IP 地址转换成整型数据。\n数字是连续的，性能更好，占用空间也更小。\nMySQL 提供了两个方法来处理 ip 地址\nINET_ATON()：把 ip 转为无符号整型 (4-8 位) INET_NTOA() :把整型的 ip 转为地址 插入数据前，先用 INET_ATON() 把 ip 地址转为整型，显示数据时，使用 INET_NTOA() 把整型的 ip 地址转为地址显示即可。\nb.对于非负型的数据 (如自增 ID,整型 IP，年龄) 来说,要优先使用无符号整型来存储。\n无符号相对于有符号可以多出一倍的存储空间\n1 2 SIGNED INT -2147483648~2147483647 UNSIGNED INT 0~4294967295 c.小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型。\n避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据 a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。\nMySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。\n如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 select *而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。\n2、TEXT 或 BLOB 类型只能使用前缀索引\n因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的\n避免使用 ENUM 类型 修改 ENUM 值需要使用 ALTER 语句； ENUM 类型的 ORDER BY 操作效率低，需要额外操作； ENUM 数据类型存在一些限制比如建议不要使用数值作为 ENUM 的枚举值。 相关阅读：是否推荐使用 MySQL 的 enum 类型？ - 架构文摘 - 知乎 。\n尽可能把所有列定义为 NOT NULL 除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。\n索引 NULL 列需要额外的空间来保存，所以要占用更多的空间； 进行比较和计算时要对 NULL 值做特别的处理。 相关阅读：技术分享 | MySQL 默认值选型（是空，还是 NULL） 。\n使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间 TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07\nTIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高\n超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储\n经常会有人用字符串存储日期型的数据（不正确的做法）\n缺点 1：无法用日期函数进行计算和比较 缺点 2：用字符串存储日期要占用更多的空间 同财务相关的金额类数据必须使用 decimal 类型 非精准浮点：float,double 精准浮点：decimal decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，decimal 可用于存储比 bigint 更大的整型数据\n不过， 由于 decimal 需要额外的空间和计算开销，应该尽量只在需要对数据进行精确计算时才使用 decimal 。\n单表不要包含过多字段 如果一个表包含过多字段的话，可以考虑将其分解成多个表，必要时增加中间表进行关联。\n索引设计规范 限制每张表上的索引数量,建议单张表索引不超过 5 个 索引并不是越多越好！索引可以提高效率同样可以降低效率。\n索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。\n因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。\n禁止使用全文索引 全文索引不适用于 OLTP 场景。\n禁止给表中的每一列都建立单独的索引 5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。\n每个 InnoDB 表必须有个主键 InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。\nInnoDB 是按照主键索引的顺序来组织表的\n不要使用更新频繁的列作为主键，不使用多列主键（相当于联合索引） 不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长） 主键建议使用自增 ID 值 常见索引列建议 出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列 包含在 ORDER BY、GROUP BY、DISTINCT 中的字段 并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好 多表 join 的关联列 如何选择索引列的顺序 建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。\n区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数） 尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好） 使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引） 避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间） 重复索引示例：primary key(id)、index(id)、unique index(id) 冗余索引示例：index(a,b,c)、index(a,b)、index(a) 对于频繁的查询优先考虑使用覆盖索引 覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引\n覆盖索引的好处：\n避免 InnoDB 表进行索引的二次查询: InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。 可以把随机 IO 变成顺序 IO 加快查询效率: 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。 索引 SET 规范 尽量避免使用外键约束\n不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引 外键可用于保证数据的参照完整性，但建议在业务端实现 外键会影响父表和子表的写操作从而降低性能 数据库 SQL 开发规范 优化对性能影响较大的 SQL 语句 要找到最需要优化的 SQL 语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询 MySQL 的慢查询日志来发现需要进行优化的 SQL 语句；\n充分利用表上已经存在的索引 避免使用双%号的查询条件。如：a like '%123%'，（如果无前置%,只有后置%，是可以用到列上的索引的）\n一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。\n在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。\n禁止使用 SELECT * 必须使用 SELECT \u003c字段列表\u003e 查询 SELECT * 消耗更多的 CPU 和 IO 以网络带宽资源 SELECT * 无法使用覆盖索引 SELECT \u003c字段列表\u003e 可减少表结构变更带来的影响 禁止使用不含字段列表的 INSERT 语句 如：\n1 insert into t values ('a','b','c'); 应使用：\n1 insert into t(c1,c2,c3) values ('a','b','c'); 建议使用预编译语句进行数据库操作 预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。 只传参数，比传递 SQL 语句更高效。 相同语句可以一次解析，多次使用，提高处理效率。 避免数据类型的隐式转换 隐式转换会导致索引失效如:\n1 select name,phone from customer where id = '111'; 详细解读可以看：MySQL 中的隐式转换造成的索引失效 这篇文章。\n避免使用子查询，可以把子查询优化为 join 操作 通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。\n子查询性能差的原因： 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。\n避免使用 JOIN 关联太多的表 对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。\n在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。\n如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。\n同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。\n减少同数据库的交互次数 数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。\n对应同一列进行 or 判断时，使用 in 代替 or in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。\n禁止使用 order by rand() 进行随机排序 order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。\n推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。\nWHERE 从句中禁止对列进行函数转换和计算 对列进行函数转换或计算时会导致无法使用索引\n不推荐：\n1 where date(create_time)='20190101' 推荐：\n1 where create_time \u003e= '20190101' and create_time \u003c '20190102' 在明显不会有重复值时使用 UNION ALL 而不是 UNION UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作 UNION ALL 不会再对结果集进行去重操作 拆分复杂的大 SQL 为多个小 SQL 大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL MySQL 中，一个 SQL 只能使用一个 CPU 进行计算 SQL 拆分后可以通过并行执行来提高处理效率 程序连接不同的数据库使用不同的账号，禁止跨库查询 为数据库迁移和分库分表留出余地 降低业务耦合度 避免权限过大而产生的安全风险 数据库操作行为规范 超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作 大批量操作可能会造成严重的主从延迟\n主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况\nbinlog 日志为 row 格式时会产生大量的日志\n大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因\n避免产生大事务操作\n大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。\n特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批\n对于大表使用 pt-online-schema-change 修改表结构 避免大表修改产生的主从延迟 避免在对表字段进行修改时进行锁表 对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。\npt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。\n禁止为程序使用的账号赋予 super 权限 当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接 super 权限只能留给 DBA 处理问题的账号使用 对于程序连接数据库账号,遵循权限最小原则 程序使用数据库账号只能在一个 DB 下使用，不准跨库 程序使用的账号原则上不准有 drop 权限 MySQL索引详解 索引介绍 索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。\n索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。\n索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。\n索引的优缺点 优点：\n使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。 缺点：\n创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。 索引需要使用物理文件存储，也会耗费一定空间。 但是，使用索引一定能提高查询性能吗?\n大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。\n索引的数据结构 Hash 表 哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。\n为何能够通过 key 快速取出 value 呢？ 原因在于 哈希算法（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。\n1 2 hash = hashfunc(key) index = hash % array_size 但是！哈希算法有个 Hash 冲突 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 链地址法。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 HashMap 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后HashMap为了减少链表过长的时候搜索时间过长引入了红黑树。\n为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。\n既然哈希表这么快，为什么 MySQL 没有使用其作为索引的数据结构呢？ 主要是因为 Hash 索引不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。\n试想一种情况:\n1 SELECT * FROM tb1 WHERE id \u003c 500; 在这种范围查询中，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。\n二叉查找树(BST) 二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构，它具有以下特点：\n左子树所有节点的值均小于根节点的值。 右子树所有节点的值均大于根节点的值。 左右子树也分别为二叉查找树。 当二叉查找树是平衡的时候，也就是树的每个节点的左右子树深度相差不超过 1 的时候，查询的时间复杂度为 O(log2(N))，具有比较高的效率。然而，当二叉查找树不平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为斜树），导致查询效率急剧下降，时间复杂退化为 O（N）。\n也就是说，二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。\n为了解决这个问题，并提高查询效率，人们发明了多种在二叉查找树基础上的改进型数据结构，如平衡二叉树、B-Tree、B+Tree 等。\nAVL 树 AVL 树是计算机科学中最早被发明的自平衡二叉查找树，它的名称来自于发明者 G.M. Adelson-Velsky 和 E.M. Landis 的名字缩写。AVL 树的特点是保证任何节点的左右子树高度之差不超过 1，因此也被称为高度平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。\nAVL 树采用了旋转操作来保持平衡。主要有四种旋转操作：LL 旋转、RR 旋转、LR 旋转和 RL 旋转。其中 LL 旋转和 RR 旋转分别用于处理左左和右右失衡，而 LR 旋转和 RL 旋转则用于处理左右和右左失衡。\n由于 AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了查询性能。并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。\n实际应用中，AVL 树使用的并不多。\n红黑树 红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态，它具有以下特点：\n每个节点非红即黑； 根节点总是黑色的； 每个叶子节点都是黑色的空节点（NIL 节点）； 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）； 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。 和 AVL 树不同的是，红黑树并不追求严格的平衡，而是大致的平衡。正因如此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。也正因如此，红黑树的插入和删除操作效率大大提高了，因为红黑树在插入和删除节点时只需进行 O(1) 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 O(logn) 次数的旋转操作。\n红黑树的应用还是比较广泛的，TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。\nB 树\u0026 B+树 B 树也称 B-树,全称为 多路平衡查找树 ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 Balanced （平衡）的意思。\n目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。\nB 树\u0026 B+树两者有何异同呢？\nB 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。 B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。 B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。 在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。 综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。\n在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）\nMyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引（非聚集索引）”。\nInnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“聚簇索引（聚集索引）”，而其余的索引都作为 辅助索引 ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂\n索引类型总结 按照数据结构维度划分：\nBTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。 哈希索引：类似键值对的形式，一次即可定位。 RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。 全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。 按照底层存储方式角度划分：\n聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。 非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。 按照应用维度划分：\n主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。 普通索引：仅加速查询。 唯一索引：加速查询 + 列值唯一（可以有 NULL）。 覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。 联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。 全文索引：对文本的内容进行分词，进行搜索。目前只有 CHAR、VARCHAR ，TEXT 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。 MySQL 8.x 中实现的索引新特性：\n隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。 降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。 函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。 主键索引(Primary Key) 数据表的主键列使用的就是主键索引。\n一张数据表有只能有一个主键，并且主键不能为 null，不能重复。\n在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。\n二级索引 二级索引（Secondary Index）又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。\n唯一索引，普通索引，前缀索引等索引属于二级索引。\nPS: 不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。\n唯一索引(Unique Key)：唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。 普通索引(Index)：普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。 前缀索引(Prefix)：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。 全文索引(Full Text)：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。 聚簇索引与非聚簇索引 聚簇索引（聚集索引） 聚簇索引介绍 聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。\n在 MySQL 中，InnoDB 引擎的表的 .ibd文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。\n聚簇索引的优缺点 优点：\n查询速度非常快：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。 对排序查找和范围查找优化：聚簇索引对于主键的排序查找和范围查找速度非常快。 缺点：\n依赖于有序的数据：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。 更新代价大：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。 非聚簇索引（非聚集索引） 非聚簇索引介绍 非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。\n非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。\n非聚簇索引的优缺点 优点：\n更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的\n缺点：\n依赖于有序的数据：跟聚簇索引一样，非聚簇索引也依赖于有序的数据 可能会二次查询(回表)：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。 这是 MySQL 的表的文件截图:\n聚簇索引和非聚簇索引:\n非聚簇索引一定回表查询吗(覆盖索引)? 非聚簇索引不一定回表查询。\n试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。\n1 SELECT name FROM table WHERE name='guang19'; 那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。\n即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！如果 SQL 查的就是主键呢?\n1 SELECT id FROM table WHERE id=1; 主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。\n覆盖索引和联合索引 覆盖索引 如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 覆盖索引（Covering Index） 。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。而覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！\n覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。\n如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。\n我们这里简单演示一下覆盖索引的效果。\n1、创建一个名为 cus_order 的表，来实际测试一下这种排序方式。为了测试方便， cus_order 这张表只有 id、score、name这 3 个字段。\n1 2 3 4 5 6 CREATE TABLE `cus_order` ( `id` int(11) unsigned NOT NULL AUTO_INCREMENT, `score` int(11) NOT NULL, `name` varchar(11) NOT NULL DEFAULT '', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=100000 DEFAULT CHARSET=utf8mb4; 2、定义一个简单的存储过程（PROCEDURE）来插入 100w 测试数据。\n1 2 3 4 5 6 7 8 9 10 11 DELIMITER ;; CREATE DEFINER=`root`@`%` PROCEDURE `BatchinsertDataToCusOder`(IN start_num INT,IN max_num INT) BEGIN DECLARE i INT default start_num; WHILE i \u003c max_num DO insert into `cus_order`(`id`, `score`, `name`) values (i,RAND() * 1000000,CONCAT('user', i)); SET i = i + 1; END WHILE; END;; DELIMITER ; 存储过程定义完成之后，我们执行存储过程即可！\n1 CALL BatchinsertDataToCusOder(1, 1000000); # 插入100w+的随机数据 等待一会，100w 的测试数据就插入完成了！\n3、创建覆盖索引并使用 EXPLAIN 命令分析。\n为了能够对这 100w 数据按照 score 进行排序，我们需要执行下面的 SQL 语句。\n1 SELECT `score`,`name` FROM `cus_order` ORDER BY `score` DESC;#降序排序 使用 EXPLAIN 命令分析这条 SQL 语句，通过 Extra 这一列的 Using filesort ，我们发现是没有用到覆盖索引的。\n不过这也是理所应当，毕竟我们现在还没有创建索引呢！\n我们这里以 score 和 name 两个字段建立联合索引：\n1 ALTER TABLE `cus_order` ADD INDEX id_score_name(score, name); 创建完成之后，再用 EXPLAIN 命令分析再次分析这条 SQL 语句。\n通过 Extra 这一列的 Using index ，说明这条 SQL 语句成功使用了覆盖索引。\n关于 EXPLAIN 命令的详细介绍请看：MySQL 执行计划分析这篇文章。\n联合索引 使用表中的多个字段创建索引，就是 联合索引，也叫 组合索引 或 复合索引。\n以 score 和 name 两个字段建立联合索引：\n1 ALTER TABLE `cus_order` ADD INDEX id_score_name(score, name); 最左前缀匹配原则 最左前缀匹配原则指的是，在使用联合索引时，MySQL 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 \u003e、\u003c）才会停止匹配。对于 \u003e=、\u003c=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。\n相关阅读：联合索引的最左匹配原则全网都在说的一个错误结论。\n索引下推 索引下推（Index Condition Pushdown） 是 MySQL 5.6 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。\n正确使用索引的一些建议 选择合适的字段创建索引 不为 NULL 的字段：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。 被频繁查询的字段：我们创建索引的字段应该是查询操作非常频繁的字段。 被作为条件查询的字段：被作为 WHERE 条件查询的字段，应该被考虑建立索引。 频繁需要排序的字段：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。 被经常频繁用于连接的字段：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。 被频繁更新的字段应该慎重建立索引 虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。\n限制每张表上的索引数量 索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。\n索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。\n因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。\n尽可能的考虑建立联合索引而不是单列索引 因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。\n注意避免冗余索引 冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。\n字符串类型的字段使用前缀索引代替普通索引 前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。\n避免索引失效 索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：\n使用 SELECT * 进行查询; SELECT * 不会直接导致索引失效（如果不走索引大概率是因为 where 查询范围过大导致的），但它可能会带来一些其他的性能问题比如造成网络传输和数据处理的浪费、无法使用索引覆盖; 创建了组合索引，但查询条件未遵守最左匹配原则; 在索引列上进行计算、函数、类型转换等操作; 以 % 开头的 LIKE 查询比如 like '%abc'; 查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到; 发生隐式转换; …… 删除长期未使用的索引 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。\nMySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用。\n知道如何分析语句是否走索引查询 我们可以使用 EXPLAIN 命令来分析 SQL 的 执行计划 ，这样就知道语句是否命中索引了。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。\nEXPLAIN 并不会真的去执行相关的语句，而是通过 查询优化器 对语句进行分析，找出最优的查询方案，并显示对应的信息。\nEXPLAIN 的输出格式如下：\n1 2 3 4 5 6 7 mysql\u003e EXPLAIN SELECT `score`,`name` FROM `cus_order` ORDER BY `score` DESC; +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+ | 1 | SIMPLE | cus_order | NULL | ALL | NULL | NULL | NULL | NULL | 997572 | 100.00 | Using filesort | +----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+ 1 row in set, 1 warning (0.00 sec) 各个字段的含义如下：\n列名 含义 id SELECT 查询的序列标识符 select_type SELECT 关键字对应的查询类型 table 用到的表名 partitions 匹配的分区，对于未分区的表，值为 NULL type 表的访问方法 possible_keys 可能用到的索引 key 实际用到的索引 key_len 所选索引的长度 ref 当使用索引等值查询时，与索引作比较的列或常量 rows 预计要读取的行数 filtered 按表条件过滤后，留存的记录数的百分比 Extra 附加信息 篇幅问题，我这里只是简单介绍了一下 MySQL 执行计划，详细介绍请看：MySQL 执行计划分析这篇文章。\nMySQL事务隔离级别详解 事务隔离级别总结 SQL 标准定义了四个隔离级别：\nREAD-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。 READ-COMMITTED(读取已提交)：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。 REPEATABLE-READ(可重复读)：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。 SERIALIZABLE(可串行化)：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。 隔离级别 脏读 不可重复读 幻读 READ-UNCOMMITTED √ √ √ READ-COMMITTED × √ √ REPEATABLE-READ × × √ SERIALIZABLE × × × MySQL InnoDB 存储引擎的默认支持的隔离级别是 REPEATABLE-READ（可重读）。我们可以通过SELECT @@tx_isolation;命令来查看，MySQL 8.0 该命令改为SELECT @@transaction_isolation;\n1 2 3 4 5 6 MySQL\u003e SELECT @@tx_isolation; +-----------------+ | @@tx_isolation | +-----------------+ | REPEATABLE-READ | +-----------------+ 从上面对 SQL 标准定义了四个隔离级别的介绍可以看出，标准的 SQL 隔离级别定义里，REPEATABLE-READ(可重复读)是不可以防止幻读的。\n但是！InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：\n快照读：由 MVCC 机制来保证不出现幻读。 当前读：使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。 因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 READ-COMMITTED ，但是你要知道的是 InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失。\nInnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE 隔离级别。\n《MySQL 技术内幕：InnoDB 存储引擎(第 2 版)》7.7 章这样写到：\nInnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。\n实际情况演示 在下面我会使用 2 个命令行 MySQL ，模拟多线程（多事务）对同一份数据的脏读问题。\nMySQL 命令行的默认配置中事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。如果要显式地开启一个事务需要使用命令：START TRANSACTION。\n我们可以通过下面的命令来设置隔离级别。\n1 SET [SESSION|GLOBAL] TRANSACTION ISOLATION LEVEL [READ UNCOMMITTED|READ COMMITTED|REPEATABLE READ|SERIALIZABLE] 我们再来看一下我们在下面实际操作中使用到的一些并发控制语句:\nSTART TRANSACTION |BEGIN：显式地开启一个事务。 COMMIT：提交事务，使得对数据库做的所有修改成为永久性。 ROLLBACK：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。 脏读(读未提交) 避免脏读(读已提交) 不可重复读 还是刚才上面的读已提交的图，虽然避免了读未提交，但是却出现了，一个事务还没有结束，就发生了 不可重复读问题。\n可重复读 幻读 演示幻读出现的情况 SQL 脚本 1 在第一次查询工资为 500 的记录时只有一条，SQL 脚本 2 插入了一条工资为 500 的记录，提交之后；SQL 脚本 1 在同一个事务中再次使用当前读查询发现出现了两条工资为 500 的记录这种就是幻读。\n解决幻读的方法 解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。解决幻读的方式主要有以下几种：\n将事务隔离级别调整为 SERIALIZABLE 。 在可重复读的事务级别下，给事务操作的这张表添加表锁。 在可重复读的事务级别下，给事务操作的这张表添加 Next-key Lock（Record Lock+Gap Lock）。 SQL语句在MySQL中的执行过程 MySQL 基础架构分析 MySQL 基本架构概览 下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。\n先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。\n连接器： 身份认证和权限相关(登录 MySQL 的时候)。 查询缓存： 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。 分析器： 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。 优化器： 按照 MySQL 认为最优的方案去执行。 执行器： 执行语句，然后从存储引擎返回数据。 简单来说 MySQL 主要分为 Server 层和存储引擎层：\nServer 层：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块。 存储引擎：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。 Server 层基本组件介绍 连接器 连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。\n主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。\n查询缓存(MySQL 8.0 版本后移除) 查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。\n连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询语句，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。\nMySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。\n所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。\nMySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。\n分析器 MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：\n第一步，词法分析，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。\n第二步，语法分析，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。\n完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。\n优化器 优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。\n可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。\n执行器 当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。\n语句分析 查询语句 说了以上这么多，那么究竟一条 SQL 语句是如何执行的呢？其实我们的 SQL 可以分为两种，一种是查询，一种是更新（增加，修改，删除）。我们先分析下查询语句，语句如下：\n1 select * from tb_student A where A.age='18' and A.name=' 张三 '; 结合上面的说明，我们分析下这个语句的执行流程：\n先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。\n通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id=‘1’。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。\n接下来就是优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：\n1 2 a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。 b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。 那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。\n进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。 更新语句 以上就是一条查询 SQL 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？SQL 语句如下：\n1 update tb_student A set A.age='19' where A.name=' 张三 '; 我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 binlog（归档日志） ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 redo log（重做日志），我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：\n先查询到张三这一条数据，如果有缓存，也是会用到缓存。 然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。 执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。 更新完成。 这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?\n这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。\n并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？\n先写 redo log 直接提交，然后写 binlog，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。 先写 binlog，然后写 redo log，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。 如果采用 redo log 两阶段提交的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：\n判断 redo log 是否完整，如果判断是完整的，就立即提交。 如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。 这样就解决了数据一致性的问题。\n总结 MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。 引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。 查询语句的执行流程如下：权限校验（如果命中缓存）—\u003e查询缓存—\u003e分析器—\u003e优化器—\u003e权限校验—\u003e执行器—\u003e引擎 更新语句执行流程如下：分析器—-\u003e权限校验—-\u003e执行器—\u003e引擎—redo log(prepare 状态)—\u003ebinlog—\u003eredo log(commit 状态) MySQL执行计划分析 什么是执行计划？ 执行计划 是指一条 SQL 语句在经过 MySQL 查询优化器 的优化会后，具体的执行方式。\n执行计划通常用于 SQL 性能分析、优化等场景。通过 EXPLAIN 的结果，可以了解到如数据表的查询顺序、数据查询操作的操作类型、哪些索引可以被命中、哪些索引实际会命中、每个数据表有多少行记录被查询等信息。\n如何获取执行计划？ MySQL 为我们提供了 EXPLAIN 命令，来获取执行计划的相关信息。\n需要注意的是，EXPLAIN 语句并不会真的去执行相关的语句，而是通过查询优化器对语句进行分析，找出最优的查询方案，并显示对应的信息。\nEXPLAIN 执行计划支持 SELECT、DELETE、INSERT、REPLACE 以及 UPDATE 语句。我们一般多用于分析 SELECT 查询语句，使用起来非常简单，语法如下：\n1 EXPLAIN + SELECT 查询语句； 我们简单来看下一条查询语句的执行计划：\n1 2 3 4 5 6 7 mysql\u003e explain SELECT * FROM dept_emp WHERE emp_no IN (SELECT emp_no FROM dept_emp GROUP BY emp_no HAVING COUNT(emp_no)\u003e1); +----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+ | id | select_type | table | partitions | type | possible_keys | key | key_len | ref | rows | filtered | Extra | +----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+ | 1 | PRIMARY | dept_emp | NULL | ALL | NULL | NULL | NULL | NULL | 331143 | 100.00 | Using where | | 2 | SUBQUERY | dept_emp | NULL | index | PRIMARY,dept_no | PRIMARY | 16 | NULL | 331143 | 100.00 | Using index | +----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+ 可以看到，执行计划结果中共有 12 列，各列代表的含义总结如下表：\n列名 含义 id SELECT 查询的序列标识符 select_type SELECT 关键字对应的查询类型 table 用到的表名 partitions 匹配的分区，对于未分区的表，值为 NULL type 表的访问方法 possible_keys 可能用到的索引 key 实际用到的索引 key_len 所选索引的长度 ref 当使用索引等值查询时，与索引作比较的列或常量 rows 预计要读取的行数 filtered 按表条件过滤后，留存的记录数的百分比 Extra 附加信息 如何分析 EXPLAIN 结果？ 为了分析 EXPLAIN 语句的执行结果，我们需要搞懂执行计划中的重要字段。\nid SELECT 标识符，是查询中 SELECT 的序号，用来标识整个查询中 SELELCT 语句的顺序。\nid 如果相同，从上往下依次执行。id 不同，id 值越大，执行优先级越高，如果行引用其他行的并集结果，则该值可以为 NULL。\nselect_type 查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询，常见的值有：\nSIMPLE：简单查询，不包含 UNION 或者子查询。 PRIMARY：查询中如果包含子查询或其他部分，外层的 SELECT 将被标记为 PRIMARY。 SUBQUERY：子查询中的第一个 SELECT。 UNION：在 UNION 语句中，UNION 之后出现的 SELECT。 DERIVED：在 FROM 中出现的子查询将被标记为 DERIVED。 UNION RESULT：UNION 查询的结果。 table 查询用到的表名，每行都有对应的表名，表名除了正常的表之外，也可能是以下列出的值：\n: 本行引用了 id 为 M 和 N 的行的 UNION 结果； : 本行引用了 id 为 N 的表所产生的的派生表结果。派生表有可能产生自 FROM 语句中的子查询。 - : 本行引用了 id 为 N 的表所产生的的物化子查询结果。 type（重要） 查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：system \u003e const \u003e eq_ref \u003e ref \u003e fulltext \u003e ref_or_null \u003e index_merge \u003e unique_subquery \u003e index_subquery \u003e range \u003e index \u003e ALL\n常见的几种类型具体含义如下：\nsystem：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。 const：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。 eq_ref：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。 ref：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。 index_merge：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。 range：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。 index：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。 ALL：全表扫描。 possible_keys possible_keys 列表示 MySQL 执行查询时可能用到的索引。如果这一列为 NULL ，则表示没有可能用到的索引；这种情况下，需要检查 WHERE 语句中所使用的的列，看是否可以通过给这些列中某个或多个添加索引的方法来提高查询性能。\nkey（重要） key 列表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引。\nkey_len key_len 列表示 MySQL 实际使用的索引的最大长度；当使用到联合索引时，有可能是多个列的长度和。在满足需求的前提下越短越好。如果 key 列显示 NULL ，则 key_len 列也显示 NULL 。\nrows rows 列表示根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。\nExtra（重要） 这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：\nUsing filesort：在排序时使用了外部的索引排序，没有用到表内索引进行排序。 Using temporary：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。 Using index：表明查询使用了覆盖索引，不用回表，查询效率非常高。 Using index condition：表示查询优化器选择使用了索引条件下推这个特性。 Using where：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。 Using join buffer (Block Nested Loop)：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。 这里提醒下，当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。\nMySQL时间类型数据存储建议 不要用字符串存储日期 和绝大部分对数据库不太了解的新手一样，我在大学的时候就这样干过，甚至认为这样是一个不错的表示日期的方法。毕竟简单直白，容易上手。\n但是，这是不正确的做法，主要会有下面两个问题：\n字符串占用的空间更大！ 字符串存储的日期效率比较低（逐个字符进行比对），无法用日期相关的 API 进行计算和比较。 Datetime 和 Timestamp 之间的抉择 Datetime 和 Timestamp 是 MySQL 提供的两种比较相似的保存时间的数据类型，可以精确到秒。他们两者究竟该如何选择呢？\n下面我们来简单对比一下二者。\n时区信息 DateTime 类型是没有时区信息的（时区无关） ，DateTime 类型保存的时间都是当前会话所设置的时区对应的时间。这样就会有什么问题呢？当你的时区更换之后，比如你的服务器更换地址或者更换客户端连接时区设置的话，就会导致你从数据库中读出的时间错误。\nTimestamp 和时区有关。Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。\n下面实际演示一下！\n建表 SQL 语句：\n1 2 3 4 5 6 CREATE TABLE `time_zone_test` ( `id` bigint(20) NOT NULL AUTO_INCREMENT, `date_time` datetime DEFAULT NULL, `time_stamp` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 插入数据：\n1 INSERT INTO time_zone_test(date_time,time_stamp) VALUES(NOW(),NOW()); 查看数据：\n1 select date_time,time_stamp from time_zone_test; 结果：\n1 2 3 4 5 +---------------------+---------------------+ | date_time | time_stamp | +---------------------+---------------------+ | 2020-01-11 09:53:32 | 2020-01-11 09:53:32 | +---------------------+---------------------+ 现在我们运行\n修改当前会话的时区:\n1 set time_zone='+8:00'; 再次查看数据：\n1 2 3 4 5 +---------------------+---------------------+ | date_time | time_stamp | +---------------------+---------------------+ | 2020-01-11 09:53:32 | 2020-01-11 17:53:32 | +---------------------+---------------------+ 扩展：一些关于 MySQL 时区设置的一个常用 sql 命令\n1 2 3 4 5 6 7 8 9 10 # 查看当前会话时区 SELECT @@session.time_zone; # 设置当前会话时区 SET time_zone = 'Europe/Helsinki'; SET time_zone = \"+00:00\"; # 数据库全局时区设置 SELECT @@global.time_zone; # 设置全局时区 SET GLOBAL time_zone = '+8:00'; SET GLOBAL time_zone = 'Europe/Helsinki'; 占用空间 下图是 MySQL 日期类型所占的存储空间（官方文档传送门：https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html）：\n在 MySQL 5.6.4 之前，DateTime 和 Timestamp 的存储空间是固定的，分别为 8 字节和 4 字节。但是从 MySQL 5.6.4 开始，它们的存储空间会根据毫秒精度的不同而变化，DateTime 的范围是 5~8 字节，Timestamp 的范围是 4~7 字节。\n表示范围 Timestamp 表示的时间范围更小，只能到 2038 年：\nDateTime：1000-01-01 00:00:00.000000 ~ 9999-12-31 23:59:59.499999 Timestamp：1970-01-01 00:00:01.000000 ~ 2038-01-19 03:14:07.499999 性能 由于 TIMESTAMP 需要根据时区进行转换，所以从毫秒数转换到 TIMESTAMP 时，不仅要调用一个简单的函数，还要调用操作系统底层的系统函数。这个系统函数为了保证操作系统时区的一致性，需要进行加锁操作，这就降低了效率。\nDATETIME 不涉及时区转换，所以不会有这个问题。\n为了避免 TIMESTAMP 的时区转换问题，建议使用指定的时区，而不是依赖于操作系统时区。\n数值时间戳是更好的选择吗？ 很多时候，我们也会使用 int 或者 bigint 类型的数值也就是数值时间戳来表示时间。\n这种存储方式的具有 Timestamp 类型的所具有一些优点，并且使用它的进行日期排序以及对比等操作的效率会更高，跨系统也很方便，毕竟只是存放的数值。缺点也很明显，就是数据的可读性太差了，你无法直观的看到具体时间。\n时间戳的定义如下：\n时间戳的定义是从一个基准时间开始算起，这个基准时间是「1970-1-1 00:00:00 +0:00」，从这个时间开始，用整数表示，以秒计时，随着时间的流逝这个时间整数不断增加。这样一来，我只需要一个数值，就可以完美地表示时间了，而且这个数值是一个绝对数值，即无论的身处地球的任何角落，这个表示时间的时间戳，都是一样的，生成的数值都是一样的，并且没有时区的概念，所以在系统的中时间的传输中，都不需要进行额外的转换了，只有在显示给用户的时候，才转换为字符串格式的本地时间。\n数据库中实际操作：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 mysql\u003e select UNIX_TIMESTAMP('2020-01-11 09:53:32'); +---------------------------------------+ | UNIX_TIMESTAMP('2020-01-11 09:53:32') | +---------------------------------------+ | 1578707612 | +---------------------------------------+ 1 row in set (0.00 sec) mysql\u003e select FROM_UNIXTIME(1578707612); +---------------------------+ | FROM_UNIXTIME(1578707612) | +---------------------------+ | 2020-01-11 09:53:32 | +---------------------------+ 1 row in set (0.01 sec) 总结 MySQL 中时间到底怎么存储才好？Datetime?Timestamp?还是数值时间戳？\n并没有一个银弹，很多程序员会觉得数值型时间戳是真的好，效率又高还各种兼容，但是很多人又觉得它表现的不够直观。\n《高性能 MySQL 》这本神书的作者就是推荐 Timestamp，原因是数值表示时间不够直观。下面是原文：\n除了特殊行为之外，通常也应该尽量使用TIMESTAMP,因为它比DATETIME空间效率更高。\n有时候人们会将Uix时间截存储为整数值，但这不会带来任何收益。用整数保存时间\n截的格式通常不方便处理，所以我们不推荐这样做。\n如果需要存储比秒更小粒度的日期和时间值怎么办？MySQL目前没有提供合适的数据\n类型，但是可以使用自己的存储格式：可以使用BIGINT类型存储微秒级别的时间截，或\n者使用DOUBLE存储秒之后的小数部分。这两种方式都可以，或者也可以使用MariaDB\n替代MySQL。\n每种方式都有各自的优势，根据实际场景选择最合适的才是王道。下面再对这三种方式做一个简单的对比，以供大家实际开发中选择正确的存放时间的数据类型：\n类型 存储空间 日期格式 日期范围 是否带时区信息 DATETIME 5~8字节 YYYY-MM-DD hh:mm:ss[.fraction] 1000-01-01 00:00:00[.000000] ～ 9999-12-31 23:59:59[.999999] 否 TIMESTAMP 4~7字节 YYYY-MM-DD hh:mm:ss[.fraction] 1970-01-01 00:00:01[.000000] ～ 2038-01-19 03:14:07[.999999] 是 数值型时间戳 4字节 全数字如1578707612 1970-01-01 00:00:01之后的时间 否 MySQL隐式转换造成索引失效 数据准备 首先使用存储过程生成 1000 万条测试数据， 测试表一共建立了 7 个字段（包括主键），num1和num2保存的是和ID一样的顺序数字，其中num2是字符串类型。 type1和type2保存的都是主键对 5 的取模，目的是模拟实际应用中常用类似 type 类型的数据，但是type2是没有建立索引的。 str1和str2都是保存了一个 20 位长度的随机字符串，str1不能为NULL，str2允许为NULL，相应的生成测试数据的时候我也会在str2字段生产少量NULL值（每 100 条数据产生一个NULL值）。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 -- 创建测试数据表 DROP TABLE IF EXISTS test1; CREATE TABLE `test1` ( `id` int(11) NOT NULL, `num1` int(11) NOT NULL DEFAULT '0', `num2` varchar(11) NOT NULL DEFAULT '', `type1` int(4) NOT NULL DEFAULT '0', `type2` int(4) NOT NULL DEFAULT '0', `str1` varchar(100) NOT NULL DEFAULT '', `str2` varchar(100) DEFAULT NULL, PRIMARY KEY (`id`), KEY `num1` (`num1`), KEY `num2` (`num2`), KEY `type1` (`type1`), KEY `str1` (`str1`), KEY `str2` (`str2`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; -- 创建存储过程 DROP PROCEDURE IF EXISTS pre_test1; DELIMITER // CREATE PROCEDURE `pre_test1`() BEGIN DECLARE i INT DEFAULT 0; SET autocommit = 0; WHILE i \u003c 10000000 DO SET i = i + 1; SET @str1 = SUBSTRING(MD5(RAND()),1,20); -- 每100条数据str2产生一个null值 IF i % 100 = 0 THEN SET @str2 = NULL; ELSE SET @str2 = @str1; END IF; INSERT INTO test1 (`id`, `num1`, `num2`, `type1`, `type2`, `str1`, `str2`) VALUES (CONCAT('', i), CONCAT('', i), CONCAT('', i), i%5, i%5, @str1, @str2); -- 事务优化，每一万条数据提交一次事务 IF i % 10000 = 0 THEN COMMIT; END IF; END WHILE; END; // DELIMITER ; -- 执行存储过程 CALL pre_test1(); 数据量比较大，还涉及使用MD5生成随机字符串，所以速度有点慢，稍安勿躁，耐心等待即可。\n1000 万条数据，我用了 33 分钟才跑完（实际时间跟你电脑硬件配置有关）。这里贴几条生成的数据，大致长这样。\nSQL 测试 先来看这组 SQL，一共四条，我们的测试数据表num1是int类型，num2是varchar类型，但是存储的数据都是跟主键id一样的顺序数字，两个字段都建立有索引。\n1 2 3 4 1: SELECT * FROM `test1` WHERE num1 = 10000; 2: SELECT * FROM `test1` WHERE num1 = '10000'; 3: SELECT * FROM `test1` WHERE num2 = 10000; 4: SELECT * FROM `test1` WHERE num2 = '10000'; 这四条 SQL 都是有针对性写的，12 查询的字段是 int 类型，34 查询的字段是varchar类型。12 或 34 查询的字段虽然都相同，但是一个条件是数字，一个条件是用引号引起来的字符串。这样做有什么区别呢？先不看下边的测试结果你能猜出这四条 SQL 的效率顺序吗？\n经测试这四条 SQL 最后的执行结果却相差很大，其中 124 三条 SQL 基本都是瞬间出结果，大概在 0.001~0.005 秒，在千万级的数据量下这样的结果可以判定这三条 SQL 性能基本没差别了。但是第三条 SQL，多次测试耗时基本在 4.5~4.8 秒之间。\n为什么 34 两条 SQL 效率相差那么大，但是同样做对比的 12 两条 SQL 却没什么差别呢？查看一下执行计划，下边分别 1234 条 SQL 的执行计划数据：\n可以看到，124 三条 SQL 都能使用到索引，连接类型都为ref，扫描行数都为 1，所以效率非常高。再看看第三条 SQL，没有用上索引，所以为全表扫描，rows直接到达 1000 万了，所以性能差别才那么大。\n仔细观察你会发现，34 两条 SQL 查询的字段num2是varchar类型的，查询条件等号右边加引号的第 4 条 SQL 是用到索引的，那么是查询的数据类型和字段数据类型不一致造成的吗？如果是这样那 12 两条 SQL 查询的字段num1是int类型，但是第 2 条 SQL 查询条件右边加了引号为什么还能用上索引呢。\n查阅 MySQL 相关文档发现是隐式转换造成的，看一下官方的描述：\n官方文档：12.2 Type Conversion in Expression Evaluation\n当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。某些转换是隐式发生的。例如，MySQL 会根据需要自动将字符串转换为数字，反之亦然。以下规则描述了比较操作的转换方式：\n两个参数至少有一个是NULL时，比较的结果也是NULL，特殊的情况是使用\u003c=\u003e对两个NULL做比较时会返回1，这两种情况都不需要做类型转换 两个参数都是字符串，会按照字符串来比较，不做类型转换 两个参数都是整数，按照整数来比较，不做类型转换 十六进制的值和非数字做比较时，会被当做二进制串 有一个参数是TIMESTAMP或DATETIME，并且另外一个参数是常量，常量会被转换为timestamp 有一个参数是decimal类型，如果另外一个参数是decimal或者整数，会将整数转换为decimal后进行比较，如果另外一个参数是浮点数，则会把decimal转换为浮点数进行比较 所有其他情况下，两个参数都会被转换为浮点数再进行比较 根据官方文档的描述，我们的第 23 两条 SQL 都发生了隐式转换，第 2 条 SQL 的查询条件num1 = '10000'，左边是int类型右边是字符串，第 3 条 SQL 相反，那么根据官方转换规则第 7 条，左右两边都会转换为浮点数再进行比较。\n先看第 2 条 SQL：SELECT * FROMtest1WHERE num1 = '10000'; 左边为 int 类型10000，转换为浮点数还是10000，右边字符串类型'10000'，转换为浮点数也是10000。两边的转换结果都是唯一确定的，所以不影响使用索引。\n第 3 条 SQL：SELECT * FROMtest1WHERE num2 = 10000; 左边是字符串类型'10000'，转浮点数为 10000 是唯一的，右边int类型10000转换结果也是唯一的。但是，因为左边是检索条件，'10000'转到10000虽然是唯一，但是其他字符串也可以转换为10000，比如'10000a'，'010000'，'10000'等等都能转为浮点数10000，这样的情况下，是不能用到索引的。\n关于这个隐式转换我们可以通过查询测试验证一下，先插入几条数据，其中num2='10000a'、'010000'和'10000'：\n1 2 3 INSERT INTO `test1` (`id`, `num1`, `num2`, `type1`, `type2`, `str1`, `str2`) VALUES ('10000001', '10000', '10000a', '0', '0', '2df3d9465ty2e4hd523', '2df3d9465ty2e4hd523'); INSERT INTO `test1` (`id`, `num1`, `num2`, `type1`, `type2`, `str1`, `str2`) VALUES ('10000002', '10000', '010000', '0', '0', '2df3d9465ty2e4hd523', '2df3d9465ty2e4hd523'); INSERT INTO `test1` (`id`, `num1`, `num2`, `type1`, `type2`, `str1`, `str2`) VALUES ('10000003', '10000', ' 10000', '0', '0', '2df3d9465ty2e4hd523', '2df3d9465ty2e4hd523'); 然后使用第三条 SQL 语句SELECT * FROMtest1WHERE num2 = 10000;进行查询：\n从结果可以看到，后面插入的三条数据也都匹配上了。那么这个字符串隐式转换的规则是什么呢？为什么num2='10000a'、'010000'和'10000'这三种情形都能匹配上呢？查阅相关资料发现规则如下：\n不以数字开头的字符串都将转换为0。如'abc'、'a123bc'、'abc123'都会转化为0； 以数字开头的字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。比如'123abc'会转换为123，'012abc'会转换为012也就是12，'5.3a66b78c'会转换为5.3，其他同理。 现对以上规则做如下测试验证：\n如此也就印证了之前的查询结果了。\n再次写一条 SQL 查询 str1 字段：SELECT * FROMtest1WHERE str1 = 1234;\n分析和总结 通过上面的测试我们发现 MySQL 使用操作符的一些特性：\n当操作符左右两边的数据类型不一致时，会发生隐式转换。 当 where 查询操作符左边为数值类型时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。 当 where 查询操作符左边为字符类型时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。 字符串转换为数值类型时，非数字开头的字符串会转化为0，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。 所以，我们在写 SQL 时一定要养成良好的习惯，查询的字段是什么类型，等号右边的条件就写成对应的类型。特别当查询的字段是字符串时，等号右边的条件一定要用引号引起来标明这是一个字符串，否则会造成索引失效触发全表扫描。\nMySQL自增主键一定是连续的吗 众所周知，自增主键可以让聚集索引尽量地保持递增顺序插入，避免了随机查询，从而提高了查询效率。\n但实际上，MySQL 的自增主键并不能保证一定是连续递增的。\n下面举个例子来看下，如下所示创建一张表：\n自增值保存在哪里？ 使用 insert into test_pk values(null, 1, 1) 插入一行数据，再执行 show create table 命令来看一下表的结构定义：\n上述表的结构定义存放在后缀名为 .frm 的本地文件中，在 MySQL 安装目录下的 data 文件夹下可以找到这个 .frm 文件：\n从上述表结构可以看到，表定义里面出现了一个 AUTO_INCREMENT=2，表示下一次插入数据时，如果需要自动生成自增值，会生成 id = 2。\n但需要注意的是，自增值并不会保存在这个表结构也就是 .frm 文件中，不同的引擎对于自增值的保存策略不同：\n1）MyISAM 引擎的自增值保存在数据文件中\n2）InnoDB 引擎的自增值，其实是保存在了内存里，并没有持久化。第一次打开表的时候，都会去找自增值的最大值 max(id)，然后将 max(id)+1 作为这个表当前的自增值。\n举个例子：我们现在表里当前数据行里最大的 id 是 1，AUTO_INCREMENT=2，对吧。这时候，我们删除 id=1 的行，AUTO_INCREMENT 还是 2。\n但如果马上重启 MySQL 实例，重启后这个表的 AUTO_INCREMENT 就会变成 1。﻿ 也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值。\n以上，是在我本地 MySQL 5.x 版本的实验，实际上，到了 MySQL 8.0 版本后，自增值的变更记录被放在了 redo log 中，提供了自增值持久化的能力 ，也就是实现了“如果发生重启，表的自增值可以根据 redo log 恢复为 MySQL 重启前的值”\n也就是说对于上面这个例子来说，重启实例后这个表的 AUTO_INCREMENT 仍然是 2。\n理解了 MySQL 自增值到底保存在哪里以后，我们再来看看自增值的修改机制，并以此引出第一种自增值不连续的场景。\n自增值不连续的场景 自增值不连续场景 1 在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：\n如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段； 如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。 根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设某次要插入的值是 insert_num，当前的自增值是 autoIncrement_num：\n如果 insert_num \u003c autoIncrement_num，那么这个表的自增值不变 如果 insert_num \u003e= autoIncrement_num，就需要把当前自增值修改为新的自增值 也就是说，如果插入的 id 是 100，当前的自增值是 90，insert_num \u003e= autoIncrement_num，那么自增值就会被修改为新的自增值即 101\n一定是这样吗？\n非也~\n了解过分布式 id 的小伙伴一定知道，为了避免两个库生成的主键发生冲突，我们可以让一个库的自增 id 都是奇数，另一个库的自增 id 都是偶数\n这个奇数偶数其实是通过 auto_increment_offset 和 auto_increment_increment 这两个参数来决定的，这俩分别用来表示自增的初始值和步长，默认值都是 1。\n所以，上面的例子中生成新的自增值的步骤实际是这样的：从 auto_increment_offset 开始，以 auto_increment_increment 为步长，持续叠加，直到找到第一个大于 100 的值，作为新的自增值。\n所以，这种情况下，自增值可能会是 102，103 等等之类的，就会导致不连续的主键 id。\n更遗憾的是，即使在自增初始值和步长这两个参数都设置为 1 的时候，自增主键 id 也不一定能保证主键是连续的\n自增值不连续场景 2 举个例子，我们现在往表里插入一条 (null,1,1) 的记录，生成的主键是 1，AUTO_INCREMENT= 2，对吧\n这时我再执行一条插入 (null,1,1) 的命令，很显然会报错 Duplicate entry，因为我们设置了一个唯一索引字段 a：\n但是，你会惊奇的发现，虽然插入失败了，但自增值仍然从 2 增加到了 3！\n这是为啥？\n我们来分析下这个 insert 语句的执行流程：\n执行器调用 InnoDB 引擎接口准备插入一行记录 (null,1,1); InnoDB 发现用户没有指定自增 id 的值，则获取表 test_pk 当前的自增值 2； 将传入的记录改成 (2,1,1); 将表的自增值改成 3； 继续执行插入数据操作，由于已经存在 a=1 的记录，所以报 Duplicate key error，语句返回 可以看到，自增值修改的这个操作，是在真正执行插入数据的操作之前。\n这个语句真正执行的时候，因为碰到唯一键 a 冲突，所以 id = 2 这一行并没有插入成功，但也没有将自增值再改回去。所以，在这之后，再插入新的数据行时，拿到的自增 id 就是 3。也就是说，出现了自增主键不连续的情况。\n至此，我们已经罗列了两种自增主键不连续的情况：\n自增初始值和自增步长设置不为 1 唯一键冲突 除此之外，事务回滚也会导致这种情况\n自增值不连续场景 3 我们现在表里有一行 (1,1,1) 的记录，AUTO_INCREMENT = 3：\n我们先插入一行数据 (null, 2, 2)，也就是 (3, 2, 2) 嘛，并且 AUTO_INCREMENT 变为 4：\n再去执行这样一段 SQL：\n虽然我们插入了一条 (null, 3, 3) 记录，但是使用 rollback 进行回滚了，所以数据库中是没有这条记录的：\n在这种事务回滚的情况下，自增值并没有同样发生回滚！如下图所示，自增值仍然固执地从 4 增加到了 5：\n所以这时候我们再去插入一条数据（null, 3, 3）的时候，主键 id 就会被自动赋为 5 了：\n那么，为什么在出现唯一键冲突或者回滚的时候，MySQL 没有把表的自增值改回去呢？回退回去的话不就不会发生自增 id 不连续了吗？\n事实上，这么做的主要原因是为了提高性能。\n我们直接用反证法来验证：假设 MySQL 在事务回滚的时候会把自增值改回去，会发生什么？\n现在有两个并行执行的事务 A 和 B，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请，对吧。\n假设事务 A 申请到了 id = 1， 事务 B 申请到 id=2，那么这时候表 t 的自增值是 3，之后继续执行。 事务 B 正确提交了，但事务 A 出现了唯一键冲突，也就是 id = 1 的那行记录插入失败了，那如果允许事务 A 把自增 id 回退，也就是把表的当前自增值改回 1，那么就会出现这样的情况：表里面已经有 id = 2 的行，而当前的自增 id 值是 1。 接下来，继续执行的其他事务就会申请到 id=2。这时，就会出现插入语句报错“主键冲突”。 而为了解决这个主键冲突，有两种方法：\n每次申请 id 之前，先判断表里面是否已经存在这个 id，如果存在，就跳过这个 id 把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id 很显然，上述两个方法的成本都比较高，会导致性能问题。而究其原因呢，是我们假设的这个 “允许自增 id 回退”。\n因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但不保证是连续的。\n综上，已经分析了三种自增值不连续的场景，还有第四种场景：批量插入数据。\n自增值不连续场景 4 对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：\n语句执行过程中，第一次申请自增 id，会分配 1 个； 1 个用完以后，这个语句第二次申请自增 id，会分配 2 个； 2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个； 依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。 注意，这里说的批量插入数据，不是在普通的 insert 语句里面包含多个 value 值！！！，因为这类语句在申请自增 id 的时候，是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。\n而对于 insert … select、replace … select 和 load data 这种类型的语句来说，MySQL 并不知道到底需要申请多少 id，所以就采用了这种批量申请的策略，毕竟一个一个申请的话实在太慢了。\n举个例子，假设我们现在这个表有下面这些数据：\n我们创建一个和当前表 test_pk 有相同结构定义的表 test_pk2：\n然后使用 insert...select 往 teset_pk2 表中批量插入数据：\n可以看到，成功导入了数据。\n再来看下 test_pk2 的自增值是多少：\n如上分析，是 8 而不是 6\n具体来说，insert…select 实际上往表中插入了 5 行数据 （1 1）（2 2）（3 3）（4 4）（5 5）。但是，这五行数据是分三次申请的自增 id，结合批量申请策略，每次申请到的自增 id 个数都是上一次的两倍，所以：\n第一次申请到了一个 id：id=1 第二次被分配了两个 id：id=2 和 id=3 第三次被分配到了 4 个 id：id=4、id = 5、id = 6、id=7 由于这条语句实际只用上了 5 个 id，所以 id=6 和 id=7 就被浪费掉了。之后，再执行 insert into test_pk2 values(null,6,6)，实际上插入的数据就是（8,6,6)：\n小结 本文总结下自增值不连续的 4 个场景：\n自增初始值和自增步长设置不为 1 唯一键冲突 事务回滚 批量插入（如 insert...select 语句） ",
  "wordCount" : "41844",
  "inLanguage": "en",
  "image": "https://009965.xyz/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/not-using-covering-index-demo.png","datePublished": "2023-07-24T05:00:00Z",
  "dateModified": "2023-07-24T05:00:00Z",
  "author":{
    "@type": "Person",
    "name": "Wjy"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://009965.xyz/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Wjy's Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://009965.xyz/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://009965.xyz/" accesskey="h" title="Wjy&#39;s Blog (Alt + H)">Wjy&#39;s Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://009965.xyz/" title="🏠主页">
                    <span>🏠主页</span>
                </a>
            </li>
            <li>
                <a href="https://009965.xyz/posts" title="📚文章">
                    <span>📚文章</span>
                </a>
            </li>
            <li>
                <a href="https://009965.xyz/archives/" title="⏱时间轴">
                    <span>⏱时间轴</span>
                </a>
            </li>
            <li>
                <a href="https://009965.xyz/tags" title="🔖标签">
                    <span>🔖标签</span>
                </a>
            </li>
            <li>
                <a href="https://009965.xyz/search" title="🔍搜索 (Alt &#43; /)" accesskey=/>
                    <span>🔍搜索</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://009965.xyz/">Home</a>&nbsp;»&nbsp;<a href="https://009965.xyz/posts/">Posts</a></div>
    <h1 class="post-title entry-hint-parent">
      14_MySQL面试题
    </h1>
    <div class="post-meta"><span title='2023-07-24 05:00:00 +0000 UTC'>2023-07-24</span>&nbsp;·&nbsp;Wjy

</div>
  </header> <div class="toc">
    <details  open>
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#mysql%e5%ad%97%e6%ae%b5%e7%b1%bb%e5%9e%8b" aria-label="MySQL字段类型">MySQL字段类型</a><ul>
                        
                <li>
                    <a href="#char-%e5%92%8c-varchar-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="char 和 varchar 的区别是什么？">char 和 varchar 的区别是什么？</a></li>
                <li>
                    <a href="#varchar100%e5%92%8c-varchar10%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="varchar(100)和 varchar(10)的区别是什么？">varchar(100)和 varchar(10)的区别是什么？</a></li>
                <li>
                    <a href="#decimal-%e5%92%8c-floatdouble-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="decimal 和 float/double 的区别是什么？">decimal 和 float/double 的区别是什么？</a></li>
                <li>
                    <a href="#%e4%b8%ba%e4%bb%80%e4%b9%88%e4%b8%8d%e6%8e%a8%e8%8d%90%e4%bd%bf%e7%94%a8-text-%e5%92%8c-blob" aria-label="为什么不推荐使用 text 和 blob？">为什么不推荐使用 text 和 blob？</a></li>
                <li>
                    <a href="#datetime-%e5%92%8c-timestamp-%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="datetime 和 timestamp 的区别是什么？">datetime 和 timestamp 的区别是什么？</a></li>
                <li>
                    <a href="#null-%e5%92%8c--%e7%9a%84%e5%8c%ba%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="NULL 和 &rsquo;&rsquo; 的区别是什么？">NULL 和 &rsquo;&rsquo; 的区别是什么？</a></li></ul>
                </li>
                <li>
                    <a href="#mysql-%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e" aria-label="MySQL 存储引擎">MySQL 存储引擎</a><ul>
                        
                <li>
                    <a href="#mysql-%e6%94%af%e6%8c%81%e5%93%aa%e4%ba%9b%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e9%bb%98%e8%ae%a4%e4%bd%bf%e7%94%a8%e5%93%aa%e4%b8%aa" aria-label="MySQL 支持哪些存储引擎？默认使用哪个？">MySQL 支持哪些存储引擎？默认使用哪个？</a></li>
                <li>
                    <a href="#mysql-%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e%e6%9e%b6%e6%9e%84%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="MySQL 存储引擎架构了解吗？">MySQL 存储引擎架构了解吗？</a></li>
                <li>
                    <a href="#myisam-%e5%92%8c-innodb-%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="MyISAM 和 InnoDB 有什么区别？">MyISAM 和 InnoDB 有什么区别？</a></li>
                <li>
                    <a href="#myisam-%e5%92%8c-innodb-%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9" aria-label="MyISAM 和 InnoDB 如何选择？">MyISAM 和 InnoDB 如何选择？</a></li></ul>
                </li>
                <li>
                    <a href="#mysql-%e6%9f%a5%e8%af%a2%e7%bc%93%e5%ad%98" aria-label="MySQL 查询缓存">MySQL 查询缓存</a></li>
                <li>
                    <a href="#mysql-%e4%ba%8b%e5%8a%a1" aria-label="MySQL 事务">MySQL 事务</a><ul>
                        
                <li>
                    <a href="#%e4%bd%95%e8%b0%93%e4%ba%8b%e5%8a%a1" aria-label="何谓事务？">何谓事务？</a></li>
                <li>
                    <a href="#%e4%bd%95%e8%b0%93%e6%95%b0%e6%8d%ae%e5%ba%93%e4%ba%8b%e5%8a%a1" aria-label="何谓数据库事务？">何谓数据库事务？</a></li>
                <li>
                    <a href="#%e5%b9%b6%e5%8f%91%e4%ba%8b%e5%8a%a1%e5%b8%a6%e6%9d%a5%e4%ba%86%e5%93%aa%e4%ba%9b%e9%97%ae%e9%a2%98" aria-label="并发事务带来了哪些问题?">并发事务带来了哪些问题?</a><ul>
                        
                <li>
                    <a href="#%e8%84%8f%e8%af%bbdirty-read" aria-label="脏读（Dirty read）">脏读（Dirty read）</a></li>
                <li>
                    <a href="#%e4%b8%a2%e5%a4%b1%e4%bf%ae%e6%94%b9lost-to-modify" aria-label="丢失修改（Lost to modify）">丢失修改（Lost to modify）</a></li>
                <li>
                    <a href="#%e4%b8%8d%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bbunrepeatable-read" aria-label="不可重复读（Unrepeatable read）">不可重复读（Unrepeatable read）</a></li>
                <li>
                    <a href="#%e5%b9%bb%e8%af%bbphantom-read" aria-label="幻读（Phantom read）">幻读（Phantom read）</a></li></ul>
                </li>
                <li>
                    <a href="#%e4%b8%8d%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb%e5%92%8c%e5%b9%bb%e8%af%bb%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="不可重复读和幻读有什么区别？">不可重复读和幻读有什么区别？</a></li>
                <li>
                    <a href="#%e5%b9%b6%e5%8f%91%e4%ba%8b%e5%8a%a1%e7%9a%84%e6%8e%a7%e5%88%b6%e6%96%b9%e5%bc%8f%e6%9c%89%e5%93%aa%e4%ba%9b" aria-label="并发事务的控制方式有哪些？">并发事务的控制方式有哪些？</a></li>
                <li>
                    <a href="#sql-%e6%a0%87%e5%87%86%e5%ae%9a%e4%b9%89%e4%ba%86%e5%93%aa%e4%ba%9b%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab" aria-label="SQL 标准定义了哪些事务隔离级别?">SQL 标准定义了哪些事务隔离级别?</a></li>
                <li>
                    <a href="#mysql-%e7%9a%84%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e6%98%af%e5%9f%ba%e4%ba%8e%e9%94%81%e5%ae%9e%e7%8e%b0%e7%9a%84%e5%90%97" aria-label="MySQL 的隔离级别是基于锁实现的吗？">MySQL 的隔离级别是基于锁实现的吗？</a></li>
                <li>
                    <a href="#mysql-%e7%9a%84%e9%bb%98%e8%ae%a4%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e6%98%af%e4%bb%80%e4%b9%88" aria-label="MySQL 的默认隔离级别是什么?">MySQL 的默认隔离级别是什么?</a></li></ul>
                </li>
                <li>
                    <a href="#mysql%e9%94%81" aria-label="MySQL锁">MySQL锁</a><ul>
                        
                <li>
                    <a href="#%e8%a1%a8%e7%ba%a7%e9%94%81%e5%92%8c%e8%a1%8c%e7%ba%a7%e9%94%81%e4%ba%86%e8%a7%a3%e5%90%97%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="表级锁和行级锁了解吗？有什么区别？">表级锁和行级锁了解吗？有什么区别？</a></li>
                <li>
                    <a href="#%e8%a1%8c%e7%ba%a7%e9%94%81%e7%9a%84%e4%bd%bf%e7%94%a8%e6%9c%89%e4%bb%80%e4%b9%88%e6%b3%a8%e6%84%8f%e4%ba%8b%e9%a1%b9" aria-label="行级锁的使用有什么注意事项？">行级锁的使用有什么注意事项？</a></li>
                <li>
                    <a href="#innodb-%e6%9c%89%e5%93%aa%e5%87%a0%e7%b1%bb%e8%a1%8c%e9%94%81" aria-label="InnoDB 有哪几类行锁？">InnoDB 有哪几类行锁？</a></li>
                <li>
                    <a href="#%e5%85%b1%e4%ba%ab%e9%94%81%e5%92%8c%e6%8e%92%e4%bb%96%e9%94%81%e5%91%a2" aria-label="共享锁和排他锁呢？">共享锁和排他锁呢？</a></li>
                <li>
                    <a href="#%e6%84%8f%e5%90%91%e9%94%81%e6%9c%89%e4%bb%80%e4%b9%88%e4%bd%9c%e7%94%a8" aria-label="意向锁有什么作用？">意向锁有什么作用？</a></li>
                <li>
                    <a href="#%e5%bd%93%e5%89%8d%e8%af%bb%e5%92%8c%e5%bf%ab%e7%85%a7%e8%af%bb%e6%9c%89%e4%bb%80%e4%b9%88%e5%8c%ba%e5%88%ab" aria-label="当前读和快照读有什么区别？">当前读和快照读有什么区别？</a></li>
                <li>
                    <a href="#%e8%87%aa%e5%a2%9e%e9%94%81%e6%9c%89%e4%ba%86%e8%a7%a3%e5%90%97" aria-label="自增锁有了解吗？">自增锁有了解吗？</a></li></ul>
                </li>
                <li>
                    <a href="#mysql-%e6%80%a7%e8%83%bd%e4%bc%98%e5%8c%96" aria-label="MySQL 性能优化">MySQL 性能优化</a><ul>
                        
                <li>
                    <a href="#%e8%83%bd%e7%94%a8-mysql-%e7%9b%b4%e6%8e%a5%e5%ad%98%e5%82%a8%e6%96%87%e4%bb%b6%e6%af%94%e5%a6%82%e5%9b%be%e7%89%87%e5%90%97" aria-label="能用 MySQL 直接存储文件（比如图片）吗？">能用 MySQL 直接存储文件（比如图片）吗？</a></li>
                <li>
                    <a href="#mysql-%e5%a6%82%e4%bd%95%e5%ad%98%e5%82%a8-ip-%e5%9c%b0%e5%9d%80" aria-label="MySQL 如何存储 IP 地址？">MySQL 如何存储 IP 地址？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%88%86%e6%9e%90-sql-%e7%9a%84%e6%80%a7%e8%83%bd" aria-label="如何分析 SQL 的性能？">如何分析 SQL 的性能？</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%91%bd%e5%90%8d%e8%a7%84%e8%8c%83" aria-label="数据库命名规范">数据库命名规范</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%9f%ba%e6%9c%ac%e8%ae%be%e8%ae%a1%e8%a7%84%e8%8c%83" aria-label="数据库基本设计规范">数据库基本设计规范</a><ul>
                        
                <li>
                    <a href="#%e6%89%80%e6%9c%89%e8%a1%a8%e5%bf%85%e9%a1%bb%e4%bd%bf%e7%94%a8-innodb-%e5%ad%98%e5%82%a8%e5%bc%95%e6%93%8e" aria-label="所有表必须使用 InnoDB 存储引擎">所有表必须使用 InnoDB 存储引擎</a></li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%92%8c%e8%a1%a8%e7%9a%84%e5%ad%97%e7%ac%a6%e9%9b%86%e7%bb%9f%e4%b8%80%e4%bd%bf%e7%94%a8-utf8" aria-label="数据库和表的字符集统一使用 UTF8">数据库和表的字符集统一使用 UTF8</a></li>
                <li>
                    <a href="#%e6%89%80%e6%9c%89%e8%a1%a8%e5%92%8c%e5%ad%97%e6%ae%b5%e9%83%bd%e9%9c%80%e8%a6%81%e6%b7%bb%e5%8a%a0%e6%b3%a8%e9%87%8a" aria-label="所有表和字段都需要添加注释">所有表和字段都需要添加注释</a></li>
                <li>
                    <a href="#%e5%b0%bd%e9%87%8f%e6%8e%a7%e5%88%b6%e5%8d%95%e8%a1%a8%e6%95%b0%e6%8d%ae%e9%87%8f%e7%9a%84%e5%a4%a7%e5%b0%8f%e5%bb%ba%e8%ae%ae%e6%8e%a7%e5%88%b6%e5%9c%a8-500-%e4%b8%87%e4%bb%a5%e5%86%85" aria-label="尽量控制单表数据量的大小，建议控制在 500 万以内">尽量控制单表数据量的大小，建议控制在 500 万以内</a></li>
                <li>
                    <a href="#%e8%b0%a8%e6%85%8e%e4%bd%bf%e7%94%a8-mysql-%e5%88%86%e5%8c%ba%e8%a1%a8" aria-label="谨慎使用 MySQL 分区表">谨慎使用 MySQL 分区表</a></li>
                <li>
                    <a href="#%e7%bb%8f%e5%b8%b8%e4%b8%80%e8%b5%b7%e4%bd%bf%e7%94%a8%e7%9a%84%e5%88%97%e6%94%be%e5%88%b0%e4%b8%80%e4%b8%aa%e8%a1%a8%e4%b8%ad" aria-label="经常一起使用的列放到一个表中">经常一起使用的列放到一个表中</a></li>
                <li>
                    <a href="#%e7%a6%81%e6%ad%a2%e5%9c%a8%e8%a1%a8%e4%b8%ad%e5%bb%ba%e7%ab%8b%e9%a2%84%e7%95%99%e5%ad%97%e6%ae%b5" aria-label="禁止在表中建立预留字段">禁止在表中建立预留字段</a></li>
                <li>
                    <a href="#%e7%a6%81%e6%ad%a2%e5%9c%a8%e6%95%b0%e6%8d%ae%e5%ba%93%e4%b8%ad%e5%ad%98%e5%82%a8%e6%96%87%e4%bb%b6%e6%af%94%e5%a6%82%e5%9b%be%e7%89%87%e8%bf%99%e7%b1%bb%e5%a4%a7%e7%9a%84%e4%ba%8c%e8%bf%9b%e5%88%b6%e6%95%b0%e6%8d%ae" aria-label="禁止在数据库中存储文件（比如图片）这类大的二进制数据">禁止在数据库中存储文件（比如图片）这类大的二进制数据</a></li>
                <li>
                    <a href="#%e4%b8%8d%e8%a6%81%e8%a2%ab%e6%95%b0%e6%8d%ae%e5%ba%93%e8%8c%83%e5%bc%8f%e6%89%80%e6%9d%9f%e7%bc%9a" aria-label="不要被数据库范式所束缚">不要被数据库范式所束缚</a></li>
                <li>
                    <a href="#%e7%a6%81%e6%ad%a2%e5%9c%a8%e7%ba%bf%e4%b8%8a%e5%81%9a%e6%95%b0%e6%8d%ae%e5%ba%93%e5%8e%8b%e5%8a%9b%e6%b5%8b%e8%af%95" aria-label="禁止在线上做数据库压力测试">禁止在线上做数据库压力测试</a></li>
                <li>
                    <a href="#%e7%a6%81%e6%ad%a2%e4%bb%8e%e5%bc%80%e5%8f%91%e7%8e%af%e5%a2%83%e6%b5%8b%e8%af%95%e7%8e%af%e5%a2%83%e7%9b%b4%e6%8e%a5%e8%bf%9e%e6%8e%a5%e7%94%9f%e4%ba%a7%e7%8e%af%e5%a2%83%e6%95%b0%e6%8d%ae%e5%ba%93" aria-label="禁止从开发环境,测试环境直接连接生产环境数据库">禁止从开发环境,测试环境直接连接生产环境数据库</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e5%ad%97%e6%ae%b5%e8%ae%be%e8%ae%a1%e8%a7%84%e8%8c%83" aria-label="数据库字段设计规范">数据库字段设计规范</a><ul>
                        
                <li>
                    <a href="#%e4%bc%98%e5%85%88%e9%80%89%e6%8b%a9%e7%ac%a6%e5%90%88%e5%ad%98%e5%82%a8%e9%9c%80%e8%a6%81%e7%9a%84%e6%9c%80%e5%b0%8f%e7%9a%84%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b" aria-label="优先选择符合存储需要的最小的数据类型">优先选择符合存储需要的最小的数据类型</a></li>
                <li>
                    <a href="#%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8-textblob-%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e6%9c%80%e5%b8%b8%e8%a7%81%e7%9a%84-text-%e7%b1%bb%e5%9e%8b%e5%8f%af%e4%bb%a5%e5%ad%98%e5%82%a8-64k-%e7%9a%84%e6%95%b0%e6%8d%ae" aria-label="避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据">避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</a></li>
                <li>
                    <a href="#%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8-enum-%e7%b1%bb%e5%9e%8b" aria-label="避免使用 ENUM 类型">避免使用 ENUM 类型</a></li>
                <li>
                    <a href="#%e5%b0%bd%e5%8f%af%e8%83%bd%e6%8a%8a%e6%89%80%e6%9c%89%e5%88%97%e5%ae%9a%e4%b9%89%e4%b8%ba-not-null" aria-label="尽可能把所有列定义为 NOT NULL">尽可能把所有列定义为 NOT NULL</a></li>
                <li>
                    <a href="#%e4%bd%bf%e7%94%a8-timestamp4-%e4%b8%aa%e5%ad%97%e8%8a%82-%e6%88%96-datetime-%e7%b1%bb%e5%9e%8b-8-%e4%b8%aa%e5%ad%97%e8%8a%82-%e5%ad%98%e5%82%a8%e6%97%b6%e9%97%b4" aria-label="使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间">使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</a></li>
                <li>
                    <a href="#%e5%90%8c%e8%b4%a2%e5%8a%a1%e7%9b%b8%e5%85%b3%e7%9a%84%e9%87%91%e9%a2%9d%e7%b1%bb%e6%95%b0%e6%8d%ae%e5%bf%85%e9%a1%bb%e4%bd%bf%e7%94%a8-decimal-%e7%b1%bb%e5%9e%8b" aria-label="同财务相关的金额类数据必须使用 decimal 类型">同财务相关的金额类数据必须使用 decimal 类型</a></li>
                <li>
                    <a href="#%e5%8d%95%e8%a1%a8%e4%b8%8d%e8%a6%81%e5%8c%85%e5%90%ab%e8%bf%87%e5%a4%9a%e5%ad%97%e6%ae%b5" aria-label="单表不要包含过多字段">单表不要包含过多字段</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95%e8%ae%be%e8%ae%a1%e8%a7%84%e8%8c%83" aria-label="索引设计规范">索引设计规范</a><ul>
                        
                <li>
                    <a href="#%e9%99%90%e5%88%b6%e6%af%8f%e5%bc%a0%e8%a1%a8%e4%b8%8a%e7%9a%84%e7%b4%a2%e5%bc%95%e6%95%b0%e9%87%8f%e5%bb%ba%e8%ae%ae%e5%8d%95%e5%bc%a0%e8%a1%a8%e7%b4%a2%e5%bc%95%e4%b8%8d%e8%b6%85%e8%bf%87-5-%e4%b8%aa" aria-label="限制每张表上的索引数量,建议单张表索引不超过 5 个">限制每张表上的索引数量,建议单张表索引不超过 5 个</a></li>
                <li>
                    <a href="#%e7%a6%81%e6%ad%a2%e4%bd%bf%e7%94%a8%e5%85%a8%e6%96%87%e7%b4%a2%e5%bc%95" aria-label="禁止使用全文索引">禁止使用全文索引</a></li>
                <li>
                    <a href="#%e7%a6%81%e6%ad%a2%e7%bb%99%e8%a1%a8%e4%b8%ad%e7%9a%84%e6%af%8f%e4%b8%80%e5%88%97%e9%83%bd%e5%bb%ba%e7%ab%8b%e5%8d%95%e7%8b%ac%e7%9a%84%e7%b4%a2%e5%bc%95" aria-label="禁止给表中的每一列都建立单独的索引">禁止给表中的每一列都建立单独的索引</a></li>
                <li>
                    <a href="#%e6%af%8f%e4%b8%aa-innodb-%e8%a1%a8%e5%bf%85%e9%a1%bb%e6%9c%89%e4%b8%aa%e4%b8%bb%e9%94%ae" aria-label="每个 InnoDB 表必须有个主键">每个 InnoDB 表必须有个主键</a></li>
                <li>
                    <a href="#%e5%b8%b8%e8%a7%81%e7%b4%a2%e5%bc%95%e5%88%97%e5%bb%ba%e8%ae%ae" aria-label="常见索引列建议">常见索引列建议</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e9%80%89%e6%8b%a9%e7%b4%a2%e5%bc%95%e5%88%97%e7%9a%84%e9%a1%ba%e5%ba%8f" aria-label="如何选择索引列的顺序">如何选择索引列的顺序</a></li>
                <li>
                    <a href="#%e9%81%bf%e5%85%8d%e5%bb%ba%e7%ab%8b%e5%86%97%e4%bd%99%e7%b4%a2%e5%bc%95%e5%92%8c%e9%87%8d%e5%a4%8d%e7%b4%a2%e5%bc%95%e5%a2%9e%e5%8a%a0%e4%ba%86%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96%e5%99%a8%e7%94%9f%e6%88%90%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e7%9a%84%e6%97%b6%e9%97%b4" aria-label="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）">避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</a></li>
                <li>
                    <a href="#%e5%af%b9%e4%ba%8e%e9%a2%91%e7%b9%81%e7%9a%84%e6%9f%a5%e8%af%a2%e4%bc%98%e5%85%88%e8%80%83%e8%99%91%e4%bd%bf%e7%94%a8%e8%a6%86%e7%9b%96%e7%b4%a2%e5%bc%95" aria-label="对于频繁的查询优先考虑使用覆盖索引">对于频繁的查询优先考虑使用覆盖索引</a></li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95-set-%e8%a7%84%e8%8c%83" aria-label="索引 SET 规范">索引 SET 规范</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%ba%93-sql-%e5%bc%80%e5%8f%91%e8%a7%84%e8%8c%83" aria-label="数据库 SQL 开发规范">数据库 SQL 开发规范</a><ul>
                        
                <li>
                    <a href="#%e4%bc%98%e5%8c%96%e5%af%b9%e6%80%a7%e8%83%bd%e5%bd%b1%e5%93%8d%e8%be%83%e5%a4%a7%e7%9a%84-sql-%e8%af%ad%e5%8f%a5" aria-label="优化对性能影响较大的 SQL 语句">优化对性能影响较大的 SQL 语句</a></li>
                <li>
                    <a href="#%e5%85%85%e5%88%86%e5%88%a9%e7%94%a8%e8%a1%a8%e4%b8%8a%e5%b7%b2%e7%bb%8f%e5%ad%98%e5%9c%a8%e7%9a%84%e7%b4%a2%e5%bc%95" aria-label="充分利用表上已经存在的索引">充分利用表上已经存在的索引</a></li>
                <li>
                    <a href="#%e7%a6%81%e6%ad%a2%e4%bd%bf%e7%94%a8-select--%e5%bf%85%e9%a1%bb%e4%bd%bf%e7%94%a8-select-%e5%ad%97%e6%ae%b5%e5%88%97%e8%a1%a8-%e6%9f%a5%e8%af%a2" aria-label="禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询">禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</a></li>
                <li>
                    <a href="#%e7%a6%81%e6%ad%a2%e4%bd%bf%e7%94%a8%e4%b8%8d%e5%90%ab%e5%ad%97%e6%ae%b5%e5%88%97%e8%a1%a8%e7%9a%84-insert-%e8%af%ad%e5%8f%a5" aria-label="禁止使用不含字段列表的 INSERT 语句">禁止使用不含字段列表的 INSERT 语句</a></li>
                <li>
                    <a href="#%e5%bb%ba%e8%ae%ae%e4%bd%bf%e7%94%a8%e9%a2%84%e7%bc%96%e8%af%91%e8%af%ad%e5%8f%a5%e8%bf%9b%e8%a1%8c%e6%95%b0%e6%8d%ae%e5%ba%93%e6%93%8d%e4%bd%9c" aria-label="建议使用预编译语句进行数据库操作">建议使用预编译语句进行数据库操作</a></li>
                <li>
                    <a href="#%e9%81%bf%e5%85%8d%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e7%9a%84%e9%9a%90%e5%bc%8f%e8%bd%ac%e6%8d%a2" aria-label="避免数据类型的隐式转换">避免数据类型的隐式转换</a></li>
                <li>
                    <a href="#%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8%e5%ad%90%e6%9f%a5%e8%af%a2%e5%8f%af%e4%bb%a5%e6%8a%8a%e5%ad%90%e6%9f%a5%e8%af%a2%e4%bc%98%e5%8c%96%e4%b8%ba-join-%e6%93%8d%e4%bd%9c" aria-label="避免使用子查询，可以把子查询优化为 join 操作">避免使用子查询，可以把子查询优化为 join 操作</a></li>
                <li>
                    <a href="#%e9%81%bf%e5%85%8d%e4%bd%bf%e7%94%a8-join-%e5%85%b3%e8%81%94%e5%a4%aa%e5%a4%9a%e7%9a%84%e8%a1%a8" aria-label="避免使用 JOIN 关联太多的表">避免使用 JOIN 关联太多的表</a></li>
                <li>
                    <a href="#%e5%87%8f%e5%b0%91%e5%90%8c%e6%95%b0%e6%8d%ae%e5%ba%93%e7%9a%84%e4%ba%a4%e4%ba%92%e6%ac%a1%e6%95%b0" aria-label="减少同数据库的交互次数">减少同数据库的交互次数</a></li>
                <li>
                    <a href="#%e5%af%b9%e5%ba%94%e5%90%8c%e4%b8%80%e5%88%97%e8%bf%9b%e8%a1%8c-or-%e5%88%a4%e6%96%ad%e6%97%b6%e4%bd%bf%e7%94%a8-in-%e4%bb%a3%e6%9b%bf-or" aria-label="对应同一列进行 or 判断时，使用 in 代替 or">对应同一列进行 or 判断时，使用 in 代替 or</a></li>
                <li>
                    <a href="#%e7%a6%81%e6%ad%a2%e4%bd%bf%e7%94%a8-order-by-rand-%e8%bf%9b%e8%a1%8c%e9%9a%8f%e6%9c%ba%e6%8e%92%e5%ba%8f" aria-label="禁止使用 order by rand() 进行随机排序">禁止使用 order by rand() 进行随机排序</a></li>
                <li>
                    <a href="#where-%e4%bb%8e%e5%8f%a5%e4%b8%ad%e7%a6%81%e6%ad%a2%e5%af%b9%e5%88%97%e8%bf%9b%e8%a1%8c%e5%87%bd%e6%95%b0%e8%bd%ac%e6%8d%a2%e5%92%8c%e8%ae%a1%e7%ae%97" aria-label="WHERE 从句中禁止对列进行函数转换和计算">WHERE 从句中禁止对列进行函数转换和计算</a></li>
                <li>
                    <a href="#%e5%9c%a8%e6%98%8e%e6%98%be%e4%b8%8d%e4%bc%9a%e6%9c%89%e9%87%8d%e5%a4%8d%e5%80%bc%e6%97%b6%e4%bd%bf%e7%94%a8-union-all-%e8%80%8c%e4%b8%8d%e6%98%af-union" aria-label="在明显不会有重复值时使用 UNION ALL 而不是 UNION">在明显不会有重复值时使用 UNION ALL 而不是 UNION</a></li>
                <li>
                    <a href="#%e6%8b%86%e5%88%86%e5%a4%8d%e6%9d%82%e7%9a%84%e5%a4%a7-sql-%e4%b8%ba%e5%a4%9a%e4%b8%aa%e5%b0%8f-sql" aria-label="拆分复杂的大 SQL 为多个小 SQL">拆分复杂的大 SQL 为多个小 SQL</a></li>
                <li>
                    <a href="#%e7%a8%8b%e5%ba%8f%e8%bf%9e%e6%8e%a5%e4%b8%8d%e5%90%8c%e7%9a%84%e6%95%b0%e6%8d%ae%e5%ba%93%e4%bd%bf%e7%94%a8%e4%b8%8d%e5%90%8c%e7%9a%84%e8%b4%a6%e5%8f%b7%e7%a6%81%e6%ad%a2%e8%b7%a8%e5%ba%93%e6%9f%a5%e8%af%a2" aria-label="程序连接不同的数据库使用不同的账号，禁止跨库查询">程序连接不同的数据库使用不同的账号，禁止跨库查询</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%ba%93%e6%93%8d%e4%bd%9c%e8%a1%8c%e4%b8%ba%e8%a7%84%e8%8c%83" aria-label="数据库操作行为规范">数据库操作行为规范</a><ul>
                        
                <li>
                    <a href="#%e8%b6%85-100-%e4%b8%87%e8%a1%8c%e7%9a%84%e6%89%b9%e9%87%8f%e5%86%99-updatedeleteinsert-%e6%93%8d%e4%bd%9c%e8%a6%81%e5%88%86%e6%89%b9%e5%a4%9a%e6%ac%a1%e8%bf%9b%e8%a1%8c%e6%93%8d%e4%bd%9c" aria-label="超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作">超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</a></li>
                <li>
                    <a href="#%e5%af%b9%e4%ba%8e%e5%a4%a7%e8%a1%a8%e4%bd%bf%e7%94%a8-pt-online-schema-change-%e4%bf%ae%e6%94%b9%e8%a1%a8%e7%bb%93%e6%9e%84" aria-label="对于大表使用 pt-online-schema-change 修改表结构">对于大表使用 pt-online-schema-change 修改表结构</a></li>
                <li>
                    <a href="#%e7%a6%81%e6%ad%a2%e4%b8%ba%e7%a8%8b%e5%ba%8f%e4%bd%bf%e7%94%a8%e7%9a%84%e8%b4%a6%e5%8f%b7%e8%b5%8b%e4%ba%88-super-%e6%9d%83%e9%99%90" aria-label="禁止为程序使用的账号赋予 super 权限">禁止为程序使用的账号赋予 super 权限</a></li>
                <li>
                    <a href="#%e5%af%b9%e4%ba%8e%e7%a8%8b%e5%ba%8f%e8%bf%9e%e6%8e%a5%e6%95%b0%e6%8d%ae%e5%ba%93%e8%b4%a6%e5%8f%b7%e9%81%b5%e5%be%aa%e6%9d%83%e9%99%90%e6%9c%80%e5%b0%8f%e5%8e%9f%e5%88%99" aria-label="对于程序连接数据库账号,遵循权限最小原则">对于程序连接数据库账号,遵循权限最小原则</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#mysql%e7%b4%a2%e5%bc%95%e8%af%a6%e8%a7%a3" aria-label="MySQL索引详解">MySQL索引详解</a><ul>
                        
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95%e4%bb%8b%e7%bb%8d" aria-label="索引介绍">索引介绍</a></li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9" aria-label="索引的优缺点">索引的优缺点</a></li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95%e7%9a%84%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84" aria-label="索引的数据结构">索引的数据结构</a><ul>
                        
                <li>
                    <a href="#hash-%e8%a1%a8" aria-label="Hash 表">Hash 表</a></li>
                <li>
                    <a href="#%e4%ba%8c%e5%8f%89%e6%9f%a5%e6%89%be%e6%a0%91bst" aria-label="二叉查找树(BST)">二叉查找树(BST)</a></li>
                <li>
                    <a href="#avl-%e6%a0%91" aria-label="AVL 树">AVL 树</a></li>
                <li>
                    <a href="#%e7%ba%a2%e9%bb%91%e6%a0%91" aria-label="红黑树">红黑树</a></li>
                <li>
                    <a href="#b-%e6%a0%91-b%e6%a0%91" aria-label="B 树&amp; B&#43;树">B 树&amp; B+树</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95%e7%b1%bb%e5%9e%8b%e6%80%bb%e7%bb%93" aria-label="索引类型总结">索引类型总结</a></li>
                <li>
                    <a href="#%e4%b8%bb%e9%94%ae%e7%b4%a2%e5%bc%95primary-key" aria-label="主键索引(Primary Key)">主键索引(Primary Key)</a></li>
                <li>
                    <a href="#%e4%ba%8c%e7%ba%a7%e7%b4%a2%e5%bc%95" aria-label="二级索引">二级索引</a></li>
                <li>
                    <a href="#%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e4%b8%8e%e9%9d%9e%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95" aria-label="聚簇索引与非聚簇索引">聚簇索引与非聚簇索引</a><ul>
                        
                <li>
                    <a href="#%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95" aria-label="聚簇索引（聚集索引）">聚簇索引（聚集索引）</a><ul>
                        
                <li>
                    <a href="#%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e4%bb%8b%e7%bb%8d" aria-label="聚簇索引介绍">聚簇索引介绍</a></li>
                <li>
                    <a href="#%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9" aria-label="聚簇索引的优缺点">聚簇索引的优缺点</a></li></ul>
                </li>
                <li>
                    <a href="#%e9%9d%9e%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e9%9d%9e%e8%81%9a%e9%9b%86%e7%b4%a2%e5%bc%95" aria-label="非聚簇索引（非聚集索引）">非聚簇索引（非聚集索引）</a><ul>
                        
                <li>
                    <a href="#%e9%9d%9e%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e4%bb%8b%e7%bb%8d" aria-label="非聚簇索引介绍">非聚簇索引介绍</a></li>
                <li>
                    <a href="#%e9%9d%9e%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e7%9a%84%e4%bc%98%e7%bc%ba%e7%82%b9" aria-label="非聚簇索引的优缺点">非聚簇索引的优缺点</a></li>
                <li>
                    <a href="#%e9%9d%9e%e8%81%9a%e7%b0%87%e7%b4%a2%e5%bc%95%e4%b8%80%e5%ae%9a%e5%9b%9e%e8%a1%a8%e6%9f%a5%e8%af%a2%e5%90%97%e8%a6%86%e7%9b%96%e7%b4%a2%e5%bc%95" aria-label="非聚簇索引一定回表查询吗(覆盖索引)?">非聚簇索引一定回表查询吗(覆盖索引)?</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e8%a6%86%e7%9b%96%e7%b4%a2%e5%bc%95%e5%92%8c%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95" aria-label="覆盖索引和联合索引">覆盖索引和联合索引</a><ul>
                        
                <li>
                    <a href="#%e8%a6%86%e7%9b%96%e7%b4%a2%e5%bc%95" aria-label="覆盖索引">覆盖索引</a></li>
                <li>
                    <a href="#%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95" aria-label="联合索引">联合索引</a></li>
                <li>
                    <a href="#%e6%9c%80%e5%b7%a6%e5%89%8d%e7%bc%80%e5%8c%b9%e9%85%8d%e5%8e%9f%e5%88%99" aria-label="最左前缀匹配原则">最左前缀匹配原则</a></li></ul>
                </li>
                <li>
                    <a href="#%e7%b4%a2%e5%bc%95%e4%b8%8b%e6%8e%a8" aria-label="索引下推">索引下推</a></li>
                <li>
                    <a href="#%e6%ad%a3%e7%a1%ae%e4%bd%bf%e7%94%a8%e7%b4%a2%e5%bc%95%e7%9a%84%e4%b8%80%e4%ba%9b%e5%bb%ba%e8%ae%ae" aria-label="正确使用索引的一些建议">正确使用索引的一些建议</a><ul>
                        
                <li>
                    <a href="#%e9%80%89%e6%8b%a9%e5%90%88%e9%80%82%e7%9a%84%e5%ad%97%e6%ae%b5%e5%88%9b%e5%bb%ba%e7%b4%a2%e5%bc%95" aria-label="选择合适的字段创建索引">选择合适的字段创建索引</a></li>
                <li>
                    <a href="#%e8%a2%ab%e9%a2%91%e7%b9%81%e6%9b%b4%e6%96%b0%e7%9a%84%e5%ad%97%e6%ae%b5%e5%ba%94%e8%af%a5%e6%85%8e%e9%87%8d%e5%bb%ba%e7%ab%8b%e7%b4%a2%e5%bc%95" aria-label="被频繁更新的字段应该慎重建立索引">被频繁更新的字段应该慎重建立索引</a></li>
                <li>
                    <a href="#%e9%99%90%e5%88%b6%e6%af%8f%e5%bc%a0%e8%a1%a8%e4%b8%8a%e7%9a%84%e7%b4%a2%e5%bc%95%e6%95%b0%e9%87%8f" aria-label="限制每张表上的索引数量">限制每张表上的索引数量</a></li>
                <li>
                    <a href="#%e5%b0%bd%e5%8f%af%e8%83%bd%e7%9a%84%e8%80%83%e8%99%91%e5%bb%ba%e7%ab%8b%e8%81%94%e5%90%88%e7%b4%a2%e5%bc%95%e8%80%8c%e4%b8%8d%e6%98%af%e5%8d%95%e5%88%97%e7%b4%a2%e5%bc%95" aria-label="尽可能的考虑建立联合索引而不是单列索引">尽可能的考虑建立联合索引而不是单列索引</a></li>
                <li>
                    <a href="#%e6%b3%a8%e6%84%8f%e9%81%bf%e5%85%8d%e5%86%97%e4%bd%99%e7%b4%a2%e5%bc%95" aria-label="注意避免冗余索引">注意避免冗余索引</a></li>
                <li>
                    <a href="#%e5%ad%97%e7%ac%a6%e4%b8%b2%e7%b1%bb%e5%9e%8b%e7%9a%84%e5%ad%97%e6%ae%b5%e4%bd%bf%e7%94%a8%e5%89%8d%e7%bc%80%e7%b4%a2%e5%bc%95%e4%bb%a3%e6%9b%bf%e6%99%ae%e9%80%9a%e7%b4%a2%e5%bc%95" aria-label="字符串类型的字段使用前缀索引代替普通索引">字符串类型的字段使用前缀索引代替普通索引</a></li>
                <li>
                    <a href="#%e9%81%bf%e5%85%8d%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88" aria-label="避免索引失效">避免索引失效</a></li>
                <li>
                    <a href="#%e5%88%a0%e9%99%a4%e9%95%bf%e6%9c%9f%e6%9c%aa%e4%bd%bf%e7%94%a8%e7%9a%84%e7%b4%a2%e5%bc%95" aria-label="删除长期未使用的索引">删除长期未使用的索引</a></li>
                <li>
                    <a href="#%e7%9f%a5%e9%81%93%e5%a6%82%e4%bd%95%e5%88%86%e6%9e%90%e8%af%ad%e5%8f%a5%e6%98%af%e5%90%a6%e8%b5%b0%e7%b4%a2%e5%bc%95%e6%9f%a5%e8%af%a2" aria-label="知道如何分析语句是否走索引查询">知道如何分析语句是否走索引查询</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#mysql%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e8%af%a6%e8%a7%a3" aria-label="MySQL事务隔离级别详解">MySQL事务隔离级别详解</a><ul>
                        
                <li>
                    <a href="#%e4%ba%8b%e5%8a%a1%e9%9a%94%e7%a6%bb%e7%ba%a7%e5%88%ab%e6%80%bb%e7%bb%93" aria-label="事务隔离级别总结">事务隔离级别总结</a></li>
                <li>
                    <a href="#%e5%ae%9e%e9%99%85%e6%83%85%e5%86%b5%e6%bc%94%e7%a4%ba" aria-label="实际情况演示">实际情况演示</a><ul>
                        
                <li>
                    <a href="#%e8%84%8f%e8%af%bb%e8%af%bb%e6%9c%aa%e6%8f%90%e4%ba%a4" aria-label="脏读(读未提交)">脏读(读未提交)</a></li>
                <li>
                    <a href="#%e9%81%bf%e5%85%8d%e8%84%8f%e8%af%bb%e8%af%bb%e5%b7%b2%e6%8f%90%e4%ba%a4" aria-label="避免脏读(读已提交)">避免脏读(读已提交)</a></li>
                <li>
                    <a href="#%e4%b8%8d%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb" aria-label="不可重复读">不可重复读</a></li>
                <li>
                    <a href="#%e5%8f%af%e9%87%8d%e5%a4%8d%e8%af%bb" aria-label="可重复读">可重复读</a></li>
                <li>
                    <a href="#%e5%b9%bb%e8%af%bb" aria-label="幻读">幻读</a><ul>
                        
                <li>
                    <a href="#%e6%bc%94%e7%a4%ba%e5%b9%bb%e8%af%bb%e5%87%ba%e7%8e%b0%e7%9a%84%e6%83%85%e5%86%b5" aria-label="演示幻读出现的情况">演示幻读出现的情况</a></li>
                <li>
                    <a href="#%e8%a7%a3%e5%86%b3%e5%b9%bb%e8%af%bb%e7%9a%84%e6%96%b9%e6%b3%95" aria-label="解决幻读的方法">解决幻读的方法</a></li></ul>
                </li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#sql%e8%af%ad%e5%8f%a5%e5%9c%a8mysql%e4%b8%ad%e7%9a%84%e6%89%a7%e8%a1%8c%e8%bf%87%e7%a8%8b" aria-label="SQL语句在MySQL中的执行过程">SQL语句在MySQL中的执行过程</a><ul>
                        
                <li>
                    <a href="#mysql-%e5%9f%ba%e7%a1%80%e6%9e%b6%e6%9e%84%e5%88%86%e6%9e%90" aria-label="MySQL 基础架构分析">MySQL 基础架构分析</a><ul>
                        
                <li>
                    <a href="#mysql-%e5%9f%ba%e6%9c%ac%e6%9e%b6%e6%9e%84%e6%a6%82%e8%a7%88" aria-label="MySQL 基本架构概览">MySQL 基本架构概览</a></li>
                <li>
                    <a href="#server-%e5%b1%82%e5%9f%ba%e6%9c%ac%e7%bb%84%e4%bb%b6%e4%bb%8b%e7%bb%8d" aria-label="Server 层基本组件介绍">Server 层基本组件介绍</a><ul>
                        
                <li>
                    <a href="#%e8%bf%9e%e6%8e%a5%e5%99%a8" aria-label="连接器">连接器</a></li>
                <li>
                    <a href="#%e6%9f%a5%e8%af%a2%e7%bc%93%e5%ad%98mysql-80-%e7%89%88%e6%9c%ac%e5%90%8e%e7%a7%bb%e9%99%a4" aria-label="查询缓存(MySQL 8.0 版本后移除)">查询缓存(MySQL 8.0 版本后移除)</a></li>
                <li>
                    <a href="#%e5%88%86%e6%9e%90%e5%99%a8" aria-label="分析器">分析器</a></li>
                <li>
                    <a href="#%e4%bc%98%e5%8c%96%e5%99%a8" aria-label="优化器">优化器</a></li>
                <li>
                    <a href="#%e6%89%a7%e8%a1%8c%e5%99%a8" aria-label="执行器">执行器</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#%e8%af%ad%e5%8f%a5%e5%88%86%e6%9e%90" aria-label="语句分析">语句分析</a><ul>
                        
                <li>
                    <a href="#%e6%9f%a5%e8%af%a2%e8%af%ad%e5%8f%a5" aria-label="查询语句">查询语句</a></li>
                <li>
                    <a href="#%e6%9b%b4%e6%96%b0%e8%af%ad%e5%8f%a5" aria-label="更新语句">更新语句</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#mysql%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92%e5%88%86%e6%9e%90" aria-label="MySQL执行计划分析">MySQL执行计划分析</a><ul>
                        
                <li>
                    <a href="#%e4%bb%80%e4%b9%88%e6%98%af%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92" aria-label="什么是执行计划？">什么是执行计划？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e8%8e%b7%e5%8f%96%e6%89%a7%e8%a1%8c%e8%ae%a1%e5%88%92" aria-label="如何获取执行计划？">如何获取执行计划？</a></li>
                <li>
                    <a href="#%e5%a6%82%e4%bd%95%e5%88%86%e6%9e%90-explain-%e7%bb%93%e6%9e%9c" aria-label="如何分析 EXPLAIN 结果？">如何分析 EXPLAIN 结果？</a><ul>
                        
                <li>
                    <a href="#id" aria-label="id">id</a></li>
                <li>
                    <a href="#select_type" aria-label="select_type">select_type</a></li>
                <li>
                    <a href="#table" aria-label="table">table</a></li>
                <li>
                    <a href="#type%e9%87%8d%e8%a6%81" aria-label="type（重要）">type（重要）</a></li>
                <li>
                    <a href="#possible_keys" aria-label="possible_keys">possible_keys</a></li>
                <li>
                    <a href="#key%e9%87%8d%e8%a6%81" aria-label="key（重要）">key（重要）</a></li>
                <li>
                    <a href="#key_len" aria-label="key_len">key_len</a></li>
                <li>
                    <a href="#rows" aria-label="rows">rows</a></li>
                <li>
                    <a href="#extra%e9%87%8d%e8%a6%81" aria-label="Extra（重要）">Extra（重要）</a></li></ul>
                </li></ul>
                </li>
                <li>
                    <a href="#mysql%e6%97%b6%e9%97%b4%e7%b1%bb%e5%9e%8b%e6%95%b0%e6%8d%ae%e5%ad%98%e5%82%a8%e5%bb%ba%e8%ae%ae" aria-label="MySQL时间类型数据存储建议">MySQL时间类型数据存储建议</a><ul>
                        
                <li>
                    <a href="#%e4%b8%8d%e8%a6%81%e7%94%a8%e5%ad%97%e7%ac%a6%e4%b8%b2%e5%ad%98%e5%82%a8%e6%97%a5%e6%9c%9f" aria-label="不要用字符串存储日期">不要用字符串存储日期</a></li>
                <li>
                    <a href="#datetime-%e5%92%8c-timestamp-%e4%b9%8b%e9%97%b4%e7%9a%84%e6%8a%89%e6%8b%a9" aria-label="Datetime 和 Timestamp 之间的抉择">Datetime 和 Timestamp 之间的抉择</a><ul>
                        
                <li>
                    <a href="#%e6%97%b6%e5%8c%ba%e4%bf%a1%e6%81%af" aria-label="时区信息">时区信息</a></li>
                <li>
                    <a href="#%e5%8d%a0%e7%94%a8%e7%a9%ba%e9%97%b4" aria-label="占用空间">占用空间</a></li>
                <li>
                    <a href="#%e8%a1%a8%e7%a4%ba%e8%8c%83%e5%9b%b4" aria-label="表示范围">表示范围</a></li>
                <li>
                    <a href="#%e6%80%a7%e8%83%bd" aria-label="性能">性能</a></li></ul>
                </li>
                <li>
                    <a href="#%e6%95%b0%e5%80%bc%e6%97%b6%e9%97%b4%e6%88%b3%e6%98%af%e6%9b%b4%e5%a5%bd%e7%9a%84%e9%80%89%e6%8b%a9%e5%90%97" aria-label="数值时间戳是更好的选择吗？">数值时间戳是更好的选择吗？</a></li>
                <li>
                    <a href="#%e6%80%bb%e7%bb%93-1" aria-label="总结">总结</a></li></ul>
                </li>
                <li>
                    <a href="#mysql%e9%9a%90%e5%bc%8f%e8%bd%ac%e6%8d%a2%e9%80%a0%e6%88%90%e7%b4%a2%e5%bc%95%e5%a4%b1%e6%95%88" aria-label="MySQL隐式转换造成索引失效">MySQL隐式转换造成索引失效</a><ul>
                        
                <li>
                    <a href="#%e6%95%b0%e6%8d%ae%e5%87%86%e5%a4%87" aria-label="数据准备">数据准备</a></li>
                <li>
                    <a href="#sql-%e6%b5%8b%e8%af%95" aria-label="SQL 测试">SQL 测试</a></li>
                <li>
                    <a href="#%e5%88%86%e6%9e%90%e5%92%8c%e6%80%bb%e7%bb%93" aria-label="分析和总结">分析和总结</a></li></ul>
                </li>
                <li>
                    <a href="#mysql%e8%87%aa%e5%a2%9e%e4%b8%bb%e9%94%ae%e4%b8%80%e5%ae%9a%e6%98%af%e8%bf%9e%e7%bb%ad%e7%9a%84%e5%90%97" aria-label="MySQL自增主键一定是连续的吗">MySQL自增主键一定是连续的吗</a><ul>
                        
                <li>
                    <a href="#%e8%87%aa%e5%a2%9e%e5%80%bc%e4%bf%9d%e5%ad%98%e5%9c%a8%e5%93%aa%e9%87%8c" aria-label="自增值保存在哪里？">自增值保存在哪里？</a></li>
                <li>
                    <a href="#%e8%87%aa%e5%a2%9e%e5%80%bc%e4%b8%8d%e8%bf%9e%e7%bb%ad%e7%9a%84%e5%9c%ba%e6%99%af" aria-label="自增值不连续的场景">自增值不连续的场景</a><ul>
                        
                <li>
                    <a href="#%e8%87%aa%e5%a2%9e%e5%80%bc%e4%b8%8d%e8%bf%9e%e7%bb%ad%e5%9c%ba%e6%99%af-1" aria-label="自增值不连续场景 1">自增值不连续场景 1</a></li>
                <li>
                    <a href="#%e8%87%aa%e5%a2%9e%e5%80%bc%e4%b8%8d%e8%bf%9e%e7%bb%ad%e5%9c%ba%e6%99%af-2" aria-label="自增值不连续场景 2">自增值不连续场景 2</a></li>
                <li>
                    <a href="#%e8%87%aa%e5%a2%9e%e5%80%bc%e4%b8%8d%e8%bf%9e%e7%bb%ad%e5%9c%ba%e6%99%af-3" aria-label="自增值不连续场景 3">自增值不连续场景 3</a></li>
                <li>
                    <a href="#%e8%87%aa%e5%a2%9e%e5%80%bc%e4%b8%8d%e8%bf%9e%e7%bb%ad%e5%9c%ba%e6%99%af-4" aria-label="自增值不连续场景 4">自增值不连续场景 4</a></li></ul>
                </li>
                <li>
                    <a href="#%e5%b0%8f%e7%bb%93" aria-label="小结">小结</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="mysql字段类型">MySQL字段类型<a hidden class="anchor" aria-hidden="true" href="#mysql字段类型">#</a></h1>
<p>MySQL 字段类型可以简单分为三大类：</p>
<ul>
<li><strong>数值类型</strong>：整型（tinyint、smallint、mediumint、int 和 bigint）、浮点型（float 和 double）、定点型（decimal）</li>
<li><strong>字符串类型</strong>：char、varchar、tinytext、text、mediumtext、longtext、tinyblob、blob、mediumblob 和 longblob 等，最常用的是 char 和 varchar 。</li>
<li><strong>日期时间类型</strong>：year、time、date、datetime 和 timestamp 等。</li>
</ul>
<h2 id="char-和-varchar-的区别是什么">char 和 varchar 的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#char-和-varchar-的区别是什么">#</a></h2>
<p>char 和 varchar 是最常用到的字符串类型，两者的主要区别在于：<strong>char 是定长字符串，varchar 是变长字符串。</strong></p>
<p>char 在存储时会在右边填充空格以达到指定的长度，检索时会去掉空格；varchar 在存储时需要使用 1 或 2 个额外字节记录字符串的长度，检索时不需要处理。</p>
<p>char 更适合存储长度较短或者长度都差不多的字符串，例如 Bcrypt 算法、MD5 算法加密后的密码、身份证号码。varchar 类型适合存储长度不确定或者差异较大的字符串，例如用户昵称、文章标题等。</p>
<p>char(M) 和 varchar(M) 的 M 都代表能够保存的字符数的最大值，无论是字母、数字还是中文，每个都只占用一个字符。</p>
<h2 id="varchar100和-varchar10的区别是什么">varchar(100)和 varchar(10)的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#varchar100和-varchar10的区别是什么">#</a></h2>
<p>varchar(100)和 varchar(10)都是变长类型，表示能存储最多 100 个字符和 10 个字符。因此，varchar (100) 可以满足更大范围的字符存储需求，有更好的业务拓展性。而 varchar(10)存储超过 10 个字符时，就需要修改表结构才可以。</p>
<p>虽说 varchar(100)和 varchar(10)能存储的字符范围不同，但二者存储相同的字符串，所占用磁盘的存储空间其实是一样的，这也是很多人容易误解的一点。</p>
<p>不过，varchar(100)会消耗更多的内存。这是因为 varchar 类型在内存中操作时，通常会分配固定大小的内存块来保存值，即使用字符类型中定义的长度。例如在进行排序的时候，varcahr(100)是按照 100 这个长度来进行的，也就会消耗更多内存。</p>
<h2 id="decimal-和-floatdouble-的区别是什么">decimal 和 float/double 的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#decimal-和-floatdouble-的区别是什么">#</a></h2>
<p>decimal 和 float 的区别是：<strong>decimal 是定点数，float/double 是浮点数。decimal 可以存储精确的小数值，float/double 只能存储近似的小数值。</strong></p>
<p>decimal 用于存储有精度要求的小数比如与金钱相关的数据，可以避免浮点数带来的精度损失。</p>
<p>在 Java 中，MySQL 的 decimal 类型对应的是 Java 类 <code>java.math.BigDecimal</code> 。</p>
<h2 id="为什么不推荐使用-text-和-blob">为什么不推荐使用 text 和 blob？<a hidden class="anchor" aria-hidden="true" href="#为什么不推荐使用-text-和-blob">#</a></h2>
<p>text 类型类似于 char（0 - 255 字节）、varchar（0 - 65 535 字节），不过其可以存储更长的字符串，也就是长文本数据，比如一篇博客的内容。</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>可存储大小</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYTEXT</td>
<td>0 - 255 字节</td>
<td>一般文本字符串</td>
</tr>
<tr>
<td>TEXT</td>
<td>0 - 65 535 字节</td>
<td>长文本字符串</td>
</tr>
<tr>
<td>MEDIUMTEXT</td>
<td>0 - 16 772 150 字节</td>
<td>较大文本数据</td>
</tr>
<tr>
<td>LONGTEXT</td>
<td>0 - 4 294 967 295 字节</td>
<td>极大文本数据</td>
</tr>
</tbody>
</table>
<p>blob 类型主要用于存储二进制大对象，例如图片，音视频等文件。</p>
<table>
<thead>
<tr>
<th><strong>类型</strong></th>
<th><strong>可存储大小</strong></th>
<th><strong>用途</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYBLOB</td>
<td>0 - 255 字节</td>
<td>短文本二进制字符串</td>
</tr>
<tr>
<td>BLOB</td>
<td>0 - 65KB</td>
<td>二进制字符串</td>
</tr>
<tr>
<td>MEDIUMBLOB</td>
<td>0 - 16MB</td>
<td>二进制形式的长文本数据</td>
</tr>
<tr>
<td>LONGBLOB</td>
<td>0 - 4GB</td>
<td>二进制形式的极大文本数据</td>
</tr>
</tbody>
</table>
<p>日常开发中，text 类型用的很少，但偶尔会用，blob 类型就属于是基本不用。如果预期长度范围 varchar 就满足，就避免使用 text。</p>
<p>数据库规范中一般不推荐使用 blob 及 text 类型，二者的部分缺点和限制如下：</p>
<ul>
<li>不能有默认值。</li>
<li>在遇到使用临时表的情况时，无法使用内存临时表，只能在磁盘上创建临时表（《高性能 MySQL》这本书有提到）。</li>
<li>检索效率比 char 和 varchar 低。</li>
<li>不能直接创建索引，需要指定前缀长度。</li>
<li>会消耗大量的网络和 IO 带宽。</li>
<li>可能会导致表上的 DML 操作都变得较慢。</li>
<li>&hellip;&hellip;</li>
</ul>
<h2 id="datetime-和-timestamp-的区别是什么">datetime 和 timestamp 的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#datetime-和-timestamp-的区别是什么">#</a></h2>
<p>DateTime 类型没有时区信息，Timestamp 和时区有关。</p>
<p>Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。</p>
<ul>
<li>DateTime：1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</li>
<li>Timestamp：1970-01-01 00:00:01 ~ 2037-12-31 23:59:59</li>
</ul>
<p>关于两者的详细对比，请参考我写的<a href="/">MySQL 时间类型数据存储建议</a>。</p>
<h2 id="null-和--的区别是什么">NULL 和 &rsquo;&rsquo; 的区别是什么？<a hidden class="anchor" aria-hidden="true" href="#null-和--的区别是什么">#</a></h2>
<p><code>NULL</code> 跟 <code>''</code>(空字符串)是两个完全不一样的值，区别如下：</p>
<ul>
<li><code>NULL</code> 代表一个不确定的值,就算是两个 <code>NULL</code>,它俩也不一定相等。例如，<code>SELECT NULL=NULL</code>的结果为 false，但是在我们使用<code>DISTINCT</code>,<code>GROUP BY</code>,<code>ORDER BY</code>时,<code>NULL</code>又被认为是相等的。</li>
<li><code>''</code>的长度是 0，是不占用空间的，而<code>NULL</code> 是需要占用空间的。</li>
<li><code>NULL</code> 会影响聚合函数的结果。例如，<code>SUM</code>、<code>AVG</code>、<code>MIN</code>、<code>MAX</code> 等聚合函数会忽略 <code>NULL</code> 值。 <code>COUNT</code> 的处理方式取决于参数的类型。如果参数是 <code>*</code>(<code>COUNT(*)</code>)，则会统计所有的记录数，包括 <code>NULL</code> 值；如果参数是某个字段名(<code>COUNT(列名)</code>)，则会忽略 <code>NULL</code> 值，只统计非空值的个数。</li>
<li>查询 <code>NULL</code> 值时，必须使用 <code>IS NULL</code> 或 <code>IS NOT NULLl</code> 来判断，而不能使用 =、!=、 &lt;、&gt; 之类的比较运算符。而<code>''</code>是可以使用这些比较运算符的。</li>
</ul>
<p>看了上面的介绍之后，相信你对另外一个高频面试题：“为什么MySQL不建议使用 <code>NULL</code> 作为列默认值？”也有了答案。</p>
<h1 id="mysql-存储引擎">MySQL 存储引擎<a hidden class="anchor" aria-hidden="true" href="#mysql-存储引擎">#</a></h1>
<h2 id="mysql-支持哪些存储引擎默认使用哪个">MySQL 支持哪些存储引擎？默认使用哪个？<a hidden class="anchor" aria-hidden="true" href="#mysql-支持哪些存储引擎默认使用哪个">#</a></h2>
<p>MySQL 支持多种存储引擎，你可以通过 <code>SHOW ENGINES</code> 命令来查看 MySQL 支持的所有存储引擎。</p>
<p>MySQL 当前默认的存储引擎是 InnoDB。并且，所有的存储引擎中只有 InnoDB 是事务性存储引擎，也就是说只有 InnoDB 支持事务。我这里使用的 MySQL 版本是 8.x，不同的 MySQL 版本之间可能会有差别。MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>
<p>你可以通过 <code>SELECT VERSION()</code> 命令查看你的 MySQL 版本。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mysql&gt; SELECT VERSION();
</span></span><span style="display:flex;"><span>+-----------+
</span></span><span style="display:flex;"><span>| VERSION() |
</span></span><span style="display:flex;"><span>+-----------+
</span></span><span style="display:flex;"><span>| 8.0.27    |
</span></span><span style="display:flex;"><span>+-----------+
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">1</span> row in <span style="color:#fff;font-weight:bold">set</span> (0.00 sec)
</span></span></code></pre></td></tr></table>
</div>
</div><p>你也可以通过 <code>SHOW VARIABLES LIKE '%storage_engine%'</code> 命令直接查看 MySQL 当前默认的存储引擎。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>mysql&gt; SHOW VARIABLES  LIKE <span style="color:#0ff;font-weight:bold">&#39;%storage_engine%&#39;</span>;
</span></span><span style="display:flex;"><span>+---------------------------------+-----------+
</span></span><span style="display:flex;"><span>| Variable_name                   | Value     |
</span></span><span style="display:flex;"><span>+---------------------------------+-----------+
</span></span><span style="display:flex;"><span>| default_storage_engine          | InnoDB    |
</span></span><span style="display:flex;"><span>| default_tmp_storage_engine      | InnoDB    |
</span></span><span style="display:flex;"><span>| disabled_storage_engines        |           |
</span></span><span style="display:flex;"><span>| internal_tmp_mem_storage_engine | TempTable |
</span></span><span style="display:flex;"><span>+---------------------------------+-----------+
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">4</span> rows in <span style="color:#fff;font-weight:bold">set</span> (0.00 sec)
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果你想要深入了解每个存储引擎以及它们之间的区别，推荐你去阅读以下 MySQL 官方文档对应的介绍(面试不会问这么细，了解即可)：</p>
<ul>
<li>InnoDB 存储引擎详细介绍：<a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html">https://dev.mysql.com/doc/refman/8.0/en/innodb-storage-engine.html</a> 。</li>
<li>其他存储引擎详细介绍：<a href="https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html">https://dev.mysql.com/doc/refman/8.0/en/storage-engines.html</a> 。</li>
</ul>
<h2 id="mysql-存储引擎架构了解吗">MySQL 存储引擎架构了解吗？<a hidden class="anchor" aria-hidden="true" href="#mysql-存储引擎架构了解吗">#</a></h2>
<p>MySQL 存储引擎采用的是 <strong>插件式架构</strong> ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p>
<p>并且，你还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。这些非官方提供的存储引擎可以称为第三方存储引擎，区别于官方存储引擎。像目前最常用的 InnoDB 其实刚开始就是一个第三方存储引擎，后面由于过于优秀，其被 Oracle 直接收购了。</p>
<p>MySQL 官方文档也有介绍到如何编写一个自定义存储引擎，地址：<a href="https://dev.mysql.com/doc/internals/en/custom-engine.html">https://dev.mysql.com/doc/internals/en/custom-engine.html</a> 。</p>
<h2 id="myisam-和-innodb-有什么区别">MyISAM 和 InnoDB 有什么区别？<a hidden class="anchor" aria-hidden="true" href="#myisam-和-innodb-有什么区别">#</a></h2>
<p>MySQL 5.5 之前，MyISAM 引擎是 MySQL 的默认存储引擎，可谓是风光一时。</p>
<p>虽然，MyISAM 的性能还行，各种特性也还不错（比如全文索引、压缩、空间函数等）。但是，MyISAM 不支持事务和行级锁，而且最大的缺陷就是崩溃后无法安全恢复。</p>
<p>MySQL 5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p>
<p>言归正传！咱们下面还是来简单对比一下两者：</p>
<p><strong>1.是否支持行级锁</strong></p>
<p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p>
<p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下是多么滴憨憨啊！这也是为什么 InnoDB 在并发写的时候，性能更牛皮了！</p>
<p><strong>2.是否支持事务</strong></p>
<p>MyISAM 不提供事务支持。</p>
<p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p>
<p>关于 MySQL 事务的详细介绍，可以看看我写的这篇文章：<a href="/">MySQL 事务隔离级别详解</a>。</p>
<p><strong>3.是否支持外键</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，我们是不建议在实际生产项目中使用外键的，在业务代码中进行约束即可！</p>
<p>阿里的《Java 开发手册》也是明确规定禁止使用外键的。</p>
<p>不过，在代码中进行约束的话，对程序员的能力要求更高，具体是否要采用外键还是要根据你的项目实际情况而定。</p>
<p>总结：一般我们也是不建议在数据库层面使用外键的，应用层面可以解决。不过，这样会对数据的一致性造成威胁。具体要不要使用外键还是要根据你的项目来决定。</p>
<p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p>
<p><strong>5.是否支持 MVCC</strong></p>
<p>MyISAM 不支持，而 InnoDB 支持。</p>
<p>讲真，这个对比有点废话，毕竟 MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p>
<p><strong>6.索引实现不一样。</strong></p>
<p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p>
<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p>
<p>详细区别，推荐你看看我写的这篇文章：<a href="/">MySQL 索引详解</a>。</p>
<p><strong>7.性能有差别。</strong></p>
<p>InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。</p>
<p><strong>总结</strong>：</p>
<ul>
<li>InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li>
<li>MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li>
<li>MyISAM 不支持外键，而 InnoDB 支持。</li>
<li>MyISAM 不支持 MVCC，而 InnoDB 支持。</li>
<li>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li>
<li>MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li>
<li>InnoDB 的性能比 MyISAM 更强大。</li>
</ul>
<h2 id="myisam-和-innodb-如何选择">MyISAM 和 InnoDB 如何选择？<a hidden class="anchor" aria-hidden="true" href="#myisam-和-innodb-如何选择">#</a></h2>
<p>大多数时候我们使用的都是 InnoDB 存储引擎，在某些读密集的情况下，使用 MyISAM 也是合适的。不过，前提是你的项目不介意 MyISAM 不支持事务、崩溃恢复等缺点（可是~我们一般都会介意啊！）。</p>
<p>《MySQL 高性能》上面有一句话这样写到:</p>
<blockquote>
<p>不要轻易相信“MyISAM 比 InnoDB 快”之类的经验之谈，这个结论往往不是绝对的。在很多我们已知场景中，InnoDB 的速度都可以让 MyISAM 望尘莫及，尤其是用到了聚簇索引，或者需要访问的数据都可以放入内存的应用。</p>
</blockquote>
<p>一般情况下我们选择 InnoDB 都是没有问题的，但是某些情况下你并不在乎可扩展能力和并发能力，也不需要事务支持，也不在乎崩溃后的安全恢复问题的话，选择 MyISAM 也是一个不错的选择。但是一般情况下，我们都是需要考虑到这些问题的。</p>
<p>因此，对于咱们日常开发的业务系统来说，你几乎找不到什么理由再使用 MyISAM 作为自己的 MySQL 数据库的存储引擎。</p>
<h1 id="mysql-查询缓存">MySQL 查询缓存<a hidden class="anchor" aria-hidden="true" href="#mysql-查询缓存">#</a></h1>
<p>执行查询语句的时候，会先查询缓存。不过，MySQL 8.0 版本后移除，因为这个功能不太实用</p>
<p><code>my.cnf</code> 加入以下配置，重启 MySQL 开启查询缓存</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-properties" data-lang="properties"><span style="display:flex;"><span><span style="color:#007f7f">query_cache_type</span>=<span style="color:#0ff;font-weight:bold">1</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">query_cache_size</span>=<span style="color:#0ff;font-weight:bold">600000</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>MySQL 执行以下命令也可以开启查询缓存</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-properties" data-lang="properties"><span style="display:flex;"><span><span style="color:#007f7f">set</span> <span style="color:#0ff;font-weight:bold">global  query_cache_type=1;</span>
</span></span><span style="display:flex;"><span><span style="color:#007f7f">set</span> <span style="color:#0ff;font-weight:bold">global  query_cache_size=600000;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如上，<strong>开启查询缓存后在同样的查询条件以及数据情况下，会直接在缓存中返回结果</strong>。这里的查询条件包括查询本身、当前要查询的数据库、客户端协议版本号等一些可能影响结果的信息。</p>
<p><strong>查询缓存不命中的情况：</strong></p>
<ol>
<li>任何两个查询在任何字符上的不同都会导致缓存不命中。</li>
<li>如果查询中包含任何用户自定义函数、存储函数、用户变量、临时表、MySQL 库中的系统表，其查询结果也不会被缓存。</li>
<li>缓存建立之后，MySQL 的查询缓存系统会跟踪查询中涉及的每张表，如果这些表（数据或结构）发生变化，那么和这张表相关的所有缓存数据都将失效。</li>
</ol>
<p><strong>缓存虽然能够提升数据库的查询性能，但是缓存同时也带来了额外的开销，每次查询后都要做一次缓存操作，失效后还要销毁。</strong> 因此，开启查询缓存要谨慎，尤其对于写密集的应用来说更是如此。如果开启，要注意合理控制缓存空间大小，一般来说其大小设置为几十 MB 比较合适。此外，<strong>还可以通过 <code>sql_cache</code> 和 <code>sql_no_cache</code> 来控制某个查询语句是否需要缓存：</strong></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SELECT</span> sql_no_cache <span style="color:#fff;font-weight:bold">COUNT</span>(*) <span style="color:#fff;font-weight:bold">FROM</span> usr;
</span></span></code></pre></td></tr></table>
</div>
</div><h1 id="mysql-事务">MySQL 事务<a hidden class="anchor" aria-hidden="true" href="#mysql-事务">#</a></h1>
<h2 id="何谓事务">何谓事务？<a hidden class="anchor" aria-hidden="true" href="#何谓事务">#</a></h2>
<p>我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：</p>
<ul>
<li>数据库中途突然因为某些原因挂掉了。</li>
<li>客户端突然因为网络原因连接不上数据库了。</li>
<li>并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。</li>
<li>&hellip;&hellip;</li>
</ul>
<p>上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。事务的概念起源于数据库，目前，已经成为一个比较广泛的概念。</p>
<p><strong>何为事务？</strong> 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p>
<p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。</p>
<ol>
<li>将小明的余额减少 1000 元</li>
<li>将小红的余额增加 1000 元。</li>
</ol>
<p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p>
<h2 id="何谓数据库事务">何谓数据库事务？<a hidden class="anchor" aria-hidden="true" href="#何谓数据库事务">#</a></h2>
<p>大多数情况下，我们在谈论事务的时候，如果没有特指<strong>分布式事务</strong>，往往指的就是<strong>数据库事务</strong>。</p>
<p>数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。</p>
<p><strong>那数据库事务有什么作用呢？</strong></p>
<p>简单来说，数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span># <span style="color:#f00">开启一个事务</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">START</span> <span style="color:#fff;font-weight:bold">TRANSACTION</span>;
</span></span><span style="display:flex;"><span># <span style="color:#f00">多条</span> <span style="color:#fff;font-weight:bold">SQL</span> <span style="color:#f00">语句</span>
</span></span><span style="display:flex;"><span>SQL1,SQL2...
</span></span><span style="display:flex;"><span>## <span style="color:#f00">提交事务</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">COMMIT</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><p>另外，关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code> 等）事务都有 <strong>ACID</strong> 特性：</p>
<p><strong>原子性</strong>（<code>Atomicity</code>）：事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</p>
<p><strong>一致性</strong>（<code>Consistency</code>）：执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</p>
<p><strong>隔离性</strong>（<code>Isolation</code>）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</p>
<p><strong>持久性</strong>（<code>Durability</code>）：一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p>
<p>这里要额外补充一点：<strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的！</strong> 想必大家也和我一样，被 ACID 这个概念被误导了很久! 我也是看周志明老师的公开课<a href="https://time.geekbang.org/opencourse/intro/100064201">《周志明的软件架构课》</a>才搞清楚的。</p>
<h2 id="并发事务带来了哪些问题">并发事务带来了哪些问题?<a hidden class="anchor" aria-hidden="true" href="#并发事务带来了哪些问题">#</a></h2>
<p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<h3 id="脏读dirty-read">脏读（Dirty read）<a hidden class="anchor" aria-hidden="true" href="#脏读dirty-read">#</a></h3>
<p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p>
<p>例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19，事务1回滚导致对A的修改并未提交到数据库， A 的值还是 20。</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/%E8%84%8F%E8%AF%BB.png"></p>
<h3 id="丢失修改lost-to-modify">丢失修改（Lost to modify）<a hidden class="anchor" aria-hidden="true" href="#丢失修改lost-to-modify">#</a></h3>
<p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p>
<p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%B8%A2%E5%A4%B1%E4%BF%AE%E6%94%B9.png"></p>
<h3 id="不可重复读unrepeatable-read">不可重复读（Unrepeatable read）<a hidden class="anchor" aria-hidden="true" href="#不可重复读unrepeatable-read">#</a></h3>
<p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p>
<p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.png"></p>
<h3 id="幻读phantom-read">幻读（Phantom read）<a hidden class="anchor" aria-hidden="true" href="#幻读phantom-read">#</a></h3>
<p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p>
<p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/%E5%B9%BB%E8%AF%BB.png"></p>
<h2 id="不可重复读和幻读有什么区别">不可重复读和幻读有什么区别？<a hidden class="anchor" aria-hidden="true" href="#不可重复读和幻读有什么区别">#</a></h2>
<ul>
<li>不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li>
<li>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li>
</ul>
<p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p>
<p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p>
<h2 id="并发事务的控制方式有哪些">并发事务的控制方式有哪些？<a hidden class="anchor" aria-hidden="true" href="#并发事务的控制方式有哪些">#</a></h2>
<p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p>
<p><strong>锁</strong> 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p>
<ul>
<li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>
<li><strong>排他锁（X 锁）</strong>：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li>
</ul>
<p>读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 <strong>表级锁(table-level locking)</strong> 和 <strong>行级锁(row-level locking)</strong> 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</p>
<p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p>
<p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p>
<ul>
<li>undo log : undo log 用于记录某行数据的多个版本的数据。</li>
<li>read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</li>
</ul>
<p>关于 InnoDB 对 MVCC 的具体实现可以看这篇文章：<a href="/">InnoDB 存储引擎对 MVCC 的实现</a> 。</p>
<h2 id="sql-标准定义了哪些事务隔离级别">SQL 标准定义了哪些事务隔离级别?<a hidden class="anchor" aria-hidden="true" href="#sql-标准定义了哪些事务隔离级别">#</a></h2>
<p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)</strong>：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><strong>READ-COMMITTED(读取已提交)</strong>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><strong>REPEATABLE-READ(可重复读)</strong>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>SERIALIZABLE(可串行化)</strong>：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">READ-UNCOMMITTED</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">READ-COMMITTED</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">REPEATABLE-READ</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">SERIALIZABLE</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<h2 id="mysql-的隔离级别是基于锁实现的吗">MySQL 的隔离级别是基于锁实现的吗？<a hidden class="anchor" aria-hidden="true" href="#mysql-的隔离级别是基于锁实现的吗">#</a></h2>
<p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p>
<p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p>
<h2 id="mysql-的默认隔离级别是什么">MySQL 的默认隔离级别是什么?<a hidden class="anchor" aria-hidden="true" href="#mysql-的默认隔离级别是什么">#</a></h2>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>mysql&gt; <span style="color:#fff;font-weight:bold">SELECT</span> @@tx_isolation;
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">-----------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>| @@tx_isolation  |
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">-----------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>| <span style="color:#fff;font-weight:bold">REPEATABLE</span>-<span style="color:#fff;font-weight:bold">READ</span> |
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">-----------------+
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>关于 MySQL 事务隔离级别的详细介绍，可以看看我写的这篇文章：<a href="/">MySQL 事务隔离级别详解</a></p>
<h1 id="mysql锁">MySQL锁<a hidden class="anchor" aria-hidden="true" href="#mysql锁">#</a></h1>
<h2 id="表级锁和行级锁了解吗有什么区别">表级锁和行级锁了解吗？有什么区别？<a hidden class="anchor" aria-hidden="true" href="#表级锁和行级锁了解吗有什么区别">#</a></h2>
<p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。</p>
<p>行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p>
<p><strong>表级锁和行级锁对比</strong>：</p>
<ul>
<li><strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</li>
<li><strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</li>
</ul>
<h2 id="行级锁的使用有什么注意事项">行级锁的使用有什么注意事项？<a hidden class="anchor" aria-hidden="true" href="#行级锁的使用有什么注意事项">#</a></h2>
<p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！！！</p>
<p>不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p>
<h2 id="innodb-有哪几类行锁">InnoDB 有哪几类行锁？<a hidden class="anchor" aria-hidden="true" href="#innodb-有哪几类行锁">#</a></h2>
<p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p>
<ul>
<li><strong>记录锁（Record Lock）</strong>：也被称为记录锁，属于单个行记录上的锁。</li>
<li><strong>间隙锁（Gap Lock）</strong>：锁定一个范围，不包括记录本身。</li>
<li><strong>临键锁（Next-Key Lock）</strong>：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li>
</ul>
<p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p>
<p>一些大厂面试中可能会问到 Next-Key Lock 的加锁范围，这里推荐一篇文章：<a href="https://segmentfault.com/a/1190000040129107">MySQL next-key lock 加锁范围是什么？ - 程序员小航 - 2021</a> 。</p>
<h2 id="共享锁和排他锁呢">共享锁和排他锁呢？<a hidden class="anchor" aria-hidden="true" href="#共享锁和排他锁呢">#</a></h2>
<p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p>
<ul>
<li><strong>共享锁（S 锁）</strong>：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li>
<li><strong>排他锁（X 锁）</strong>：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li>
</ul>
<p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p>
<table>
<thead>
<tr>
<th style="text-align:left"></th>
<th style="text-align:left">S 锁</th>
<th style="text-align:left">X 锁</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">S 锁</td>
<td style="text-align:left">不冲突</td>
<td style="text-align:left">冲突</td>
</tr>
<tr>
<td style="text-align:left">X 锁</td>
<td style="text-align:left">冲突</td>
<td style="text-align:left">冲突</td>
</tr>
</tbody>
</table>
<p>由于 MVCC 的存在，对于一般的 <code>SELECT</code> 语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span># <span style="color:#f00">共享锁</span> <span style="color:#f00">可以在</span> MySQL <span style="color:#ff0;font-weight:bold">5</span>.<span style="color:#ff0;font-weight:bold">7</span> <span style="color:#f00">和</span> MySQL <span style="color:#ff0;font-weight:bold">8</span>.<span style="color:#ff0;font-weight:bold">0</span> <span style="color:#f00">中使用</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SELECT</span> ... <span style="color:#fff;font-weight:bold">LOCK</span> <span style="color:#fff;font-weight:bold">IN</span> <span style="color:#fff;font-weight:bold">SHARE</span> <span style="color:#fff;font-weight:bold">MODE</span>;
</span></span><span style="display:flex;"><span># <span style="color:#f00">共享锁</span> <span style="color:#f00">可以在</span> MySQL <span style="color:#ff0;font-weight:bold">8</span>.<span style="color:#ff0;font-weight:bold">0</span> <span style="color:#f00">中使用</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SELECT</span> ... <span style="color:#fff;font-weight:bold">FOR</span> <span style="color:#fff;font-weight:bold">SHARE</span>;
</span></span><span style="display:flex;"><span># <span style="color:#f00">排他锁</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SELECT</span> ... <span style="color:#fff;font-weight:bold">FOR</span> <span style="color:#fff;font-weight:bold">UPDATE</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="意向锁有什么作用">意向锁有什么作用？<a hidden class="anchor" aria-hidden="true" href="#意向锁有什么作用">#</a></h2>
<p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东东来快速判断是否可以对某个表使用表锁。</p>
<p>意向锁是表级锁，共有两种：</p>
<ul>
<li><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li>
<li><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li>
</ul>
<p><strong>意向锁是由数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</strong></p>
<p>意向锁之间是互相兼容的。</p>
<table>
<thead>
<tr>
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>IS 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
<tr>
<td>IX 锁</td>
<td>兼容</td>
<td>兼容</td>
</tr>
</tbody>
</table>
<p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p>
<table>
<thead>
<tr>
<th></th>
<th>IS 锁</th>
<th>IX 锁</th>
</tr>
</thead>
<tbody>
<tr>
<td>S 锁</td>
<td>兼容</td>
<td>互斥</td>
</tr>
<tr>
<td>X 锁</td>
<td>互斥</td>
<td>互斥</td>
</tr>
</tbody>
</table>
<h2 id="当前读和快照读有什么区别">当前读和快照读有什么区别？<a hidden class="anchor" aria-hidden="true" href="#当前读和快照读有什么区别">#</a></h2>
<p><strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句，但不包括下面这两类 <code>SELECT</code> 语句：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SELECT</span> ... <span style="color:#fff;font-weight:bold">FOR</span> <span style="color:#fff;font-weight:bold">UPDATE</span>
</span></span><span style="display:flex;"><span># <span style="color:#f00">共享锁</span> <span style="color:#f00">可以在</span> MySQL <span style="color:#ff0;font-weight:bold">5</span>.<span style="color:#ff0;font-weight:bold">7</span> <span style="color:#f00">和</span> MySQL <span style="color:#ff0;font-weight:bold">8</span>.<span style="color:#ff0;font-weight:bold">0</span> <span style="color:#f00">中使用</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SELECT</span> ... <span style="color:#fff;font-weight:bold">LOCK</span> <span style="color:#fff;font-weight:bold">IN</span> <span style="color:#fff;font-weight:bold">SHARE</span> <span style="color:#fff;font-weight:bold">MODE</span>;
</span></span><span style="display:flex;"><span># <span style="color:#f00">共享锁</span> <span style="color:#f00">可以在</span> MySQL <span style="color:#ff0;font-weight:bold">8</span>.<span style="color:#ff0;font-weight:bold">0</span> <span style="color:#f00">中使用</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SELECT</span> ... <span style="color:#fff;font-weight:bold">FOR</span> <span style="color:#fff;font-weight:bold">SHARE</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p>
<p>快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p>
<p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p>
<ul>
<li>在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li>
<li>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li>
</ul>
<p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p>
<p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p>
<p>当前读的一些常见 SQL 语句类型如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span># <span style="color:#f00">对读的记录加一个</span>X锁
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SELECT</span>...<span style="color:#fff;font-weight:bold">FOR</span> <span style="color:#fff;font-weight:bold">UPDATE</span>
</span></span><span style="display:flex;"><span># <span style="color:#f00">对读的记录加一个</span>S锁
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SELECT</span>...<span style="color:#fff;font-weight:bold">LOCK</span> <span style="color:#fff;font-weight:bold">IN</span> <span style="color:#fff;font-weight:bold">SHARE</span> <span style="color:#fff;font-weight:bold">MODE</span>
</span></span><span style="display:flex;"><span># <span style="color:#f00">对读的记录加一个</span>S锁
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SELECT</span>...<span style="color:#fff;font-weight:bold">FOR</span> <span style="color:#fff;font-weight:bold">SHARE</span>
</span></span><span style="display:flex;"><span># <span style="color:#f00">对修改的记录加一个</span>X锁
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">INSERT</span>...
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">UPDATE</span>...
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">DELETE</span>...
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="自增锁有了解吗">自增锁有了解吗？<a hidden class="anchor" aria-hidden="true" href="#自增锁有了解吗">#</a></h2>
<blockquote>
<p>不太重要的一个知识点，简单了解即可。</p>
</blockquote>
<p>关系型数据库设计表的时候，通常会有一列作为自增主键。InnoDB 中的自增主键会涉及一种比较特殊的表级锁— <strong>自增锁（AUTO-INC Locks）</strong> 。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">CREATE</span> <span style="color:#fff;font-weight:bold">TABLE</span> `sequence_id` (
</span></span><span style="display:flex;"><span>  `id` <span style="color:#fff;font-weight:bold">bigint</span>(<span style="color:#ff0;font-weight:bold">20</span>) unsigned <span style="color:#fff;font-weight:bold">NOT</span> <span style="color:#fff;font-weight:bold">NULL</span> AUTO_INCREMENT,
</span></span><span style="display:flex;"><span>  `stub` <span style="color:#fff;font-weight:bold">char</span>(<span style="color:#ff0;font-weight:bold">10</span>) <span style="color:#fff;font-weight:bold">NOT</span> <span style="color:#fff;font-weight:bold">NULL</span> <span style="color:#fff;font-weight:bold">DEFAULT</span> <span style="color:#0ff;font-weight:bold">&#39;&#39;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">PRIMARY</span> <span style="color:#fff;font-weight:bold">KEY</span> (`id`),
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">UNIQUE</span> <span style="color:#fff;font-weight:bold">KEY</span> `stub` (`stub`)
</span></span><span style="display:flex;"><span>) ENGINE=InnoDB <span style="color:#fff;font-weight:bold">DEFAULT</span> CHARSET=utf8mb4;
</span></span></code></pre></td></tr></table>
</div>
</div><p>更准确点来说，不仅仅是自增主键，<code>AUTO_INCREMENT</code>的列都会涉及到自增锁，毕竟非主键也可以设置自增长。</p>
<p>如果一个事务正在插入数据到有自增列的表时，会先获取自增锁，拿不到就可能会被阻塞住。这里的阻塞行为只是自增锁行为的其中一种，可以理解为自增锁就是一个接口，其具体的实现有多种。具体的配置项为 <code>innodb_autoinc_lock_mode</code> （MySQL 5.1.22 引入），可以选择的值如下：</p>
<table>
<thead>
<tr>
<th style="text-align:left">innodb_autoinc_lock_mode</th>
<th style="text-align:left">介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">0</td>
<td style="text-align:left">传统模式</td>
</tr>
<tr>
<td style="text-align:left">1</td>
<td style="text-align:left">连续模式（MySQL 8.0 之前默认）</td>
</tr>
<tr>
<td style="text-align:left">2</td>
<td style="text-align:left">交错模式(MySQL 8.0 之后默认)</td>
</tr>
</tbody>
</table>
<p>交错模式下，所有的“INSERT-LIKE”语句（所有的插入语句，包括：<code>INSERT</code>、<code>REPLACE</code>、<code>INSERT…SELECT</code>、<code>REPLACE…SELECT</code>、<code>LOAD DATA</code>等）都不使用表级锁，使用的是轻量级互斥锁实现，多条插入语句可以并发执行，速度更快，扩展性也更好。</p>
<p>不过，如果你的 MySQL 数据库有主从同步需求并且 Binlog 存储格式为 Statement 的话，不要将 InnoDB 自增锁模式设置为交叉模式，不然会有数据不一致性问题。这是因为并发情况下插入语句的执行顺序就无法得到保障。</p>
<blockquote>
<p>如果 MySQL 采用的格式为 Statement ，那么 MySQL 的主从同步实际上同步的就是一条一条的 SQL 语句。</p>
</blockquote>
<h1 id="mysql-性能优化">MySQL 性能优化<a hidden class="anchor" aria-hidden="true" href="#mysql-性能优化">#</a></h1>
<h2 id="能用-mysql-直接存储文件比如图片吗">能用 MySQL 直接存储文件（比如图片）吗？<a hidden class="anchor" aria-hidden="true" href="#能用-mysql-直接存储文件比如图片吗">#</a></h2>
<p>可以是可以，直接存储文件对应的二进制数据即可。不过，还是建议不要在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。</p>
<p>可以选择使用云服务厂商提供的开箱即用的文件存储服务，成熟稳定，价格也比较低。</p>
<p>也可以选择自建文件存储服务，实现起来也不难，基于 FastDFS、MinIO（推荐） 等开源项目就可以实现分布式文件服务。</p>
<p><strong>数据库只存储文件地址信息，文件由文件存储服务负责存储。</strong></p>
<h2 id="mysql-如何存储-ip-地址">MySQL 如何存储 IP 地址？<a hidden class="anchor" aria-hidden="true" href="#mysql-如何存储-ip-地址">#</a></h2>
<p>可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。</p>
<p>MySQL 提供了两个方法来处理 ip 地址</p>
<ul>
<li><code>INET_ATON()</code>：把 ip 转为无符号整型 (4-8 位)</li>
<li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li>
</ul>
<p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p>
<h2 id="如何分析-sql-的性能">如何分析 SQL 的性能？<a hidden class="anchor" aria-hidden="true" href="#如何分析-sql-的性能">#</a></h2>
<p>我们可以使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong>执行计划</strong> 。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p>
<p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>
<p><code>EXPLAIN</code> 适用于 <code>SELECT</code>, <code>DELETE</code>, <code>INSERT</code>, <code>REPLACE</code>, 和 <code>UPDATE</code>语句，我们一般分析 <code>SELECT</code> 查询较多。</p>
<p>我们这里简单来演示一下 <code>EXPLAIN</code> 的使用。</p>
<p><code>EXPLAIN</code> 的输出格式如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>mysql&gt; <span style="color:#fff;font-weight:bold">EXPLAIN</span> <span style="color:#fff;font-weight:bold">SELECT</span> `score`,`name` <span style="color:#fff;font-weight:bold">FROM</span> `cus_order` <span style="color:#fff;font-weight:bold">ORDER</span> <span style="color:#fff;font-weight:bold">BY</span> `score` <span style="color:#fff;font-weight:bold">DESC</span>;
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>| id | select_type | <span style="color:#fff;font-weight:bold">table</span>     | partitions | <span style="color:#fff;font-weight:bold">type</span> | possible_keys | <span style="color:#fff;font-weight:bold">key</span>  | key_len | <span style="color:#fff;font-weight:bold">ref</span>  | <span style="color:#fff;font-weight:bold">rows</span>   | filtered | Extra          |
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>|  <span style="color:#ff0;font-weight:bold">1</span> | <span style="color:#fff;font-weight:bold">SIMPLE</span>      | cus_order | <span style="color:#fff;font-weight:bold">NULL</span>       | <span style="color:#fff;font-weight:bold">ALL</span>  | <span style="color:#fff;font-weight:bold">NULL</span>          | <span style="color:#fff;font-weight:bold">NULL</span> | <span style="color:#fff;font-weight:bold">NULL</span>    | <span style="color:#fff;font-weight:bold">NULL</span> | <span style="color:#ff0;font-weight:bold">997572</span> |   <span style="color:#ff0;font-weight:bold">100</span>.<span style="color:#ff0;font-weight:bold">00</span> | <span style="color:#fff;font-weight:bold">Using</span> filesort |
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#ff0;font-weight:bold">1</span> <span style="color:#fff;font-weight:bold">row</span> <span style="color:#fff;font-weight:bold">in</span> <span style="color:#fff;font-weight:bold">set</span>, <span style="color:#ff0;font-weight:bold">1</span> warning (<span style="color:#ff0;font-weight:bold">0</span>.<span style="color:#ff0;font-weight:bold">00</span> sec)
</span></span></code></pre></td></tr></table>
</div>
</div><p>各个字段的含义如下：</p>
<table>
<thead>
<tr>
<th><strong>列名</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>SELECT 查询的序列标识符</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT 关键字对应的查询类型</td>
</tr>
<tr>
<td>table</td>
<td>用到的表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区，对于未分区的表，值为 NULL</td>
</tr>
<tr>
<td>type</td>
<td>表的访问方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际用到的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>所选索引的长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引等值查询时，与索引作比较的列或常量</td>
</tr>
<tr>
<td>rows</td>
<td>预计要读取的行数</td>
</tr>
<tr>
<td>filtered</td>
<td>按表条件过滤后，留存的记录数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>附加信息</td>
</tr>
</tbody>
</table>
<h2 id="数据库命名规范">数据库命名规范<a hidden class="anchor" aria-hidden="true" href="#数据库命名规范">#</a></h2>
<ul>
<li>所有数据库对象名称必须使用小写字母并用下划线分割</li>
<li>所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li>
<li>数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li>
<li>临时库表必须以 <code>tmp_</code> 为前缀并以日期为后缀，备份表必须以 <code>bak_</code> 为前缀并以日期 (时间戳) 为后缀</li>
<li>所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li>
</ul>
<h2 id="数据库基本设计规范">数据库基本设计规范<a hidden class="anchor" aria-hidden="true" href="#数据库基本设计规范">#</a></h2>
<h3 id="所有表必须使用-innodb-存储引擎">所有表必须使用 InnoDB 存储引擎<a hidden class="anchor" aria-hidden="true" href="#所有表必须使用-innodb-存储引擎">#</a></h3>
<p>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）。</p>
<p>InnoDB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p>
<h3 id="数据库和表的字符集统一使用-utf8">数据库和表的字符集统一使用 UTF8<a hidden class="anchor" aria-hidden="true" href="#数据库和表的字符集统一使用-utf8">#</a></h3>
<p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p>
<p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/horses/article/details/107243447">MySQL 字符集不一致导致索引失效的一个真实案例</a></li>
<li><a href="/">MySQL 字符集详解</a></li>
</ul>
<h3 id="所有表和字段都需要添加注释">所有表和字段都需要添加注释<a hidden class="anchor" aria-hidden="true" href="#所有表和字段都需要添加注释">#</a></h3>
<p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p>
<h3 id="尽量控制单表数据量的大小建议控制在-500-万以内">尽量控制单表数据量的大小，建议控制在 500 万以内<a hidden class="anchor" aria-hidden="true" href="#尽量控制单表数据量的大小建议控制在-500-万以内">#</a></h3>
<p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p>
<p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p>
<h3 id="谨慎使用-mysql-分区表">谨慎使用 MySQL 分区表<a hidden class="anchor" aria-hidden="true" href="#谨慎使用-mysql-分区表">#</a></h3>
<p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p>
<p>谨慎选择分区键，跨分区查询效率可能更低；</p>
<p>建议采用物理分表的方式管理大数据。</p>
<h3 id="经常一起使用的列放到一个表中">经常一起使用的列放到一个表中<a hidden class="anchor" aria-hidden="true" href="#经常一起使用的列放到一个表中">#</a></h3>
<p>避免更多的关联操作。</p>
<h3 id="禁止在表中建立预留字段">禁止在表中建立预留字段<a hidden class="anchor" aria-hidden="true" href="#禁止在表中建立预留字段">#</a></h3>
<ul>
<li>预留字段的命名很难做到见名识义。</li>
<li>预留字段无法确认存储的数据类型，所以无法选择合适的类型。</li>
<li>对预留字段类型的修改，会对表进行锁定。</li>
</ul>
<h3 id="禁止在数据库中存储文件比如图片这类大的二进制数据">禁止在数据库中存储文件（比如图片）这类大的二进制数据<a hidden class="anchor" aria-hidden="true" href="#禁止在数据库中存储文件比如图片这类大的二进制数据">#</a></h3>
<p>在数据库中存储文件会严重影响数据库性能，消耗过多存储空间。</p>
<p>文件（比如图片）这类大的二进制数据通常存储于文件服务器，数据库只存储文件地址信息。</p>
<h3 id="不要被数据库范式所束缚">不要被数据库范式所束缚<a hidden class="anchor" aria-hidden="true" href="#不要被数据库范式所束缚">#</a></h3>
<p>一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度。</p>
<h3 id="禁止在线上做数据库压力测试">禁止在线上做数据库压力测试<a hidden class="anchor" aria-hidden="true" href="#禁止在线上做数据库压力测试">#</a></h3>
<h3 id="禁止从开发环境测试环境直接连接生产环境数据库">禁止从开发环境,测试环境直接连接生产环境数据库<a hidden class="anchor" aria-hidden="true" href="#禁止从开发环境测试环境直接连接生产环境数据库">#</a></h3>
<p>安全隐患极大，要对生产环境抱有敬畏之心！</p>
<h2 id="数据库字段设计规范">数据库字段设计规范<a hidden class="anchor" aria-hidden="true" href="#数据库字段设计规范">#</a></h2>
<h3 id="优先选择符合存储需要的最小的数据类型">优先选择符合存储需要的最小的数据类型<a hidden class="anchor" aria-hidden="true" href="#优先选择符合存储需要的最小的数据类型">#</a></h3>
<p>存储字节越小，占用也就空间越小，性能也越好。</p>
<p><strong>a.某些字符串可以转换成数字类型存储比如可以将 IP 地址转换成整型数据。</strong></p>
<p>数字是连续的，性能更好，占用空间也更小。</p>
<p>MySQL 提供了两个方法来处理 ip 地址</p>
<ul>
<li><code>INET_ATON()</code>：把 ip 转为无符号整型 (4-8 位)</li>
<li><code>INET_NTOA()</code> :把整型的 ip 转为地址</li>
</ul>
<p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p>
<p><strong>b.对于非负型的数据 (如自增 ID,整型 IP，年龄) 来说,要优先使用无符号整型来存储。</strong></p>
<p>无符号相对于有符号可以多出一倍的存储空间</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>SIGNED <span style="color:#fff;font-weight:bold">INT</span> -<span style="color:#ff0;font-weight:bold">2147483648</span>~<span style="color:#ff0;font-weight:bold">2147483647</span>
</span></span><span style="display:flex;"><span>UNSIGNED <span style="color:#fff;font-weight:bold">INT</span> <span style="color:#ff0;font-weight:bold">0</span>~<span style="color:#ff0;font-weight:bold">4294967295</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>c.小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型。</strong></p>
<h3 id="避免使用-textblob-数据类型最常见的-text-类型可以存储-64k-的数据">避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据<a hidden class="anchor" aria-hidden="true" href="#避免使用-textblob-数据类型最常见的-text-类型可以存储-64k-的数据">#</a></h3>
<p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。</strong></p>
<p>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p>
<p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 <code>select *</code>而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p>
<p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p>
<p>因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p>
<h3 id="避免使用-enum-类型">避免使用 ENUM 类型<a hidden class="anchor" aria-hidden="true" href="#避免使用-enum-类型">#</a></h3>
<ul>
<li>修改 ENUM 值需要使用 ALTER 语句；</li>
<li>ENUM 类型的 ORDER BY 操作效率低，需要额外操作；</li>
<li>ENUM 数据类型存在一些限制比如建议不要使用数值作为 ENUM 的枚举值。</li>
</ul>
<p>相关阅读：<a href="https://www.zhihu.com/question/404422255/answer/1661698499">是否推荐使用 MySQL 的 enum 类型？ - 架构文摘 - 知乎</a> 。</p>
<h3 id="尽可能把所有列定义为-not-null">尽可能把所有列定义为 NOT NULL<a hidden class="anchor" aria-hidden="true" href="#尽可能把所有列定义为-not-null">#</a></h3>
<p>除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。</p>
<ul>
<li>索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；</li>
<li>进行比较和计算时要对 NULL 值做特别的处理。</li>
</ul>
<p>相关阅读：<a href="https://opensource.actionsky.com/20190710-mysql/">技术分享 | MySQL 默认值选型（是空，还是 NULL）</a> 。</p>
<h3 id="使用-timestamp4-个字节-或-datetime-类型-8-个字节-存储时间">使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间<a hidden class="anchor" aria-hidden="true" href="#使用-timestamp4-个字节-或-datetime-类型-8-个字节-存储时间">#</a></h3>
<p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p>
<p>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高</p>
<p>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p>
<p><strong>经常会有人用字符串存储日期型的数据（不正确的做法）</strong></p>
<ul>
<li>缺点 1：无法用日期函数进行计算和比较</li>
<li>缺点 2：用字符串存储日期要占用更多的空间</li>
</ul>
<h3 id="同财务相关的金额类数据必须使用-decimal-类型">同财务相关的金额类数据必须使用 decimal 类型<a hidden class="anchor" aria-hidden="true" href="#同财务相关的金额类数据必须使用-decimal-类型">#</a></h3>
<ul>
<li><strong>非精准浮点</strong>：float,double</li>
<li><strong>精准浮点</strong>：decimal</li>
</ul>
<p>decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，decimal 可用于存储比 bigint 更大的整型数据</p>
<p>不过， 由于 decimal 需要额外的空间和计算开销，应该尽量只在需要对数据进行精确计算时才使用 decimal 。</p>
<h3 id="单表不要包含过多字段">单表不要包含过多字段<a hidden class="anchor" aria-hidden="true" href="#单表不要包含过多字段">#</a></h3>
<p>如果一个表包含过多字段的话，可以考虑将其分解成多个表，必要时增加中间表进行关联。</p>
<h2 id="索引设计规范">索引设计规范<a hidden class="anchor" aria-hidden="true" href="#索引设计规范">#</a></h2>
<h3 id="限制每张表上的索引数量建议单张表索引不超过-5-个">限制每张表上的索引数量,建议单张表索引不超过 5 个<a hidden class="anchor" aria-hidden="true" href="#限制每张表上的索引数量建议单张表索引不超过-5-个">#</a></h3>
<p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p>
<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>
<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>
<h3 id="禁止使用全文索引">禁止使用全文索引<a hidden class="anchor" aria-hidden="true" href="#禁止使用全文索引">#</a></h3>
<p>全文索引不适用于 OLTP 场景。</p>
<h3 id="禁止给表中的每一列都建立单独的索引">禁止给表中的每一列都建立单独的索引<a hidden class="anchor" aria-hidden="true" href="#禁止给表中的每一列都建立单独的索引">#</a></h3>
<p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p>
<h3 id="每个-innodb-表必须有个主键">每个 InnoDB 表必须有个主键<a hidden class="anchor" aria-hidden="true" href="#每个-innodb-表必须有个主键">#</a></h3>
<p>InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p>
<p>InnoDB 是按照主键索引的顺序来组织表的</p>
<ul>
<li>不要使用更新频繁的列作为主键，不使用多列主键（相当于联合索引）</li>
<li>不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li>
<li>主键建议使用自增 ID 值</li>
</ul>
<h3 id="常见索引列建议">常见索引列建议<a hidden class="anchor" aria-hidden="true" href="#常见索引列建议">#</a></h3>
<ul>
<li>出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li>
<li>包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li>
<li>并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li>
<li>多表 join 的关联列</li>
</ul>
<h3 id="如何选择索引列的顺序">如何选择索引列的顺序<a hidden class="anchor" aria-hidden="true" href="#如何选择索引列的顺序">#</a></h3>
<p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p>
<ul>
<li>区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li>
<li>尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li>
<li>使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li>
</ul>
<h3 id="避免建立冗余索引和重复索引增加了查询优化器生成执行计划的时间">避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）<a hidden class="anchor" aria-hidden="true" href="#避免建立冗余索引和重复索引增加了查询优化器生成执行计划的时间">#</a></h3>
<ul>
<li>重复索引示例：primary key(id)、index(id)、unique index(id)</li>
<li>冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li>
</ul>
<h3 id="对于频繁的查询优先考虑使用覆盖索引">对于频繁的查询优先考虑使用覆盖索引<a hidden class="anchor" aria-hidden="true" href="#对于频繁的查询优先考虑使用覆盖索引">#</a></h3>
<blockquote>
<p>覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引</p>
</blockquote>
<p><strong>覆盖索引的好处：</strong></p>
<ul>
<li><strong>避免 InnoDB 表进行索引的二次查询:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li>
<li><strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li>
</ul>
<hr>
<h3 id="索引-set-规范">索引 SET 规范<a hidden class="anchor" aria-hidden="true" href="#索引-set-规范">#</a></h3>
<p><strong>尽量避免使用外键约束</strong></p>
<ul>
<li>不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li>
<li>外键可用于保证数据的参照完整性，但建议在业务端实现</li>
<li>外键会影响父表和子表的写操作从而降低性能</li>
</ul>
<h2 id="数据库-sql-开发规范">数据库 SQL 开发规范<a hidden class="anchor" aria-hidden="true" href="#数据库-sql-开发规范">#</a></h2>
<h3 id="优化对性能影响较大的-sql-语句">优化对性能影响较大的 SQL 语句<a hidden class="anchor" aria-hidden="true" href="#优化对性能影响较大的-sql-语句">#</a></h3>
<p>要找到最需要优化的 SQL 语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询 MySQL 的慢查询日志来发现需要进行优化的 SQL 语句；</p>
<h3 id="充分利用表上已经存在的索引">充分利用表上已经存在的索引<a hidden class="anchor" aria-hidden="true" href="#充分利用表上已经存在的索引">#</a></h3>
<p>避免使用双%号的查询条件。如：<code>a like '%123%'</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</p>
<p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p>
<p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p>
<h3 id="禁止使用-select--必须使用-select-字段列表-查询">禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询<a hidden class="anchor" aria-hidden="true" href="#禁止使用-select--必须使用-select-字段列表-查询">#</a></h3>
<ul>
<li><code>SELECT *</code> 消耗更多的 CPU 和 IO 以网络带宽资源</li>
<li><code>SELECT *</code> 无法使用覆盖索引</li>
<li><code>SELECT &lt;字段列表&gt;</code> 可减少表结构变更带来的影响</li>
</ul>
<h3 id="禁止使用不含字段列表的-insert-语句">禁止使用不含字段列表的 INSERT 语句<a hidden class="anchor" aria-hidden="true" href="#禁止使用不含字段列表的-insert-语句">#</a></h3>
<p>如：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">insert</span> <span style="color:#fff;font-weight:bold">into</span> t <span style="color:#fff;font-weight:bold">values</span> (<span style="color:#0ff;font-weight:bold">&#39;a&#39;</span>,<span style="color:#0ff;font-weight:bold">&#39;b&#39;</span>,<span style="color:#0ff;font-weight:bold">&#39;c&#39;</span>);
</span></span></code></pre></td></tr></table>
</div>
</div><p>应使用：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">insert</span> <span style="color:#fff;font-weight:bold">into</span> t(c1,c2,c3) <span style="color:#fff;font-weight:bold">values</span> (<span style="color:#0ff;font-weight:bold">&#39;a&#39;</span>,<span style="color:#0ff;font-weight:bold">&#39;b&#39;</span>,<span style="color:#0ff;font-weight:bold">&#39;c&#39;</span>);
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="建议使用预编译语句进行数据库操作">建议使用预编译语句进行数据库操作<a hidden class="anchor" aria-hidden="true" href="#建议使用预编译语句进行数据库操作">#</a></h3>
<ul>
<li>预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</li>
<li>只传参数，比传递 SQL 语句更高效。</li>
<li>相同语句可以一次解析，多次使用，提高处理效率。</li>
</ul>
<h3 id="避免数据类型的隐式转换">避免数据类型的隐式转换<a hidden class="anchor" aria-hidden="true" href="#避免数据类型的隐式转换">#</a></h3>
<p>隐式转换会导致索引失效如:</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">select</span> name,phone <span style="color:#fff;font-weight:bold">from</span> customer <span style="color:#fff;font-weight:bold">where</span> id = <span style="color:#0ff;font-weight:bold">&#39;111&#39;</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><p>详细解读可以看：<a href="/">MySQL 中的隐式转换造成的索引失效</a> 这篇文章。</p>
<h3 id="避免使用子查询可以把子查询优化为-join-操作">避免使用子查询，可以把子查询优化为 join 操作<a hidden class="anchor" aria-hidden="true" href="#避免使用子查询可以把子查询优化为-join-操作">#</a></h3>
<p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p>
<p><strong>子查询性能差的原因：</strong> 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p>
<h3 id="避免使用-join-关联太多的表">避免使用 JOIN 关联太多的表<a hidden class="anchor" aria-hidden="true" href="#避免使用-join-关联太多的表">#</a></h3>
<p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p>
<p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p>
<p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p>
<p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p>
<h3 id="减少同数据库的交互次数">减少同数据库的交互次数<a hidden class="anchor" aria-hidden="true" href="#减少同数据库的交互次数">#</a></h3>
<p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p>
<h3 id="对应同一列进行-or-判断时使用-in-代替-or">对应同一列进行 or 判断时，使用 in 代替 or<a hidden class="anchor" aria-hidden="true" href="#对应同一列进行-or-判断时使用-in-代替-or">#</a></h3>
<p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p>
<h3 id="禁止使用-order-by-rand-进行随机排序">禁止使用 order by rand() 进行随机排序<a hidden class="anchor" aria-hidden="true" href="#禁止使用-order-by-rand-进行随机排序">#</a></h3>
<p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p>
<p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p>
<h3 id="where-从句中禁止对列进行函数转换和计算">WHERE 从句中禁止对列进行函数转换和计算<a hidden class="anchor" aria-hidden="true" href="#where-从句中禁止对列进行函数转换和计算">#</a></h3>
<p>对列进行函数转换或计算时会导致无法使用索引</p>
<p><strong>不推荐：</strong></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">where</span> <span style="color:#fff;font-weight:bold">date</span>(create_time)=<span style="color:#0ff;font-weight:bold">&#39;20190101&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>推荐：</strong></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">where</span> create_time &gt;= <span style="color:#0ff;font-weight:bold">&#39;20190101&#39;</span> <span style="color:#fff;font-weight:bold">and</span> create_time &lt; <span style="color:#0ff;font-weight:bold">&#39;20190102&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="在明显不会有重复值时使用-union-all-而不是-union">在明显不会有重复值时使用 UNION ALL 而不是 UNION<a hidden class="anchor" aria-hidden="true" href="#在明显不会有重复值时使用-union-all-而不是-union">#</a></h3>
<ul>
<li>UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li>
<li>UNION ALL 不会再对结果集进行去重操作</li>
</ul>
<h3 id="拆分复杂的大-sql-为多个小-sql">拆分复杂的大 SQL 为多个小 SQL<a hidden class="anchor" aria-hidden="true" href="#拆分复杂的大-sql-为多个小-sql">#</a></h3>
<ul>
<li>大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li>
<li>MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li>
<li>SQL 拆分后可以通过并行执行来提高处理效率</li>
</ul>
<h3 id="程序连接不同的数据库使用不同的账号禁止跨库查询">程序连接不同的数据库使用不同的账号，禁止跨库查询<a hidden class="anchor" aria-hidden="true" href="#程序连接不同的数据库使用不同的账号禁止跨库查询">#</a></h3>
<ul>
<li>为数据库迁移和分库分表留出余地</li>
<li>降低业务耦合度</li>
<li>避免权限过大而产生的安全风险</li>
</ul>
<h2 id="数据库操作行为规范">数据库操作行为规范<a hidden class="anchor" aria-hidden="true" href="#数据库操作行为规范">#</a></h2>
<h3 id="超-100-万行的批量写-updatedeleteinsert-操作要分批多次进行操作">超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作<a hidden class="anchor" aria-hidden="true" href="#超-100-万行的批量写-updatedeleteinsert-操作要分批多次进行操作">#</a></h3>
<p><strong>大批量操作可能会造成严重的主从延迟</strong></p>
<p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p>
<p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p>
<p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p>
<p><strong>避免产生大事务操作</strong></p>
<p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p>
<p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p>
<h3 id="对于大表使用-pt-online-schema-change-修改表结构">对于大表使用 pt-online-schema-change 修改表结构<a hidden class="anchor" aria-hidden="true" href="#对于大表使用-pt-online-schema-change-修改表结构">#</a></h3>
<ul>
<li>避免大表修改产生的主从延迟</li>
<li>避免在对表字段进行修改时进行锁表</li>
</ul>
<p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p>
<p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p>
<h3 id="禁止为程序使用的账号赋予-super-权限">禁止为程序使用的账号赋予 super 权限<a hidden class="anchor" aria-hidden="true" href="#禁止为程序使用的账号赋予-super-权限">#</a></h3>
<ul>
<li>当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li>
<li>super 权限只能留给 DBA 处理问题的账号使用</li>
</ul>
<h3 id="对于程序连接数据库账号遵循权限最小原则">对于程序连接数据库账号,遵循权限最小原则<a hidden class="anchor" aria-hidden="true" href="#对于程序连接数据库账号遵循权限最小原则">#</a></h3>
<ul>
<li>程序使用数据库账号只能在一个 DB 下使用，不准跨库</li>
<li>程序使用的账号原则上不准有 drop 权限</li>
</ul>
<h1 id="mysql索引详解">MySQL索引详解<a hidden class="anchor" aria-hidden="true" href="#mysql索引详解">#</a></h1>
<h2 id="索引介绍">索引介绍<a hidden class="anchor" aria-hidden="true" href="#索引介绍">#</a></h2>
<p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p>
<p>索引的作用就相当于书的目录。打个比方: 我们在查字典的时候，如果没有目录，那我们就只能一页一页的去找我们需要查的那个字，速度很慢。如果有目录了，我们只需要先去目录里查找字的位置，然后直接翻到那一页就行了。</p>
<p>索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。</p>
<h2 id="索引的优缺点">索引的优缺点<a hidden class="anchor" aria-hidden="true" href="#索引的优缺点">#</a></h2>
<p><strong>优点</strong>：</p>
<ul>
<li>使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li>
<li>索引需要使用物理文件存储，也会耗费一定空间。</li>
</ul>
<p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p>
<p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p>
<h2 id="索引的数据结构">索引的数据结构<a hidden class="anchor" aria-hidden="true" href="#索引的数据结构">#</a></h2>
<h3 id="hash-表">Hash 表<a hidden class="anchor" aria-hidden="true" href="#hash-表">#</a></h3>
<p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p>
<p><strong>为何能够通过 key 快速取出 value 呢？</strong> 原因在于 <strong>哈希算法</strong>（也叫散列算法）。通过哈希算法，我们可以快速找到 key 对应的 index，找到了 index 也就找到了对应的 value。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>hash = hashfunc(key)
</span></span><span style="display:flex;"><span>index = hash % array_size
</span></span></code></pre></td></tr></table>
</div>
</div><p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysql20210513092328171.png"></p>
<p>但是！哈希算法有个 <strong>Hash 冲突</strong> 问题，也就是说多个不同的 key 最后得到的 index 相同。通常情况下，我们常用的解决办法是 <strong>链地址法</strong>。链地址法就是将哈希冲突数据存放在链表中。就比如 JDK1.8 之前 <code>HashMap</code> 就是通过链地址法来解决哈希冲突的。不过，JDK1.8 以后<code>HashMap</code>为了减少链表过长的时候搜索时间过长引入了红黑树。</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysql20210513092224836.png"></p>
<p>为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。</p>
<p>既然哈希表这么快，<strong>为什么 MySQL 没有使用其作为索引的数据结构呢？</strong> 主要是因为 Hash 索引不支持顺序和范围查询。假如我们要对表中的数据进行排序或者进行范围查询，那 Hash 索引可就不行了。并且，每次 IO 只能取一个。</p>
<p>试想一种情况:</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span>SELECT * FROM tb1 WHERE id &lt; 500;
</span></span></code></pre></td></tr></table>
</div>
</div><p>在这种范围查询中，直接遍历比 500 小的叶子节点就够了。而 Hash 索引是根据 hash 算法来定位的，难不成还要把 1 - 499 的数据，每个都进行一次 hash 计算来定位吗?这就是 Hash 最大的缺点了。</p>
<h3 id="二叉查找树bst">二叉查找树(BST)<a hidden class="anchor" aria-hidden="true" href="#二叉查找树bst">#</a></h3>
<p>二叉查找树（Binary Search Tree）是一种基于二叉树的数据结构，它具有以下特点：</p>
<ol>
<li>左子树所有节点的值均小于根节点的值。</li>
<li>右子树所有节点的值均大于根节点的值。</li>
<li>左右子树也分别为二叉查找树。</li>
</ol>
<p>当二叉查找树是平衡的时候，也就是树的每个节点的左右子树深度相差不超过 1 的时候，查询的时间复杂度为 O(log2(N))，具有比较高的效率。然而，当二叉查找树不平衡时，例如在最坏情况下（有序插入节点），树会退化成线性链表（也被称为斜树），导致查询效率急剧下降，时间复杂退化为 O（N）。</p>
<p>也就是说，<strong>二叉查找树的性能非常依赖于它的平衡程度，这就导致其不适合作为 MySQL 底层索引的数据结构。</strong></p>
<p>为了解决这个问题，并提高查询效率，人们发明了多种在二叉查找树基础上的改进型数据结构，如平衡二叉树、B-Tree、B+Tree 等。</p>
<h3 id="avl-树">AVL 树<a hidden class="anchor" aria-hidden="true" href="#avl-树">#</a></h3>
<p>AVL 树是计算机科学中最早被发明的自平衡二叉查找树，它的名称来自于发明者 G.M. Adelson-Velsky 和 E.M. Landis 的名字缩写。AVL 树的特点是保证任何节点的左右子树高度之差不超过 1，因此也被称为高度平衡二叉树，它的查找、插入和删除在平均和最坏情况下的时间复杂度都是 O(logn)。</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/avl-tree.png"></p>
<p>AVL 树采用了旋转操作来保持平衡。主要有四种旋转操作：LL 旋转、RR 旋转、LR 旋转和 RL 旋转。其中 LL 旋转和 RR 旋转分别用于处理左左和右右失衡，而 LR 旋转和 RL 旋转则用于处理左右和右左失衡。</p>
<p>由于 AVL 树需要频繁地进行旋转操作来保持平衡，因此会有较大的计算开销进而降低了查询性能。并且， 在使用 AVL 树时，每个树节点仅存储一个数据，而每次进行磁盘 IO 时只能读取一个节点的数据，如果需要查询的数据分布在多个节点上，那么就需要进行多次磁盘 IO。 <strong>磁盘 IO 是一项耗时的操作，在设计数据库索引时，我们需要优先考虑如何最大限度地减少磁盘 IO 操作的次数。</strong></p>
<p>实际应用中，AVL 树使用的并不多。</p>
<h3 id="红黑树">红黑树<a hidden class="anchor" aria-hidden="true" href="#红黑树">#</a></h3>
<p>红黑树是一种自平衡二叉查找树，通过在插入和删除节点时进行颜色变换和旋转操作，使得树始终保持平衡状态，它具有以下特点：</p>
<ol>
<li>每个节点非红即黑；</li>
<li>根节点总是黑色的；</li>
<li>每个叶子节点都是黑色的空节点（NIL 节点）；</li>
<li>如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li>
<li>从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li>
</ol>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/red-black-tree.png"></p>
<p>和 AVL 树不同的是，红黑树并不追求严格的平衡，而是大致的平衡。正因如此，红黑树的查询效率稍有下降，因为红黑树的平衡性相对较弱，可能会导致树的高度较高，这可能会导致一些数据需要进行多次磁盘 IO 操作才能查询到，这也是 MySQL 没有选择红黑树的主要原因。也正因如此，红黑树的插入和删除操作效率大大提高了，因为红黑树在插入和删除节点时只需进行 O(1) 次数的旋转和变色操作，即可保持基本平衡状态，而不需要像 AVL 树一样进行 O(logn) 次数的旋转操作。</p>
<p><strong>红黑树的应用还是比较广泛的，TreeMap、TreeSet 以及 JDK1.8 的 HashMap 底层都用到了红黑树。对于数据在内存中的这种情况来说，红黑树的表现是非常优异的。</strong></p>
<h3 id="b-树-b树">B 树&amp; B+树<a hidden class="anchor" aria-hidden="true" href="#b-树-b树">#</a></h3>
<p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p>
<p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p>
<p><strong>B 树&amp; B+树两者有何异同呢？</strong></p>
<ul>
<li>B 树的所有节点既存放键(key) 也存放数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li>
<li>B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li>
<li>B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li>
<li>在 B 树中进行范围查询时，首先找到要查找的下限，然后对 B 树进行中序遍历，直到找到查找的上限；而 B+树的范围查询，只需要对链表进行遍历即可。</li>
</ul>
<p>综上，B+树与 B 树相比，具备更少的 IO 次数、更稳定的查询效率和更适于范围查询这些优势。</p>
<p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p>
<blockquote>
<p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。</p>
<p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂</p>
</blockquote>
<h2 id="索引类型总结">索引类型总结<a hidden class="anchor" aria-hidden="true" href="#索引类型总结">#</a></h2>
<p>按照数据结构维度划分：</p>
<ul>
<li>BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。</li>
<li>哈希索引：类似键值对的形式，一次即可定位。</li>
<li>RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>
<li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>
</ul>
<p>按照底层存储方式角度划分：</p>
<ul>
<li>聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li>
<li>非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li>
</ul>
<p>按照应用维度划分：</p>
<ul>
<li>主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li>
<li>普通索引：仅加速查询。</li>
<li>唯一索引：加速查询 + 列值唯一（可以有 NULL）。</li>
<li>覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li>
<li>联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li>
<li>全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li>
</ul>
<p>MySQL 8.x 中实现的索引新特性：</p>
<ul>
<li>隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li>
<li>降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li>
<li>函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li>
</ul>
<h2 id="主键索引primary-key">主键索引(Primary Key)<a hidden class="anchor" aria-hidden="true" href="#主键索引primary-key">#</a></h2>
<p>数据表的主键列使用的就是主键索引。</p>
<p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p>
<p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/cluster-index.png"></p>
<h2 id="二级索引">二级索引<a hidden class="anchor" aria-hidden="true" href="#二级索引">#</a></h2>
<p><strong>二级索引（Secondary Index）又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p>
<p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p>
<p>PS: 不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</p>
<ol>
<li><strong>唯一索引(Unique Key)</strong>：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li>
<li><strong>普通索引(Index)</strong>：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li>
<li><strong>前缀索引(Prefix)</strong>：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li>
<li><strong>全文索引(Full Text)</strong>：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。</li>
</ol>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/no-cluster-index.png"></p>
<h2 id="聚簇索引与非聚簇索引">聚簇索引与非聚簇索引<a hidden class="anchor" aria-hidden="true" href="#聚簇索引与非聚簇索引">#</a></h2>
<h3 id="聚簇索引聚集索引">聚簇索引（聚集索引）<a hidden class="anchor" aria-hidden="true" href="#聚簇索引聚集索引">#</a></h3>
<h4 id="聚簇索引介绍">聚簇索引介绍<a hidden class="anchor" aria-hidden="true" href="#聚簇索引介绍">#</a></h4>
<p><strong>聚簇索引（Clustered Index）即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。</strong></p>
<p>在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p>
<h4 id="聚簇索引的优缺点">聚簇索引的优缺点<a hidden class="anchor" aria-hidden="true" href="#聚簇索引的优缺点">#</a></h4>
<p><strong>优点</strong>：</p>
<ul>
<li><strong>查询速度非常快</strong>：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li>
<li><strong>对排序查找和范围查找优化</strong>：聚簇索引对于主键的排序查找和范围查找速度非常快。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>依赖于有序的数据</strong>：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li>
<li><strong>更新代价大</strong>：如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li>
</ul>
<h3 id="非聚簇索引非聚集索引">非聚簇索引（非聚集索引）<a hidden class="anchor" aria-hidden="true" href="#非聚簇索引非聚集索引">#</a></h3>
<h4 id="非聚簇索引介绍">非聚簇索引介绍<a hidden class="anchor" aria-hidden="true" href="#非聚簇索引介绍">#</a></h4>
<p><strong>非聚簇索引(Non-Clustered Index)即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</strong></p>
<p>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p>
<h4 id="非聚簇索引的优缺点">非聚簇索引的优缺点<a hidden class="anchor" aria-hidden="true" href="#非聚簇索引的优缺点">#</a></h4>
<p><strong>优点</strong>：</p>
<p>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的</p>
<p><strong>缺点</strong>：</p>
<ul>
<li><strong>依赖于有序的数据</strong>：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li>
<li><strong>可能会二次查询(回表)</strong>：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li>
</ul>
<p>这是 MySQL 的表的文件截图:</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysql20210420165311654.png"></p>
<p>聚簇索引和非聚簇索引:</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysql20210420165326946.png"></p>
<h4 id="非聚簇索引一定回表查询吗覆盖索引">非聚簇索引一定回表查询吗(覆盖索引)?<a hidden class="anchor" aria-hidden="true" href="#非聚簇索引一定回表查询吗覆盖索引">#</a></h4>
<p><strong>非聚簇索引不一定回表查询。</strong></p>
<p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span> <span style="color:#fff;font-weight:bold">SELECT</span> name <span style="color:#fff;font-weight:bold">FROM</span> <span style="color:#fff;font-weight:bold">table</span> <span style="color:#fff;font-weight:bold">WHERE</span> name=<span style="color:#0ff;font-weight:bold">&#39;guang19&#39;</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p>
<p>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！<strong>如果 SQL 查的就是主键呢?</strong></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SELECT</span> id <span style="color:#fff;font-weight:bold">FROM</span> <span style="color:#fff;font-weight:bold">table</span> <span style="color:#fff;font-weight:bold">WHERE</span> id=<span style="color:#ff0;font-weight:bold">1</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p>
<h2 id="覆盖索引和联合索引">覆盖索引和联合索引<a hidden class="anchor" aria-hidden="true" href="#覆盖索引和联合索引">#</a></h2>
<h3 id="覆盖索引">覆盖索引<a hidden class="anchor" aria-hidden="true" href="#覆盖索引">#</a></h3>
<p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为 <strong>覆盖索引（Covering Index）</strong> 。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次，这样就会比较慢。而覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p>
<p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p>
<blockquote>
<p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p>
</blockquote>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysql20210420165341868.png"></p>
<p>我们这里简单演示一下覆盖索引的效果。</p>
<p>1、创建一个名为 <code>cus_order</code> 的表，来实际测试一下这种排序方式。为了测试方便， <code>cus_order</code> 这张表只有 <code>id</code>、<code>score</code>、<code>name</code>这 3 个字段。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">CREATE</span> <span style="color:#fff;font-weight:bold">TABLE</span> `cus_order` (
</span></span><span style="display:flex;"><span>  `id` <span style="color:#fff;font-weight:bold">int</span>(<span style="color:#ff0;font-weight:bold">11</span>) unsigned <span style="color:#fff;font-weight:bold">NOT</span> <span style="color:#fff;font-weight:bold">NULL</span> AUTO_INCREMENT,
</span></span><span style="display:flex;"><span>  `score` <span style="color:#fff;font-weight:bold">int</span>(<span style="color:#ff0;font-weight:bold">11</span>) <span style="color:#fff;font-weight:bold">NOT</span> <span style="color:#fff;font-weight:bold">NULL</span>,
</span></span><span style="display:flex;"><span>  `name` <span style="color:#fff;font-weight:bold">varchar</span>(<span style="color:#ff0;font-weight:bold">11</span>) <span style="color:#fff;font-weight:bold">NOT</span> <span style="color:#fff;font-weight:bold">NULL</span> <span style="color:#fff;font-weight:bold">DEFAULT</span> <span style="color:#0ff;font-weight:bold">&#39;&#39;</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">PRIMARY</span> <span style="color:#fff;font-weight:bold">KEY</span> (`id`)
</span></span><span style="display:flex;"><span>) ENGINE=InnoDB AUTO_INCREMENT=<span style="color:#ff0;font-weight:bold">100000</span> <span style="color:#fff;font-weight:bold">DEFAULT</span> CHARSET=utf8mb4;
</span></span></code></pre></td></tr></table>
</div>
</div><p>2、定义一个简单的存储过程（PROCEDURE）来插入 100w 测试数据。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">DELIMITER</span> ;;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">CREATE</span> <span style="color:#fff;font-weight:bold">DEFINER</span>=`root`@`%` <span style="color:#fff;font-weight:bold">PROCEDURE</span> `BatchinsertDataToCusOder`(<span style="color:#fff;font-weight:bold">IN</span> start_num <span style="color:#fff;font-weight:bold">INT</span>,<span style="color:#fff;font-weight:bold">IN</span> max_num <span style="color:#fff;font-weight:bold">INT</span>)
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">BEGIN</span>
</span></span><span style="display:flex;"><span>      <span style="color:#fff;font-weight:bold">DECLARE</span> i <span style="color:#fff;font-weight:bold">INT</span> <span style="color:#fff;font-weight:bold">default</span> start_num;
</span></span><span style="display:flex;"><span>      WHILE i &lt; max_num <span style="color:#fff;font-weight:bold">DO</span>
</span></span><span style="display:flex;"><span>          <span style="color:#fff;font-weight:bold">insert</span> <span style="color:#fff;font-weight:bold">into</span> `cus_order`(`id`, `score`, `name`)
</span></span><span style="display:flex;"><span>          <span style="color:#fff;font-weight:bold">values</span> (i,RAND() * <span style="color:#ff0;font-weight:bold">1000000</span>,CONCAT(<span style="color:#0ff;font-weight:bold">&#39;user&#39;</span>, i));
</span></span><span style="display:flex;"><span>          <span style="color:#fff;font-weight:bold">SET</span> i = i + <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>      <span style="color:#fff;font-weight:bold">END</span> WHILE;
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">END</span>;;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">DELIMITER</span> ;
</span></span></code></pre></td></tr></table>
</div>
</div><p>存储过程定义完成之后，我们执行存储过程即可！</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">CALL</span> BatchinsertDataToCusOder(<span style="color:#ff0;font-weight:bold">1</span>, <span style="color:#ff0;font-weight:bold">1000000</span>); # <span style="color:#f00">插入</span><span style="color:#ff0;font-weight:bold">100</span>w+<span style="color:#f00">的随机数据</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>等待一会，100w 的测试数据就插入完成了！</p>
<p>3、创建覆盖索引并使用 <code>EXPLAIN</code> 命令分析。</p>
<p>为了能够对这 100w 数据按照 <code>score</code> 进行排序，我们需要执行下面的 SQL 语句。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SELECT</span> `score`,`name` <span style="color:#fff;font-weight:bold">FROM</span> `cus_order` <span style="color:#fff;font-weight:bold">ORDER</span> <span style="color:#fff;font-weight:bold">BY</span> `score` <span style="color:#fff;font-weight:bold">DESC</span>;#<span style="color:#f00">降序排序</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>使用 <code>EXPLAIN</code> 命令分析这条 SQL 语句，通过 <code>Extra</code> 这一列的 <code>Using filesort</code> ，我们发现是没有用到覆盖索引的。</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/not-using-covering-index-demo.png"></p>
<p>不过这也是理所应当，毕竟我们现在还没有创建索引呢！</p>
<p>我们这里以 <code>score</code> 和 <code>name</code> 两个字段建立联合索引：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">ALTER</span> <span style="color:#fff;font-weight:bold">TABLE</span> `cus_order` <span style="color:#fff;font-weight:bold">ADD</span> <span style="color:#fff;font-weight:bold">INDEX</span> id_score_name(score, name);
</span></span></code></pre></td></tr></table>
</div>
</div><p>创建完成之后，再用 <code>EXPLAIN</code> 命令分析再次分析这条 SQL 语句。</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/using-covering-index-demo.png"></p>
<p>通过 <code>Extra</code> 这一列的 <code>Using index</code> ，说明这条 SQL 语句成功使用了覆盖索引。</p>
<p>关于 <code>EXPLAIN</code> 命令的详细介绍请看：<a href="/">MySQL 执行计划分析</a>这篇文章。</p>
<h3 id="联合索引">联合索引<a hidden class="anchor" aria-hidden="true" href="#联合索引">#</a></h3>
<p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p>
<p>以 <code>score</code> 和 <code>name</code> 两个字段建立联合索引：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">ALTER</span> <span style="color:#fff;font-weight:bold">TABLE</span> `cus_order` <span style="color:#fff;font-weight:bold">ADD</span> <span style="color:#fff;font-weight:bold">INDEX</span> id_score_name(score, name);
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="最左前缀匹配原则">最左前缀匹配原则<a hidden class="anchor" aria-hidden="true" href="#最左前缀匹配原则">#</a></h3>
<p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 <strong><code>&gt;</code></strong>、<strong><code>&lt;</code></strong>）才会停止匹配。对于 <strong><code>&gt;=</code></strong>、<strong><code>&lt;=</code></strong>、<strong><code>BETWEEN</code></strong>、<strong><code>like</code></strong> 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p>
<p>相关阅读：<a href="https://mp.weixin.qq.com/s/8qemhRg5MgXs1So5YCv0fQ">联合索引的最左匹配原则全网都在说的一个错误结论</a>。</p>
<h2 id="索引下推">索引下推<a hidden class="anchor" aria-hidden="true" href="#索引下推">#</a></h2>
<p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p>
<h2 id="正确使用索引的一些建议">正确使用索引的一些建议<a hidden class="anchor" aria-hidden="true" href="#正确使用索引的一些建议">#</a></h2>
<h3 id="选择合适的字段创建索引">选择合适的字段创建索引<a hidden class="anchor" aria-hidden="true" href="#选择合适的字段创建索引">#</a></h3>
<ul>
<li><strong>不为 NULL 的字段</strong>：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li>
<li><strong>被频繁查询的字段</strong>：我们创建索引的字段应该是查询操作非常频繁的字段。</li>
<li><strong>被作为条件查询的字段</strong>：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li>
<li><strong>频繁需要排序的字段</strong>：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li>
<li><strong>被经常频繁用于连接的字段</strong>：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li>
</ul>
<h3 id="被频繁更新的字段应该慎重建立索引">被频繁更新的字段应该慎重建立索引<a hidden class="anchor" aria-hidden="true" href="#被频繁更新的字段应该慎重建立索引">#</a></h3>
<p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p>
<h3 id="限制每张表上的索引数量">限制每张表上的索引数量<a hidden class="anchor" aria-hidden="true" href="#限制每张表上的索引数量">#</a></h3>
<p>索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。</p>
<p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p>
<p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p>
<h3 id="尽可能的考虑建立联合索引而不是单列索引">尽可能的考虑建立联合索引而不是单列索引<a hidden class="anchor" aria-hidden="true" href="#尽可能的考虑建立联合索引而不是单列索引">#</a></h3>
<p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p>
<h3 id="注意避免冗余索引">注意避免冗余索引<a hidden class="anchor" aria-hidden="true" href="#注意避免冗余索引">#</a></h3>
<p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p>
<h3 id="字符串类型的字段使用前缀索引代替普通索引">字符串类型的字段使用前缀索引代替普通索引<a hidden class="anchor" aria-hidden="true" href="#字符串类型的字段使用前缀索引代替普通索引">#</a></h3>
<p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p>
<h3 id="避免索引失效">避免索引失效<a hidden class="anchor" aria-hidden="true" href="#避免索引失效">#</a></h3>
<p>索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：</p>
<ul>
<li>使用 <code>SELECT *</code> 进行查询; <code>SELECT *</code> 不会直接导致索引失效（如果不走索引大概率是因为 where 查询范围过大导致的），但它可能会带来一些其他的性能问题比如造成网络传输和数据处理的浪费、无法使用索引覆盖;</li>
<li>创建了组合索引，但查询条件未遵守最左匹配原则;</li>
<li>在索引列上进行计算、函数、类型转换等操作;</li>
<li>以 <code>%</code> 开头的 LIKE 查询比如 <code>like '%abc'</code>;</li>
<li>查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li>
<li>发生<a href="/">隐式转换</a>;</li>
<li>&hellip;&hellip;</li>
</ul>
<h3 id="删除长期未使用的索引">删除长期未使用的索引<a hidden class="anchor" aria-hidden="true" href="#删除长期未使用的索引">#</a></h3>
<p>删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗。</p>
<p>MySQL 5.7 可以通过查询 <code>sys</code> 库的 <code>schema_unused_indexes</code> 视图来查询哪些索引从未被使用。</p>
<h3 id="知道如何分析语句是否走索引查询">知道如何分析语句是否走索引查询<a hidden class="anchor" aria-hidden="true" href="#知道如何分析语句是否走索引查询">#</a></h3>
<p>我们可以使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong>执行计划</strong> ，这样就知道语句是否命中索引了。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p>
<p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>
<p><code>EXPLAIN</code> 的输出格式如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>mysql&gt; <span style="color:#fff;font-weight:bold">EXPLAIN</span> <span style="color:#fff;font-weight:bold">SELECT</span> `score`,`name` <span style="color:#fff;font-weight:bold">FROM</span> `cus_order` <span style="color:#fff;font-weight:bold">ORDER</span> <span style="color:#fff;font-weight:bold">BY</span> `score` <span style="color:#fff;font-weight:bold">DESC</span>;
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>| id | select_type | <span style="color:#fff;font-weight:bold">table</span>     | partitions | <span style="color:#fff;font-weight:bold">type</span> | possible_keys | <span style="color:#fff;font-weight:bold">key</span>  | key_len | <span style="color:#fff;font-weight:bold">ref</span>  | <span style="color:#fff;font-weight:bold">rows</span>   | filtered | Extra          |
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>|  <span style="color:#ff0;font-weight:bold">1</span> | <span style="color:#fff;font-weight:bold">SIMPLE</span>      | cus_order | <span style="color:#fff;font-weight:bold">NULL</span>       | <span style="color:#fff;font-weight:bold">ALL</span>  | <span style="color:#fff;font-weight:bold">NULL</span>          | <span style="color:#fff;font-weight:bold">NULL</span> | <span style="color:#fff;font-weight:bold">NULL</span>    | <span style="color:#fff;font-weight:bold">NULL</span> | <span style="color:#ff0;font-weight:bold">997572</span> |   <span style="color:#ff0;font-weight:bold">100</span>.<span style="color:#ff0;font-weight:bold">00</span> | <span style="color:#fff;font-weight:bold">Using</span> filesort |
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#ff0;font-weight:bold">1</span> <span style="color:#fff;font-weight:bold">row</span> <span style="color:#fff;font-weight:bold">in</span> <span style="color:#fff;font-weight:bold">set</span>, <span style="color:#ff0;font-weight:bold">1</span> warning (<span style="color:#ff0;font-weight:bold">0</span>.<span style="color:#ff0;font-weight:bold">00</span> sec)
</span></span></code></pre></td></tr></table>
</div>
</div><p>各个字段的含义如下：</p>
<table>
<thead>
<tr>
<th><strong>列名</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>SELECT 查询的序列标识符</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT 关键字对应的查询类型</td>
</tr>
<tr>
<td>table</td>
<td>用到的表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区，对于未分区的表，值为 NULL</td>
</tr>
<tr>
<td>type</td>
<td>表的访问方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际用到的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>所选索引的长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引等值查询时，与索引作比较的列或常量</td>
</tr>
<tr>
<td>rows</td>
<td>预计要读取的行数</td>
</tr>
<tr>
<td>filtered</td>
<td>按表条件过滤后，留存的记录数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>附加信息</td>
</tr>
</tbody>
</table>
<p>篇幅问题，我这里只是简单介绍了一下 MySQL 执行计划，详细介绍请看：<a href="/">MySQL 执行计划分析</a>这篇文章。</p>
<h1 id="mysql事务隔离级别详解">MySQL事务隔离级别详解<a hidden class="anchor" aria-hidden="true" href="#mysql事务隔离级别详解">#</a></h1>
<h2 id="事务隔离级别总结">事务隔离级别总结<a hidden class="anchor" aria-hidden="true" href="#事务隔离级别总结">#</a></h2>
<p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li><strong>READ-UNCOMMITTED(读取未提交)</strong>：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li><strong>READ-COMMITTED(读取已提交)</strong>：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li>
<li><strong>REPEATABLE-READ(可重复读)</strong>：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li>
<li><strong>SERIALIZABLE(可串行化)</strong>：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">READ-UNCOMMITTED</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">READ-COMMITTED</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">REPEATABLE-READ</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">SERIALIZABLE</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
<p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过<code>SELECT @@tx_isolation;</code>命令来查看，MySQL 8.0 该命令改为<code>SELECT @@transaction_isolation;</code></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>MySQL&gt; <span style="color:#fff;font-weight:bold">SELECT</span> @@tx_isolation;
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">-----------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>| @@tx_isolation  |
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">-----------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>| <span style="color:#fff;font-weight:bold">REPEATABLE</span>-<span style="color:#fff;font-weight:bold">READ</span> |
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">-----------------+
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>从上面对 SQL 标准定义了四个隔离级别的介绍可以看出，标准的 SQL 隔离级别定义里，REPEATABLE-READ(可重复读)是不可以防止幻读的。</p>
<p>但是！InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的，主要有下面两种情况：</p>
<ul>
<li><strong>快照读</strong>：由 MVCC 机制来保证不出现幻读。</li>
<li><strong>当前读</strong>：使用 Next-Key Lock 进行加锁来保证不出现幻读，Next-Key Lock 是行锁（Record Lock）和间隙锁（Gap Lock）的结合，行锁只能锁住已经存在的行，为了避免插入新行，需要依赖间隙锁。</li>
</ul>
<p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 <strong>READ-COMMITTED</strong> ，但是你要知道的是 InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ</strong> 并不会有任何性能损失。</p>
<p>InnoDB 存储引擎在分布式事务的情况下一般会用到 SERIALIZABLE 隔离级别。</p>
<p>《MySQL 技术内幕：InnoDB 存储引擎(第 2 版)》7.7 章这样写到：</p>
<blockquote>
<p>InnoDB 存储引擎提供了对 XA 事务的支持，并通过 XA 事务来支持分布式事务的实现。分布式事务指的是允许多个独立的事务资源（transactional resources）参与到一个全局的事务中。事务资源通常是关系型数据库系统，但也可以是其他类型的资源。全局事务要求在其中的所有参与的事务要么都提交，要么都回滚，这对于事务原有的 ACID 要求又有了提高。另外，在使用分布式事务时，InnoDB 存储引擎的事务隔离级别必须设置为 SERIALIZABLE。</p>
</blockquote>
<h2 id="实际情况演示">实际情况演示<a hidden class="anchor" aria-hidden="true" href="#实际情况演示">#</a></h2>
<p>在下面我会使用 2 个命令行 MySQL ，模拟多线程（多事务）对同一份数据的脏读问题。</p>
<p>MySQL 命令行的默认配置中事务都是自动提交的，即执行 SQL 语句后就会马上执行 COMMIT 操作。如果要显式地开启一个事务需要使用命令：<code>START TRANSACTION</code>。</p>
<p>我们可以通过下面的命令来设置隔离级别。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SET</span> [<span style="color:#fff;font-weight:bold">SESSION</span>|<span style="color:#fff;font-weight:bold">GLOBAL</span>] <span style="color:#fff;font-weight:bold">TRANSACTION</span> <span style="color:#fff;font-weight:bold">ISOLATION</span> <span style="color:#fff;font-weight:bold">LEVEL</span> [<span style="color:#fff;font-weight:bold">READ</span> <span style="color:#fff;font-weight:bold">UNCOMMITTED</span>|<span style="color:#fff;font-weight:bold">READ</span> <span style="color:#fff;font-weight:bold">COMMITTED</span>|<span style="color:#fff;font-weight:bold">REPEATABLE</span> <span style="color:#fff;font-weight:bold">READ</span>|<span style="color:#fff;font-weight:bold">SERIALIZABLE</span>]
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们再来看一下我们在下面实际操作中使用到的一些并发控制语句:</p>
<ul>
<li><code>START TRANSACTION</code> |<code>BEGIN</code>：显式地开启一个事务。</li>
<li><code>COMMIT</code>：提交事务，使得对数据库做的所有修改成为永久性。</li>
<li><code>ROLLBACK</code>：回滚会结束用户的事务，并撤销正在进行的所有未提交的修改。</li>
</ul>
<h3 id="脏读读未提交">脏读(读未提交)<a hidden class="anchor" aria-hidden="true" href="#脏读读未提交">#</a></h3>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/2019-31-1%E8%84%8F%E8%AF%BB%28%E8%AF%BB%E6%9C%AA%E6%8F%90%E4%BA%A4%29%E5%AE%9E%E4%BE%8B.jpg"></p>
<h3 id="避免脏读读已提交">避免脏读(读已提交)<a hidden class="anchor" aria-hidden="true" href="#避免脏读读已提交">#</a></h3>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/2019-31-2%E8%AF%BB%E5%B7%B2%E6%8F%90%E4%BA%A4%E5%AE%9E%E4%BE%8B.jpg"></p>
<h3 id="不可重复读">不可重复读<a hidden class="anchor" aria-hidden="true" href="#不可重复读">#</a></h3>
<p>还是刚才上面的读已提交的图，虽然避免了读未提交，但是却出现了，一个事务还没有结束，就发生了 不可重复读问题。</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/2019-32-1%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%AE%9E%E4%BE%8B.jpg"></p>
<h3 id="可重复读">可重复读<a hidden class="anchor" aria-hidden="true" href="#可重复读">#</a></h3>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/2019-33-2%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB.jpg"></p>
<h3 id="幻读">幻读<a hidden class="anchor" aria-hidden="true" href="#幻读">#</a></h3>
<h4 id="演示幻读出现的情况">演示幻读出现的情况<a hidden class="anchor" aria-hidden="true" href="#演示幻读出现的情况">#</a></h4>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/phantom_read.png"></p>
<p>SQL 脚本 1 在第一次查询工资为 500 的记录时只有一条，SQL 脚本 2 插入了一条工资为 500 的记录，提交之后；SQL 脚本 1 在同一个事务中再次使用当前读查询发现出现了两条工资为 500 的记录这种就是幻读。</p>
<h4 id="解决幻读的方法">解决幻读的方法<a hidden class="anchor" aria-hidden="true" href="#解决幻读的方法">#</a></h4>
<p>解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。解决幻读的方式主要有以下几种：</p>
<ol>
<li>将事务隔离级别调整为 <code>SERIALIZABLE</code> 。</li>
<li>在可重复读的事务级别下，给事务操作的这张表添加表锁。</li>
<li>在可重复读的事务级别下，给事务操作的这张表添加 <code>Next-key Lock（Record Lock+Gap Lock）</code>。</li>
</ol>
<h1 id="sql语句在mysql中的执行过程">SQL语句在MySQL中的执行过程<a hidden class="anchor" aria-hidden="true" href="#sql语句在mysql中的执行过程">#</a></h1>
<h2 id="mysql-基础架构分析">MySQL 基础架构分析<a hidden class="anchor" aria-hidden="true" href="#mysql-基础架构分析">#</a></h2>
<h3 id="mysql-基本架构概览">MySQL 基本架构概览<a hidden class="anchor" aria-hidden="true" href="#mysql-基本架构概览">#</a></h3>
<p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到用户的 SQL 语句在 MySQL 内部是如何执行的。</p>
<p>先简单介绍一下下图涉及的一些组件的基本作用帮助大家理解这幅图，在 1.2 节中会详细介绍到这些组件的作用。</p>
<ul>
<li><strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li>
<li><strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li>
<li><strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li>
<li><strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li>
<li><strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。</li>
</ul>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/13526879-3037b144ed09eb88.png"></p>
<p>简单来说 MySQL 主要分为 Server 层和存储引擎层：</p>
<ul>
<li><strong>Server 层</strong>：主要包括连接器、查询缓存、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binlog 日志模块。</li>
<li><strong>存储引擎</strong>：主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。<strong>现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5 版本开始就被当做默认存储引擎了。</strong></li>
</ul>
<h3 id="server-层基本组件介绍">Server 层基本组件介绍<a hidden class="anchor" aria-hidden="true" href="#server-层基本组件介绍">#</a></h3>
<h4 id="连接器">连接器<a hidden class="anchor" aria-hidden="true" href="#连接器">#</a></h4>
<p>连接器主要和身份认证和权限相关的功能相关，就好比一个级别很高的门卫一样。</p>
<p>主要负责用户登录数据库，进行用户的身份认证，包括校验账户密码，权限等操作，如果用户账户密码已通过，连接器会到权限表中查询该用户的所有权限，之后在这个连接里的权限逻辑判断都是会依赖此时读取到的权限数据，也就是说，后续只要这个连接不断开，即使管理员修改了该用户的权限，该用户也是不受影响的。</p>
<h4 id="查询缓存mysql-80-版本后移除">查询缓存(MySQL 8.0 版本后移除)<a hidden class="anchor" aria-hidden="true" href="#查询缓存mysql-80-版本后移除">#</a></h4>
<p>查询缓存主要用来缓存我们所执行的 SELECT 语句以及该语句的结果集。</p>
<p>连接建立后，执行查询语句的时候，会先查询缓存，MySQL 会先校验这个 SQL 是否执行过，以 Key-Value 的形式缓存在内存中，Key 是查询语句，Value 是结果集。如果缓存 key 被命中，就会直接返回给客户端，如果没有命中，就会执行后续的操作，完成后也会把结果缓存起来，方便下一次调用。当然在真正执行缓存查询的时候还是会校验用户的权限，是否有该表的查询条件。</p>
<p>MySQL 查询不建议使用缓存，因为查询缓存失效在实际业务场景中可能会非常频繁，假如你对一个表更新的话，这个表上的所有的查询缓存都会被清空。对于不经常更新的数据来说，使用缓存还是可以的。</p>
<p>所以，一般在大多数情况下我们都是不推荐去使用查询缓存的。</p>
<p>MySQL 8.0 版本后删除了缓存的功能，官方也是认为该功能在实际的应用场景比较少，所以干脆直接删掉了。</p>
<h4 id="分析器">分析器<a hidden class="anchor" aria-hidden="true" href="#分析器">#</a></h4>
<p>MySQL 没有命中缓存，那么就会进入分析器，分析器主要是用来分析 SQL 语句是来干嘛的，分析器也会分为几步：</p>
<p><strong>第一步，词法分析</strong>，一条 SQL 语句有多个字符串组成，首先要提取关键字，比如 select，提出查询的表，提出字段名，提出查询条件等等。做完这些操作后，就会进入第二步。</p>
<p><strong>第二步，语法分析</strong>，主要就是判断你输入的 SQL 是否正确，是否符合 MySQL 的语法。</p>
<p>完成这 2 步之后，MySQL 就准备开始执行了，但是如何执行，怎么执行是最好的结果呢？这个时候就需要优化器上场了。</p>
<h4 id="优化器">优化器<a hidden class="anchor" aria-hidden="true" href="#优化器">#</a></h4>
<p>优化器的作用就是它认为的最优的执行方案去执行（有时候可能也不是最优，这篇文章涉及对这部分知识的深入讲解），比如多个索引的时候该如何选择索引，多表查询的时候如何选择关联顺序等。</p>
<p>可以说，经过了优化器之后可以说这个语句具体该如何执行就已经定下来。</p>
<h4 id="执行器">执行器<a hidden class="anchor" aria-hidden="true" href="#执行器">#</a></h4>
<p>当选择了执行方案后，MySQL 就准备开始执行了，首先执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息，如果有权限，就会去调用引擎的接口，返回接口执行的结果。</p>
<h2 id="语句分析">语句分析<a hidden class="anchor" aria-hidden="true" href="#语句分析">#</a></h2>
<h3 id="查询语句">查询语句<a hidden class="anchor" aria-hidden="true" href="#查询语句">#</a></h3>
<p>说了以上这么多，那么究竟一条 SQL 语句是如何执行的呢？其实我们的 SQL 可以分为两种，一种是查询，一种是更新（增加，修改，删除）。我们先分析下查询语句，语句如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">select</span> * <span style="color:#fff;font-weight:bold">from</span> tb_student  A <span style="color:#fff;font-weight:bold">where</span> A.age=<span style="color:#0ff;font-weight:bold">&#39;18&#39;</span> <span style="color:#fff;font-weight:bold">and</span> A.name=<span style="color:#0ff;font-weight:bold">&#39; 张三 &#39;</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><p>结合上面的说明，我们分析下这个语句的执行流程：</p>
<ul>
<li>
<p>先检查该语句是否有权限，如果没有权限，直接返回错误信息，如果有权限，在 MySQL8.0 版本以前，会先查询缓存，以这条 SQL 语句为 key 在内存中查询是否有结果，如果有直接缓存，如果没有，执行下一步。</p>
</li>
<li>
<p>通过分析器进行词法分析，提取 SQL 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student，需要查询所有的列，查询条件是这个表的 id=&lsquo;1&rsquo;。然后判断这个 SQL 语句是否有语法错误，比如关键词是否正确等等，如果检查没问题就执行下一步。</p>
</li>
<li>
<p>接下来就是优化器进行确定执行方案，上面的 SQL 语句，可以有两种执行方案：</p>
</li>
</ul>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>a.先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18。
</span></span><span style="display:flex;"><span>b.先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。</p>
<ul>
<li>进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。</li>
</ul>
<h3 id="更新语句">更新语句<a hidden class="anchor" aria-hidden="true" href="#更新语句">#</a></h3>
<p>以上就是一条查询 SQL 的执行流程，那么接下来我们看看一条更新语句如何执行的呢？SQL 语句如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>update tb_student A set A.age=&#39;19&#39; where A.name=&#39; 张三 &#39;;
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们来给张三修改下年龄，在实际数据库肯定不会设置年龄这个字段的，不然要被技术负责人打的。其实这条语句也基本上会沿着上一个查询的流程走，只不过执行更新的时候肯定要记录日志啦，这就会引入日志模块了，MySQL 自带的日志模块是 <strong>binlog（归档日志）</strong> ，所有的存储引擎都可以使用，我们常用的 InnoDB 引擎还自带了一个日志模块 <strong>redo log（重做日志）</strong>，我们就以 InnoDB 模式下来探讨这个语句的执行流程。流程如下：</p>
<ul>
<li>先查询到张三这一条数据，如果有缓存，也是会用到缓存。</li>
<li>然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。</li>
<li>执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。</li>
<li>更新完成。</li>
</ul>
<p><strong>这里肯定有同学会问，为什么要用两个日志模块，用一个日志模块不行吗?</strong></p>
<p>这是因为最开始 MySQL 并没有 InnoDB 引擎（InnoDB 引擎是其他公司以插件形式插入 MySQL 的），MySQL 自带的引擎是 MyISAM，但是我们知道 redo log 是 InnoDB 引擎特有的，其他存储引擎都没有，这就导致会没有 crash-safe 的能力(crash-safe 的能力即使数据库发生异常重启，之前提交的记录都不会丢失)，binlog 日志只能用来归档。</p>
<p>并不是说只用一个日志模块不可以，只是 InnoDB 引擎就是通过 redo log 来支持事务的。那么，又会有同学问，我用两个日志模块，但是不要这么复杂行不行，为什么 redo log 要引入 prepare 预提交状态？这里我们用反证法来说明下为什么要这么做？</p>
<ul>
<li><strong>先写 redo log 直接提交，然后写 binlog</strong>，假设写完 redo log 后，机器挂了，binlog 日志没有被写入，那么机器重启后，这台机器会通过 redo log 恢复数据，但是这个时候 binlog 并没有记录该数据，后续进行机器备份的时候，就会丢失这一条数据，同时主从同步也会丢失这一条数据。</li>
<li><strong>先写 binlog，然后写 redo log</strong>，假设写完了 binlog，机器异常重启了，由于没有 redo log，本机是无法恢复这一条记录的，但是 binlog 又有记录，那么和上面同样的道理，就会产生数据不一致的情况。</li>
</ul>
<p>如果采用 redo log 两阶段提交的方式就不一样了，写完 binlog 后，然后再提交 redo log 就会防止出现上述的问题，从而保证了数据的一致性。那么问题来了，有没有一个极端的情况呢？假设 redo log 处于预提交状态，binlog 也已经写完了，这个时候发生了异常重启会怎么样呢？ 这个就要依赖于 MySQL 的处理机制了，MySQL 的处理过程如下：</p>
<ul>
<li>判断 redo log 是否完整，如果判断是完整的，就立即提交。</li>
<li>如果 redo log 只是预提交但不是 commit 状态，这个时候就会去判断 binlog 是否完整，如果完整就提交 redo log, 不完整就回滚事务。</li>
</ul>
<p>这样就解决了数据一致性的问题。</p>
<h2 id="总结">总结<a hidden class="anchor" aria-hidden="true" href="#总结">#</a></h2>
<ul>
<li>MySQL 主要分为 Server 层和引擎层，Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。</li>
<li>引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。</li>
<li>查询语句的执行流程如下：权限校验（如果命中缓存）&mdash;&gt;查询缓存&mdash;&gt;分析器&mdash;&gt;优化器&mdash;&gt;权限校验&mdash;&gt;执行器&mdash;&gt;引擎</li>
<li>更新语句执行流程如下：分析器&mdash;-&gt;权限校验&mdash;-&gt;执行器&mdash;&gt;引擎&mdash;redo log(prepare 状态)&mdash;&gt;binlog&mdash;&gt;redo log(commit 状态)</li>
</ul>
<h1 id="mysql执行计划分析">MySQL执行计划分析<a hidden class="anchor" aria-hidden="true" href="#mysql执行计划分析">#</a></h1>
<h2 id="什么是执行计划">什么是执行计划？<a hidden class="anchor" aria-hidden="true" href="#什么是执行计划">#</a></h2>
<p><strong>执行计划</strong> 是指一条 SQL 语句在经过 <strong>MySQL 查询优化器</strong> 的优化会后，具体的执行方式。</p>
<p>执行计划通常用于 SQL 性能分析、优化等场景。通过 <code>EXPLAIN</code> 的结果，可以了解到如数据表的查询顺序、数据查询操作的操作类型、哪些索引可以被命中、哪些索引实际会命中、每个数据表有多少行记录被查询等信息。</p>
<h2 id="如何获取执行计划">如何获取执行计划？<a hidden class="anchor" aria-hidden="true" href="#如何获取执行计划">#</a></h2>
<p>MySQL 为我们提供了 <code>EXPLAIN</code> 命令，来获取执行计划的相关信息。</p>
<p>需要注意的是，<code>EXPLAIN</code> 语句并不会真的去执行相关的语句，而是通过查询优化器对语句进行分析，找出最优的查询方案，并显示对应的信息。</p>
<p><code>EXPLAIN</code> 执行计划支持 <code>SELECT</code>、<code>DELETE</code>、<code>INSERT</code>、<code>REPLACE</code> 以及 <code>UPDATE</code> 语句。我们一般多用于分析 <code>SELECT</code> 查询语句，使用起来非常简单，语法如下：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">EXPLAIN</span> + <span style="color:#fff;font-weight:bold">SELECT</span> <span style="color:#f00">查询语句；</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们简单来看下一条查询语句的执行计划：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">7
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>mysql&gt; <span style="color:#fff;font-weight:bold">explain</span> <span style="color:#fff;font-weight:bold">SELECT</span> * <span style="color:#fff;font-weight:bold">FROM</span> dept_emp <span style="color:#fff;font-weight:bold">WHERE</span> emp_no <span style="color:#fff;font-weight:bold">IN</span> (<span style="color:#fff;font-weight:bold">SELECT</span> emp_no <span style="color:#fff;font-weight:bold">FROM</span> dept_emp <span style="color:#fff;font-weight:bold">GROUP</span> <span style="color:#fff;font-weight:bold">BY</span> emp_no <span style="color:#fff;font-weight:bold">HAVING</span> <span style="color:#fff;font-weight:bold">COUNT</span>(emp_no)&gt;<span style="color:#ff0;font-weight:bold">1</span>);
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>| id | select_type | <span style="color:#fff;font-weight:bold">table</span>    | partitions | <span style="color:#fff;font-weight:bold">type</span>  | possible_keys   | <span style="color:#fff;font-weight:bold">key</span>     | key_len | <span style="color:#fff;font-weight:bold">ref</span>  | <span style="color:#fff;font-weight:bold">rows</span>   | filtered | Extra       |
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>|  <span style="color:#ff0;font-weight:bold">1</span> | <span style="color:#fff;font-weight:bold">PRIMARY</span>     | dept_emp | <span style="color:#fff;font-weight:bold">NULL</span>       | <span style="color:#fff;font-weight:bold">ALL</span>   | <span style="color:#fff;font-weight:bold">NULL</span>            | <span style="color:#fff;font-weight:bold">NULL</span>    | <span style="color:#fff;font-weight:bold">NULL</span>    | <span style="color:#fff;font-weight:bold">NULL</span> | <span style="color:#ff0;font-weight:bold">331143</span> |   <span style="color:#ff0;font-weight:bold">100</span>.<span style="color:#ff0;font-weight:bold">00</span> | <span style="color:#fff;font-weight:bold">Using</span> <span style="color:#fff;font-weight:bold">where</span> |
</span></span><span style="display:flex;"><span>|  <span style="color:#ff0;font-weight:bold">2</span> | SUBQUERY    | dept_emp | <span style="color:#fff;font-weight:bold">NULL</span>       | <span style="color:#fff;font-weight:bold">index</span> | <span style="color:#fff;font-weight:bold">PRIMARY</span>,dept_no | <span style="color:#fff;font-weight:bold">PRIMARY</span> | <span style="color:#ff0;font-weight:bold">16</span>      | <span style="color:#fff;font-weight:bold">NULL</span> | <span style="color:#ff0;font-weight:bold">331143</span> |   <span style="color:#ff0;font-weight:bold">100</span>.<span style="color:#ff0;font-weight:bold">00</span> | <span style="color:#fff;font-weight:bold">Using</span> <span style="color:#fff;font-weight:bold">index</span> |
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">----+-------------+----------+------------+-------+-----------------+---------+---------+------+--------+----------+-------------+
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>可以看到，执行计划结果中共有 12 列，各列代表的含义总结如下表：</p>
<table>
<thead>
<tr>
<th><strong>列名</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>id</td>
<td>SELECT 查询的序列标识符</td>
</tr>
<tr>
<td>select_type</td>
<td>SELECT 关键字对应的查询类型</td>
</tr>
<tr>
<td>table</td>
<td>用到的表名</td>
</tr>
<tr>
<td>partitions</td>
<td>匹配的分区，对于未分区的表，值为 NULL</td>
</tr>
<tr>
<td>type</td>
<td>表的访问方法</td>
</tr>
<tr>
<td>possible_keys</td>
<td>可能用到的索引</td>
</tr>
<tr>
<td>key</td>
<td>实际用到的索引</td>
</tr>
<tr>
<td>key_len</td>
<td>所选索引的长度</td>
</tr>
<tr>
<td>ref</td>
<td>当使用索引等值查询时，与索引作比较的列或常量</td>
</tr>
<tr>
<td>rows</td>
<td>预计要读取的行数</td>
</tr>
<tr>
<td>filtered</td>
<td>按表条件过滤后，留存的记录数的百分比</td>
</tr>
<tr>
<td>Extra</td>
<td>附加信息</td>
</tr>
</tbody>
</table>
<h2 id="如何分析-explain-结果">如何分析 EXPLAIN 结果？<a hidden class="anchor" aria-hidden="true" href="#如何分析-explain-结果">#</a></h2>
<p>为了分析 <code>EXPLAIN</code> 语句的执行结果，我们需要搞懂执行计划中的重要字段。</p>
<h3 id="id">id<a hidden class="anchor" aria-hidden="true" href="#id">#</a></h3>
<p>SELECT 标识符，是查询中 SELECT 的序号，用来标识整个查询中 SELELCT 语句的顺序。</p>
<p>id 如果相同，从上往下依次执行。id 不同，id 值越大，执行优先级越高，如果行引用其他行的并集结果，则该值可以为 NULL。</p>
<h3 id="select_type">select_type<a hidden class="anchor" aria-hidden="true" href="#select_type">#</a></h3>
<p>查询的类型，主要用于区分普通查询、联合查询、子查询等复杂的查询，常见的值有：</p>
<ul>
<li><strong>SIMPLE</strong>：简单查询，不包含 UNION 或者子查询。</li>
<li><strong>PRIMARY</strong>：查询中如果包含子查询或其他部分，外层的 SELECT 将被标记为 PRIMARY。</li>
<li><strong>SUBQUERY</strong>：子查询中的第一个 SELECT。</li>
<li><strong>UNION</strong>：在 UNION 语句中，UNION 之后出现的 SELECT。</li>
<li><strong>DERIVED</strong>：在 FROM 中出现的子查询将被标记为 DERIVED。</li>
<li><strong>UNION RESULT</strong>：UNION 查询的结果。</li>
</ul>
<h3 id="table">table<a hidden class="anchor" aria-hidden="true" href="#table">#</a></h3>
<p>查询用到的表名，每行都有对应的表名，表名除了正常的表之外，也可能是以下列出的值：</p>
<ul>
<li><strong><code>&lt;unionM,N&gt;</code></strong> : 本行引用了 id 为 M 和 N 的行的 UNION 结果；</li>
<li><strong><code>&lt;derivedN&gt;</code></strong> : 本行引用了 id 为 N 的表所产生的的派生表结果。派生表有可能产生自 FROM 语句中的子查询。 -<strong><code>&lt;subqueryN&gt;</code></strong> : 本行引用了 id 为 N 的表所产生的的物化子查询结果。</li>
</ul>
<h3 id="type重要">type（重要）<a hidden class="anchor" aria-hidden="true" href="#type重要">#</a></h3>
<p>查询执行的类型，描述了查询是如何执行的。所有值的顺序从最优到最差排序为：system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</p>
<p>常见的几种类型具体含义如下：</p>
<ul>
<li><strong>system</strong>：如果表使用的引擎对于表行数统计是精确的（如：MyISAM），且表中只有一行记录的情况下，访问方法是 system ，是 const 的一种特例。</li>
<li><strong>const</strong>：表中最多只有一行匹配的记录，一次查询就可以找到，常用于使用主键或唯一索引的所有字段作为查询条件。</li>
<li><strong>eq_ref</strong>：当连表查询时，前一张表的行在当前这张表中只有一行与之对应。是除了 system 与 const 之外最好的 join 方式，常用于使用主键或唯一索引的所有字段作为连表条件。</li>
<li><strong>ref</strong>：使用普通索引作为查询条件，查询结果可能找到多个符合条件的行。</li>
<li><strong>index_merge</strong>：当查询条件使用了多个索引时，表示开启了 Index Merge 优化，此时执行计划中的 key 列列出了使用到的索引。</li>
<li><strong>range</strong>：对索引列进行范围查询，执行计划中的 key 列表示哪个索引被使用了。</li>
<li><strong>index</strong>：查询遍历了整棵索引树，与 ALL 类似，只不过扫描的是索引，而索引一般在内存中，速度更快。</li>
<li><strong>ALL</strong>：全表扫描。</li>
</ul>
<h3 id="possible_keys">possible_keys<a hidden class="anchor" aria-hidden="true" href="#possible_keys">#</a></h3>
<p>possible_keys 列表示 MySQL 执行查询时可能用到的索引。如果这一列为 NULL ，则表示没有可能用到的索引；这种情况下，需要检查 WHERE 语句中所使用的的列，看是否可以通过给这些列中某个或多个添加索引的方法来提高查询性能。</p>
<h3 id="key重要">key（重要）<a hidden class="anchor" aria-hidden="true" href="#key重要">#</a></h3>
<p>key 列表示 MySQL 实际使用到的索引。如果为 NULL，则表示未用到索引。</p>
<h3 id="key_len">key_len<a hidden class="anchor" aria-hidden="true" href="#key_len">#</a></h3>
<p>key_len 列表示 MySQL 实际使用的索引的最大长度；当使用到联合索引时，有可能是多个列的长度和。在满足需求的前提下越短越好。如果 key 列显示 NULL ，则 key_len 列也显示 NULL 。</p>
<h3 id="rows">rows<a hidden class="anchor" aria-hidden="true" href="#rows">#</a></h3>
<p>rows 列表示根据表统计信息及选用情况，大致估算出找到所需的记录或所需读取的行数，数值越小越好。</p>
<h3 id="extra重要">Extra（重要）<a hidden class="anchor" aria-hidden="true" href="#extra重要">#</a></h3>
<p>这列包含了 MySQL 解析查询的额外信息，通过这些信息，可以更准确的理解 MySQL 到底是如何执行查询的。常见的值如下：</p>
<ul>
<li><strong>Using filesort</strong>：在排序时使用了外部的索引排序，没有用到表内索引进行排序。</li>
<li><strong>Using temporary</strong>：MySQL 需要创建临时表来存储查询的结果，常见于 ORDER BY 和 GROUP BY。</li>
<li><strong>Using index</strong>：表明查询使用了覆盖索引，不用回表，查询效率非常高。</li>
<li><strong>Using index condition</strong>：表示查询优化器选择使用了索引条件下推这个特性。</li>
<li><strong>Using where</strong>：表明查询使用了 WHERE 子句进行条件过滤。一般在没有使用到索引的时候会出现。</li>
<li><strong>Using join buffer (Block Nested Loop)</strong>：连表查询的方式，表示当被驱动表的没有使用索引的时候，MySQL 会先将驱动表读出来放到 join buffer 中，再遍历被驱动表与驱动表进行查询。</li>
</ul>
<p>这里提醒下，当 Extra 列包含 Using filesort 或 Using temporary 时，MySQL 的性能可能会存在问题，需要尽可能避免。</p>
<h1 id="mysql时间类型数据存储建议">MySQL时间类型数据存储建议<a hidden class="anchor" aria-hidden="true" href="#mysql时间类型数据存储建议">#</a></h1>
<h2 id="不要用字符串存储日期">不要用字符串存储日期<a hidden class="anchor" aria-hidden="true" href="#不要用字符串存储日期">#</a></h2>
<p>和绝大部分对数据库不太了解的新手一样，我在大学的时候就这样干过，甚至认为这样是一个不错的表示日期的方法。毕竟简单直白，容易上手。</p>
<p>但是，这是不正确的做法，主要会有下面两个问题：</p>
<ol>
<li>字符串占用的空间更大！</li>
<li>字符串存储的日期效率比较低（逐个字符进行比对），无法用日期相关的 API 进行计算和比较。</li>
</ol>
<h2 id="datetime-和-timestamp-之间的抉择">Datetime 和 Timestamp 之间的抉择<a hidden class="anchor" aria-hidden="true" href="#datetime-和-timestamp-之间的抉择">#</a></h2>
<p>Datetime 和 Timestamp 是 MySQL 提供的两种比较相似的保存时间的数据类型，可以精确到秒。他们两者究竟该如何选择呢？</p>
<p>下面我们来简单对比一下二者。</p>
<h3 id="时区信息">时区信息<a hidden class="anchor" aria-hidden="true" href="#时区信息">#</a></h3>
<p><strong>DateTime 类型是没有时区信息的（时区无关）</strong> ，DateTime 类型保存的时间都是当前会话所设置的时区对应的时间。这样就会有什么问题呢？当你的时区更换之后，比如你的服务器更换地址或者更换客户端连接时区设置的话，就会导致你从数据库中读出的时间错误。</p>
<p><strong>Timestamp 和时区有关</strong>。Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。</p>
<p>下面实际演示一下！</p>
<p>建表 SQL 语句：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">6
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">CREATE</span> <span style="color:#fff;font-weight:bold">TABLE</span> `time_zone_test` (
</span></span><span style="display:flex;"><span>  `id` <span style="color:#fff;font-weight:bold">bigint</span>(<span style="color:#ff0;font-weight:bold">20</span>) <span style="color:#fff;font-weight:bold">NOT</span> <span style="color:#fff;font-weight:bold">NULL</span> AUTO_INCREMENT,
</span></span><span style="display:flex;"><span>  `date_time` datetime <span style="color:#fff;font-weight:bold">DEFAULT</span> <span style="color:#fff;font-weight:bold">NULL</span>,
</span></span><span style="display:flex;"><span>  `time_stamp` <span style="color:#fff;font-weight:bold">timestamp</span> <span style="color:#fff;font-weight:bold">NOT</span> <span style="color:#fff;font-weight:bold">NULL</span> <span style="color:#fff;font-weight:bold">DEFAULT</span> <span style="color:#fff;font-weight:bold">CURRENT_TIMESTAMP</span> <span style="color:#fff;font-weight:bold">ON</span> <span style="color:#fff;font-weight:bold">UPDATE</span> <span style="color:#fff;font-weight:bold">CURRENT_TIMESTAMP</span>,
</span></span><span style="display:flex;"><span>  <span style="color:#fff;font-weight:bold">PRIMARY</span> <span style="color:#fff;font-weight:bold">KEY</span> (`id`)
</span></span><span style="display:flex;"><span>) ENGINE=InnoDB <span style="color:#fff;font-weight:bold">DEFAULT</span> CHARSET=utf8;
</span></span></code></pre></td></tr></table>
</div>
</div><p>插入数据：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">INSERT</span> <span style="color:#fff;font-weight:bold">INTO</span> time_zone_test(date_time,time_stamp) <span style="color:#fff;font-weight:bold">VALUES</span>(NOW(),NOW());
</span></span></code></pre></td></tr></table>
</div>
</div><p>查看数据：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">select</span> date_time,time_stamp <span style="color:#fff;font-weight:bold">from</span> time_zone_test;
</span></span></code></pre></td></tr></table>
</div>
</div><p>结果：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>+---------------------+---------------------+
</span></span><span style="display:flex;"><span>| date_time           | time_stamp          |
</span></span><span style="display:flex;"><span>+---------------------+---------------------+
</span></span><span style="display:flex;"><span>| 2020-01-11 09:53:32 | 2020-01-11 09:53:32 |
</span></span><span style="display:flex;"><span>+---------------------+---------------------+
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在我们运行</p>
<p>修改当前会话的时区:</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">set</span> time_zone=<span style="color:#0ff;font-weight:bold">&#39;+8:00&#39;</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><p>再次查看数据：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">5
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-text" data-lang="text"><span style="display:flex;"><span>+---------------------+---------------------+
</span></span><span style="display:flex;"><span>| date_time           | time_stamp          |
</span></span><span style="display:flex;"><span>+---------------------+---------------------+
</span></span><span style="display:flex;"><span>| 2020-01-11 09:53:32 | 2020-01-11 17:53:32 |
</span></span><span style="display:flex;"><span>+---------------------+---------------------+
</span></span></code></pre></td></tr></table>
</div>
</div><p><strong>扩展：一些关于 MySQL 时区设置的一个常用 sql 命令</strong></p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span># <span style="color:#f00">查看当前会话时区</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SELECT</span> @@<span style="color:#fff;font-weight:bold">session</span>.time_zone;
</span></span><span style="display:flex;"><span># <span style="color:#f00">设置当前会话时区</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SET</span> time_zone = <span style="color:#0ff;font-weight:bold">&#39;Europe/Helsinki&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SET</span> time_zone = <span style="color:#0ff;font-weight:bold">&#34;+00:00&#34;</span>;
</span></span><span style="display:flex;"><span># <span style="color:#f00">数据库全局时区设置</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SELECT</span> @@<span style="color:#fff;font-weight:bold">global</span>.time_zone;
</span></span><span style="display:flex;"><span># <span style="color:#f00">设置全局时区</span>
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SET</span> <span style="color:#fff;font-weight:bold">GLOBAL</span> time_zone = <span style="color:#0ff;font-weight:bold">&#39;+8:00&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">SET</span> <span style="color:#fff;font-weight:bold">GLOBAL</span> time_zone = <span style="color:#0ff;font-weight:bold">&#39;Europe/Helsinki&#39;</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><h3 id="占用空间">占用空间<a hidden class="anchor" aria-hidden="true" href="#占用空间">#</a></h3>
<p>下图是 MySQL 日期类型所占的存储空间（官方文档传送门：<a href="https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html">https://dev.mysql.com/doc/refman/8.0/en/storage-requirements.html</a>）：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/FhRGUVHFK0ujRPNA75f6CuOXQHTE.jpeg"></p>
<p>在 MySQL 5.6.4 之前，DateTime 和 Timestamp 的存储空间是固定的，分别为 8 字节和 4 字节。但是从 MySQL 5.6.4 开始，它们的存储空间会根据毫秒精度的不同而变化，DateTime 的范围是 5~8 字节，Timestamp 的范围是 4~7 字节。</p>
<h3 id="表示范围">表示范围<a hidden class="anchor" aria-hidden="true" href="#表示范围">#</a></h3>
<p>Timestamp 表示的时间范围更小，只能到 2038 年：</p>
<ul>
<li>DateTime：1000-01-01 00:00:00.000000 ~ 9999-12-31 23:59:59.499999</li>
<li>Timestamp：1970-01-01 00:00:01.000000 ~ 2038-01-19 03:14:07.499999</li>
</ul>
<h3 id="性能">性能<a hidden class="anchor" aria-hidden="true" href="#性能">#</a></h3>
<p>由于 TIMESTAMP 需要根据时区进行转换，所以从毫秒数转换到 TIMESTAMP 时，不仅要调用一个简单的函数，还要调用操作系统底层的系统函数。这个系统函数为了保证操作系统时区的一致性，需要进行加锁操作，这就降低了效率。</p>
<p>DATETIME 不涉及时区转换，所以不会有这个问题。</p>
<p>为了避免 TIMESTAMP 的时区转换问题，建议使用指定的时区，而不是依赖于操作系统时区。</p>
<h2 id="数值时间戳是更好的选择吗">数值时间戳是更好的选择吗？<a hidden class="anchor" aria-hidden="true" href="#数值时间戳是更好的选择吗">#</a></h2>
<p>很多时候，我们也会使用 int 或者 bigint 类型的数值也就是数值时间戳来表示时间。</p>
<p>这种存储方式的具有 Timestamp 类型的所具有一些优点，并且使用它的进行日期排序以及对比等操作的效率会更高，跨系统也很方便，毕竟只是存放的数值。缺点也很明显，就是数据的可读性太差了，你无法直观的看到具体时间。</p>
<p>时间戳的定义如下：</p>
<blockquote>
<p>时间戳的定义是从一个基准时间开始算起，这个基准时间是「1970-1-1 00:00:00 +0:00」，从这个时间开始，用整数表示，以秒计时，随着时间的流逝这个时间整数不断增加。这样一来，我只需要一个数值，就可以完美地表示时间了，而且这个数值是一个绝对数值，即无论的身处地球的任何角落，这个表示时间的时间戳，都是一样的，生成的数值都是一样的，并且没有时区的概念，所以在系统的中时间的传输中，都不需要进行额外的转换了，只有在显示给用户的时候，才转换为字符串格式的本地时间。</p>
</blockquote>
<p>数据库中实际操作：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span>mysql&gt; <span style="color:#fff;font-weight:bold">select</span> UNIX_TIMESTAMP(<span style="color:#0ff;font-weight:bold">&#39;2020-01-11 09:53:32&#39;</span>);
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">---------------------------------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>| UNIX_TIMESTAMP(<span style="color:#0ff;font-weight:bold">&#39;2020-01-11 09:53:32&#39;</span>) |
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">---------------------------------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>|                            <span style="color:#ff0;font-weight:bold">1578707612</span> |
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">---------------------------------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#ff0;font-weight:bold">1</span> <span style="color:#fff;font-weight:bold">row</span> <span style="color:#fff;font-weight:bold">in</span> <span style="color:#fff;font-weight:bold">set</span> (<span style="color:#ff0;font-weight:bold">0</span>.<span style="color:#ff0;font-weight:bold">00</span> sec)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>mysql&gt; <span style="color:#fff;font-weight:bold">select</span> FROM_UNIXTIME(<span style="color:#ff0;font-weight:bold">1578707612</span>);
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">---------------------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>| FROM_UNIXTIME(<span style="color:#ff0;font-weight:bold">1578707612</span>) |
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">---------------------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>| <span style="color:#ff0;font-weight:bold">2020</span>-<span style="color:#ff0;font-weight:bold">01</span>-<span style="color:#ff0;font-weight:bold">11</span> <span style="color:#ff0;font-weight:bold">09</span>:<span style="color:#ff0;font-weight:bold">53</span>:<span style="color:#ff0;font-weight:bold">32</span>       |
</span></span><span style="display:flex;"><span>+<span style="color:#007f7f">---------------------------+
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#ff0;font-weight:bold">1</span> <span style="color:#fff;font-weight:bold">row</span> <span style="color:#fff;font-weight:bold">in</span> <span style="color:#fff;font-weight:bold">set</span> (<span style="color:#ff0;font-weight:bold">0</span>.<span style="color:#ff0;font-weight:bold">01</span> sec)
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="总结-1">总结<a hidden class="anchor" aria-hidden="true" href="#总结-1">#</a></h2>
<p>MySQL 中时间到底怎么存储才好？Datetime?Timestamp?还是数值时间戳？</p>
<p>并没有一个银弹，很多程序员会觉得数值型时间戳是真的好，效率又高还各种兼容，但是很多人又觉得它表现的不够直观。</p>
<p>《高性能 MySQL 》这本神书的作者就是推荐 Timestamp，原因是数值表示时间不够直观。下面是原文：</p>
<blockquote>
<p>除了特殊行为之外，通常也应该尽量使用TIMESTAMP,因为它比DATETIME空间效率更高。<br>
有时候人们会将Uix时间截存储为整数值，但这不会带来任何收益。用整数保存时间<br>
截的格式通常不方便处理，所以我们不推荐这样做。<br>
如果需要存储比秒更小粒度的日期和时间值怎么办？MySQL目前没有提供合适的数据<br>
类型，但是可以使用自己的存储格式：可以使用BIGINT类型存储微秒级别的时间截，或<br>
者使用DOUBLE存储秒之后的小数部分。这两种方式都可以，或者也可以使用MariaDB<br>
替代MySQL。</p>
</blockquote>
<p>每种方式都有各自的优势，根据实际场景选择最合适的才是王道。下面再对这三种方式做一个简单的对比，以供大家实际开发中选择正确的存放时间的数据类型：</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储空间</th>
<th>日期格式</th>
<th>日期范围</th>
<th>是否带时区信息</th>
</tr>
</thead>
<tbody>
<tr>
<td>DATETIME</td>
<td>5~8字节</td>
<td>YYYY-MM-DD hh:mm:ss[.fraction]</td>
<td>1000-01-01 00:00:00[.000000] ～ 9999-12-31 23:59:59[.999999]</td>
<td>否</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4~7字节</td>
<td>YYYY-MM-DD hh:mm:ss[.fraction]</td>
<td>1970-01-01 00:00:01[.000000] ～ 2038-01-19 03:14:07[.999999]</td>
<td>是</td>
</tr>
<tr>
<td>数值型时间戳</td>
<td>4字节</td>
<td>全数字如1578707612</td>
<td>1970-01-01 00:00:01之后的时间</td>
<td>否</td>
</tr>
</tbody>
</table>
<h1 id="mysql隐式转换造成索引失效">MySQL隐式转换造成索引失效<a hidden class="anchor" aria-hidden="true" href="#mysql隐式转换造成索引失效">#</a></h1>
<h2 id="数据准备">数据准备<a hidden class="anchor" aria-hidden="true" href="#数据准备">#</a></h2>
<p>首先使用存储过程生成 1000 万条测试数据， 测试表一共建立了 7 个字段（包括主键），<code>num1</code>和<code>num2</code>保存的是和<code>ID</code>一样的顺序数字，其中<code>num2</code>是字符串类型。 <code>type1</code>和<code>type2</code>保存的都是主键对 5 的取模，目的是模拟实际应用中常用类似 type 类型的数据，但是<code>type2</code>是没有建立索引的。 <code>str1</code>和<code>str2</code>都是保存了一个 20 位长度的随机字符串，<code>str1</code>不能为<code>NULL</code>，<code>str2</code>允许为<code>NULL</code>，相应的生成测试数据的时候我也会在<code>str2</code>字段生产少量<code>NULL</code>值（每 100 条数据产生一个<code>NULL</code>值）。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">20
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">21
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">22
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">23
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">24
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">25
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">26
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">27
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">28
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">29
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">30
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">31
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">32
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">33
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">34
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">35
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">36
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">37
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">38
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">39
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">40
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">41
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">42
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">43
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">44
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">45
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">46
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#007f7f">-- 创建测试数据表
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">DROP</span> <span style="color:#fff;font-weight:bold">TABLE</span> <span style="color:#fff;font-weight:bold">IF</span> <span style="color:#fff;font-weight:bold">EXISTS</span> test1;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">CREATE</span> <span style="color:#fff;font-weight:bold">TABLE</span> `test1` (
</span></span><span style="display:flex;"><span>    `id` <span style="color:#fff;font-weight:bold">int</span>(<span style="color:#ff0;font-weight:bold">11</span>) <span style="color:#fff;font-weight:bold">NOT</span> <span style="color:#fff;font-weight:bold">NULL</span>,
</span></span><span style="display:flex;"><span>    `num1` <span style="color:#fff;font-weight:bold">int</span>(<span style="color:#ff0;font-weight:bold">11</span>) <span style="color:#fff;font-weight:bold">NOT</span> <span style="color:#fff;font-weight:bold">NULL</span> <span style="color:#fff;font-weight:bold">DEFAULT</span> <span style="color:#0ff;font-weight:bold">&#39;0&#39;</span>,
</span></span><span style="display:flex;"><span>    `num2` <span style="color:#fff;font-weight:bold">varchar</span>(<span style="color:#ff0;font-weight:bold">11</span>) <span style="color:#fff;font-weight:bold">NOT</span> <span style="color:#fff;font-weight:bold">NULL</span> <span style="color:#fff;font-weight:bold">DEFAULT</span> <span style="color:#0ff;font-weight:bold">&#39;&#39;</span>,
</span></span><span style="display:flex;"><span>    `type1` <span style="color:#fff;font-weight:bold">int</span>(<span style="color:#ff0;font-weight:bold">4</span>) <span style="color:#fff;font-weight:bold">NOT</span> <span style="color:#fff;font-weight:bold">NULL</span> <span style="color:#fff;font-weight:bold">DEFAULT</span> <span style="color:#0ff;font-weight:bold">&#39;0&#39;</span>,
</span></span><span style="display:flex;"><span>    `type2` <span style="color:#fff;font-weight:bold">int</span>(<span style="color:#ff0;font-weight:bold">4</span>) <span style="color:#fff;font-weight:bold">NOT</span> <span style="color:#fff;font-weight:bold">NULL</span> <span style="color:#fff;font-weight:bold">DEFAULT</span> <span style="color:#0ff;font-weight:bold">&#39;0&#39;</span>,
</span></span><span style="display:flex;"><span>    `str1` <span style="color:#fff;font-weight:bold">varchar</span>(<span style="color:#ff0;font-weight:bold">100</span>) <span style="color:#fff;font-weight:bold">NOT</span> <span style="color:#fff;font-weight:bold">NULL</span> <span style="color:#fff;font-weight:bold">DEFAULT</span> <span style="color:#0ff;font-weight:bold">&#39;&#39;</span>,
</span></span><span style="display:flex;"><span>    `str2` <span style="color:#fff;font-weight:bold">varchar</span>(<span style="color:#ff0;font-weight:bold">100</span>) <span style="color:#fff;font-weight:bold">DEFAULT</span> <span style="color:#fff;font-weight:bold">NULL</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">PRIMARY</span> <span style="color:#fff;font-weight:bold">KEY</span> (`id`),
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">KEY</span> `num1` (`num1`),
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">KEY</span> `num2` (`num2`),
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">KEY</span> `type1` (`type1`),
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">KEY</span> `str1` (`str1`),
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">KEY</span> `str2` (`str2`)
</span></span><span style="display:flex;"><span>) ENGINE=InnoDB <span style="color:#fff;font-weight:bold">DEFAULT</span> CHARSET=utf8;
</span></span><span style="display:flex;"><span><span style="color:#007f7f">-- 创建存储过程
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">DROP</span> <span style="color:#fff;font-weight:bold">PROCEDURE</span> <span style="color:#fff;font-weight:bold">IF</span> <span style="color:#fff;font-weight:bold">EXISTS</span> pre_test1;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">DELIMITER</span> //
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">CREATE</span> <span style="color:#fff;font-weight:bold">PROCEDURE</span> `pre_test1`()
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">BEGIN</span>
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">DECLARE</span> i <span style="color:#fff;font-weight:bold">INT</span> <span style="color:#fff;font-weight:bold">DEFAULT</span> <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">SET</span> autocommit = <span style="color:#ff0;font-weight:bold">0</span>;
</span></span><span style="display:flex;"><span>    WHILE i &lt; <span style="color:#ff0;font-weight:bold">10000000</span> <span style="color:#fff;font-weight:bold">DO</span>
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">SET</span> i = i + <span style="color:#ff0;font-weight:bold">1</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">SET</span> @str1 = <span style="color:#fff;font-weight:bold">SUBSTRING</span>(MD5(RAND()),<span style="color:#ff0;font-weight:bold">1</span>,<span style="color:#ff0;font-weight:bold">20</span>);
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">-- 每100条数据str2产生一个null值
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">IF</span> i % <span style="color:#ff0;font-weight:bold">100</span> = <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#fff;font-weight:bold">THEN</span>
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">SET</span> @str2 = <span style="color:#fff;font-weight:bold">NULL</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">ELSE</span>
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">SET</span> @str2 = @str1;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">END</span> <span style="color:#fff;font-weight:bold">IF</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">INSERT</span> <span style="color:#fff;font-weight:bold">INTO</span> test1 (`id`, `num1`, `num2`,
</span></span><span style="display:flex;"><span>        `type1`, `type2`, `str1`, `str2`)
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">VALUES</span> (CONCAT(<span style="color:#0ff;font-weight:bold">&#39;&#39;</span>, i), CONCAT(<span style="color:#0ff;font-weight:bold">&#39;&#39;</span>, i),
</span></span><span style="display:flex;"><span>        CONCAT(<span style="color:#0ff;font-weight:bold">&#39;&#39;</span>, i), i%<span style="color:#ff0;font-weight:bold">5</span>, i%<span style="color:#ff0;font-weight:bold">5</span>, @str1, @str2);
</span></span><span style="display:flex;"><span>        <span style="color:#007f7f">-- 事务优化，每一万条数据提交一次事务
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span>        <span style="color:#fff;font-weight:bold">IF</span> i % <span style="color:#ff0;font-weight:bold">10000</span> = <span style="color:#ff0;font-weight:bold">0</span> <span style="color:#fff;font-weight:bold">THEN</span>
</span></span><span style="display:flex;"><span>            <span style="color:#fff;font-weight:bold">COMMIT</span>;
</span></span><span style="display:flex;"><span>        <span style="color:#fff;font-weight:bold">END</span> <span style="color:#fff;font-weight:bold">IF</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#fff;font-weight:bold">END</span> WHILE;
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">END</span>;
</span></span><span style="display:flex;"><span>// <span style="color:#fff;font-weight:bold">DELIMITER</span> ;
</span></span><span style="display:flex;"><span><span style="color:#007f7f">-- 执行存储过程
</span></span></span><span style="display:flex;"><span><span style="color:#007f7f"></span><span style="color:#fff;font-weight:bold">CALL</span> pre_test1();
</span></span></code></pre></td></tr></table>
</div>
</div><p>数据量比较大，还涉及使用<code>MD5</code>生成随机字符串，所以速度有点慢，稍安勿躁，耐心等待即可。</p>
<p>1000 万条数据，我用了 33 分钟才跑完（实际时间跟你电脑硬件配置有关）。这里贴几条生成的数据，大致长这样。</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysqlindex-invalidation-caused-by-implicit-conversion-01.png"></p>
<h2 id="sql-测试">SQL 测试<a hidden class="anchor" aria-hidden="true" href="#sql-测试">#</a></h2>
<p>先来看这组 SQL，一共四条，我们的测试数据表<code>num1</code>是<code>int</code>类型，<code>num2</code>是<code>varchar</code>类型，但是存储的数据都是跟主键<code>id</code>一样的顺序数字，两个字段都建立有索引。</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">4
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">1</span>: <span style="color:#fff;font-weight:bold">SELECT</span> * <span style="color:#fff;font-weight:bold">FROM</span> `test1` <span style="color:#fff;font-weight:bold">WHERE</span> num1 = <span style="color:#ff0;font-weight:bold">10000</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">2</span>: <span style="color:#fff;font-weight:bold">SELECT</span> * <span style="color:#fff;font-weight:bold">FROM</span> `test1` <span style="color:#fff;font-weight:bold">WHERE</span> num1 = <span style="color:#0ff;font-weight:bold">&#39;10000&#39;</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">3</span>: <span style="color:#fff;font-weight:bold">SELECT</span> * <span style="color:#fff;font-weight:bold">FROM</span> `test1` <span style="color:#fff;font-weight:bold">WHERE</span> num2 = <span style="color:#ff0;font-weight:bold">10000</span>;
</span></span><span style="display:flex;"><span><span style="color:#ff0;font-weight:bold">4</span>: <span style="color:#fff;font-weight:bold">SELECT</span> * <span style="color:#fff;font-weight:bold">FROM</span> `test1` <span style="color:#fff;font-weight:bold">WHERE</span> num2 = <span style="color:#0ff;font-weight:bold">&#39;10000&#39;</span>;
</span></span></code></pre></td></tr></table>
</div>
</div><p>这四条 SQL 都是有针对性写的，12 查询的字段是 int 类型，34 查询的字段是<code>varchar</code>类型。12 或 34 查询的字段虽然都相同，但是一个条件是数字，一个条件是用引号引起来的字符串。这样做有什么区别呢？先不看下边的测试结果你能猜出这四条 SQL 的效率顺序吗？</p>
<p>经测试这四条 SQL 最后的执行结果却相差很大，其中 124 三条 SQL 基本都是瞬间出结果，大概在 0.001~0.005 秒，在千万级的数据量下这样的结果可以判定这三条 SQL 性能基本没差别了。但是第三条 SQL，多次测试耗时基本在 4.5~4.8 秒之间。</p>
<p>为什么 34 两条 SQL 效率相差那么大，但是同样做对比的 12 两条 SQL 却没什么差别呢？查看一下执行计划，下边分别 1234 条 SQL 的执行计划数据：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysqlindex-invalidation-caused-by-implicit-conversion-02.png"></p>
<p>可以看到，124 三条 SQL 都能使用到索引，连接类型都为<code>ref</code>，扫描行数都为 1，所以效率非常高。再看看第三条 SQL，没有用上索引，所以为全表扫描，<code>rows</code>直接到达 1000 万了，所以性能差别才那么大。</p>
<p>仔细观察你会发现，34 两条 SQL 查询的字段<code>num2</code>是<code>varchar</code>类型的，查询条件等号右边加引号的第 4 条 SQL 是用到索引的，那么是查询的数据类型和字段数据类型不一致造成的吗？如果是这样那 12 两条 SQL 查询的字段<code>num1</code>是<code>int</code>类型，但是第 2 条 SQL 查询条件右边加了引号为什么还能用上索引呢。</p>
<p>查阅 MySQL 相关文档发现是隐式转换造成的，看一下官方的描述：</p>
<blockquote>
<p>官方文档：<a href="https://dev.mysql.com/doc/refman/5.7/en/type-conversion.html?spm=5176.100239.blogcont47339.5.1FTben">12.2 Type Conversion in Expression Evaluation</a></p>
<p>当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。某些转换是隐式发生的。例如，MySQL 会根据需要自动将字符串转换为数字，反之亦然。以下规则描述了比较操作的转换方式：</p>
<ol>
<li>两个参数至少有一个是<code>NULL</code>时，比较的结果也是<code>NULL</code>，特殊的情况是使用<code>&lt;=&gt;</code>对两个<code>NULL</code>做比较时会返回<code>1</code>，这两种情况都不需要做类型转换</li>
<li>两个参数都是字符串，会按照字符串来比较，不做类型转换</li>
<li>两个参数都是整数，按照整数来比较，不做类型转换</li>
<li>十六进制的值和非数字做比较时，会被当做二进制串</li>
<li>有一个参数是<code>TIMESTAMP</code>或<code>DATETIME</code>，并且另外一个参数是常量，常量会被转换为<code>timestamp</code></li>
<li>有一个参数是<code>decimal</code>类型，如果另外一个参数是<code>decimal</code>或者整数，会将整数转换为<code>decimal</code>后进行比较，如果另外一个参数是浮点数，则会把<code>decimal</code>转换为浮点数进行比较</li>
<li><strong>所有其他情况下，两个参数都会被转换为浮点数再进行比较</strong></li>
</ol>
</blockquote>
<p>根据官方文档的描述，我们的第 23 两条 SQL 都发生了隐式转换，第 2 条 SQL 的查询条件<code>num1 = '10000'</code>，左边是<code>int</code>类型右边是字符串，第 3 条 SQL 相反，那么根据官方转换规则第 7 条，左右两边都会转换为浮点数再进行比较。</p>
<p>先看第 2 条 SQL：<code>SELECT * FROM</code>test1<code>WHERE num1 = '10000';</code> <strong>左边为 int 类型</strong><code>10000</code>，转换为浮点数还是<code>10000</code>，右边字符串类型<code>'10000'</code>，转换为浮点数也是<code>10000</code>。两边的转换结果都是唯一确定的，所以不影响使用索引。</p>
<p>第 3 条 SQL：<code>SELECT * FROM</code>test1<code>WHERE num2 = 10000;</code> <strong>左边是字符串类型</strong><code>'10000'</code>，转浮点数为 10000 是唯一的，右边<code>int</code>类型<code>10000</code>转换结果也是唯一的。但是，因为左边是检索条件，<code>'10000'</code>转到<code>10000</code>虽然是唯一，但是其他字符串也可以转换为<code>10000</code>，比如<code>'10000a'</code>，<code>'010000'</code>，<code>'10000'</code>等等都能转为浮点数<code>10000</code>，这样的情况下，是不能用到索引的。</p>
<p>关于这个<strong>隐式转换</strong>我们可以通过查询测试验证一下，先插入几条数据，其中<code>num2='10000a'</code>、<code>'010000'</code>和<code>'10000'</code>：</p>
<div class="highlight"><div style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">
<table style="border-spacing:0;padding:0;margin:0;border:0;"><tr><td style="vertical-align:top;padding:0;margin:0;border:0;">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:0.4em;padding:0 0.4em 0 0.4em;color:#727272">3
</span></code></pre></td>
<td style="vertical-align:top;padding:0;margin:0;border:0;;width:100%">
<pre tabindex="0" style="color:#e5e5e5;background-color:#000;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">INSERT</span> <span style="color:#fff;font-weight:bold">INTO</span> `test1` (`id`, `num1`, `num2`, `type1`, `type2`, `str1`, `str2`) <span style="color:#fff;font-weight:bold">VALUES</span> (<span style="color:#0ff;font-weight:bold">&#39;10000001&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;10000&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;10000a&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;0&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;0&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;2df3d9465ty2e4hd523&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;2df3d9465ty2e4hd523&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">INSERT</span> <span style="color:#fff;font-weight:bold">INTO</span> `test1` (`id`, `num1`, `num2`, `type1`, `type2`, `str1`, `str2`) <span style="color:#fff;font-weight:bold">VALUES</span> (<span style="color:#0ff;font-weight:bold">&#39;10000002&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;10000&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;010000&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;0&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;0&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;2df3d9465ty2e4hd523&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;2df3d9465ty2e4hd523&#39;</span>);
</span></span><span style="display:flex;"><span><span style="color:#fff;font-weight:bold">INSERT</span> <span style="color:#fff;font-weight:bold">INTO</span> `test1` (`id`, `num1`, `num2`, `type1`, `type2`, `str1`, `str2`) <span style="color:#fff;font-weight:bold">VALUES</span> (<span style="color:#0ff;font-weight:bold">&#39;10000003&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;10000&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39; 10000&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;0&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;0&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;2df3d9465ty2e4hd523&#39;</span>, <span style="color:#0ff;font-weight:bold">&#39;2df3d9465ty2e4hd523&#39;</span>);
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后使用第三条 SQL 语句<code>SELECT * FROM</code>test1<code>WHERE num2 = 10000;</code>进行查询：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysqlindex-invalidation-caused-by-implicit-conversion-03.png"></p>
<p>从结果可以看到，后面插入的三条数据也都匹配上了。那么这个字符串隐式转换的规则是什么呢？为什么<code>num2='10000a'</code>、<code>'010000'</code>和<code>'10000'</code>这三种情形都能匹配上呢？查阅相关资料发现规则如下：</p>
<ol>
<li><strong>不以数字开头</strong>的字符串都将转换为<code>0</code>。如<code>'abc'</code>、<code>'a123bc'</code>、<code>'abc123'</code>都会转化为<code>0</code>；</li>
<li><strong>以数字开头的</strong>字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。比如<code>'123abc'</code>会转换为<code>123</code>，<code>'012abc'</code>会转换为<code>012</code>也就是<code>12</code>，<code>'5.3a66b78c'</code>会转换为<code>5.3</code>，其他同理。</li>
</ol>
<p>现对以上规则做如下测试验证：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysqlindex-invalidation-caused-by-implicit-conversion-04.png"></p>
<p>如此也就印证了之前的查询结果了。</p>
<p>再次写一条 SQL 查询 str1 字段：<code>SELECT * FROM</code>test1<code>WHERE str1 = 1234;</code></p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/mysqlindex-invalidation-caused-by-implicit-conversion-05.png"></p>
<h2 id="分析和总结">分析和总结<a hidden class="anchor" aria-hidden="true" href="#分析和总结">#</a></h2>
<p>通过上面的测试我们发现 MySQL 使用操作符的一些特性：</p>
<ol>
<li>当操作符<strong>左右两边的数据类型不一致</strong>时，会发生<strong>隐式转换</strong>。</li>
<li>当 where 查询操作符<strong>左边为数值类型</strong>时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。</li>
<li>当 where 查询操作符<strong>左边为字符类型</strong>时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。</li>
<li>字符串转换为数值类型时，非数字开头的字符串会转化为<code>0</code>，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。</li>
</ol>
<p>所以，我们在写 SQL 时一定要养成良好的习惯，查询的字段是什么类型，等号右边的条件就写成对应的类型。特别当查询的字段是字符串时，等号右边的条件一定要用引号引起来标明这是一个字符串，否则会造成索引失效触发全表扫描。</p>
<h1 id="mysql自增主键一定是连续的吗">MySQL自增主键一定是连续的吗<a hidden class="anchor" aria-hidden="true" href="#mysql自增主键一定是连续的吗">#</a></h1>
<p>众所周知，自增主键可以让聚集索引尽量地保持递增顺序插入，避免了随机查询，从而提高了查询效率。</p>
<p>但实际上，MySQL 的自增主键并不能保证一定是连续递增的。</p>
<p>下面举个例子来看下，如下所示创建一张表：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/3e6b80ba50cb425386b80924e3da0d23~tplv-k3u1fbpfcp-zoom-1.png"></p>
<h2 id="自增值保存在哪里">自增值保存在哪里？<a hidden class="anchor" aria-hidden="true" href="#自增值保存在哪里">#</a></h2>
<p>使用 <code>insert into test_pk values(null, 1, 1)</code> 插入一行数据，再执行 <code>show create table</code> 命令来看一下表的结构定义：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/c17e46230bd34150966f0d86b2ad5e91~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>上述表的结构定义存放在后缀名为 <code>.frm</code> 的本地文件中，在 MySQL 安装目录下的 data 文件夹下可以找到这个 <code>.frm</code> 文件：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/3ec0514dd7be423d80b9e7f2d52f5902~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>从上述表结构可以看到，表定义里面出现了一个 <code>AUTO_INCREMENT=2</code>，表示下一次插入数据时，如果需要自动生成自增值，会生成 id = 2。</p>
<p>但需要注意的是，自增值并不会保存在这个表结构也就是 <code>.frm</code> 文件中，不同的引擎对于自增值的保存策略不同：</p>
<p>1）MyISAM 引擎的自增值保存在数据文件中</p>
<p>2）InnoDB 引擎的自增值，其实是保存在了内存里，并没有持久化。第一次打开表的时候，都会去找自增值的最大值 <code>max(id)</code>，然后将 <code>max(id)+1</code> 作为这个表当前的自增值。</p>
<p>举个例子：我们现在表里当前数据行里最大的 id 是 1，AUTO_INCREMENT=2，对吧。这时候，我们删除 id=1 的行，AUTO_INCREMENT 还是 2。</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/61b8dc9155624044a86d91c368b20059~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>但如果马上重启 MySQL 实例，重启后这个表的 AUTO_INCREMENT 就会变成 1。﻿ 也就是说，MySQL 重启可能会修改一个表的 AUTO_INCREMENT 的值。</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/27fdb15375664249a31f88b64e6e5e66~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/dee15f93e65d44d384345a03404f3481~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>以上，是在我本地 MySQL 5.x 版本的实验，实际上，<strong>到了 MySQL 8.0 版本后，自增值的变更记录被放在了 redo log 中，提供了自增值持久化的能力</strong> ，也就是实现了“如果发生重启，表的自增值可以根据 redo log 恢复为 MySQL 重启前的值”</p>
<p>也就是说对于上面这个例子来说，重启实例后这个表的 AUTO_INCREMENT 仍然是 2。</p>
<p>理解了 MySQL 自增值到底保存在哪里以后，我们再来看看自增值的修改机制，并以此引出第一种自增值不连续的场景。</p>
<h2 id="自增值不连续的场景">自增值不连续的场景<a hidden class="anchor" aria-hidden="true" href="#自增值不连续的场景">#</a></h2>
<h3 id="自增值不连续场景-1">自增值不连续场景 1<a hidden class="anchor" aria-hidden="true" href="#自增值不连续场景-1">#</a></h3>
<p>在 MySQL 里面，如果字段 id 被定义为 AUTO_INCREMENT，在插入一行数据的时候，自增值的行为如下：</p>
<ul>
<li>如果插入数据时 id 字段指定为 0、null 或未指定值，那么就把这个表当前的 AUTO_INCREMENT 值填到自增字段；</li>
<li>如果插入数据时 id 字段指定了具体的值，就直接使用语句里指定的值。</li>
</ul>
<p>根据要插入的值和当前自增值的大小关系，自增值的变更结果也会有所不同。假设某次要插入的值是 <code>insert_num</code>，当前的自增值是 <code>autoIncrement_num</code>：</p>
<ul>
<li>如果 <code>insert_num &lt; autoIncrement_num</code>，那么这个表的自增值不变</li>
<li>如果 <code>insert_num &gt;= autoIncrement_num</code>，就需要把当前自增值修改为新的自增值</li>
</ul>
<p>也就是说，如果插入的 id 是 100，当前的自增值是 90，<code>insert_num &gt;= autoIncrement_num</code>，那么自增值就会被修改为新的自增值即 101</p>
<p>一定是这样吗？</p>
<p>非也~</p>
<p>了解过分布式 id 的小伙伴一定知道，为了避免两个库生成的主键发生冲突，我们可以让一个库的自增 id 都是奇数，另一个库的自增 id 都是偶数</p>
<p>这个奇数偶数其实是通过 <code>auto_increment_offset</code> 和 <code>auto_increment_increment</code> 这两个参数来决定的，这俩分别用来表示自增的初始值和步长，默认值都是 1。</p>
<p>所以，上面的例子中生成新的自增值的步骤实际是这样的：从 <code>auto_increment_offset</code> 开始，以 <code>auto_increment_increment</code> 为步长，持续叠加，直到找到第一个大于 100 的值，作为新的自增值。</p>
<p>所以，这种情况下，自增值可能会是 102，103 等等之类的，就会导致不连续的主键 id。</p>
<p>更遗憾的是，即使在自增初始值和步长这两个参数都设置为 1 的时候，自增主键 id 也不一定能保证主键是连续的</p>
<h3 id="自增值不连续场景-2">自增值不连续场景 2<a hidden class="anchor" aria-hidden="true" href="#自增值不连续场景-2">#</a></h3>
<p>举个例子，我们现在往表里插入一条 (null,1,1) 的记录，生成的主键是 1，AUTO_INCREMENT= 2，对吧</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/c22c4f2cea234c7ea496025eb826c3bc~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>这时我再执行一条插入 <code>(null,1,1)</code> 的命令，很显然会报错 <code>Duplicate entry</code>，因为我们设置了一个唯一索引字段 <code>a</code>：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/c0325e31398d4fa6bb1cbe08ef797b7f~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>但是，你会惊奇的发现，虽然插入失败了，但自增值仍然从 2 增加到了 3！</p>
<p>这是为啥？</p>
<p>我们来分析下这个 insert 语句的执行流程：</p>
<ol>
<li>执行器调用 InnoDB 引擎接口准备插入一行记录 (null,1,1);</li>
<li>InnoDB 发现用户没有指定自增 id 的值，则获取表 <code>test_pk</code> 当前的自增值 2；</li>
<li>将传入的记录改成 (2,1,1);</li>
<li>将表的自增值改成 3；</li>
<li>继续执行插入数据操作，由于已经存在 a=1 的记录，所以报 Duplicate key error，语句返回</li>
</ol>
<p>可以看到，自增值修改的这个操作，是在真正执行插入数据的操作之前。</p>
<p>这个语句真正执行的时候，因为碰到唯一键 a 冲突，所以 id = 2 这一行并没有插入成功，但也没有将自增值再改回去。所以，在这之后，再插入新的数据行时，拿到的自增 id 就是 3。也就是说，出现了自增主键不连续的情况。</p>
<p>至此，我们已经罗列了两种自增主键不连续的情况：</p>
<ol>
<li>自增初始值和自增步长设置不为 1</li>
<li>唯一键冲突</li>
</ol>
<p>除此之外，事务回滚也会导致这种情况</p>
<h3 id="自增值不连续场景-3">自增值不连续场景 3<a hidden class="anchor" aria-hidden="true" href="#自增值不连续场景-3">#</a></h3>
<p>我们现在表里有一行 <code>(1,1,1)</code> 的记录，AUTO_INCREMENT = 3：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/6220fcf7dac54299863e43b6fb97de3e~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>我们先插入一行数据 <code>(null, 2, 2)</code>，也就是 (3, 2, 2) 嘛，并且 AUTO_INCREMENT 变为 4：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/3f02d46437d643c3b3d9f44a004ab269~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>再去执行这样一段 SQL：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/faf5ce4a2920469cae697f845be717f5~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>虽然我们插入了一条 (null, 3, 3) 记录，但是使用 rollback 进行回滚了，所以数据库中是没有这条记录的：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/6cb4c02722674dd399939d3d03a431c1~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>在这种事务回滚的情况下，自增值并没有同样发生回滚！如下图所示，自增值仍然固执地从 4 增加到了 5：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/e6eea1c927424ac7bda34a511ca521ae~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>所以这时候我们再去插入一条数据（null, 3, 3）的时候，主键 id 就会被自动赋为 <code>5</code> 了：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/80da69dd13b543c4a32d6ed832a3c568~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>那么，为什么在出现唯一键冲突或者回滚的时候，MySQL 没有把表的自增值改回去呢？回退回去的话不就不会发生自增 id 不连续了吗？</p>
<p>事实上，这么做的主要原因是为了提高性能。</p>
<p>我们直接用反证法来验证：假设 MySQL 在事务回滚的时候会把自增值改回去，会发生什么？</p>
<p>现在有两个并行执行的事务 A 和 B，在申请自增值的时候，为了避免两个事务申请到相同的自增 id，肯定要加锁，然后顺序申请，对吧。</p>
<ol>
<li>假设事务 A 申请到了 id = 1， 事务 B 申请到 id=2，那么这时候表 t 的自增值是 3，之后继续执行。</li>
<li>事务 B 正确提交了，但事务 A 出现了唯一键冲突，也就是 id = 1 的那行记录插入失败了，那如果允许事务 A 把自增 id 回退，也就是把表的当前自增值改回 1，那么就会出现这样的情况：表里面已经有 id = 2 的行，而当前的自增 id 值是 1。</li>
<li>接下来，继续执行的其他事务就会申请到 id=2。这时，就会出现插入语句报错“主键冲突”。</li>
</ol>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/5f26f02e60f643c9a7cab88a9f1bdce9~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>而为了解决这个主键冲突，有两种方法：</p>
<ol>
<li>每次申请 id 之前，先判断表里面是否已经存在这个 id，如果存在，就跳过这个 id</li>
<li>把自增 id 的锁范围扩大，必须等到一个事务执行完成并提交，下一个事务才能再申请自增 id</li>
</ol>
<p>很显然，上述两个方法的成本都比较高，会导致性能问题。而究其原因呢，是我们假设的这个 “允许自增 id 回退”。</p>
<p>因此，InnoDB 放弃了这个设计，语句执行失败也不回退自增 id。也正是因为这样，所以才只保证了自增 id 是递增的，但不保证是连续的。</p>
<p>综上，已经分析了三种自增值不连续的场景，还有第四种场景：批量插入数据。</p>
<h3 id="自增值不连续场景-4">自增值不连续场景 4<a hidden class="anchor" aria-hidden="true" href="#自增值不连续场景-4">#</a></h3>
<p>对于批量插入数据的语句，MySQL 有一个批量申请自增 id 的策略：</p>
<ol>
<li>语句执行过程中，第一次申请自增 id，会分配 1 个；</li>
<li>1 个用完以后，这个语句第二次申请自增 id，会分配 2 个；</li>
<li>2 个用完以后，还是这个语句，第三次申请自增 id，会分配 4 个；</li>
<li>依此类推，同一个语句去申请自增 id，每次申请到的自增 id 个数都是上一次的两倍。</li>
</ol>
<p>注意，这里说的批量插入数据，不是在普通的 insert 语句里面包含多个 value 值！！！，因为这类语句在申请自增 id 的时候，是可以精确计算出需要多少个 id 的，然后一次性申请，申请完成后锁就可以释放了。</p>
<p>而对于 <code>insert … select</code>、replace … select 和 load data 这种类型的语句来说，MySQL 并不知道到底需要申请多少 id，所以就采用了这种批量申请的策略，毕竟一个一个申请的话实在太慢了。</p>
<p>举个例子，假设我们现在这个表有下面这些数据：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/6453cfc107f94e3bb86c95072d443472~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>我们创建一个和当前表 <code>test_pk</code> 有相同结构定义的表 <code>test_pk2</code>：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/45248a6dc34f431bba14d434bee2c79e~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>然后使用 <code>insert...select</code> 往 <code>teset_pk2</code> 表中批量插入数据：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/c1b061e86bae484694d15ceb703b10ca~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>可以看到，成功导入了数据。</p>
<p>再来看下 <code>test_pk2</code> 的自增值是多少：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/0ff9039366154c738331d64ebaf88d3b~tplv-k3u1fbpfcp-zoom-1.png"></p>
<p>如上分析，是 8 而不是 6</p>
<p>具体来说，insert…select 实际上往表中插入了 5 行数据 （1 1）（2 2）（3 3）（4 4）（5 5）。但是，这五行数据是分三次申请的自增 id，结合批量申请策略，每次申请到的自增 id 个数都是上一次的两倍，所以：</p>
<ul>
<li>第一次申请到了一个 id：id=1</li>
<li>第二次被分配了两个 id：id=2 和 id=3</li>
<li>第三次被分配到了 4 个 id：id=4、id = 5、id = 6、id=7</li>
</ul>
<p>由于这条语句实际只用上了 5 个 id，所以 id=6 和 id=7 就被浪费掉了。之后，再执行 <code>insert into test_pk2 values(null,6,6)</code>，实际上插入的数据就是（8,6,6)：</p>
<p><img loading="lazy" src="/posts/interview/14_mysql%E9%9D%A2%E8%AF%95%E9%A2%98/51612fbac3804cff8c5157df21d6e355~tplv-k3u1fbpfcp-zoom-1.png"></p>
<h2 id="小结">小结<a hidden class="anchor" aria-hidden="true" href="#小结">#</a></h2>
<p>本文总结下自增值不连续的 4 个场景：</p>
<ol>
<li>自增初始值和自增步长设置不为 1</li>
<li>唯一键冲突</li>
<li>事务回滚</li>
<li>批量插入（如 <code>insert...select</code> 语句）</li>
</ol>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://009965.xyz/tags/interview/">Interview</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://009965.xyz/">Wjy&#39;s Blog</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
